# Generated from RegelSpraak.g4 by ANTLR 4.13.1
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO

def serializedATN():
    return [
        4,1,294,2137,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,
        7,6,2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,
        13,2,14,7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,
        20,7,20,2,21,7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,
        26,2,27,7,27,2,28,7,28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,
        33,7,33,2,34,7,34,2,35,7,35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,
        39,2,40,7,40,2,41,7,41,2,42,7,42,2,43,7,43,2,44,7,44,2,45,7,45,2,
        46,7,46,2,47,7,47,2,48,7,48,2,49,7,49,2,50,7,50,2,51,7,51,2,52,7,
        52,2,53,7,53,2,54,7,54,2,55,7,55,2,56,7,56,2,57,7,57,2,58,7,58,2,
        59,7,59,2,60,7,60,2,61,7,61,2,62,7,62,2,63,7,63,2,64,7,64,2,65,7,
        65,2,66,7,66,2,67,7,67,2,68,7,68,2,69,7,69,2,70,7,70,2,71,7,71,2,
        72,7,72,2,73,7,73,2,74,7,74,2,75,7,75,2,76,7,76,2,77,7,77,2,78,7,
        78,2,79,7,79,2,80,7,80,2,81,7,81,2,82,7,82,2,83,7,83,2,84,7,84,2,
        85,7,85,2,86,7,86,2,87,7,87,2,88,7,88,2,89,7,89,2,90,7,90,2,91,7,
        91,2,92,7,92,2,93,7,93,2,94,7,94,2,95,7,95,2,96,7,96,2,97,7,97,2,
        98,7,98,2,99,7,99,2,100,7,100,2,101,7,101,2,102,7,102,2,103,7,103,
        2,104,7,104,2,105,7,105,2,106,7,106,2,107,7,107,2,108,7,108,2,109,
        7,109,2,110,7,110,2,111,7,111,2,112,7,112,2,113,7,113,2,114,7,114,
        2,115,7,115,2,116,7,116,2,117,7,117,2,118,7,118,2,119,7,119,2,120,
        7,120,2,121,7,121,2,122,7,122,2,123,7,123,2,124,7,124,2,125,7,125,
        2,126,7,126,2,127,7,127,2,128,7,128,2,129,7,129,2,130,7,130,2,131,
        7,131,2,132,7,132,2,133,7,133,2,134,7,134,2,135,7,135,2,136,7,136,
        2,137,7,137,2,138,7,138,2,139,7,139,2,140,7,140,2,141,7,141,2,142,
        7,142,2,143,7,143,2,144,7,144,2,145,7,145,2,146,7,146,2,147,7,147,
        2,148,7,148,2,149,7,149,2,150,7,150,2,151,7,151,2,152,7,152,2,153,
        7,153,2,154,7,154,2,155,7,155,2,156,7,156,2,157,7,157,2,158,7,158,
        2,159,7,159,2,160,7,160,2,161,7,161,2,162,7,162,2,163,7,163,2,164,
        7,164,1,0,1,0,1,0,1,0,1,0,1,0,5,0,337,8,0,10,0,12,0,340,9,0,1,0,
        1,0,1,1,1,1,1,1,1,1,1,1,1,1,3,1,350,8,1,1,2,1,2,1,2,3,2,355,8,2,
        1,2,1,2,1,3,1,3,1,3,4,3,362,8,3,11,3,12,3,363,1,4,1,4,3,4,368,8,
        4,1,4,1,4,1,4,1,4,1,4,5,4,375,8,4,10,4,12,4,378,9,4,1,4,3,4,381,
        8,4,1,5,3,5,384,8,5,1,5,4,5,387,8,5,11,5,12,5,388,1,5,3,5,392,8,
        5,4,5,394,8,5,11,5,12,5,395,1,5,5,5,399,8,5,10,5,12,5,402,9,5,1,
        6,1,6,1,6,1,6,1,6,1,6,1,6,1,6,5,6,412,8,6,10,6,12,6,415,9,6,1,6,
        3,6,418,8,6,1,7,1,7,3,7,422,8,7,1,8,4,8,425,8,8,11,8,12,8,426,1,
        9,1,9,1,10,1,10,1,11,1,11,1,12,3,12,436,8,12,1,12,4,12,439,8,12,
        11,12,12,12,440,1,12,4,12,444,8,12,11,12,12,12,445,1,12,1,12,4,12,
        450,8,12,11,12,12,12,451,1,12,1,12,4,12,456,8,12,11,12,12,12,457,
        1,12,1,12,4,12,462,8,12,11,12,12,12,463,1,12,4,12,467,8,12,11,12,
        12,12,468,1,12,1,12,4,12,473,8,12,11,12,12,12,474,1,12,1,12,4,12,
        479,8,12,11,12,12,12,480,1,12,1,12,1,12,1,12,1,12,4,12,488,8,12,
        11,12,12,12,489,3,12,492,8,12,1,13,3,13,495,8,13,1,13,4,13,498,8,
        13,11,13,12,13,499,1,13,4,13,503,8,13,11,13,12,13,504,1,13,1,13,
        4,13,509,8,13,11,13,12,13,510,1,13,1,13,4,13,515,8,13,11,13,12,13,
        516,1,13,1,13,4,13,521,8,13,11,13,12,13,522,1,13,4,13,526,8,13,11,
        13,12,13,527,1,13,1,13,4,13,532,8,13,11,13,12,13,533,1,13,1,13,4,
        13,538,8,13,11,13,12,13,539,1,13,1,13,1,13,1,13,1,13,4,13,547,8,
        13,11,13,12,13,548,3,13,551,8,13,1,14,1,14,3,14,555,8,14,1,15,3,
        15,558,8,15,1,15,4,15,561,8,15,11,15,12,15,562,1,15,4,15,566,8,15,
        11,15,12,15,567,1,15,1,15,4,15,572,8,15,11,15,12,15,573,1,15,1,15,
        4,15,578,8,15,11,15,12,15,579,1,15,1,15,4,15,584,8,15,11,15,12,15,
        585,1,15,4,15,589,8,15,11,15,12,15,590,1,15,1,15,4,15,595,8,15,11,
        15,12,15,596,1,15,1,15,4,15,601,8,15,11,15,12,15,602,3,15,605,8,
        15,1,16,1,16,1,16,1,16,5,16,611,8,16,10,16,12,16,614,9,16,1,17,1,
        17,1,17,1,17,5,17,620,8,17,10,17,12,17,623,9,17,1,18,1,18,1,18,1,
        18,5,18,629,8,18,10,18,12,18,632,9,18,1,19,1,19,1,20,1,20,1,21,1,
        21,1,22,1,22,1,23,1,23,1,23,1,23,4,23,646,8,23,11,23,12,23,647,1,
        23,3,23,651,8,23,1,23,3,23,654,8,23,1,23,5,23,657,8,23,10,23,12,
        23,660,9,23,1,24,1,24,3,24,664,8,24,1,24,1,24,1,25,3,25,669,8,25,
        1,25,1,25,3,25,673,8,25,1,25,1,25,3,25,677,8,25,1,25,3,25,680,8,
        25,1,26,1,26,1,26,1,26,3,26,686,8,26,1,26,1,26,3,26,690,8,26,1,26,
        1,26,1,26,1,26,5,26,696,8,26,10,26,12,26,699,9,26,3,26,701,8,26,
        1,26,3,26,704,8,26,1,27,1,27,1,27,1,27,1,27,1,27,3,27,712,8,27,1,
        28,1,28,1,28,1,28,1,28,3,28,719,8,28,1,29,1,29,1,29,1,29,1,29,3,
        29,726,8,29,1,30,1,30,1,31,1,31,1,31,1,31,1,31,3,31,735,8,31,1,32,
        1,32,1,33,1,33,1,34,3,34,742,8,34,1,34,1,34,1,34,1,34,1,34,1,34,
        3,34,750,8,34,1,35,1,35,1,35,1,35,1,35,1,35,3,35,758,8,35,1,35,3,
        35,761,8,35,1,36,1,36,1,36,1,36,1,36,3,36,768,8,36,1,37,1,37,4,37,
        772,8,37,11,37,12,37,773,1,38,1,38,1,39,1,39,1,40,1,40,1,40,5,40,
        783,8,40,10,40,12,40,786,9,40,1,41,1,41,1,41,1,41,1,41,1,41,3,41,
        794,8,41,1,41,1,41,3,41,798,8,41,1,41,1,41,3,41,802,8,41,1,41,1,
        41,3,41,806,8,41,1,42,1,42,1,43,1,43,1,43,3,43,813,8,43,1,43,1,43,
        1,43,1,43,3,43,819,8,43,1,44,1,44,1,44,3,44,824,8,44,1,45,1,45,1,
        45,3,45,829,8,45,1,45,1,45,1,45,1,45,4,45,835,8,45,11,45,12,45,836,
        1,46,1,46,1,46,1,46,3,46,843,8,46,1,46,3,46,846,8,46,1,47,1,47,1,
        47,1,47,1,48,1,48,1,49,1,49,1,50,1,50,1,50,1,50,1,50,3,50,861,8,
        50,1,50,1,50,3,50,865,8,50,1,50,1,50,3,50,869,8,50,1,50,3,50,872,
        8,50,1,51,3,51,875,8,51,1,51,1,51,1,51,1,51,5,51,881,8,51,10,51,
        12,51,884,9,51,1,52,1,52,5,52,888,8,52,10,52,12,52,891,9,52,1,53,
        3,53,894,8,53,1,53,1,53,1,53,1,53,5,53,900,8,53,10,53,12,53,903,
        9,53,1,53,3,53,906,8,53,1,54,1,54,1,54,1,54,4,54,912,8,54,11,54,
        12,54,913,1,54,1,54,1,54,1,54,1,54,1,54,1,54,3,54,923,8,54,1,55,
        1,55,1,55,1,55,1,55,1,55,3,55,931,8,55,1,55,3,55,934,8,55,1,56,4,
        56,937,8,56,11,56,12,56,938,1,57,1,57,4,57,943,8,57,11,57,12,57,
        944,1,58,4,58,948,8,58,11,58,12,58,949,1,59,1,59,1,60,1,60,1,60,
        3,60,957,8,60,1,60,1,60,1,60,1,60,3,60,963,8,60,1,60,3,60,966,8,
        60,1,60,3,60,969,8,60,1,61,1,61,1,61,3,61,974,8,61,1,61,1,61,4,61,
        978,8,61,11,61,12,61,979,1,62,1,62,5,62,984,8,62,10,62,12,62,987,
        9,62,1,63,1,63,1,63,1,63,1,63,1,63,1,63,1,63,1,63,1,63,1,63,1,63,
        1,63,1,63,3,63,1003,8,63,1,64,1,64,1,64,1,65,1,65,1,65,1,65,1,65,
        3,65,1013,8,65,3,65,1015,8,65,1,66,1,66,1,66,1,66,1,66,1,66,1,66,
        1,66,1,66,1,66,1,66,1,66,3,66,1029,8,66,1,66,3,66,1032,8,66,1,66,
        1,66,1,66,1,66,1,66,1,66,1,66,1,66,1,66,1,66,3,66,1044,8,66,1,66,
        1,66,1,66,1,66,1,66,1,66,1,66,1,66,1,66,1,66,1,66,3,66,1057,8,66,
        1,67,1,67,1,68,1,68,1,68,1,68,1,68,1,68,1,68,1,68,1,68,1,68,1,68,
        1,68,1,69,4,69,1074,8,69,11,69,12,69,1075,1,70,4,70,1079,8,70,11,
        70,12,70,1080,1,71,1,71,1,71,1,71,1,71,3,71,1088,8,71,1,72,1,72,
        3,72,1092,8,72,1,73,1,73,1,74,1,74,1,74,1,74,3,74,1100,8,74,1,74,
        3,74,1103,8,74,1,74,1,74,1,74,1,74,1,74,3,74,1110,8,74,1,74,3,74,
        1113,8,74,3,74,1115,8,74,1,75,1,75,1,75,1,75,1,75,5,75,1122,8,75,
        10,75,12,75,1125,9,75,1,76,1,76,1,76,1,76,1,76,1,77,1,77,1,78,1,
        78,1,78,1,78,1,78,1,78,3,78,1140,8,78,1,78,3,78,1143,8,78,3,78,1145,
        8,78,1,79,1,79,1,79,3,79,1150,8,79,1,80,1,80,1,80,1,80,1,80,1,80,
        1,81,3,81,1159,8,81,1,81,1,81,1,81,1,82,1,82,1,82,3,82,1167,8,82,
        1,83,1,83,1,83,1,83,1,83,1,83,4,83,1175,8,83,11,83,12,83,1176,1,
        83,1,83,1,83,1,83,3,83,1183,8,83,1,83,1,83,1,83,1,83,1,83,1,83,4,
        83,1191,8,83,11,83,12,83,1192,1,83,1,83,1,83,1,83,3,83,1199,8,83,
        1,83,1,83,1,83,1,83,1,83,1,83,4,83,1207,8,83,11,83,12,83,1208,3,
        83,1211,8,83,1,84,1,84,1,84,1,84,1,84,1,84,1,84,1,84,1,84,1,84,1,
        84,1,84,1,84,1,84,3,84,1227,8,84,1,85,1,85,1,85,3,85,1232,8,85,1,
        86,4,86,1235,8,86,11,86,12,86,1236,1,87,1,87,1,88,1,88,1,88,3,88,
        1244,8,88,1,88,1,88,1,88,1,88,1,88,1,88,4,88,1252,8,88,11,88,12,
        88,1253,1,89,1,89,1,89,3,89,1259,8,89,1,90,1,90,1,90,3,90,1264,8,
        90,1,91,1,91,1,91,1,91,5,91,1270,8,91,10,91,12,91,1273,9,91,1,92,
        1,92,1,92,1,92,5,92,1279,8,92,10,92,12,92,1282,9,92,1,93,1,93,4,
        93,1286,8,93,11,93,12,93,1287,1,93,3,93,1291,8,93,1,94,1,94,4,94,
        1295,8,94,11,94,12,94,1296,1,94,3,94,1300,8,94,1,95,1,95,1,95,1,
        95,1,96,1,96,1,97,3,97,1309,8,97,1,97,1,97,1,98,3,98,1314,8,98,1,
        98,3,98,1317,8,98,1,98,4,98,1320,8,98,11,98,12,98,1321,1,99,1,99,
        1,99,1,100,1,100,1,100,1,100,1,100,3,100,1332,8,100,3,100,1334,8,
        100,1,101,1,101,3,101,1338,8,101,1,102,1,102,1,102,1,102,1,102,3,
        102,1345,8,102,1,103,1,103,1,104,3,104,1350,8,104,1,104,1,104,3,
        104,1354,8,104,1,104,1,104,1,105,1,105,1,106,3,106,1361,8,106,1,
        106,1,106,1,106,1,106,1,106,1,107,1,107,1,107,1,108,1,108,1,108,
        1,109,1,109,1,109,1,110,1,110,1,110,1,110,1,110,1,110,1,110,4,110,
        1384,8,110,11,110,12,110,1385,1,111,1,111,1,111,1,111,1,111,1,111,
        3,111,1394,8,111,1,112,1,112,1,113,1,113,1,113,1,113,1,113,1,113,
        1,113,1,113,1,113,1,113,1,113,3,113,1409,8,113,1,114,1,114,1,114,
        1,114,3,114,1415,8,114,1,114,1,114,1,114,1,114,1,114,1,114,4,114,
        1423,8,114,11,114,12,114,1424,1,115,1,115,1,116,1,116,1,117,1,117,
        1,118,1,118,1,119,1,119,1,120,1,120,1,120,1,120,1,120,1,120,1,120,
        1,120,1,120,1,120,1,120,1,120,1,120,1,120,1,120,1,120,1,120,1,120,
        1,120,1,120,1,120,1,120,1,120,1,120,3,120,1461,8,120,1,121,1,121,
        5,121,1465,8,121,10,121,12,121,1468,9,121,1,121,1,121,1,122,3,122,
        1473,8,122,1,122,1,122,1,122,1,122,1,123,1,123,1,123,3,123,1482,
        8,123,1,123,1,123,5,123,1486,8,123,10,123,12,123,1489,9,123,1,124,
        1,124,1,124,1,124,1,124,1,124,1,124,1,124,1,124,1,124,1,124,1,124,
        1,124,3,124,1504,8,124,1,125,1,125,1,125,1,125,1,125,1,125,1,125,
        1,125,1,125,1,125,1,125,1,125,1,125,3,125,1519,8,125,1,126,1,126,
        1,126,3,126,1524,8,126,1,127,1,127,1,127,1,127,1,127,1,127,1,127,
        1,127,1,127,1,127,1,127,1,127,1,127,1,127,1,127,5,127,1541,8,127,
        10,127,12,127,1544,9,127,1,127,1,127,1,127,1,127,1,127,1,127,1,127,
        3,127,1553,8,127,1,127,1,127,3,127,1557,8,127,1,128,1,128,1,128,
        1,128,3,128,1563,8,128,1,128,1,128,1,128,3,128,1568,8,128,1,129,
        1,129,1,130,1,130,1,131,1,131,1,131,1,131,5,131,1578,8,131,10,131,
        12,131,1581,9,131,1,132,1,132,1,133,1,133,1,133,1,133,5,133,1589,
        8,133,10,133,12,133,1592,9,133,1,134,1,134,1,135,1,135,1,135,1,135,
        5,135,1600,8,135,10,135,12,135,1603,9,135,1,136,1,136,1,137,1,137,
        1,137,1,137,1,137,1,137,1,137,1,137,1,137,1,137,1,137,1,137,1,137,
        3,137,1620,8,137,1,137,1,137,1,137,1,137,1,137,1,137,3,137,1628,
        8,137,1,137,1,137,1,137,1,137,5,137,1634,8,137,10,137,12,137,1637,
        9,137,1,137,1,137,1,137,1,137,1,137,1,137,1,137,1,137,1,137,1,137,
        1,137,1,137,3,137,1651,8,137,1,137,1,137,1,137,1,137,1,137,1,137,
        1,137,1,137,1,137,3,137,1662,8,137,1,137,3,137,1665,8,137,1,137,
        1,137,1,137,1,137,1,137,1,137,1,137,1,137,1,137,5,137,1676,8,137,
        10,137,12,137,1679,9,137,1,137,1,137,1,137,1,137,1,137,1,137,1,137,
        1,137,1,137,1,137,1,137,1,137,1,137,1,137,5,137,1695,8,137,10,137,
        12,137,1698,9,137,1,137,1,137,1,137,1,137,1,137,1,137,1,137,1,137,
        1,137,1,137,5,137,1710,8,137,10,137,12,137,1713,9,137,1,137,1,137,
        1,137,1,137,1,137,1,137,1,137,1,137,1,137,1,137,1,137,1,137,1,137,
        1,137,1,137,1,137,1,137,1,137,1,137,1,137,1,137,1,137,1,137,1,137,
        1,137,1,137,1,137,1,137,1,137,1,137,1,137,1,137,1,137,1,137,1,137,
        1,137,1,137,1,137,1,137,1,137,1,137,5,137,1756,8,137,10,137,12,137,
        1759,9,137,1,137,1,137,1,137,1,137,1,137,1,137,1,137,5,137,1768,
        8,137,10,137,12,137,1771,9,137,1,137,1,137,1,137,1,137,1,137,1,137,
        3,137,1779,8,137,1,137,1,137,1,137,1,137,1,137,3,137,1786,8,137,
        1,137,1,137,3,137,1790,8,137,1,137,3,137,1793,8,137,1,137,1,137,
        1,137,4,137,1798,8,137,11,137,12,137,1799,1,137,1,137,1,137,3,137,
        1805,8,137,1,137,1,137,1,137,1,137,1,137,3,137,1812,8,137,1,137,
        4,137,1815,8,137,11,137,12,137,1816,1,137,1,137,1,137,1,137,1,137,
        3,137,1824,8,137,1,137,1,137,3,137,1828,8,137,1,137,1,137,1,137,
        1,137,1,137,3,137,1835,8,137,1,137,1,137,3,137,1839,8,137,1,137,
        1,137,1,137,1,137,1,137,3,137,1846,8,137,1,137,1,137,3,137,1850,
        8,137,1,137,1,137,1,137,1,137,1,137,1,137,1,137,1,137,1,137,1,137,
        1,137,1,137,1,137,1,137,1,137,1,137,1,137,1,137,3,137,1870,8,137,
        1,137,1,137,1,137,4,137,1875,8,137,11,137,12,137,1876,1,137,1,137,
        1,137,1,137,1,137,1,137,1,137,1,137,1,137,1,137,1,137,1,137,1,137,
        5,137,1892,8,137,10,137,12,137,1895,9,137,1,138,1,138,1,138,1,138,
        1,138,1,139,1,139,1,139,1,139,1,139,1,139,3,139,1908,8,139,1,140,
        1,140,1,140,1,141,1,141,1,141,1,142,1,142,1,142,3,142,1919,8,142,
        1,143,1,143,1,143,1,144,1,144,1,144,1,144,1,144,1,144,1,144,1,144,
        1,144,1,144,1,144,1,144,1,144,1,144,1,144,1,144,3,144,1940,8,144,
        1,145,1,145,1,145,1,145,1,145,1,145,1,145,1,145,1,145,1,145,1,145,
        1,145,1,145,1,145,1,145,1,145,3,145,1958,8,145,1,146,1,146,1,146,
        1,146,3,146,1964,8,146,1,147,1,147,1,147,1,147,1,147,1,147,3,147,
        1972,8,147,1,148,1,148,1,149,1,149,1,149,1,149,3,149,1980,8,149,
        1,149,1,149,1,149,1,149,3,149,1986,8,149,1,150,1,150,1,150,1,150,
        3,150,1992,8,150,1,151,1,151,1,151,1,151,1,151,1,151,1,151,1,152,
        1,152,1,152,1,152,1,152,1,152,1,152,5,152,2008,8,152,10,152,12,152,
        2011,9,152,1,152,1,152,1,152,1,152,1,153,1,153,1,153,1,153,1,153,
        1,153,1,153,1,153,1,153,1,153,1,153,1,153,1,153,1,153,1,153,1,153,
        1,153,1,153,1,153,1,153,1,153,1,153,1,153,1,153,1,153,1,153,3,153,
        2043,8,153,1,154,1,154,1,154,1,154,1,154,1,154,1,154,1,154,3,154,
        2053,8,154,1,155,1,155,1,155,1,155,1,155,1,155,1,155,1,155,1,155,
        1,155,1,155,1,155,3,155,2067,8,155,1,156,1,156,1,156,1,156,4,156,
        2073,8,156,11,156,12,156,2074,1,156,3,156,2078,8,156,1,156,3,156,
        2081,8,156,1,157,1,157,1,158,1,158,1,158,1,158,1,158,1,158,1,158,
        3,158,2092,8,158,1,158,3,158,2095,8,158,1,159,1,159,1,160,1,160,
        1,160,3,160,2102,8,160,1,161,1,161,5,161,2106,8,161,10,161,12,161,
        2109,9,161,1,162,1,162,1,162,3,162,2114,8,162,1,163,1,163,1,163,
        1,163,1,163,1,163,1,163,1,163,1,163,1,163,1,163,1,163,1,163,1,163,
        3,163,2130,8,163,1,164,1,164,1,164,3,164,2135,8,164,1,164,0,1,274,
        165,0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,
        44,46,48,50,52,54,56,58,60,62,64,66,68,70,72,74,76,78,80,82,84,86,
        88,90,92,94,96,98,100,102,104,106,108,110,112,114,116,118,120,122,
        124,126,128,130,132,134,136,138,140,142,144,146,148,150,152,154,
        156,158,160,162,164,166,168,170,172,174,176,178,180,182,184,186,
        188,190,192,194,196,198,200,202,204,206,208,210,212,214,216,218,
        220,222,224,226,228,230,232,234,236,238,240,242,244,246,248,250,
        252,254,256,258,260,262,264,266,268,270,272,274,276,278,280,282,
        284,286,288,290,292,294,296,298,300,302,304,306,308,310,312,314,
        316,318,320,322,324,326,328,0,53,1,0,293,293,16,0,96,96,110,110,
        113,113,124,124,132,132,161,161,190,190,201,202,205,206,209,210,
        221,221,223,224,232,232,234,234,253,253,267,267,15,0,96,96,110,110,
        124,124,132,132,161,161,190,190,201,202,205,206,209,210,221,221,
        223,224,232,232,234,234,253,253,267,267,4,0,119,119,212,212,215,
        215,217,217,12,0,146,146,148,148,176,176,208,208,216,216,220,220,
        229,229,231,231,233,233,241,241,244,244,248,248,7,0,209,210,221,
        222,224,225,227,228,238,239,242,243,250,251,1,0,163,164,2,0,3,3,
        168,168,2,0,179,180,183,183,2,0,212,212,217,217,7,0,137,137,209,
        210,221,228,238,239,242,243,250,251,253,267,1,0,187,189,2,0,190,
        190,267,267,2,0,190,190,267,268,5,0,28,28,95,96,98,100,102,106,281,
        281,2,0,148,148,240,240,2,0,110,110,113,113,2,0,47,48,128,128,6,
        0,48,50,52,52,128,128,131,131,133,133,141,142,3,0,212,212,215,215,
        217,217,9,0,146,146,176,176,208,208,216,216,220,220,231,231,233,
        233,241,241,248,248,3,0,212,212,217,217,252,252,1,0,245,246,1,0,
        157,158,4,0,201,202,205,206,215,215,268,268,3,0,284,285,289,289,
        292,292,2,0,211,211,214,214,1,0,119,121,2,0,109,109,119,119,1,0,
        161,162,1,0,153,154,2,0,113,113,119,119,1,0,54,59,1,0,54,55,2,0,
        54,55,64,67,2,0,216,216,229,229,3,0,47,48,54,54,128,128,11,0,22,
        25,38,39,47,67,113,113,125,125,128,128,131,131,133,134,140,140,142,
        142,220,220,3,0,137,137,143,143,152,152,2,0,126,127,136,136,2,0,
        147,147,288,288,2,0,137,137,143,143,2,0,221,221,224,224,3,0,138,
        139,144,145,155,155,2,0,191,191,193,193,2,0,68,71,80,83,1,0,84,87,
        1,0,88,91,4,0,72,72,74,74,76,76,78,78,4,0,73,73,75,75,77,77,79,79,
        1,0,278,279,2,0,197,197,200,200,1,0,138,139,2372,0,338,1,0,0,0,2,
        349,1,0,0,0,4,351,1,0,0,0,6,358,1,0,0,0,8,365,1,0,0,0,10,383,1,0,
        0,0,12,403,1,0,0,0,14,421,1,0,0,0,16,424,1,0,0,0,18,428,1,0,0,0,
        20,430,1,0,0,0,22,432,1,0,0,0,24,491,1,0,0,0,26,550,1,0,0,0,28,554,
        1,0,0,0,30,604,1,0,0,0,32,606,1,0,0,0,34,615,1,0,0,0,36,624,1,0,
        0,0,38,633,1,0,0,0,40,635,1,0,0,0,42,637,1,0,0,0,44,639,1,0,0,0,
        46,641,1,0,0,0,48,663,1,0,0,0,50,672,1,0,0,0,52,681,1,0,0,0,54,711,
        1,0,0,0,56,713,1,0,0,0,58,720,1,0,0,0,60,727,1,0,0,0,62,729,1,0,
        0,0,64,736,1,0,0,0,66,738,1,0,0,0,68,741,1,0,0,0,70,751,1,0,0,0,
        72,767,1,0,0,0,74,769,1,0,0,0,76,775,1,0,0,0,78,777,1,0,0,0,80,779,
        1,0,0,0,82,787,1,0,0,0,84,807,1,0,0,0,86,818,1,0,0,0,88,820,1,0,
        0,0,90,825,1,0,0,0,92,845,1,0,0,0,94,847,1,0,0,0,96,851,1,0,0,0,
        98,853,1,0,0,0,100,855,1,0,0,0,102,874,1,0,0,0,104,885,1,0,0,0,106,
        905,1,0,0,0,108,922,1,0,0,0,110,924,1,0,0,0,112,936,1,0,0,0,114,
        942,1,0,0,0,116,947,1,0,0,0,118,951,1,0,0,0,120,953,1,0,0,0,122,
        970,1,0,0,0,124,981,1,0,0,0,126,1002,1,0,0,0,128,1004,1,0,0,0,130,
        1014,1,0,0,0,132,1056,1,0,0,0,134,1058,1,0,0,0,136,1060,1,0,0,0,
        138,1073,1,0,0,0,140,1078,1,0,0,0,142,1087,1,0,0,0,144,1091,1,0,
        0,0,146,1093,1,0,0,0,148,1114,1,0,0,0,150,1116,1,0,0,0,152,1126,
        1,0,0,0,154,1131,1,0,0,0,156,1133,1,0,0,0,158,1146,1,0,0,0,160,1151,
        1,0,0,0,162,1158,1,0,0,0,164,1163,1,0,0,0,166,1210,1,0,0,0,168,1226,
        1,0,0,0,170,1228,1,0,0,0,172,1234,1,0,0,0,174,1238,1,0,0,0,176,1243,
        1,0,0,0,178,1255,1,0,0,0,180,1260,1,0,0,0,182,1265,1,0,0,0,184,1274,
        1,0,0,0,186,1290,1,0,0,0,188,1299,1,0,0,0,190,1301,1,0,0,0,192,1305,
        1,0,0,0,194,1308,1,0,0,0,196,1313,1,0,0,0,198,1323,1,0,0,0,200,1333,
        1,0,0,0,202,1337,1,0,0,0,204,1344,1,0,0,0,206,1346,1,0,0,0,208,1349,
        1,0,0,0,210,1357,1,0,0,0,212,1360,1,0,0,0,214,1367,1,0,0,0,216,1370,
        1,0,0,0,218,1373,1,0,0,0,220,1376,1,0,0,0,222,1393,1,0,0,0,224,1395,
        1,0,0,0,226,1408,1,0,0,0,228,1414,1,0,0,0,230,1426,1,0,0,0,232,1428,
        1,0,0,0,234,1430,1,0,0,0,236,1432,1,0,0,0,238,1434,1,0,0,0,240,1460,
        1,0,0,0,242,1462,1,0,0,0,244,1472,1,0,0,0,246,1478,1,0,0,0,248,1503,
        1,0,0,0,250,1518,1,0,0,0,252,1520,1,0,0,0,254,1556,1,0,0,0,256,1567,
        1,0,0,0,258,1569,1,0,0,0,260,1571,1,0,0,0,262,1573,1,0,0,0,264,1582,
        1,0,0,0,266,1584,1,0,0,0,268,1593,1,0,0,0,270,1595,1,0,0,0,272,1604,
        1,0,0,0,274,1869,1,0,0,0,276,1896,1,0,0,0,278,1907,1,0,0,0,280,1909,
        1,0,0,0,282,1912,1,0,0,0,284,1918,1,0,0,0,286,1920,1,0,0,0,288,1939,
        1,0,0,0,290,1957,1,0,0,0,292,1963,1,0,0,0,294,1971,1,0,0,0,296,1973,
        1,0,0,0,298,1985,1,0,0,0,300,1987,1,0,0,0,302,1993,1,0,0,0,304,2000,
        1,0,0,0,306,2042,1,0,0,0,308,2052,1,0,0,0,310,2066,1,0,0,0,312,2068,
        1,0,0,0,314,2082,1,0,0,0,316,2084,1,0,0,0,318,2096,1,0,0,0,320,2098,
        1,0,0,0,322,2103,1,0,0,0,324,2110,1,0,0,0,326,2129,1,0,0,0,328,2131,
        1,0,0,0,330,337,3,2,1,0,331,337,3,120,60,0,332,337,3,122,61,0,333,
        337,3,4,2,0,334,337,3,156,78,0,335,337,3,80,40,0,336,330,1,0,0,0,
        336,331,1,0,0,0,336,332,1,0,0,0,336,333,1,0,0,0,336,334,1,0,0,0,
        336,335,1,0,0,0,337,340,1,0,0,0,338,336,1,0,0,0,338,339,1,0,0,0,
        339,341,1,0,0,0,340,338,1,0,0,0,341,342,5,0,0,1,342,1,1,0,0,0,343,
        350,3,46,23,0,344,350,3,70,35,0,345,350,3,100,50,0,346,350,3,90,
        45,0,347,350,3,108,54,0,348,350,3,312,156,0,349,343,1,0,0,0,349,
        344,1,0,0,0,349,345,1,0,0,0,349,346,1,0,0,0,349,347,1,0,0,0,349,
        348,1,0,0,0,350,3,1,0,0,0,351,352,5,98,0,0,352,354,3,32,16,0,353,
        355,3,128,64,0,354,353,1,0,0,0,354,355,1,0,0,0,355,356,1,0,0,0,356,
        357,3,6,3,0,357,5,1,0,0,0,358,359,3,8,4,0,359,361,3,10,5,0,360,362,
        3,12,6,0,361,360,1,0,0,0,362,363,1,0,0,0,363,361,1,0,0,0,363,364,
        1,0,0,0,364,7,1,0,0,0,365,367,5,293,0,0,366,368,5,293,0,0,367,366,
        1,0,0,0,367,368,1,0,0,0,368,369,1,0,0,0,369,370,3,16,8,0,370,371,
        5,293,0,0,371,376,3,16,8,0,372,373,5,293,0,0,373,375,3,16,8,0,374,
        372,1,0,0,0,375,378,1,0,0,0,376,374,1,0,0,0,376,377,1,0,0,0,377,
        380,1,0,0,0,378,376,1,0,0,0,379,381,5,293,0,0,380,379,1,0,0,0,380,
        381,1,0,0,0,381,9,1,0,0,0,382,384,5,293,0,0,383,382,1,0,0,0,383,
        384,1,0,0,0,384,393,1,0,0,0,385,387,5,292,0,0,386,385,1,0,0,0,387,
        388,1,0,0,0,388,386,1,0,0,0,388,389,1,0,0,0,389,391,1,0,0,0,390,
        392,5,293,0,0,391,390,1,0,0,0,391,392,1,0,0,0,392,394,1,0,0,0,393,
        386,1,0,0,0,394,395,1,0,0,0,395,393,1,0,0,0,395,396,1,0,0,0,396,
        400,1,0,0,0,397,399,5,292,0,0,398,397,1,0,0,0,399,402,1,0,0,0,400,
        398,1,0,0,0,400,401,1,0,0,0,401,11,1,0,0,0,402,400,1,0,0,0,403,404,
        5,293,0,0,404,405,5,268,0,0,405,406,5,293,0,0,406,407,3,248,124,
        0,407,408,5,293,0,0,408,413,3,14,7,0,409,410,5,293,0,0,410,412,3,
        14,7,0,411,409,1,0,0,0,412,415,1,0,0,0,413,411,1,0,0,0,413,414,1,
        0,0,0,414,417,1,0,0,0,415,413,1,0,0,0,416,418,5,293,0,0,417,416,
        1,0,0,0,417,418,1,0,0,0,418,13,1,0,0,0,419,422,3,248,124,0,420,422,
        5,294,0,0,421,419,1,0,0,0,421,420,1,0,0,0,422,15,1,0,0,0,423,425,
        8,0,0,0,424,423,1,0,0,0,425,426,1,0,0,0,426,424,1,0,0,0,426,427,
        1,0,0,0,427,17,1,0,0,0,428,429,5,267,0,0,429,19,1,0,0,0,430,431,
        7,1,0,0,431,21,1,0,0,0,432,433,7,2,0,0,433,23,1,0,0,0,434,436,7,
        3,0,0,435,434,1,0,0,0,435,436,1,0,0,0,436,438,1,0,0,0,437,439,3,
        20,10,0,438,437,1,0,0,0,439,440,1,0,0,0,440,438,1,0,0,0,440,441,
        1,0,0,0,441,492,1,0,0,0,442,444,3,20,10,0,443,442,1,0,0,0,444,445,
        1,0,0,0,445,443,1,0,0,0,445,446,1,0,0,0,446,492,1,0,0,0,447,449,
        5,45,0,0,448,450,3,20,10,0,449,448,1,0,0,0,450,451,1,0,0,0,451,449,
        1,0,0,0,451,452,1,0,0,0,452,492,1,0,0,0,453,455,5,45,0,0,454,456,
        3,20,10,0,455,454,1,0,0,0,456,457,1,0,0,0,457,455,1,0,0,0,457,458,
        1,0,0,0,458,459,1,0,0,0,459,461,5,176,0,0,460,462,3,20,10,0,461,
        460,1,0,0,0,462,463,1,0,0,0,463,461,1,0,0,0,463,464,1,0,0,0,464,
        492,1,0,0,0,465,467,3,20,10,0,466,465,1,0,0,0,467,468,1,0,0,0,468,
        466,1,0,0,0,468,469,1,0,0,0,469,470,1,0,0,0,470,472,5,176,0,0,471,
        473,3,20,10,0,472,471,1,0,0,0,473,474,1,0,0,0,474,472,1,0,0,0,474,
        475,1,0,0,0,475,492,1,0,0,0,476,478,5,140,0,0,477,479,3,20,10,0,
        478,477,1,0,0,0,479,480,1,0,0,0,480,478,1,0,0,0,480,481,1,0,0,0,
        481,492,1,0,0,0,482,483,5,217,0,0,483,484,5,190,0,0,484,485,5,210,
        0,0,485,487,5,220,0,0,486,488,3,20,10,0,487,486,1,0,0,0,488,489,
        1,0,0,0,489,487,1,0,0,0,489,490,1,0,0,0,490,492,1,0,0,0,491,435,
        1,0,0,0,491,443,1,0,0,0,491,447,1,0,0,0,491,453,1,0,0,0,491,466,
        1,0,0,0,491,476,1,0,0,0,491,482,1,0,0,0,492,25,1,0,0,0,493,495,7,
        3,0,0,494,493,1,0,0,0,494,495,1,0,0,0,495,497,1,0,0,0,496,498,3,
        28,14,0,497,496,1,0,0,0,498,499,1,0,0,0,499,497,1,0,0,0,499,500,
        1,0,0,0,500,551,1,0,0,0,501,503,3,28,14,0,502,501,1,0,0,0,503,504,
        1,0,0,0,504,502,1,0,0,0,504,505,1,0,0,0,505,551,1,0,0,0,506,508,
        5,45,0,0,507,509,3,28,14,0,508,507,1,0,0,0,509,510,1,0,0,0,510,508,
        1,0,0,0,510,511,1,0,0,0,511,551,1,0,0,0,512,514,5,45,0,0,513,515,
        3,28,14,0,514,513,1,0,0,0,515,516,1,0,0,0,516,514,1,0,0,0,516,517,
        1,0,0,0,517,518,1,0,0,0,518,520,5,176,0,0,519,521,3,28,14,0,520,
        519,1,0,0,0,521,522,1,0,0,0,522,520,1,0,0,0,522,523,1,0,0,0,523,
        551,1,0,0,0,524,526,3,28,14,0,525,524,1,0,0,0,526,527,1,0,0,0,527,
        525,1,0,0,0,527,528,1,0,0,0,528,529,1,0,0,0,529,531,5,176,0,0,530,
        532,3,28,14,0,531,530,1,0,0,0,532,533,1,0,0,0,533,531,1,0,0,0,533,
        534,1,0,0,0,534,551,1,0,0,0,535,537,5,140,0,0,536,538,3,28,14,0,
        537,536,1,0,0,0,538,539,1,0,0,0,539,537,1,0,0,0,539,540,1,0,0,0,
        540,551,1,0,0,0,541,542,5,217,0,0,542,543,5,190,0,0,543,544,5,210,
        0,0,544,546,5,220,0,0,545,547,3,28,14,0,546,545,1,0,0,0,547,548,
        1,0,0,0,548,546,1,0,0,0,548,549,1,0,0,0,549,551,1,0,0,0,550,494,
        1,0,0,0,550,502,1,0,0,0,550,506,1,0,0,0,550,512,1,0,0,0,550,525,
        1,0,0,0,550,535,1,0,0,0,550,541,1,0,0,0,551,27,1,0,0,0,552,555,3,
        20,10,0,553,555,5,268,0,0,554,552,1,0,0,0,554,553,1,0,0,0,555,29,
        1,0,0,0,556,558,7,3,0,0,557,556,1,0,0,0,557,558,1,0,0,0,558,560,
        1,0,0,0,559,561,3,22,11,0,560,559,1,0,0,0,561,562,1,0,0,0,562,560,
        1,0,0,0,562,563,1,0,0,0,563,605,1,0,0,0,564,566,3,22,11,0,565,564,
        1,0,0,0,566,567,1,0,0,0,567,565,1,0,0,0,567,568,1,0,0,0,568,605,
        1,0,0,0,569,571,5,45,0,0,570,572,3,22,11,0,571,570,1,0,0,0,572,573,
        1,0,0,0,573,571,1,0,0,0,573,574,1,0,0,0,574,605,1,0,0,0,575,577,
        5,45,0,0,576,578,3,22,11,0,577,576,1,0,0,0,578,579,1,0,0,0,579,577,
        1,0,0,0,579,580,1,0,0,0,580,581,1,0,0,0,581,583,5,176,0,0,582,584,
        3,22,11,0,583,582,1,0,0,0,584,585,1,0,0,0,585,583,1,0,0,0,585,586,
        1,0,0,0,586,605,1,0,0,0,587,589,3,22,11,0,588,587,1,0,0,0,589,590,
        1,0,0,0,590,588,1,0,0,0,590,591,1,0,0,0,591,592,1,0,0,0,592,594,
        5,176,0,0,593,595,3,22,11,0,594,593,1,0,0,0,595,596,1,0,0,0,596,
        594,1,0,0,0,596,597,1,0,0,0,597,605,1,0,0,0,598,600,5,140,0,0,599,
        601,3,22,11,0,600,599,1,0,0,0,601,602,1,0,0,0,602,600,1,0,0,0,602,
        603,1,0,0,0,603,605,1,0,0,0,604,557,1,0,0,0,604,565,1,0,0,0,604,
        569,1,0,0,0,604,575,1,0,0,0,604,588,1,0,0,0,604,598,1,0,0,0,605,
        31,1,0,0,0,606,612,3,24,12,0,607,608,3,38,19,0,608,609,3,24,12,0,
        609,611,1,0,0,0,610,607,1,0,0,0,611,614,1,0,0,0,612,610,1,0,0,0,
        612,613,1,0,0,0,613,33,1,0,0,0,614,612,1,0,0,0,615,621,3,26,13,0,
        616,617,3,38,19,0,617,618,3,26,13,0,618,620,1,0,0,0,619,616,1,0,
        0,0,620,623,1,0,0,0,621,619,1,0,0,0,621,622,1,0,0,0,622,35,1,0,0,
        0,623,621,1,0,0,0,624,630,3,30,15,0,625,626,3,38,19,0,626,627,3,
        30,15,0,627,629,1,0,0,0,628,625,1,0,0,0,629,632,1,0,0,0,630,628,
        1,0,0,0,630,631,1,0,0,0,631,37,1,0,0,0,632,630,1,0,0,0,633,634,7,
        4,0,0,634,39,1,0,0,0,635,636,5,270,0,0,636,41,1,0,0,0,637,638,5,
        267,0,0,638,43,1,0,0,0,639,640,7,5,0,0,640,45,1,0,0,0,641,642,5,
        99,0,0,642,650,3,36,18,0,643,645,5,178,0,0,644,646,5,267,0,0,645,
        644,1,0,0,0,646,647,1,0,0,0,647,645,1,0,0,0,647,648,1,0,0,0,648,
        649,1,0,0,0,649,651,5,275,0,0,650,643,1,0,0,0,650,651,1,0,0,0,651,
        653,1,0,0,0,652,654,5,165,0,0,653,652,1,0,0,0,653,654,1,0,0,0,654,
        658,1,0,0,0,655,657,3,48,24,0,656,655,1,0,0,0,657,660,1,0,0,0,658,
        656,1,0,0,0,658,659,1,0,0,0,659,47,1,0,0,0,660,658,1,0,0,0,661,664,
        3,50,25,0,662,664,3,52,26,0,663,661,1,0,0,0,663,662,1,0,0,0,664,
        665,1,0,0,0,665,666,5,281,0,0,666,49,1,0,0,0,667,669,5,113,0,0,668,
        667,1,0,0,0,668,669,1,0,0,0,669,670,1,0,0,0,670,673,3,18,9,0,671,
        673,3,34,17,0,672,668,1,0,0,0,672,671,1,0,0,0,673,674,1,0,0,0,674,
        676,5,174,0,0,675,677,7,6,0,0,676,675,1,0,0,0,676,677,1,0,0,0,677,
        679,1,0,0,0,678,680,3,96,48,0,679,678,1,0,0,0,679,680,1,0,0,0,680,
        51,1,0,0,0,681,685,3,34,17,0,682,686,3,54,27,0,683,686,3,76,38,0,
        684,686,3,78,39,0,685,682,1,0,0,0,685,683,1,0,0,0,685,684,1,0,0,
        0,686,689,1,0,0,0,687,688,5,177,0,0,688,690,3,84,42,0,689,687,1,
        0,0,0,689,690,1,0,0,0,690,700,1,0,0,0,691,692,5,171,0,0,692,697,
        3,98,49,0,693,694,5,216,0,0,694,696,3,98,49,0,695,693,1,0,0,0,696,
        699,1,0,0,0,697,695,1,0,0,0,697,698,1,0,0,0,698,701,1,0,0,0,699,
        697,1,0,0,0,700,691,1,0,0,0,700,701,1,0,0,0,701,703,1,0,0,0,702,
        704,3,96,48,0,703,702,1,0,0,0,703,704,1,0,0,0,704,53,1,0,0,0,705,
        712,3,58,29,0,706,712,3,60,30,0,707,712,3,64,32,0,708,712,3,66,33,
        0,709,712,3,56,28,0,710,712,3,62,31,0,711,705,1,0,0,0,711,706,1,
        0,0,0,711,707,1,0,0,0,711,708,1,0,0,0,711,709,1,0,0,0,711,710,1,
        0,0,0,712,55,1,0,0,0,713,714,5,101,0,0,714,718,5,244,0,0,715,719,
        3,54,27,0,716,719,3,76,38,0,717,719,3,78,39,0,718,715,1,0,0,0,718,
        716,1,0,0,0,718,717,1,0,0,0,719,57,1,0,0,0,720,725,5,181,0,0,721,
        722,5,274,0,0,722,723,3,68,34,0,723,724,5,275,0,0,724,726,1,0,0,
        0,725,721,1,0,0,0,725,726,1,0,0,0,726,59,1,0,0,0,727,728,5,186,0,
        0,728,61,1,0,0,0,729,734,5,182,0,0,730,731,5,274,0,0,731,732,3,68,
        34,0,732,733,5,275,0,0,733,735,1,0,0,0,734,730,1,0,0,0,734,735,1,
        0,0,0,735,63,1,0,0,0,736,737,5,166,0,0,737,65,1,0,0,0,738,739,7,
        7,0,0,739,67,1,0,0,0,740,742,7,8,0,0,741,740,1,0,0,0,741,742,1,0,
        0,0,742,749,1,0,0,0,743,750,5,172,0,0,744,745,5,173,0,0,745,746,
        5,176,0,0,746,747,5,268,0,0,747,750,5,169,0,0,748,750,5,173,0,0,
        749,743,1,0,0,0,749,744,1,0,0,0,749,748,1,0,0,0,750,69,1,0,0,0,751,
        752,5,100,0,0,752,753,5,267,0,0,753,754,5,29,0,0,754,757,3,72,36,
        0,755,756,5,177,0,0,756,758,3,86,43,0,757,755,1,0,0,0,757,758,1,
        0,0,0,758,760,1,0,0,0,759,761,5,281,0,0,760,759,1,0,0,0,760,761,
        1,0,0,0,761,71,1,0,0,0,762,768,3,74,37,0,763,768,3,58,29,0,764,768,
        3,60,30,0,765,768,3,64,32,0,766,768,3,66,33,0,767,762,1,0,0,0,767,
        763,1,0,0,0,767,764,1,0,0,0,767,765,1,0,0,0,767,766,1,0,0,0,768,
        73,1,0,0,0,769,771,5,170,0,0,770,772,5,273,0,0,771,770,1,0,0,0,772,
        773,1,0,0,0,773,771,1,0,0,0,773,774,1,0,0,0,774,75,1,0,0,0,775,776,
        5,267,0,0,776,77,1,0,0,0,777,778,5,267,0,0,778,79,1,0,0,0,779,780,
        5,103,0,0,780,784,3,18,9,0,781,783,3,82,41,0,782,781,1,0,0,0,783,
        786,1,0,0,0,784,782,1,0,0,0,784,785,1,0,0,0,785,81,1,0,0,0,786,784,
        1,0,0,0,787,788,7,9,0,0,788,793,3,84,42,0,789,790,5,178,0,0,790,
        791,3,84,42,0,791,792,5,275,0,0,792,794,1,0,0,0,793,789,1,0,0,0,
        793,794,1,0,0,0,794,795,1,0,0,0,795,797,3,84,42,0,796,798,3,84,42,
        0,797,796,1,0,0,0,797,798,1,0,0,0,798,805,1,0,0,0,799,801,5,269,
        0,0,800,802,5,282,0,0,801,800,1,0,0,0,801,802,1,0,0,0,802,803,1,
        0,0,0,803,804,5,268,0,0,804,806,3,84,42,0,805,799,1,0,0,0,805,806,
        1,0,0,0,806,83,1,0,0,0,807,808,7,10,0,0,808,85,1,0,0,0,809,812,3,
        88,44,0,810,811,5,282,0,0,811,813,3,88,44,0,812,810,1,0,0,0,812,
        813,1,0,0,0,813,819,1,0,0,0,814,819,5,268,0,0,815,819,5,283,0,0,
        816,819,5,264,0,0,817,819,5,265,0,0,818,809,1,0,0,0,818,814,1,0,
        0,0,818,815,1,0,0,0,818,816,1,0,0,0,818,817,1,0,0,0,819,87,1,0,0,
        0,820,823,3,84,42,0,821,822,5,288,0,0,822,824,5,268,0,0,823,821,
        1,0,0,0,823,824,1,0,0,0,824,89,1,0,0,0,825,826,5,102,0,0,826,828,
        3,32,16,0,827,829,5,278,0,0,828,827,1,0,0,0,828,829,1,0,0,0,829,
        830,1,0,0,0,830,831,5,27,0,0,831,832,3,32,16,0,832,834,3,92,46,0,
        833,835,3,94,47,0,834,833,1,0,0,0,835,836,1,0,0,0,836,834,1,0,0,
        0,836,837,1,0,0,0,837,91,1,0,0,0,838,839,5,2,0,0,839,840,3,38,19,
        0,840,842,5,275,0,0,841,843,5,280,0,0,842,841,1,0,0,0,842,843,1,
        0,0,0,843,846,1,0,0,0,844,846,5,1,0,0,845,838,1,0,0,0,845,844,1,
        0,0,0,846,93,1,0,0,0,847,848,5,268,0,0,848,849,5,279,0,0,849,850,
        3,32,16,0,850,95,1,0,0,0,851,852,7,11,0,0,852,97,1,0,0,0,853,854,
        5,267,0,0,854,99,1,0,0,0,855,856,5,104,0,0,856,857,3,102,51,0,857,
        860,5,280,0,0,858,861,3,54,27,0,859,861,3,76,38,0,860,858,1,0,0,
        0,860,859,1,0,0,0,861,864,1,0,0,0,862,863,5,177,0,0,863,865,3,86,
        43,0,864,862,1,0,0,0,864,865,1,0,0,0,865,868,1,0,0,0,866,867,5,113,
        0,0,867,869,3,248,124,0,868,866,1,0,0,0,868,869,1,0,0,0,869,871,
        1,0,0,0,870,872,3,96,48,0,871,870,1,0,0,0,871,872,1,0,0,0,872,101,
        1,0,0,0,873,875,7,9,0,0,874,873,1,0,0,0,874,875,1,0,0,0,875,876,
        1,0,0,0,876,882,3,104,52,0,877,878,3,38,19,0,878,879,3,104,52,0,
        879,881,1,0,0,0,880,877,1,0,0,0,881,884,1,0,0,0,882,880,1,0,0,0,
        882,883,1,0,0,0,883,103,1,0,0,0,884,882,1,0,0,0,885,889,7,12,0,0,
        886,888,7,13,0,0,887,886,1,0,0,0,888,891,1,0,0,0,889,887,1,0,0,0,
        889,890,1,0,0,0,890,105,1,0,0,0,891,889,1,0,0,0,892,894,7,9,0,0,
        893,892,1,0,0,0,893,894,1,0,0,0,894,895,1,0,0,0,895,901,3,104,52,
        0,896,897,3,38,19,0,897,898,3,104,52,0,898,900,1,0,0,0,899,896,1,
        0,0,0,900,903,1,0,0,0,901,899,1,0,0,0,901,902,1,0,0,0,902,906,1,
        0,0,0,903,901,1,0,0,0,904,906,3,32,16,0,905,893,1,0,0,0,905,904,
        1,0,0,0,906,107,1,0,0,0,907,908,5,105,0,0,908,909,3,32,16,0,909,
        911,3,110,55,0,910,912,3,110,55,0,911,910,1,0,0,0,912,913,1,0,0,
        0,913,911,1,0,0,0,913,914,1,0,0,0,914,915,1,0,0,0,915,916,3,116,
        58,0,916,923,1,0,0,0,917,918,5,28,0,0,918,919,3,32,16,0,919,920,
        3,110,55,0,920,921,3,116,58,0,921,923,1,0,0,0,922,907,1,0,0,0,922,
        917,1,0,0,0,923,109,1,0,0,0,924,925,7,9,0,0,925,930,3,114,57,0,926,
        927,5,178,0,0,927,928,3,32,16,0,928,929,5,275,0,0,929,931,1,0,0,
        0,930,926,1,0,0,0,930,931,1,0,0,0,931,933,1,0,0,0,932,934,3,112,
        56,0,933,932,1,0,0,0,933,934,1,0,0,0,934,111,1,0,0,0,935,937,3,20,
        10,0,936,935,1,0,0,0,937,938,1,0,0,0,938,936,1,0,0,0,938,939,1,0,
        0,0,939,113,1,0,0,0,940,943,3,20,10,0,941,943,3,38,19,0,942,940,
        1,0,0,0,942,941,1,0,0,0,943,944,1,0,0,0,944,942,1,0,0,0,944,945,
        1,0,0,0,945,115,1,0,0,0,946,948,3,118,59,0,947,946,1,0,0,0,948,949,
        1,0,0,0,949,947,1,0,0,0,949,950,1,0,0,0,950,117,1,0,0,0,951,952,
        8,14,0,0,952,119,1,0,0,0,953,954,5,96,0,0,954,956,3,124,62,0,955,
        957,5,268,0,0,956,955,1,0,0,0,956,957,1,0,0,0,957,958,1,0,0,0,958,
        959,3,128,64,0,959,965,3,132,66,0,960,962,3,164,82,0,961,963,5,279,
        0,0,962,961,1,0,0,0,962,963,1,0,0,0,963,966,1,0,0,0,964,966,5,279,
        0,0,965,960,1,0,0,0,965,964,1,0,0,0,965,966,1,0,0,0,966,968,1,0,
        0,0,967,969,3,242,121,0,968,967,1,0,0,0,968,969,1,0,0,0,969,121,
        1,0,0,0,970,971,5,97,0,0,971,973,3,32,16,0,972,974,5,112,0,0,973,
        972,1,0,0,0,973,974,1,0,0,0,974,977,1,0,0,0,975,978,3,120,60,0,976,
        978,3,156,78,0,977,975,1,0,0,0,977,976,1,0,0,0,978,979,1,0,0,0,979,
        977,1,0,0,0,979,980,1,0,0,0,980,123,1,0,0,0,981,985,3,34,17,0,982,
        984,3,126,63,0,983,982,1,0,0,0,984,987,1,0,0,0,985,983,1,0,0,0,985,
        986,1,0,0,0,986,125,1,0,0,0,987,985,1,0,0,0,988,1003,5,198,0,0,989,
        990,5,278,0,0,990,1003,3,34,17,0,991,992,5,278,0,0,992,993,5,176,
        0,0,993,1003,3,34,17,0,994,995,5,216,0,0,995,1003,3,34,17,0,996,
        997,5,113,0,0,997,1003,3,34,17,0,998,999,5,204,0,0,999,1000,3,34,
        17,0,1000,1001,5,113,0,0,1001,1003,1,0,0,0,1002,988,1,0,0,0,1002,
        989,1,0,0,0,1002,991,1,0,0,0,1002,994,1,0,0,0,1002,996,1,0,0,0,1002,
        998,1,0,0,0,1003,127,1,0,0,0,1004,1005,5,108,0,0,1005,1006,3,130,
        65,0,1006,129,1,0,0,0,1007,1015,5,207,0,0,1008,1009,5,150,0,0,1009,
        1012,3,40,20,0,1010,1011,7,15,0,0,1011,1013,3,40,20,0,1012,1010,
        1,0,0,0,1012,1013,1,0,0,0,1013,1015,1,0,0,0,1014,1007,1,0,0,0,1014,
        1008,1,0,0,0,1015,131,1,0,0,0,1016,1017,5,215,0,0,1017,1018,5,209,
        0,0,1018,1019,5,113,0,0,1019,1020,5,215,0,0,1020,1057,3,32,16,0,
        1021,1028,3,190,95,0,1022,1023,5,8,0,0,1023,1029,3,248,124,0,1024,
        1025,5,9,0,0,1025,1029,3,248,124,0,1026,1027,5,10,0,0,1027,1029,
        3,248,124,0,1028,1022,1,0,0,0,1028,1024,1,0,0,0,1028,1026,1,0,0,
        0,1029,1031,1,0,0,0,1030,1032,3,290,145,0,1031,1030,1,0,0,0,1031,
        1032,1,0,0,0,1032,1057,1,0,0,0,1033,1034,3,190,95,0,1034,1035,5,
        114,0,0,1035,1036,3,134,67,0,1036,1037,3,248,124,0,1037,1057,1,0,
        0,0,1038,1057,3,136,68,0,1039,1040,3,178,89,0,1040,1041,7,16,0,0,
        1041,1043,3,194,97,0,1042,1044,3,290,145,0,1043,1042,1,0,0,0,1043,
        1044,1,0,0,0,1044,1057,1,0,0,0,1045,1046,3,178,89,0,1046,1047,5,
        110,0,0,1047,1048,7,9,0,0,1048,1049,3,32,16,0,1049,1050,5,176,0,
        0,1050,1051,3,192,96,0,1051,1052,7,17,0,0,1052,1053,3,248,124,0,
        1053,1057,1,0,0,0,1054,1057,3,148,74,0,1055,1057,3,316,158,0,1056,
        1016,1,0,0,0,1056,1021,1,0,0,0,1056,1033,1,0,0,0,1056,1038,1,0,0,
        0,1056,1039,1,0,0,0,1056,1045,1,0,0,0,1056,1054,1,0,0,0,1056,1055,
        1,0,0,0,1057,133,1,0,0,0,1058,1059,7,18,0,0,1059,135,1,0,0,0,1060,
        1061,5,215,0,0,1061,1062,3,138,69,0,1062,1063,5,244,0,0,1063,1064,
        5,215,0,0,1064,1065,3,140,70,0,1065,1066,5,113,0,0,1066,1067,7,19,
        0,0,1067,1068,3,138,69,0,1068,1069,5,244,0,0,1069,1070,7,19,0,0,
        1070,1071,3,140,70,0,1071,137,1,0,0,0,1072,1074,3,144,72,0,1073,
        1072,1,0,0,0,1074,1075,1,0,0,0,1075,1073,1,0,0,0,1075,1076,1,0,0,
        0,1076,139,1,0,0,0,1077,1079,3,142,71,0,1078,1077,1,0,0,0,1079,1080,
        1,0,0,0,1080,1078,1,0,0,0,1080,1081,1,0,0,0,1081,141,1,0,0,0,1082,
        1088,3,20,10,0,1083,1088,3,38,19,0,1084,1088,5,212,0,0,1085,1088,
        5,217,0,0,1086,1088,5,215,0,0,1087,1082,1,0,0,0,1087,1083,1,0,0,
        0,1087,1084,1,0,0,0,1087,1085,1,0,0,0,1087,1086,1,0,0,0,1088,143,
        1,0,0,0,1089,1092,3,20,10,0,1090,1092,3,146,73,0,1091,1089,1,0,0,
        0,1091,1090,1,0,0,0,1092,145,1,0,0,0,1093,1094,7,20,0,0,1094,147,
        1,0,0,0,1095,1096,5,41,0,0,1096,1097,3,32,16,0,1097,1099,5,43,0,
        0,1098,1100,3,150,75,0,1099,1098,1,0,0,0,1099,1100,1,0,0,0,1100,
        1102,1,0,0,0,1101,1103,5,279,0,0,1102,1101,1,0,0,0,1102,1103,1,0,
        0,0,1103,1115,1,0,0,0,1104,1105,5,44,0,0,1105,1106,5,215,0,0,1106,
        1107,5,45,0,0,1107,1109,3,32,16,0,1108,1110,3,150,75,0,1109,1108,
        1,0,0,0,1109,1110,1,0,0,0,1110,1112,1,0,0,0,1111,1113,5,279,0,0,
        1112,1111,1,0,0,0,1112,1113,1,0,0,0,1113,1115,1,0,0,0,1114,1095,
        1,0,0,0,1114,1104,1,0,0,0,1115,149,1,0,0,0,1116,1117,5,176,0,0,1117,
        1118,3,154,77,0,1118,1119,5,128,0,0,1119,1123,3,250,125,0,1120,1122,
        3,152,76,0,1121,1120,1,0,0,0,1122,1125,1,0,0,0,1123,1121,1,0,0,0,
        1123,1124,1,0,0,0,1124,151,1,0,0,0,1125,1123,1,0,0,0,1126,1127,5,
        216,0,0,1127,1128,3,154,77,0,1128,1129,5,128,0,0,1129,1130,3,250,
        125,0,1130,153,1,0,0,0,1131,1132,3,24,12,0,1132,155,1,0,0,0,1133,
        1134,5,95,0,0,1134,1144,3,32,16,0,1135,1145,3,158,79,0,1136,1142,
        3,162,81,0,1137,1139,3,164,82,0,1138,1140,5,279,0,0,1139,1138,1,
        0,0,0,1139,1140,1,0,0,0,1140,1143,1,0,0,0,1141,1143,5,279,0,0,1142,
        1137,1,0,0,0,1142,1141,1,0,0,0,1142,1143,1,0,0,0,1143,1145,1,0,0,
        0,1144,1135,1,0,0,0,1144,1136,1,0,0,0,1145,157,1,0,0,0,1146,1147,
        3,160,80,0,1147,1149,5,92,0,0,1148,1150,5,279,0,0,1149,1148,1,0,
        0,0,1149,1150,1,0,0,0,1150,159,1,0,0,0,1151,1152,5,212,0,0,1152,
        1153,3,32,16,0,1153,1154,5,244,0,0,1154,1155,5,124,0,0,1155,1156,
        3,32,16,0,1156,161,1,0,0,0,1157,1159,7,21,0,0,1158,1157,1,0,0,0,
        1158,1159,1,0,0,0,1159,1160,1,0,0,0,1160,1161,3,32,16,0,1161,1162,
        5,94,0,0,1162,163,1,0,0,0,1163,1166,5,111,0,0,1164,1167,3,248,124,
        0,1165,1167,3,166,83,0,1166,1164,1,0,0,0,1166,1165,1,0,0,0,1167,
        165,1,0,0,0,1168,1169,5,46,0,0,1169,1170,3,168,84,0,1170,1171,7,
        22,0,0,1171,1172,5,40,0,0,1172,1174,5,280,0,0,1173,1175,3,170,85,
        0,1174,1173,1,0,0,0,1175,1176,1,0,0,0,1176,1174,1,0,0,0,1176,1177,
        1,0,0,0,1177,1211,1,0,0,0,1178,1183,3,178,89,0,1179,1183,5,219,0,
        0,1180,1183,5,217,0,0,1181,1183,5,252,0,0,1182,1178,1,0,0,0,1182,
        1179,1,0,0,0,1182,1180,1,0,0,0,1182,1181,1,0,0,0,1183,1184,1,0,0,
        0,1184,1185,5,122,0,0,1185,1186,3,168,84,0,1186,1187,7,22,0,0,1187,
        1188,5,154,0,0,1188,1190,5,280,0,0,1189,1191,3,170,85,0,1190,1189,
        1,0,0,0,1191,1192,1,0,0,0,1192,1190,1,0,0,0,1192,1193,1,0,0,0,1193,
        1211,1,0,0,0,1194,1199,3,178,89,0,1195,1199,5,219,0,0,1196,1199,
        5,217,0,0,1197,1199,5,252,0,0,1198,1194,1,0,0,0,1198,1195,1,0,0,
        0,1198,1196,1,0,0,0,1198,1197,1,0,0,0,1199,1200,1,0,0,0,1200,1201,
        5,154,0,0,1201,1202,5,122,0,0,1202,1203,3,168,84,0,1203,1204,7,22,
        0,0,1204,1206,5,280,0,0,1205,1207,3,170,85,0,1206,1205,1,0,0,0,1207,
        1208,1,0,0,0,1208,1206,1,0,0,0,1208,1209,1,0,0,0,1209,1211,1,0,0,
        0,1210,1168,1,0,0,0,1210,1182,1,0,0,0,1210,1198,1,0,0,0,1211,167,
        1,0,0,0,1212,1227,5,124,0,0,1213,1227,5,203,0,0,1214,1215,7,23,0,
        0,1215,1216,7,24,0,0,1216,1217,5,244,0,0,1217,1227,5,212,0,0,1218,
        1219,5,159,0,0,1219,1220,7,24,0,0,1220,1221,5,244,0,0,1221,1227,
        5,212,0,0,1222,1223,5,160,0,0,1223,1224,7,24,0,0,1224,1225,5,244,
        0,0,1225,1227,5,212,0,0,1226,1212,1,0,0,0,1226,1213,1,0,0,0,1226,
        1214,1,0,0,0,1226,1218,1,0,0,0,1226,1222,1,0,0,0,1227,169,1,0,0,
        0,1228,1231,3,172,86,0,1229,1232,3,174,87,0,1230,1232,3,176,88,0,
        1231,1229,1,0,0,0,1231,1230,1,0,0,0,1232,171,1,0,0,0,1233,1235,7,
        25,0,0,1234,1233,1,0,0,0,1235,1236,1,0,0,0,1236,1234,1,0,0,0,1236,
        1237,1,0,0,0,1237,173,1,0,0,0,1238,1239,3,248,124,0,1239,175,1,0,
        0,0,1240,1244,3,178,89,0,1241,1244,5,219,0,0,1242,1244,5,252,0,0,
        1243,1240,1,0,0,0,1243,1241,1,0,0,0,1243,1242,1,0,0,0,1244,1245,
        1,0,0,0,1245,1246,5,154,0,0,1246,1247,5,122,0,0,1247,1248,3,168,
        84,0,1248,1249,7,22,0,0,1249,1251,5,280,0,0,1250,1252,3,170,85,0,
        1251,1250,1,0,0,0,1252,1253,1,0,0,0,1253,1251,1,0,0,0,1253,1254,
        1,0,0,0,1254,177,1,0,0,0,1255,1258,3,182,91,0,1256,1257,7,26,0,0,
        1257,1259,3,202,101,0,1258,1256,1,0,0,0,1258,1259,1,0,0,0,1259,179,
        1,0,0,0,1260,1263,3,184,92,0,1261,1262,7,26,0,0,1262,1264,3,202,
        101,0,1263,1261,1,0,0,0,1263,1264,1,0,0,0,1264,181,1,0,0,0,1265,
        1271,3,186,93,0,1266,1267,3,38,19,0,1267,1268,3,186,93,0,1268,1270,
        1,0,0,0,1269,1266,1,0,0,0,1270,1273,1,0,0,0,1271,1269,1,0,0,0,1271,
        1272,1,0,0,0,1272,183,1,0,0,0,1273,1271,1,0,0,0,1274,1280,3,188,
        94,0,1275,1276,3,38,19,0,1276,1277,3,188,94,0,1277,1279,1,0,0,0,
        1278,1275,1,0,0,0,1279,1282,1,0,0,0,1280,1278,1,0,0,0,1280,1281,
        1,0,0,0,1281,185,1,0,0,0,1282,1280,1,0,0,0,1283,1285,7,3,0,0,1284,
        1286,3,20,10,0,1285,1284,1,0,0,0,1286,1287,1,0,0,0,1287,1285,1,0,
        0,0,1287,1288,1,0,0,0,1288,1291,1,0,0,0,1289,1291,5,219,0,0,1290,
        1283,1,0,0,0,1290,1289,1,0,0,0,1291,187,1,0,0,0,1292,1294,7,3,0,
        0,1293,1295,3,28,14,0,1294,1293,1,0,0,0,1295,1296,1,0,0,0,1296,1294,
        1,0,0,0,1296,1297,1,0,0,0,1297,1300,1,0,0,0,1298,1300,5,219,0,0,
        1299,1292,1,0,0,0,1299,1298,1,0,0,0,1300,189,1,0,0,0,1301,1302,3,
        192,96,0,1302,1303,5,244,0,0,1303,1304,3,178,89,0,1304,191,1,0,0,
        0,1305,1306,3,36,18,0,1306,193,1,0,0,0,1307,1309,3,38,19,0,1308,
        1307,1,0,0,0,1308,1309,1,0,0,0,1309,1310,1,0,0,0,1310,1311,3,34,
        17,0,1311,195,1,0,0,0,1312,1314,3,38,19,0,1313,1312,1,0,0,0,1313,
        1314,1,0,0,0,1314,1316,1,0,0,0,1315,1317,7,19,0,0,1316,1315,1,0,
        0,0,1316,1317,1,0,0,0,1317,1319,1,0,0,0,1318,1320,3,28,14,0,1319,
        1318,1,0,0,0,1320,1321,1,0,0,0,1321,1319,1,0,0,0,1321,1322,1,0,0,
        0,1322,197,1,0,0,0,1323,1324,7,27,0,0,1324,1325,3,32,16,0,1325,199,
        1,0,0,0,1326,1327,5,124,0,0,1327,1334,3,32,16,0,1328,1331,3,32,16,
        0,1329,1330,7,26,0,0,1330,1332,3,202,101,0,1331,1329,1,0,0,0,1331,
        1332,1,0,0,0,1332,1334,1,0,0,0,1333,1326,1,0,0,0,1333,1328,1,0,0,
        0,1334,201,1,0,0,0,1335,1338,3,204,102,0,1336,1338,3,220,110,0,1337,
        1335,1,0,0,0,1337,1336,1,0,0,0,1338,203,1,0,0,0,1339,1345,3,212,
        106,0,1340,1345,3,206,103,0,1341,1345,3,214,107,0,1342,1345,3,216,
        108,0,1343,1345,3,218,109,0,1344,1339,1,0,0,0,1344,1340,1,0,0,0,
        1344,1341,1,0,0,0,1344,1342,1,0,0,0,1344,1343,1,0,0,0,1345,205,1,
        0,0,0,1346,1347,3,208,104,0,1347,207,1,0,0,0,1348,1350,5,215,0,0,
        1349,1348,1,0,0,0,1349,1350,1,0,0,0,1350,1353,1,0,0,0,1351,1354,
        3,194,97,0,1352,1354,3,210,105,0,1353,1351,1,0,0,0,1353,1352,1,0,
        0,0,1354,1355,1,0,0,0,1355,1356,7,28,0,0,1356,209,1,0,0,0,1357,1358,
        3,32,16,0,1358,211,1,0,0,0,1359,1361,5,215,0,0,1360,1359,1,0,0,0,
        1360,1361,1,0,0,0,1361,1362,1,0,0,0,1362,1363,3,32,16,0,1363,1364,
        5,109,0,0,1364,1365,3,260,130,0,1365,1366,3,248,124,0,1366,213,1,
        0,0,0,1367,1368,3,230,115,0,1368,1369,3,236,118,0,1369,215,1,0,0,
        0,1370,1371,3,232,116,0,1371,1372,3,238,119,0,1372,217,1,0,0,0,1373,
        1374,3,234,117,0,1374,1375,3,240,120,0,1375,219,1,0,0,0,1376,1377,
        5,122,0,0,1377,1378,3,168,84,0,1378,1379,5,247,0,0,1379,1380,7,29,
        0,0,1380,1381,7,30,0,0,1381,1383,5,280,0,0,1382,1384,3,222,111,0,
        1383,1382,1,0,0,0,1384,1385,1,0,0,0,1385,1383,1,0,0,0,1385,1386,
        1,0,0,0,1386,221,1,0,0,0,1387,1388,3,172,86,0,1388,1389,3,224,112,
        0,1389,1394,1,0,0,0,1390,1391,3,172,86,0,1391,1392,3,228,114,0,1392,
        1394,1,0,0,0,1393,1387,1,0,0,0,1393,1390,1,0,0,0,1394,223,1,0,0,
        0,1395,1396,3,226,113,0,1396,225,1,0,0,0,1397,1398,3,190,95,0,1398,
        1399,3,260,130,0,1399,1400,3,248,124,0,1400,1409,1,0,0,0,1401,1402,
        3,178,89,0,1402,1403,3,208,104,0,1403,1409,1,0,0,0,1404,1405,3,190,
        95,0,1405,1406,7,31,0,0,1406,1407,3,194,97,0,1407,1409,1,0,0,0,1408,
        1397,1,0,0,0,1408,1401,1,0,0,0,1408,1404,1,0,0,0,1409,227,1,0,0,
        0,1410,1415,5,154,0,0,1411,1415,5,153,0,0,1412,1413,5,117,0,0,1413,
        1415,5,118,0,0,1414,1410,1,0,0,0,1414,1411,1,0,0,0,1414,1412,1,0,
        0,0,1415,1416,1,0,0,0,1416,1417,5,122,0,0,1417,1418,3,168,84,0,1418,
        1419,5,247,0,0,1419,1420,7,29,0,0,1420,1422,5,280,0,0,1421,1423,
        3,222,111,0,1422,1421,1,0,0,0,1423,1424,1,0,0,0,1424,1422,1,0,0,
        0,1424,1425,1,0,0,0,1425,229,1,0,0,0,1426,1427,7,32,0,0,1427,231,
        1,0,0,0,1428,1429,7,33,0,0,1429,233,1,0,0,0,1430,1431,7,34,0,0,1431,
        235,1,0,0,0,1432,1433,3,248,124,0,1433,237,1,0,0,0,1434,1435,3,248,
        124,0,1435,239,1,0,0,0,1436,1461,3,40,20,0,1437,1461,5,235,0,0,1438,
        1461,5,236,0,0,1439,1440,5,17,0,0,1440,1441,5,274,0,0,1441,1442,
        3,274,137,0,1442,1443,5,278,0,0,1443,1444,3,274,137,0,1444,1445,
        5,278,0,0,1445,1446,3,274,137,0,1446,1447,5,275,0,0,1447,1461,1,
        0,0,0,1448,1449,5,18,0,0,1449,1450,5,274,0,0,1450,1451,3,274,137,
        0,1451,1452,5,275,0,0,1452,1461,1,0,0,0,1453,1461,3,190,95,0,1454,
        1461,3,198,99,0,1455,1461,3,106,53,0,1456,1457,5,274,0,0,1457,1458,
        3,248,124,0,1458,1459,5,275,0,0,1459,1461,1,0,0,0,1460,1436,1,0,
        0,0,1460,1437,1,0,0,0,1460,1438,1,0,0,0,1460,1439,1,0,0,0,1460,1448,
        1,0,0,0,1460,1453,1,0,0,0,1460,1454,1,0,0,0,1460,1455,1,0,0,0,1460,
        1456,1,0,0,0,1461,241,1,0,0,0,1462,1466,5,107,0,0,1463,1465,3,244,
        122,0,1464,1463,1,0,0,0,1465,1468,1,0,0,0,1466,1464,1,0,0,0,1466,
        1467,1,0,0,0,1467,1469,1,0,0,0,1468,1466,1,0,0,0,1469,1470,5,279,
        0,0,1470,243,1,0,0,0,1471,1473,7,9,0,0,1472,1471,1,0,0,0,1472,1473,
        1,0,0,0,1473,1474,1,0,0,0,1474,1475,5,267,0,0,1475,1476,5,113,0,
        0,1476,1477,3,246,123,0,1477,245,1,0,0,0,1478,1487,3,274,137,0,1479,
        1482,3,264,132,0,1480,1482,3,268,134,0,1481,1479,1,0,0,0,1481,1480,
        1,0,0,0,1482,1483,1,0,0,0,1483,1484,3,274,137,0,1484,1486,1,0,0,
        0,1485,1481,1,0,0,0,1486,1489,1,0,0,0,1487,1485,1,0,0,0,1487,1488,
        1,0,0,0,1488,247,1,0,0,0,1489,1487,1,0,0,0,1490,1491,3,252,126,0,
        1491,1492,5,278,0,0,1492,1493,3,278,139,0,1493,1494,3,276,138,0,
        1494,1504,1,0,0,0,1495,1496,3,252,126,0,1496,1497,5,278,0,0,1497,
        1498,3,278,139,0,1498,1504,1,0,0,0,1499,1500,3,252,126,0,1500,1501,
        3,276,138,0,1501,1504,1,0,0,0,1502,1504,3,252,126,0,1503,1490,1,
        0,0,0,1503,1495,1,0,0,0,1503,1499,1,0,0,0,1503,1502,1,0,0,0,1504,
        249,1,0,0,0,1505,1506,3,254,127,0,1506,1507,5,278,0,0,1507,1508,
        3,278,139,0,1508,1509,3,276,138,0,1509,1519,1,0,0,0,1510,1511,3,
        254,127,0,1511,1512,5,278,0,0,1512,1513,3,278,139,0,1513,1519,1,
        0,0,0,1514,1515,3,254,127,0,1515,1516,3,276,138,0,1516,1519,1,0,
        0,0,1517,1519,3,254,127,0,1518,1505,1,0,0,0,1518,1510,1,0,0,0,1518,
        1514,1,0,0,0,1518,1517,1,0,0,0,1519,251,1,0,0,0,1520,1523,3,254,
        127,0,1521,1522,7,35,0,0,1522,1524,3,252,126,0,1523,1521,1,0,0,0,
        1523,1524,1,0,0,0,1524,253,1,0,0,0,1525,1557,3,310,155,0,1526,1557,
        3,286,143,0,1527,1528,3,262,131,0,1528,1529,5,113,0,0,1529,1530,
        3,34,17,0,1530,1557,1,0,0,0,1531,1532,3,262,131,0,1532,1533,5,110,
        0,0,1533,1534,3,34,17,0,1534,1557,1,0,0,0,1535,1536,3,262,131,0,
        1536,1537,3,258,129,0,1537,1542,3,256,128,0,1538,1539,5,278,0,0,
        1539,1541,3,256,128,0,1540,1538,1,0,0,0,1541,1544,1,0,0,0,1542,1540,
        1,0,0,0,1542,1543,1,0,0,0,1543,1545,1,0,0,0,1544,1542,1,0,0,0,1545,
        1546,5,229,0,0,1546,1547,3,256,128,0,1547,1557,1,0,0,0,1548,1552,
        3,262,131,0,1549,1550,3,260,130,0,1550,1551,3,262,131,0,1551,1553,
        1,0,0,0,1552,1549,1,0,0,0,1552,1553,1,0,0,0,1553,1557,1,0,0,0,1554,
        1557,3,306,153,0,1555,1557,3,308,154,0,1556,1525,1,0,0,0,1556,1526,
        1,0,0,0,1556,1527,1,0,0,0,1556,1531,1,0,0,0,1556,1535,1,0,0,0,1556,
        1548,1,0,0,0,1556,1554,1,0,0,0,1556,1555,1,0,0,0,1557,255,1,0,0,
        0,1558,1568,5,273,0,0,1559,1568,5,272,0,0,1560,1562,5,268,0,0,1561,
        1563,3,84,42,0,1562,1561,1,0,0,0,1562,1563,1,0,0,0,1563,1568,1,0,
        0,0,1564,1568,5,271,0,0,1565,1568,3,40,20,0,1566,1568,3,18,9,0,1567,
        1558,1,0,0,0,1567,1559,1,0,0,0,1567,1560,1,0,0,0,1567,1564,1,0,0,
        0,1567,1565,1,0,0,0,1567,1566,1,0,0,0,1568,257,1,0,0,0,1569,1570,
        7,36,0,0,1570,259,1,0,0,0,1571,1572,7,37,0,0,1572,261,1,0,0,0,1573,
        1579,3,266,133,0,1574,1575,3,264,132,0,1575,1576,3,266,133,0,1576,
        1578,1,0,0,0,1577,1574,1,0,0,0,1578,1581,1,0,0,0,1579,1577,1,0,0,
        0,1579,1580,1,0,0,0,1580,263,1,0,0,0,1581,1579,1,0,0,0,1582,1583,
        7,38,0,0,1583,265,1,0,0,0,1584,1590,3,270,135,0,1585,1586,3,268,
        134,0,1586,1587,3,270,135,0,1587,1589,1,0,0,0,1588,1585,1,0,0,0,
        1589,1592,1,0,0,0,1590,1588,1,0,0,0,1590,1591,1,0,0,0,1591,267,1,
        0,0,0,1592,1590,1,0,0,0,1593,1594,7,39,0,0,1594,269,1,0,0,0,1595,
        1601,3,274,137,0,1596,1597,3,272,136,0,1597,1598,3,274,137,0,1598,
        1600,1,0,0,0,1599,1596,1,0,0,0,1600,1603,1,0,0,0,1601,1599,1,0,0,
        0,1601,1602,1,0,0,0,1602,271,1,0,0,0,1603,1601,1,0,0,0,1604,1605,
        7,40,0,0,1605,273,1,0,0,0,1606,1607,6,137,-1,0,1607,1608,5,137,0,
        0,1608,1870,3,274,137,55,1609,1610,5,292,0,0,1610,1870,3,274,137,
        54,1611,1612,5,140,0,0,1612,1870,3,274,137,53,1613,1614,5,11,0,0,
        1614,1615,3,274,137,0,1615,1616,5,146,0,0,1616,1619,3,274,137,0,
        1617,1618,5,192,0,0,1618,1620,3,84,42,0,1619,1617,1,0,0,0,1619,1620,
        1,0,0,0,1620,1870,1,0,0,0,1621,1622,5,196,0,0,1622,1623,3,274,137,
        0,1623,1624,5,146,0,0,1624,1627,3,274,137,0,1625,1626,5,192,0,0,
        1626,1628,3,84,42,0,1627,1625,1,0,0,0,1627,1628,1,0,0,0,1628,1870,
        1,0,0,0,1629,1630,5,195,0,0,1630,1635,3,274,137,0,1631,1632,5,278,
        0,0,1632,1634,3,274,137,0,1633,1631,1,0,0,0,1634,1637,1,0,0,0,1635,
        1633,1,0,0,0,1635,1636,1,0,0,0,1636,1638,1,0,0,0,1637,1635,1,0,0,
        0,1638,1639,5,216,0,0,1639,1640,3,274,137,50,1640,1870,1,0,0,0,1641,
        1642,5,195,0,0,1642,1643,5,124,0,0,1643,1870,3,32,16,0,1644,1645,
        5,195,0,0,1645,1646,5,124,0,0,1646,1870,3,190,95,0,1647,1648,5,217,
        0,0,1648,1651,5,190,0,0,1649,1651,5,190,0,0,1650,1647,1,0,0,0,1650,
        1649,1,0,0,0,1651,1652,1,0,0,0,1652,1870,3,200,100,0,1653,1654,5,
        217,0,0,1654,1655,5,190,0,0,1655,1870,3,190,95,0,1656,1657,5,190,
        0,0,1657,1870,3,190,95,0,1658,1661,5,268,0,0,1659,1662,5,283,0,0,
        1660,1662,5,267,0,0,1661,1659,1,0,0,0,1661,1660,1,0,0,0,1662,1665,
        1,0,0,0,1663,1665,5,271,0,0,1664,1658,1,0,0,0,1664,1663,1,0,0,0,
        1665,1666,1,0,0,0,1666,1667,5,244,0,0,1667,1870,3,274,137,44,1668,
        1669,5,271,0,0,1669,1670,5,244,0,0,1670,1870,3,274,137,43,1671,1672,
        5,30,0,0,1672,1677,3,274,137,0,1673,1674,5,278,0,0,1674,1676,3,274,
        137,0,1675,1673,1,0,0,0,1676,1679,1,0,0,0,1677,1675,1,0,0,0,1677,
        1678,1,0,0,0,1678,1680,1,0,0,0,1679,1677,1,0,0,0,1680,1681,7,35,
        0,0,1681,1682,3,274,137,39,1682,1870,1,0,0,0,1683,1684,5,156,0,0,
        1684,1870,3,274,137,37,1685,1686,5,12,0,0,1686,1687,5,274,0,0,1687,
        1688,3,248,124,0,1688,1689,5,275,0,0,1689,1870,1,0,0,0,1690,1691,
        5,14,0,0,1691,1696,3,274,137,0,1692,1693,5,278,0,0,1693,1695,3,274,
        137,0,1694,1692,1,0,0,0,1695,1698,1,0,0,0,1696,1694,1,0,0,0,1696,
        1697,1,0,0,0,1697,1699,1,0,0,0,1698,1696,1,0,0,0,1699,1700,5,216,
        0,0,1700,1701,3,274,137,35,1701,1870,1,0,0,0,1702,1703,5,14,0,0,
        1703,1704,5,124,0,0,1704,1870,3,190,95,0,1705,1706,5,13,0,0,1706,
        1711,3,274,137,0,1707,1708,5,278,0,0,1708,1710,3,274,137,0,1709,
        1707,1,0,0,0,1710,1713,1,0,0,0,1711,1709,1,0,0,0,1711,1712,1,0,0,
        0,1712,1714,1,0,0,0,1713,1711,1,0,0,0,1714,1715,5,216,0,0,1715,1716,
        3,274,137,33,1716,1870,1,0,0,0,1717,1718,5,13,0,0,1718,1719,5,124,
        0,0,1719,1870,3,190,95,0,1720,1721,5,217,0,0,1721,1722,5,221,0,0,
        1722,1723,5,241,0,0,1723,1870,3,274,137,31,1724,1725,5,212,0,0,1725,
        1726,5,224,0,0,1726,1727,5,241,0,0,1727,1870,3,274,137,30,1728,1729,
        5,212,0,0,1729,1730,5,209,0,0,1730,1731,5,241,0,0,1731,1870,3,274,
        137,29,1732,1733,5,17,0,0,1733,1734,5,274,0,0,1734,1735,3,274,137,
        0,1735,1736,5,278,0,0,1736,1737,3,274,137,0,1737,1738,5,278,0,0,
        1738,1739,3,274,137,0,1739,1740,5,275,0,0,1740,1870,1,0,0,0,1741,
        1742,5,18,0,0,1742,1743,5,274,0,0,1743,1744,3,274,137,0,1744,1745,
        5,275,0,0,1745,1870,1,0,0,0,1746,1747,3,240,120,0,1747,1748,7,41,
        0,0,1748,1749,3,274,137,0,1749,1750,3,44,22,0,1750,1870,1,0,0,0,
        1751,1752,5,191,0,0,1752,1757,3,274,137,0,1753,1754,5,278,0,0,1754,
        1756,3,274,137,0,1755,1753,1,0,0,0,1756,1759,1,0,0,0,1757,1755,1,
        0,0,0,1757,1758,1,0,0,0,1758,1760,1,0,0,0,1759,1757,1,0,0,0,1760,
        1761,5,216,0,0,1761,1762,3,274,137,25,1762,1870,1,0,0,0,1763,1764,
        5,193,0,0,1764,1769,3,274,137,0,1765,1766,5,278,0,0,1766,1768,3,
        274,137,0,1767,1765,1,0,0,0,1768,1771,1,0,0,0,1769,1767,1,0,0,0,
        1769,1770,1,0,0,0,1770,1772,1,0,0,0,1771,1769,1,0,0,0,1772,1773,
        5,216,0,0,1773,1774,3,274,137,24,1774,1870,1,0,0,0,1775,1776,5,15,
        0,0,1776,1778,3,248,124,0,1777,1779,3,284,142,0,1778,1777,1,0,0,
        0,1778,1779,1,0,0,0,1779,1870,1,0,0,0,1780,1781,5,217,0,0,1781,1782,
        5,190,0,0,1782,1783,5,210,0,0,1783,1792,5,220,0,0,1784,1786,5,212,
        0,0,1785,1784,1,0,0,0,1785,1786,1,0,0,0,1786,1787,1,0,0,0,1787,1793,
        5,224,0,0,1788,1790,5,217,0,0,1789,1788,1,0,0,0,1789,1790,1,0,0,
        0,1790,1791,1,0,0,0,1791,1793,5,221,0,0,1792,1785,1,0,0,0,1792,1789,
        1,0,0,0,1793,1794,1,0,0,0,1794,1795,5,211,0,0,1795,1870,3,248,124,
        0,1796,1798,3,18,9,0,1797,1796,1,0,0,0,1798,1799,1,0,0,0,1799,1797,
        1,0,0,0,1799,1800,1,0,0,0,1800,1801,1,0,0,0,1801,1802,5,15,0,0,1802,
        1804,3,248,124,0,1803,1805,3,284,142,0,1804,1803,1,0,0,0,1804,1805,
        1,0,0,0,1805,1870,1,0,0,0,1806,1807,5,16,0,0,1807,1808,7,42,0,0,
        1808,1809,5,244,0,0,1809,1811,3,248,124,0,1810,1812,3,284,142,0,
        1811,1810,1,0,0,0,1811,1812,1,0,0,0,1812,1870,1,0,0,0,1813,1815,
        3,18,9,0,1814,1813,1,0,0,0,1815,1816,1,0,0,0,1816,1814,1,0,0,0,1816,
        1817,1,0,0,0,1817,1818,1,0,0,0,1818,1819,5,16,0,0,1819,1820,7,42,
        0,0,1820,1821,5,244,0,0,1821,1823,3,248,124,0,1822,1824,3,284,142,
        0,1823,1822,1,0,0,0,1823,1824,1,0,0,0,1824,1870,1,0,0,0,1825,1828,
        3,294,147,0,1826,1828,3,296,148,0,1827,1825,1,0,0,0,1827,1826,1,
        0,0,0,1828,1829,1,0,0,0,1829,1830,3,192,96,0,1830,1831,3,298,149,
        0,1831,1870,1,0,0,0,1832,1835,3,294,147,0,1833,1835,3,296,148,0,
        1834,1832,1,0,0,0,1834,1833,1,0,0,0,1835,1838,1,0,0,0,1836,1839,
        3,198,99,0,1837,1839,3,190,95,0,1838,1836,1,0,0,0,1838,1837,1,0,
        0,0,1839,1840,1,0,0,0,1840,1841,5,150,0,0,1841,1842,3,32,16,0,1842,
        1843,5,240,0,0,1843,1845,3,32,16,0,1844,1846,5,279,0,0,1845,1844,
        1,0,0,0,1845,1846,1,0,0,0,1846,1870,1,0,0,0,1847,1849,5,268,0,0,
        1848,1850,3,84,42,0,1849,1848,1,0,0,0,1849,1850,1,0,0,0,1850,1870,
        1,0,0,0,1851,1870,5,235,0,0,1852,1870,3,18,9,0,1853,1870,3,198,99,
        0,1854,1870,3,190,95,0,1855,1870,3,178,89,0,1856,1870,3,32,16,0,
        1857,1870,3,106,53,0,1858,1870,5,271,0,0,1859,1870,5,272,0,0,1860,
        1870,5,273,0,0,1861,1870,3,40,20,0,1862,1870,5,249,0,0,1863,1870,
        5,230,0,0,1864,1870,5,219,0,0,1865,1866,5,274,0,0,1866,1867,3,248,
        124,0,1867,1868,5,275,0,0,1868,1870,1,0,0,0,1869,1606,1,0,0,0,1869,
        1609,1,0,0,0,1869,1611,1,0,0,0,1869,1613,1,0,0,0,1869,1621,1,0,0,
        0,1869,1629,1,0,0,0,1869,1641,1,0,0,0,1869,1644,1,0,0,0,1869,1650,
        1,0,0,0,1869,1653,1,0,0,0,1869,1656,1,0,0,0,1869,1664,1,0,0,0,1869,
        1668,1,0,0,0,1869,1671,1,0,0,0,1869,1683,1,0,0,0,1869,1685,1,0,0,
        0,1869,1690,1,0,0,0,1869,1702,1,0,0,0,1869,1705,1,0,0,0,1869,1717,
        1,0,0,0,1869,1720,1,0,0,0,1869,1724,1,0,0,0,1869,1728,1,0,0,0,1869,
        1732,1,0,0,0,1869,1741,1,0,0,0,1869,1746,1,0,0,0,1869,1751,1,0,0,
        0,1869,1763,1,0,0,0,1869,1775,1,0,0,0,1869,1780,1,0,0,0,1869,1797,
        1,0,0,0,1869,1806,1,0,0,0,1869,1814,1,0,0,0,1869,1827,1,0,0,0,1869,
        1834,1,0,0,0,1869,1847,1,0,0,0,1869,1851,1,0,0,0,1869,1852,1,0,0,
        0,1869,1853,1,0,0,0,1869,1854,1,0,0,0,1869,1855,1,0,0,0,1869,1856,
        1,0,0,0,1869,1857,1,0,0,0,1869,1858,1,0,0,0,1869,1859,1,0,0,0,1869,
        1860,1,0,0,0,1869,1861,1,0,0,0,1869,1862,1,0,0,0,1869,1863,1,0,0,
        0,1869,1864,1,0,0,0,1869,1865,1,0,0,0,1870,1893,1,0,0,0,1871,1874,
        10,38,0,0,1872,1873,5,278,0,0,1873,1875,3,274,137,0,1874,1872,1,
        0,0,0,1875,1876,1,0,0,0,1876,1874,1,0,0,0,1876,1877,1,0,0,0,1877,
        1878,1,0,0,0,1878,1879,7,35,0,0,1879,1880,3,274,137,39,1880,1892,
        1,0,0,0,1881,1882,10,42,0,0,1882,1892,3,276,138,0,1883,1884,10,41,
        0,0,1884,1885,5,278,0,0,1885,1886,3,278,139,0,1886,1887,3,276,138,
        0,1887,1892,1,0,0,0,1888,1889,10,40,0,0,1889,1890,5,278,0,0,1890,
        1892,3,278,139,0,1891,1871,1,0,0,0,1891,1881,1,0,0,0,1891,1883,1,
        0,0,0,1891,1888,1,0,0,0,1892,1895,1,0,0,0,1893,1891,1,0,0,0,1893,
        1894,1,0,0,0,1894,275,1,0,0,0,1895,1893,1,0,0,0,1896,1897,7,43,0,
        0,1897,1898,5,123,0,0,1898,1899,5,268,0,0,1899,1900,5,169,0,0,1900,
        277,1,0,0,0,1901,1908,3,280,140,0,1902,1908,3,282,141,0,1903,1904,
        3,280,140,0,1904,1905,5,216,0,0,1905,1906,3,282,141,0,1906,1908,
        1,0,0,0,1907,1901,1,0,0,0,1907,1902,1,0,0,0,1907,1903,1,0,0,0,1908,
        279,1,0,0,0,1909,1910,5,20,0,0,1910,1911,3,248,124,0,1911,281,1,
        0,0,0,1912,1913,5,21,0,0,1913,1914,3,248,124,0,1914,283,1,0,0,0,
        1915,1916,5,4,0,0,1916,1919,3,248,124,0,1917,1919,3,288,144,0,1918,
        1915,1,0,0,0,1918,1917,1,0,0,0,1919,285,1,0,0,0,1920,1921,5,7,0,
        0,1921,1922,3,288,144,0,1922,287,1,0,0,0,1923,1924,5,150,0,0,1924,
        1940,3,240,120,0,1925,1926,5,244,0,0,1926,1927,3,240,120,0,1927,
        1928,5,146,0,0,1928,1929,3,240,120,0,1929,1940,1,0,0,0,1930,1931,
        5,244,0,0,1931,1932,3,240,120,0,1932,1933,5,148,0,0,1933,1934,3,
        240,120,0,1934,1940,1,0,0,0,1935,1936,5,146,0,0,1936,1940,3,240,
        120,0,1937,1938,5,148,0,0,1938,1940,3,240,120,0,1939,1923,1,0,0,
        0,1939,1925,1,0,0,0,1939,1930,1,0,0,0,1939,1935,1,0,0,0,1939,1937,
        1,0,0,0,1940,289,1,0,0,0,1941,1942,5,150,0,0,1942,1958,3,292,146,
        0,1943,1944,5,146,0,0,1944,1958,3,292,146,0,1945,1946,5,148,0,0,
        1946,1958,3,292,146,0,1947,1948,5,244,0,0,1948,1949,3,292,146,0,
        1949,1950,5,146,0,0,1950,1951,3,292,146,0,1951,1958,1,0,0,0,1952,
        1953,5,244,0,0,1953,1954,3,292,146,0,1954,1955,5,148,0,0,1955,1956,
        3,292,146,0,1956,1958,1,0,0,0,1957,1941,1,0,0,0,1957,1943,1,0,0,
        0,1957,1945,1,0,0,0,1957,1947,1,0,0,0,1957,1952,1,0,0,0,1958,291,
        1,0,0,0,1959,1964,3,40,20,0,1960,1964,5,235,0,0,1961,1964,5,236,
        0,0,1962,1964,3,190,95,0,1963,1959,1,0,0,0,1963,1960,1,0,0,0,1963,
        1961,1,0,0,0,1963,1962,1,0,0,0,1964,293,1,0,0,0,1965,1966,5,217,
        0,0,1966,1972,5,190,0,0,1967,1972,5,190,0,0,1968,1972,5,13,0,0,1969,
        1972,5,14,0,0,1970,1972,5,195,0,0,1971,1965,1,0,0,0,1971,1967,1,
        0,0,0,1971,1968,1,0,0,0,1971,1969,1,0,0,0,1971,1970,1,0,0,0,1972,
        295,1,0,0,0,1973,1974,7,44,0,0,1974,297,1,0,0,0,1975,1979,5,233,
        0,0,1976,1980,3,300,150,0,1977,1980,3,302,151,0,1978,1980,3,304,
        152,0,1979,1976,1,0,0,0,1979,1977,1,0,0,0,1979,1978,1,0,0,0,1980,
        1981,1,0,0,0,1981,1982,5,279,0,0,1982,1986,1,0,0,0,1983,1984,5,244,
        0,0,1984,1986,3,300,150,0,1985,1975,1,0,0,0,1985,1983,1,0,0,0,1986,
        299,1,0,0,0,1987,1988,5,124,0,0,1988,1991,3,32,16,0,1989,1990,7,
        26,0,0,1990,1992,3,202,101,0,1991,1989,1,0,0,0,1991,1992,1,0,0,0,
        1992,301,1,0,0,0,1993,1994,5,212,0,0,1994,1995,3,32,16,0,1995,1996,
        5,150,0,0,1996,1997,3,32,16,0,1997,1998,5,240,0,0,1998,1999,3,32,
        16,0,1999,303,1,0,0,0,2000,2001,5,212,0,0,2001,2002,3,32,16,0,2002,
        2003,5,220,0,0,2003,2004,5,276,0,0,2004,2009,3,32,16,0,2005,2006,
        5,278,0,0,2006,2008,3,32,16,0,2007,2005,1,0,0,0,2008,2011,1,0,0,
        0,2009,2007,1,0,0,0,2009,2010,1,0,0,0,2010,2012,1,0,0,0,2011,2009,
        1,0,0,0,2012,2013,5,216,0,0,2013,2014,3,32,16,0,2014,2015,5,277,
        0,0,2015,305,1,0,0,0,2016,2017,3,274,137,0,2017,2018,7,45,0,0,2018,
        2043,1,0,0,0,2019,2020,3,274,137,0,2020,2021,7,46,0,0,2021,2022,
        5,268,0,0,2022,2023,5,167,0,0,2023,2043,1,0,0,0,2024,2025,3,274,
        137,0,2025,2026,7,47,0,0,2026,2027,3,18,9,0,2027,2043,1,0,0,0,2028,
        2029,3,274,137,0,2029,2030,7,48,0,0,2030,2031,3,18,9,0,2031,2043,
        1,0,0,0,2032,2033,3,274,137,0,2033,2034,7,49,0,0,2034,2035,3,18,
        9,0,2035,2043,1,0,0,0,2036,2037,3,178,89,0,2037,2038,5,92,0,0,2038,
        2043,1,0,0,0,2039,2040,3,274,137,0,2040,2041,5,94,0,0,2041,2043,
        1,0,0,0,2042,2016,1,0,0,0,2042,2019,1,0,0,0,2042,2024,1,0,0,0,2042,
        2028,1,0,0,0,2042,2032,1,0,0,0,2042,2036,1,0,0,0,2042,2039,1,0,0,
        0,2043,307,1,0,0,0,2044,2045,5,237,0,0,2045,2046,3,32,16,0,2046,
        2047,5,93,0,0,2047,2053,1,0,0,0,2048,2049,5,237,0,0,2049,2050,3,
        32,16,0,2050,2051,5,94,0,0,2051,2053,1,0,0,0,2052,2044,1,0,0,0,2052,
        2048,1,0,0,0,2053,309,1,0,0,0,2054,2055,3,178,89,0,2055,2056,3,34,
        17,0,2056,2057,5,110,0,0,2057,2067,1,0,0,0,2058,2059,3,178,89,0,
        2059,2060,3,34,17,0,2060,2061,5,113,0,0,2061,2067,1,0,0,0,2062,2063,
        3,178,89,0,2063,2064,5,113,0,0,2064,2065,3,34,17,0,2065,2067,1,0,
        0,0,2066,2054,1,0,0,0,2066,2058,1,0,0,0,2066,2062,1,0,0,0,2067,311,
        1,0,0,0,2068,2069,5,106,0,0,2069,2077,3,32,16,0,2070,2072,5,178,
        0,0,2071,2073,5,267,0,0,2072,2071,1,0,0,0,2073,2074,1,0,0,0,2074,
        2072,1,0,0,0,2074,2075,1,0,0,0,2075,2076,1,0,0,0,2076,2078,5,275,
        0,0,2077,2070,1,0,0,0,2077,2078,1,0,0,0,2078,2080,1,0,0,0,2079,2081,
        5,281,0,0,2080,2079,1,0,0,0,2080,2081,1,0,0,0,2081,313,1,0,0,0,2082,
        2083,5,272,0,0,2083,315,1,0,0,0,2084,2085,3,248,124,0,2085,2086,
        5,116,0,0,2086,2087,3,248,124,0,2087,2088,5,278,0,0,2088,2091,5,
        26,0,0,2089,2092,3,318,159,0,2090,2092,3,320,160,0,2091,2089,1,0,
        0,0,2091,2090,1,0,0,0,2092,2094,1,0,0,0,2093,2095,3,328,164,0,2094,
        2093,1,0,0,0,2094,2095,1,0,0,0,2095,317,1,0,0,0,2096,2097,3,326,
        163,0,2097,319,1,0,0,0,2098,2099,5,280,0,0,2099,2101,3,322,161,0,
        2100,2102,5,279,0,0,2101,2100,1,0,0,0,2101,2102,1,0,0,0,2102,321,
        1,0,0,0,2103,2107,3,324,162,0,2104,2106,3,324,162,0,2105,2104,1,
        0,0,0,2106,2109,1,0,0,0,2107,2105,1,0,0,0,2107,2108,1,0,0,0,2108,
        323,1,0,0,0,2109,2107,1,0,0,0,2110,2111,5,292,0,0,2111,2113,3,326,
        163,0,2112,2114,7,50,0,0,2113,2112,1,0,0,0,2113,2114,1,0,0,0,2114,
        325,1,0,0,0,2115,2130,5,198,0,0,2116,2117,5,35,0,0,2117,2130,3,248,
        124,0,2118,2119,5,34,0,0,2119,2120,7,51,0,0,2120,2130,3,248,124,
        0,2121,2122,5,33,0,0,2122,2130,3,326,163,0,2123,2124,5,21,0,0,2124,
        2130,3,248,124,0,2125,2126,5,123,0,0,2126,2127,5,268,0,0,2127,2128,
        5,169,0,0,2128,2130,7,52,0,0,2129,2115,1,0,0,0,2129,2116,1,0,0,0,
        2129,2118,1,0,0,0,2129,2121,1,0,0,0,2129,2123,1,0,0,0,2129,2125,
        1,0,0,0,2130,327,1,0,0,0,2131,2132,5,19,0,0,2132,2134,3,248,124,
        0,2133,2135,5,199,0,0,2134,2133,1,0,0,0,2134,2135,1,0,0,0,2135,329,
        1,0,0,0,241,336,338,349,354,363,367,376,380,383,388,391,395,400,
        413,417,421,426,435,440,445,451,457,463,468,474,480,489,491,494,
        499,504,510,516,522,527,533,539,548,550,554,557,562,567,573,579,
        585,590,596,602,604,612,621,630,647,650,653,658,663,668,672,676,
        679,685,689,697,700,703,711,718,725,734,741,749,757,760,767,773,
        784,793,797,801,805,812,818,823,828,836,842,845,860,864,868,871,
        874,882,889,893,901,905,913,922,930,933,938,942,944,949,956,962,
        965,968,973,977,979,985,1002,1012,1014,1028,1031,1043,1056,1075,
        1080,1087,1091,1099,1102,1109,1112,1114,1123,1139,1142,1144,1149,
        1158,1166,1176,1182,1192,1198,1208,1210,1226,1231,1236,1243,1253,
        1258,1263,1271,1280,1287,1290,1296,1299,1308,1313,1316,1321,1331,
        1333,1337,1344,1349,1353,1360,1385,1393,1408,1414,1424,1460,1466,
        1472,1481,1487,1503,1518,1523,1542,1552,1556,1562,1567,1579,1590,
        1601,1619,1627,1635,1650,1661,1664,1677,1696,1711,1757,1769,1778,
        1785,1789,1792,1799,1804,1811,1816,1823,1827,1834,1838,1845,1849,
        1869,1876,1891,1893,1907,1918,1939,1957,1963,1971,1979,1985,1991,
        2009,2042,2052,2066,2074,2077,2080,2091,2094,2101,2107,2113,2129,
        2134
    ]

class RegelSpraakParser ( Parser ):

    grammarFileName = "RegelSpraak.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'(voor het attribuut zonder voorzetsel):'", 
                     "'(na het attribuut met voorzetsel'", "'Datum en tijd in millisecondes'", 
                     "'gedurende de tijd dat'", "'gedurende het gehele'", 
                     "'gedurende de gehele'", "<INVALID>", "'moet berekend worden als'", 
                     "'moet gesteld worden op'", "'moet ge\\u00EFnitialiseerd worden op'", 
                     "'de absolute tijdsduur van'", "'de absolute waarde van'", 
                     "'de maximale waarde van'", "'de minimale waarde van'", 
                     "'het totaal van'", "'het tijdsevenredig deel per'", 
                     "'de datum met jaar, maand en dag'", "'de eerste paasdag van'", 
                     "'Als onverdeelde rest blijft'", "'met een minimum van'", 
                     "'met een maximum van'", "'groter of gelijk aan'", 
                     "'kleiner of gelijk aan'", "'later of gelijk aan'", 
                     "'eerder of gelijk aan'", "'waarbij wordt verdeeld'", 
                     "', bestaande uit de'", "'Wederkerig feittype'", "'is van het type'", 
                     "'de concatenatie van'", "'het volgende criterium:'", 
                     "'volgende criteria:'", "'bij een even groot criterium'", 
                     "'op volgorde van'", "'naar rato van'", "'numeriek met exact'", 
                     "'aan de elfproef'", "'groter is dan'", "'kleiner is dan'", 
                     "'wordt voldaan'", "<INVALID>", "'wordt een nieuw'", 
                     "'aangemaakt'", "'Cre\\u00EBer'", "'nieuwe'", "<INVALID>", 
                     "'gelijk is aan'", "'is gelijk aan'", "'is ongelijk aan'", 
                     "'is kleiner dan'", "'is kleiner of gelijk aan'", "'is groter dan'", 
                     "'is groter of gelijk aan'", "'zijn gelijk aan'", "'zijn ongelijk aan'", 
                     "'zijn groter dan'", "'zijn groter of gelijk aan'", 
                     "'zijn kleiner dan'", "'zijn kleiner of gelijk aan'", 
                     "'is later dan'", "'is later of gelijk aan'", "'is eerder dan'", 
                     "'is eerder of gelijk aan'", "'zijn later dan'", "'zijn later of gelijk aan'", 
                     "'zijn eerder dan'", "'zijn eerder of gelijk aan'", 
                     "'is leeg'", "'is gevuld'", "'zijn leeg'", "'zijn gevuld'", 
                     "'is kenmerk'", "'is rol'", "'zijn kenmerk'", "'zijn rol'", 
                     "'is niet kenmerk'", "'is niet rol'", "'zijn niet kenmerk'", 
                     "'zijn niet rol'", "'voldoet aan de elfproef'", "'voldoen aan de elfproef'", 
                     "'voldoet niet aan de elfproef'", "'voldoen niet aan de elfproef'", 
                     "'is numeriek met exact'", "'is niet numeriek met exact'", 
                     "'zijn numeriek met exact'", "'zijn niet numeriek met exact'", 
                     "'is een dagsoort'", "'zijn een dagsoort'", "'is geen dagsoort'", 
                     "'zijn geen dagsoort'", "'moeten uniek zijn'", "'is gevuurd'", 
                     "'is inconsistent'", "'Consistentieregel'", "'Regel'", 
                     "'Regelgroep'", "'Beslistabel'", "'Objecttype'", "'Domein'", 
                     "'Lijst'", "'Dimensie'", "'Eenheidsysteem'", "'Parameter'", 
                     "'Feittype'", "'Dagsoort'", "'Daarbij geldt:'", "'geldig'", 
                     "'hebben'", "'heeft'", "'indien'", "'is recursief'", 
                     "'is'", "'moet'", "'moeten'", "'wordt verdeeld over'", 
                     "'wordt'", "'voldaan'", "'zijn'", "'haar'", "'hun'", 
                     "'aan'", "'afgerond op'", "'alle'", "'eerder dan'", 
                     "'gedeeld door'", "'gedeeld door (ABS)'", "'gelijk aan'", 
                     "'gevuld'", "'gevuurd'", "'groter dan'", "'inconsistent'", 
                     "'kleiner dan'", "'later dan'", "'leeg'", "'maal'", 
                     "'min'", "'naar beneden'", "'naar boven'", "'niet'", 
                     "'ongelijk zijn aan'", "'ongelijk aan'", "'plus'", 
                     "'rekenkundig'", "'richting nul'", "'tot'", "'tot de macht'", 
                     "'tot en met'", "'uniek'", "'vanaf'", "'verenigd met'", 
                     "'verminderd met'", "'voldoen'", "'voldoet'", "'weg van nul'", 
                     "'de wortel van'", "'tenminste'", "'ten minste'", "'ten hoogste'", 
                     "'precies'", "'voorwaarde'", "'voorwaarden'", "'(bezittelijk)'", 
                     "'(bijvoeglijk)'", "'(bezield)'", "'Boolean'", "'cijfers'", 
                     "'Datum in dagen'", "'decimalen'", "'Enumeratie'", 
                     "'gedimensioneerd met'", "'geheel getal'", "'getal'", 
                     "'kenmerk'", "'kenmerken'", "'met'", "'met eenheid'", 
                     "'(mv:'", "'negatief'", "'niet-negatief'", "'Numeriek'", 
                     "'Percentage'", "'positief'", "'rol'", "'rollen'", 
                     "'Tekst'", "'voor elk jaar'", "'voor elke dag'", "'voor elke maand'", 
                     "'aantal'", "'de eerste van'", "'in hele'", "'de laatste van'", 
                     "'reeks van teksten en waarden'", "'de som van'", "'de tijdsduur van'", 
                     "'afnemende'", "'in gelijke delen'", "'over.'", "'toenemende'", 
                     "'drie'", "'\\u00E9\\u00E9n'", "'geen van de'", "'geen'", 
                     "'twee'", "'vier'", "'altijd'", "'bij'", "'dag'", "'dagen'", 
                     "'dat'", "<INVALID>", "'dd.'", "'die'", "<INVALID>", 
                     "'en'", "<INVALID>", "'meerdere'", "'hij'", "'in'", 
                     "'jaar'", "'jaren'", "'kwartaal'", "'maand'", "'maanden'", 
                     "'milliseconde'", "'minuut'", "'minuten'", "'of'", 
                     "'onwaar'", "'op'", "'ouder'", "'over'", "'periode'", 
                     "'Rekendatum'", "'Rekenjaar'", "'regelversie'", "'seconde'", 
                     "'seconden'", "'t/m'", "'uit'", "'uur'", "'uren'", 
                     "'van'", "'volgende voorwaarde'", "'volgende voorwaarden'", 
                     "'volgende'", "'voor'", "'waar'", "'week'", "'weken'", 
                     "'er'", "'meter'", "'kilogram'", "'voet'", "'pond'", 
                     "'mijl'", "'m'", "'kg'", "'s'", "'ft'", "'lb'", "'mi'", 
                     "'\\u20AC'", "'$'", "'\\u00B0'", "<INVALID>", "<INVALID>", 
                     "'='", "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "'('", "')'", "'{'", "'}'", "','", "'.'", "':'", "';'", 
                     "'/'", "'%'", "'\\u2022'", "'*'", "'\\u00AB'", "'\\u00BB'", 
                     "'^'", "'..'", "<INVALID>", "<INVALID>", "'-'", "'|'", 
                     "'n.v.t.'" ]

    symbolicNames = [ "<INVALID>", "VOOR_HET_ATTRIBUUT_ZONDER_VOORZETSEL", 
                      "NA_HET_ATTRIBUUT_MET_VOORZETSEL", "DATUM_TIJD_MILLIS", 
                      "GEDURENDE_DE_TIJD_DAT", "GEDURENDE_HET_GEHELE", "GEDURENDE_DE_GEHELE", 
                      "HET_IS_DE_PERIODE", "WORDT_BEREKEND_ALS", "WORDT_GESTELD_OP", 
                      "WORDT_GEINITIALISEERD_OP", "DE_ABSOLUTE_TIJDSDUUR_VAN", 
                      "DE_ABSOLUTE_WAARDE_VAN", "DE_MAXIMALE_WAARDE_VAN", 
                      "DE_MINIMALE_WAARDE_VAN", "HET_TOTAAL_VAN", "HET_TIJDSEVENREDIG_DEEL_PER", 
                      "DE_DATUM_MET", "DE_EERSTE_PAASDAG_VAN", "ALS_ONVERDEELDE_REST_BLIJFT", 
                      "MET_EEN_MINIMUM_VAN", "MET_EEN_MAXIMUM_VAN", "GROTER_OF_GELIJK_AAN", 
                      "KLEINER_OF_GELIJK_AAN", "LATER_OF_GELIJK_AAN", "EERDER_OF_GELIJK_AAN", 
                      "WAARBIJ_WORDT_VERDEELD", "BESTAANDE_UIT", "WEDERKERIG_FEITTYPE", 
                      "IS_VAN_HET_TYPE", "CONCATENATIE_VAN", "VOLGEND_CRITERIUM", 
                      "VOLGENDE_CRITERIA", "BIJ_EVEN_GROOT_CRITERIUM", "OP_VOLGORDE_VAN", 
                      "NAAR_RATO_VAN", "NUMERIEK_MET_EXACT", "AAN_DE_ELFPROEF", 
                      "GROTER_IS_DAN", "KLEINER_IS_DAN", "WORDT_VOLDAAN", 
                      "ER_WORDT_EEN_NIEUW", "WORDT_EEN_NIEUW", "AANGEMAAKT", 
                      "CREEER", "NIEUWE", "ER_AAN", "GELIJK_IS_AAN", "IS_GELIJK_AAN", 
                      "IS_ONGELIJK_AAN", "IS_KLEINER_DAN", "IS_KLEINER_OF_GELIJK_AAN", 
                      "IS_GROTER_DAN", "IS_GROTER_OF_GELIJK_AAN", "ZIJN_GELIJK_AAN", 
                      "ZIJN_ONGELIJK_AAN", "ZIJN_GROTER_DAN", "ZIJN_GROTER_OF_GELIJK_AAN", 
                      "ZIJN_KLEINER_DAN", "ZIJN_KLEINER_OF_GELIJK_AAN", 
                      "IS_LATER_DAN", "IS_LATER_OF_GELIJK_AAN", "IS_EERDER_DAN", 
                      "IS_EERDER_OF_GELIJK_AAN", "ZIJN_LATER_DAN", "ZIJN_LATER_OF_GELIJK_AAN", 
                      "ZIJN_EERDER_DAN", "ZIJN_EERDER_OF_GELIJK_AAN", "IS_LEEG", 
                      "IS_GEVULD", "ZIJN_LEEG", "ZIJN_GEVULD", "IS_KENMERK", 
                      "IS_ROL", "ZIJN_KENMERK", "ZIJN_ROL", "IS_NIET_KENMERK", 
                      "IS_NIET_ROL", "ZIJN_NIET_KENMERK", "ZIJN_NIET_ROL", 
                      "VOLDOET_AAN_DE_ELFPROEF", "VOLDOEN_AAN_DE_ELFPROEF", 
                      "VOLDOET_NIET_AAN_DE_ELFPROEF", "VOLDOEN_NIET_AAN_DE_ELFPROEF", 
                      "IS_NUMERIEK_MET_EXACT", "IS_NIET_NUMERIEK_MET_EXACT", 
                      "ZIJN_NUMERIEK_MET_EXACT", "ZIJN_NIET_NUMERIEK_MET_EXACT", 
                      "IS_EEN_DAGSOORT", "ZIJN_EEN_DAGSOORT", "IS_GEEN_DAGSOORT", 
                      "ZIJN_GEEN_DAGSOORT", "MOETEN_UNIEK_ZIJN", "IS_GEVUURD", 
                      "IS_INCONSISTENT", "CONSISTENTIEREGEL", "REGEL", "REGELGROEP", 
                      "BESLISTABEL", "OBJECTTYPE", "DOMEIN", "LIJST", "DIMENSIE", 
                      "EENHEIDSYSTEEM", "PARAMETER", "FEITTYPE", "DAGSOORT", 
                      "DAARBIJ_GELDT", "GELDIG", "HEBBEN", "HEEFT", "INDIEN", 
                      "IS_RECURSIEF", "IS", "MOET", "MOETEN", "WORDT_VERDEELD_OVER", 
                      "WORDT", "VOLDAAN", "ZIJN", "HAAR", "HUN", "AAN", 
                      "AFGEROND_OP", "ALLE", "EERDER_DAN", "GEDEELD_DOOR", 
                      "GEDEELD_DOOR_ABS", "GELIJK_AAN", "GEVULD", "GEVUURD", 
                      "GROTER_DAN", "INCONSISTENT", "KLEINER_DAN", "LATER_DAN", 
                      "LEEG", "MAAL", "MIN", "NAAR_BENEDEN", "NAAR_BOVEN", 
                      "NIET", "ONGELIJK_ZIJN_AAN", "ONGELIJK_AAN", "PLUS", 
                      "REKENKUNDIG", "RICHTING_NUL", "TOT", "TOT_DE_MACHT", 
                      "TOT_EN_MET", "UNIEK", "VANAF", "VERENIGD_MET", "VERMINDERD_MET", 
                      "VOLDOEN", "VOLDOET", "WEG_VAN_NUL", "DE_WORTEL_VAN", 
                      "TENMINSTE", "TEN_MINSTE", "TEN_HOOGSTE", "PRECIES", 
                      "VOORWAARDE", "VOORWAARDEN", "BEZITTELIJK", "BIJVOEGLIJK", 
                      "BEZIELD", "BOOLEAN", "CIJFERS", "DATUM_IN_DAGEN", 
                      "DECIMALEN", "ENUMERATIE", "GEDIMENSIONEERD_MET", 
                      "GEHEEL_GETAL", "GETAL", "KENMERK", "KENMERKEN", "MET", 
                      "MET_EENHEID", "MV_START", "NEGATIEF", "NIET_NEGATIEF", 
                      "NUMERIEK", "PERCENTAGE", "POSITIEF", "ROL", "ROLLEN", 
                      "TEKST", "VOOR_ELK_JAAR", "VOOR_ELKE_DAG", "VOOR_ELKE_MAAND", 
                      "AANTAL", "EERSTE_VAN", "IN_HELE", "LAATSTE_VAN", 
                      "REEKS_VAN_TEKSTEN_EN_WAARDEN", "SOM_VAN", "TIJDSDUUR_VAN", 
                      "AFNEMENDE", "IN_GELIJKE_DELEN", "OVER_VERDELING", 
                      "TOENEMENDE", "DRIE_TELWOORD", "EEN_TELWOORD", "GEEN_VAN_DE", 
                      "GEEN", "TWEE_TELWOORD", "VIER_TELWOORD", "ALTIJD", 
                      "BIJ", "DAG", "DAGEN", "DAT", "DE", "DD_PUNT", "DIE", 
                      "EEN", "EN", "HET", "MEERDERE", "HIJ", "IN", "JAAR", 
                      "JAREN", "KWARTAAL", "MAAND", "MAANDEN", "MILLISECONDE", 
                      "MINUUT", "MINUTEN", "OF", "ONWAAR", "OP", "OUDER", 
                      "OVER", "PERIODE", "REKENDATUM", "REKENJAAR", "REGELVERSIE", 
                      "SECONDE", "SECONDEN", "TM", "UIT", "UUR", "UREN", 
                      "VAN", "VOLGENDE_VOORWAARDE", "VOLGENDE_VOORWAARDEN", 
                      "VOLGENDE", "VOOR", "WAAR", "WEEK", "WEKEN", "ER", 
                      "METER", "KILOGRAM", "VOET", "POND", "MIJL", "M", 
                      "KG", "S", "FT", "LB", "MI", "EURO_SYMBOL", "DOLLAR_SYMBOL", 
                      "DEGREE_SYMBOL", "IDENTIFIER", "NUMBER", "EQUALS", 
                      "DATE_TIME_LITERAL", "PERCENTAGE_LITERAL", "STRING_LITERAL", 
                      "ENUM_LITERAL", "LPAREN", "RPAREN", "LBRACE", "RBRACE", 
                      "COMMA", "DOT", "COLON", "SEMICOLON", "SLASH", "PERCENT_SIGN", 
                      "BULLET", "ASTERISK", "L_ANGLE_QUOTE", "R_ANGLE_QUOTE", 
                      "CARET", "DOUBLE_DOT", "WS", "LINE_COMMENT", "MINUS", 
                      "PIPE", "NVT" ]

    RULE_regelSpraakDocument = 0
    RULE_definitie = 1
    RULE_beslistabel = 2
    RULE_beslistabelTable = 3
    RULE_beslistabelHeader = 4
    RULE_beslistabelSeparator = 5
    RULE_beslistabelRow = 6
    RULE_beslistabelCellValue = 7
    RULE_beslistabelColumnText = 8
    RULE_identifier = 9
    RULE_identifierOrKeyword = 10
    RULE_identifierOrKeywordNoIs = 11
    RULE_naamPhrase = 12
    RULE_naamPhraseWithNumbers = 13
    RULE_identifierOrKeywordWithNumbers = 14
    RULE_naamPhraseNoIs = 15
    RULE_naamwoord = 16
    RULE_naamwoordWithNumbers = 17
    RULE_naamwoordNoIs = 18
    RULE_voorzetsel = 19
    RULE_datumLiteral = 20
    RULE_unit = 21
    RULE_timeUnit = 22
    RULE_objectTypeDefinition = 23
    RULE_objectTypeMember = 24
    RULE_kenmerkSpecificatie = 25
    RULE_attribuutSpecificatie = 26
    RULE_datatype = 27
    RULE_lijstDatatype = 28
    RULE_numeriekDatatype = 29
    RULE_tekstDatatype = 30
    RULE_percentageDatatype = 31
    RULE_booleanDatatype = 32
    RULE_datumTijdDatatype = 33
    RULE_getalSpecificatie = 34
    RULE_domeinDefinition = 35
    RULE_domeinType = 36
    RULE_enumeratieSpecificatie = 37
    RULE_domeinRef = 38
    RULE_objectTypeRef = 39
    RULE_eenheidsysteemDefinition = 40
    RULE_eenheidEntry = 41
    RULE_unitIdentifier = 42
    RULE_eenheidExpressie = 43
    RULE_eenheidMacht = 44
    RULE_dimensieDefinition = 45
    RULE_voorzetselSpecificatie = 46
    RULE_labelWaardeSpecificatie = 47
    RULE_tijdlijn = 48
    RULE_dimensieRef = 49
    RULE_parameterDefinition = 50
    RULE_parameterNamePhrase = 51
    RULE_parameterNamePart = 52
    RULE_parameterMetLidwoord = 53
    RULE_feitTypeDefinition = 54
    RULE_rolDefinition = 55
    RULE_rolObjectType = 56
    RULE_rolContentWords = 57
    RULE_cardinalityLine = 58
    RULE_cardinalityWord = 59
    RULE_regel = 60
    RULE_regelGroep = 61
    RULE_regelName = 62
    RULE_regelNameExtension = 63
    RULE_regelVersie = 64
    RULE_versieGeldigheid = 65
    RULE_resultaatDeel = 66
    RULE_consistencyOperator = 67
    RULE_feitCreatiePattern = 68
    RULE_feitCreatieRolPhrase = 69
    RULE_feitCreatieSubjectPhrase = 70
    RULE_feitCreatieSubjectWord = 71
    RULE_feitCreatieWord = 72
    RULE_voorzetselNietVan = 73
    RULE_objectCreatie = 74
    RULE_objectAttributeInit = 75
    RULE_attributeInitVervolg = 76
    RULE_simpleNaamwoord = 77
    RULE_consistentieregel = 78
    RULE_uniekzijnResultaat = 79
    RULE_alleAttributenVanObjecttype = 80
    RULE_inconsistentResultaat = 81
    RULE_voorwaardeDeel = 82
    RULE_toplevelSamengesteldeVoorwaarde = 83
    RULE_voorwaardeKwantificatie = 84
    RULE_samengesteldeVoorwaardeOnderdeel = 85
    RULE_bulletPrefix = 86
    RULE_elementaireVoorwaarde = 87
    RULE_genesteSamengesteldeVoorwaarde = 88
    RULE_onderwerpReferentie = 89
    RULE_onderwerpReferentieWithNumbers = 90
    RULE_onderwerpBasis = 91
    RULE_onderwerpBasisWithNumbers = 92
    RULE_basisOnderwerp = 93
    RULE_basisOnderwerpWithNumbers = 94
    RULE_attribuutReferentie = 95
    RULE_attribuutMetLidwoord = 96
    RULE_kenmerkNaam = 97
    RULE_kenmerkPhrase = 98
    RULE_bezieldeReferentie = 99
    RULE_aggregationSubject = 100
    RULE_predicaat = 101
    RULE_elementairPredicaat = 102
    RULE_objectPredicaat = 103
    RULE_eenzijdigeObjectVergelijking = 104
    RULE_rolNaam = 105
    RULE_attribuutVergelijkingsPredicaat = 106
    RULE_getalPredicaat = 107
    RULE_tekstPredicaat = 108
    RULE_datumPredicaat = 109
    RULE_samengesteldPredicaat = 110
    RULE_samengesteldeVoorwaardeOnderdeelInPredicaat = 111
    RULE_elementaireVoorwaardeInPredicaat = 112
    RULE_vergelijkingInPredicaat = 113
    RULE_genesteSamengesteldeVoorwaardeInPredicaat = 114
    RULE_getalVergelijkingsOperatorMeervoud = 115
    RULE_tekstVergelijkingsOperatorMeervoud = 116
    RULE_datumVergelijkingsOperatorMeervoud = 117
    RULE_getalExpressie = 118
    RULE_tekstExpressie = 119
    RULE_datumExpressie = 120
    RULE_variabeleDeel = 121
    RULE_variabeleToekenning = 122
    RULE_variabeleExpressie = 123
    RULE_expressie = 124
    RULE_simpleExpressie = 125
    RULE_logicalExpression = 126
    RULE_comparisonExpression = 127
    RULE_literalValue = 128
    RULE_gelijkIsAanOperator = 129
    RULE_comparisonOperator = 130
    RULE_additiveExpression = 131
    RULE_additiveOperator = 132
    RULE_multiplicativeExpression = 133
    RULE_multiplicativeOperator = 134
    RULE_powerExpression = 135
    RULE_powerOperator = 136
    RULE_primaryExpression = 137
    RULE_afronding = 138
    RULE_begrenzing = 139
    RULE_begrenzingMinimum = 140
    RULE_begrenzingMaximum = 141
    RULE_conditieBijExpressie = 142
    RULE_periodevergelijkingElementair = 143
    RULE_periodevergelijkingEnkelvoudig = 144
    RULE_periodeDefinitie = 145
    RULE_dateExpression = 146
    RULE_getalAggregatieFunctie = 147
    RULE_datumAggregatieFunctie = 148
    RULE_dimensieSelectie = 149
    RULE_aggregerenOverAlleDimensies = 150
    RULE_aggregerenOverVerzameling = 151
    RULE_aggregerenOverBereik = 152
    RULE_unaryCondition = 153
    RULE_regelStatusCondition = 154
    RULE_subordinateClauseExpression = 155
    RULE_dagsoortDefinition = 156
    RULE_tekstreeksExpr = 157
    RULE_verdelingResultaat = 158
    RULE_verdelingMethodeSimple = 159
    RULE_verdelingMethodeMultiLine = 160
    RULE_verdelingMethodeBulletList = 161
    RULE_verdelingMethodeBullet = 162
    RULE_verdelingMethode = 163
    RULE_verdelingRest = 164

    ruleNames =  [ "regelSpraakDocument", "definitie", "beslistabel", "beslistabelTable", 
                   "beslistabelHeader", "beslistabelSeparator", "beslistabelRow", 
                   "beslistabelCellValue", "beslistabelColumnText", "identifier", 
                   "identifierOrKeyword", "identifierOrKeywordNoIs", "naamPhrase", 
                   "naamPhraseWithNumbers", "identifierOrKeywordWithNumbers", 
                   "naamPhraseNoIs", "naamwoord", "naamwoordWithNumbers", 
                   "naamwoordNoIs", "voorzetsel", "datumLiteral", "unit", 
                   "timeUnit", "objectTypeDefinition", "objectTypeMember", 
                   "kenmerkSpecificatie", "attribuutSpecificatie", "datatype", 
                   "lijstDatatype", "numeriekDatatype", "tekstDatatype", 
                   "percentageDatatype", "booleanDatatype", "datumTijdDatatype", 
                   "getalSpecificatie", "domeinDefinition", "domeinType", 
                   "enumeratieSpecificatie", "domeinRef", "objectTypeRef", 
                   "eenheidsysteemDefinition", "eenheidEntry", "unitIdentifier", 
                   "eenheidExpressie", "eenheidMacht", "dimensieDefinition", 
                   "voorzetselSpecificatie", "labelWaardeSpecificatie", 
                   "tijdlijn", "dimensieRef", "parameterDefinition", "parameterNamePhrase", 
                   "parameterNamePart", "parameterMetLidwoord", "feitTypeDefinition", 
                   "rolDefinition", "rolObjectType", "rolContentWords", 
                   "cardinalityLine", "cardinalityWord", "regel", "regelGroep", 
                   "regelName", "regelNameExtension", "regelVersie", "versieGeldigheid", 
                   "resultaatDeel", "consistencyOperator", "feitCreatiePattern", 
                   "feitCreatieRolPhrase", "feitCreatieSubjectPhrase", "feitCreatieSubjectWord", 
                   "feitCreatieWord", "voorzetselNietVan", "objectCreatie", 
                   "objectAttributeInit", "attributeInitVervolg", "simpleNaamwoord", 
                   "consistentieregel", "uniekzijnResultaat", "alleAttributenVanObjecttype", 
                   "inconsistentResultaat", "voorwaardeDeel", "toplevelSamengesteldeVoorwaarde", 
                   "voorwaardeKwantificatie", "samengesteldeVoorwaardeOnderdeel", 
                   "bulletPrefix", "elementaireVoorwaarde", "genesteSamengesteldeVoorwaarde", 
                   "onderwerpReferentie", "onderwerpReferentieWithNumbers", 
                   "onderwerpBasis", "onderwerpBasisWithNumbers", "basisOnderwerp", 
                   "basisOnderwerpWithNumbers", "attribuutReferentie", "attribuutMetLidwoord", 
                   "kenmerkNaam", "kenmerkPhrase", "bezieldeReferentie", 
                   "aggregationSubject", "predicaat", "elementairPredicaat", 
                   "objectPredicaat", "eenzijdigeObjectVergelijking", "rolNaam", 
                   "attribuutVergelijkingsPredicaat", "getalPredicaat", 
                   "tekstPredicaat", "datumPredicaat", "samengesteldPredicaat", 
                   "samengesteldeVoorwaardeOnderdeelInPredicaat", "elementaireVoorwaardeInPredicaat", 
                   "vergelijkingInPredicaat", "genesteSamengesteldeVoorwaardeInPredicaat", 
                   "getalVergelijkingsOperatorMeervoud", "tekstVergelijkingsOperatorMeervoud", 
                   "datumVergelijkingsOperatorMeervoud", "getalExpressie", 
                   "tekstExpressie", "datumExpressie", "variabeleDeel", 
                   "variabeleToekenning", "variabeleExpressie", "expressie", 
                   "simpleExpressie", "logicalExpression", "comparisonExpression", 
                   "literalValue", "gelijkIsAanOperator", "comparisonOperator", 
                   "additiveExpression", "additiveOperator", "multiplicativeExpression", 
                   "multiplicativeOperator", "powerExpression", "powerOperator", 
                   "primaryExpression", "afronding", "begrenzing", "begrenzingMinimum", 
                   "begrenzingMaximum", "conditieBijExpressie", "periodevergelijkingElementair", 
                   "periodevergelijkingEnkelvoudig", "periodeDefinitie", 
                   "dateExpression", "getalAggregatieFunctie", "datumAggregatieFunctie", 
                   "dimensieSelectie", "aggregerenOverAlleDimensies", "aggregerenOverVerzameling", 
                   "aggregerenOverBereik", "unaryCondition", "regelStatusCondition", 
                   "subordinateClauseExpression", "dagsoortDefinition", 
                   "tekstreeksExpr", "verdelingResultaat", "verdelingMethodeSimple", 
                   "verdelingMethodeMultiLine", "verdelingMethodeBulletList", 
                   "verdelingMethodeBullet", "verdelingMethode", "verdelingRest" ]

    EOF = Token.EOF
    VOOR_HET_ATTRIBUUT_ZONDER_VOORZETSEL=1
    NA_HET_ATTRIBUUT_MET_VOORZETSEL=2
    DATUM_TIJD_MILLIS=3
    GEDURENDE_DE_TIJD_DAT=4
    GEDURENDE_HET_GEHELE=5
    GEDURENDE_DE_GEHELE=6
    HET_IS_DE_PERIODE=7
    WORDT_BEREKEND_ALS=8
    WORDT_GESTELD_OP=9
    WORDT_GEINITIALISEERD_OP=10
    DE_ABSOLUTE_TIJDSDUUR_VAN=11
    DE_ABSOLUTE_WAARDE_VAN=12
    DE_MAXIMALE_WAARDE_VAN=13
    DE_MINIMALE_WAARDE_VAN=14
    HET_TOTAAL_VAN=15
    HET_TIJDSEVENREDIG_DEEL_PER=16
    DE_DATUM_MET=17
    DE_EERSTE_PAASDAG_VAN=18
    ALS_ONVERDEELDE_REST_BLIJFT=19
    MET_EEN_MINIMUM_VAN=20
    MET_EEN_MAXIMUM_VAN=21
    GROTER_OF_GELIJK_AAN=22
    KLEINER_OF_GELIJK_AAN=23
    LATER_OF_GELIJK_AAN=24
    EERDER_OF_GELIJK_AAN=25
    WAARBIJ_WORDT_VERDEELD=26
    BESTAANDE_UIT=27
    WEDERKERIG_FEITTYPE=28
    IS_VAN_HET_TYPE=29
    CONCATENATIE_VAN=30
    VOLGEND_CRITERIUM=31
    VOLGENDE_CRITERIA=32
    BIJ_EVEN_GROOT_CRITERIUM=33
    OP_VOLGORDE_VAN=34
    NAAR_RATO_VAN=35
    NUMERIEK_MET_EXACT=36
    AAN_DE_ELFPROEF=37
    GROTER_IS_DAN=38
    KLEINER_IS_DAN=39
    WORDT_VOLDAAN=40
    ER_WORDT_EEN_NIEUW=41
    WORDT_EEN_NIEUW=42
    AANGEMAAKT=43
    CREEER=44
    NIEUWE=45
    ER_AAN=46
    GELIJK_IS_AAN=47
    IS_GELIJK_AAN=48
    IS_ONGELIJK_AAN=49
    IS_KLEINER_DAN=50
    IS_KLEINER_OF_GELIJK_AAN=51
    IS_GROTER_DAN=52
    IS_GROTER_OF_GELIJK_AAN=53
    ZIJN_GELIJK_AAN=54
    ZIJN_ONGELIJK_AAN=55
    ZIJN_GROTER_DAN=56
    ZIJN_GROTER_OF_GELIJK_AAN=57
    ZIJN_KLEINER_DAN=58
    ZIJN_KLEINER_OF_GELIJK_AAN=59
    IS_LATER_DAN=60
    IS_LATER_OF_GELIJK_AAN=61
    IS_EERDER_DAN=62
    IS_EERDER_OF_GELIJK_AAN=63
    ZIJN_LATER_DAN=64
    ZIJN_LATER_OF_GELIJK_AAN=65
    ZIJN_EERDER_DAN=66
    ZIJN_EERDER_OF_GELIJK_AAN=67
    IS_LEEG=68
    IS_GEVULD=69
    ZIJN_LEEG=70
    ZIJN_GEVULD=71
    IS_KENMERK=72
    IS_ROL=73
    ZIJN_KENMERK=74
    ZIJN_ROL=75
    IS_NIET_KENMERK=76
    IS_NIET_ROL=77
    ZIJN_NIET_KENMERK=78
    ZIJN_NIET_ROL=79
    VOLDOET_AAN_DE_ELFPROEF=80
    VOLDOEN_AAN_DE_ELFPROEF=81
    VOLDOET_NIET_AAN_DE_ELFPROEF=82
    VOLDOEN_NIET_AAN_DE_ELFPROEF=83
    IS_NUMERIEK_MET_EXACT=84
    IS_NIET_NUMERIEK_MET_EXACT=85
    ZIJN_NUMERIEK_MET_EXACT=86
    ZIJN_NIET_NUMERIEK_MET_EXACT=87
    IS_EEN_DAGSOORT=88
    ZIJN_EEN_DAGSOORT=89
    IS_GEEN_DAGSOORT=90
    ZIJN_GEEN_DAGSOORT=91
    MOETEN_UNIEK_ZIJN=92
    IS_GEVUURD=93
    IS_INCONSISTENT=94
    CONSISTENTIEREGEL=95
    REGEL=96
    REGELGROEP=97
    BESLISTABEL=98
    OBJECTTYPE=99
    DOMEIN=100
    LIJST=101
    DIMENSIE=102
    EENHEIDSYSTEEM=103
    PARAMETER=104
    FEITTYPE=105
    DAGSOORT=106
    DAARBIJ_GELDT=107
    GELDIG=108
    HEBBEN=109
    HEEFT=110
    INDIEN=111
    IS_RECURSIEF=112
    IS=113
    MOET=114
    MOETEN=115
    WORDT_VERDEELD_OVER=116
    WORDT=117
    VOLDAAN=118
    ZIJN=119
    HAAR=120
    HUN=121
    AAN=122
    AFGEROND_OP=123
    ALLE=124
    EERDER_DAN=125
    GEDEELD_DOOR=126
    GEDEELD_DOOR_ABS=127
    GELIJK_AAN=128
    GEVULD=129
    GEVUURD=130
    GROTER_DAN=131
    INCONSISTENT=132
    KLEINER_DAN=133
    LATER_DAN=134
    LEEG=135
    MAAL=136
    MIN=137
    NAAR_BENEDEN=138
    NAAR_BOVEN=139
    NIET=140
    ONGELIJK_ZIJN_AAN=141
    ONGELIJK_AAN=142
    PLUS=143
    REKENKUNDIG=144
    RICHTING_NUL=145
    TOT=146
    TOT_DE_MACHT=147
    TOT_EN_MET=148
    UNIEK=149
    VANAF=150
    VERENIGD_MET=151
    VERMINDERD_MET=152
    VOLDOEN=153
    VOLDOET=154
    WEG_VAN_NUL=155
    DE_WORTEL_VAN=156
    TENMINSTE=157
    TEN_MINSTE=158
    TEN_HOOGSTE=159
    PRECIES=160
    VOORWAARDE=161
    VOORWAARDEN=162
    BEZITTELIJK=163
    BIJVOEGLIJK=164
    BEZIELD=165
    BOOLEAN=166
    CIJFERS=167
    DATUM_IN_DAGEN=168
    DECIMALEN=169
    ENUMERATIE=170
    GEDIMENSIONEERD_MET=171
    GEHEEL_GETAL=172
    GETAL=173
    KENMERK=174
    KENMERKEN=175
    MET=176
    MET_EENHEID=177
    MV_START=178
    NEGATIEF=179
    NIET_NEGATIEF=180
    NUMERIEK=181
    PERCENTAGE=182
    POSITIEF=183
    ROL=184
    ROLLEN=185
    TEKST=186
    VOOR_ELK_JAAR=187
    VOOR_ELKE_DAG=188
    VOOR_ELKE_MAAND=189
    AANTAL=190
    EERSTE_VAN=191
    IN_HELE=192
    LAATSTE_VAN=193
    REEKS_VAN_TEKSTEN_EN_WAARDEN=194
    SOM_VAN=195
    TIJDSDUUR_VAN=196
    AFNEMENDE=197
    IN_GELIJKE_DELEN=198
    OVER_VERDELING=199
    TOENEMENDE=200
    DRIE_TELWOORD=201
    EEN_TELWOORD=202
    GEEN_VAN_DE=203
    GEEN=204
    TWEE_TELWOORD=205
    VIER_TELWOORD=206
    ALTIJD=207
    BIJ=208
    DAG=209
    DAGEN=210
    DAT=211
    DE=212
    DD_PUNT=213
    DIE=214
    EEN=215
    EN=216
    HET=217
    MEERDERE=218
    HIJ=219
    IN=220
    JAAR=221
    JAREN=222
    KWARTAAL=223
    MAAND=224
    MAANDEN=225
    MILLISECONDE=226
    MINUUT=227
    MINUTEN=228
    OF=229
    ONWAAR=230
    OP=231
    OUDER=232
    OVER=233
    PERIODE=234
    REKENDATUM=235
    REKENJAAR=236
    REGELVERSIE=237
    SECONDE=238
    SECONDEN=239
    TM=240
    UIT=241
    UUR=242
    UREN=243
    VAN=244
    VOLGENDE_VOORWAARDE=245
    VOLGENDE_VOORWAARDEN=246
    VOLGENDE=247
    VOOR=248
    WAAR=249
    WEEK=250
    WEKEN=251
    ER=252
    METER=253
    KILOGRAM=254
    VOET=255
    POND=256
    MIJL=257
    M=258
    KG=259
    S=260
    FT=261
    LB=262
    MI=263
    EURO_SYMBOL=264
    DOLLAR_SYMBOL=265
    DEGREE_SYMBOL=266
    IDENTIFIER=267
    NUMBER=268
    EQUALS=269
    DATE_TIME_LITERAL=270
    PERCENTAGE_LITERAL=271
    STRING_LITERAL=272
    ENUM_LITERAL=273
    LPAREN=274
    RPAREN=275
    LBRACE=276
    RBRACE=277
    COMMA=278
    DOT=279
    COLON=280
    SEMICOLON=281
    SLASH=282
    PERCENT_SIGN=283
    BULLET=284
    ASTERISK=285
    L_ANGLE_QUOTE=286
    R_ANGLE_QUOTE=287
    CARET=288
    DOUBLE_DOT=289
    WS=290
    LINE_COMMENT=291
    MINUS=292
    PIPE=293
    NVT=294

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.13.1")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class RegelSpraakDocumentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOF(self):
            return self.getToken(RegelSpraakParser.EOF, 0)

        def definitie(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.DefinitieContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.DefinitieContext,i)


        def regel(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.RegelContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.RegelContext,i)


        def regelGroep(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.RegelGroepContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.RegelGroepContext,i)


        def beslistabel(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.BeslistabelContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.BeslistabelContext,i)


        def consistentieregel(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.ConsistentieregelContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.ConsistentieregelContext,i)


        def eenheidsysteemDefinition(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.EenheidsysteemDefinitionContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.EenheidsysteemDefinitionContext,i)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_regelSpraakDocument

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRegelSpraakDocument" ):
                listener.enterRegelSpraakDocument(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRegelSpraakDocument" ):
                listener.exitRegelSpraakDocument(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRegelSpraakDocument" ):
                return visitor.visitRegelSpraakDocument(self)
            else:
                return visitor.visitChildren(self)




    def regelSpraakDocument(self):

        localctx = RegelSpraakParser.RegelSpraakDocumentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_regelSpraakDocument)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 338
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==28 or ((((_la - 95)) & ~0x3f) == 0 and ((1 << (_la - 95)) & 4031) != 0):
                self.state = 336
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [28, 99, 100, 102, 104, 105, 106]:
                    self.state = 330
                    self.definitie()
                    pass
                elif token in [96]:
                    self.state = 331
                    self.regel()
                    pass
                elif token in [97]:
                    self.state = 332
                    self.regelGroep()
                    pass
                elif token in [98]:
                    self.state = 333
                    self.beslistabel()
                    pass
                elif token in [95]:
                    self.state = 334
                    self.consistentieregel()
                    pass
                elif token in [103]:
                    self.state = 335
                    self.eenheidsysteemDefinition()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 340
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 341
            self.match(RegelSpraakParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DefinitieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def objectTypeDefinition(self):
            return self.getTypedRuleContext(RegelSpraakParser.ObjectTypeDefinitionContext,0)


        def domeinDefinition(self):
            return self.getTypedRuleContext(RegelSpraakParser.DomeinDefinitionContext,0)


        def parameterDefinition(self):
            return self.getTypedRuleContext(RegelSpraakParser.ParameterDefinitionContext,0)


        def dimensieDefinition(self):
            return self.getTypedRuleContext(RegelSpraakParser.DimensieDefinitionContext,0)


        def feitTypeDefinition(self):
            return self.getTypedRuleContext(RegelSpraakParser.FeitTypeDefinitionContext,0)


        def dagsoortDefinition(self):
            return self.getTypedRuleContext(RegelSpraakParser.DagsoortDefinitionContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_definitie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDefinitie" ):
                listener.enterDefinitie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDefinitie" ):
                listener.exitDefinitie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDefinitie" ):
                return visitor.visitDefinitie(self)
            else:
                return visitor.visitChildren(self)




    def definitie(self):

        localctx = RegelSpraakParser.DefinitieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_definitie)
        try:
            self.state = 349
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [99]:
                self.enterOuterAlt(localctx, 1)
                self.state = 343
                self.objectTypeDefinition()
                pass
            elif token in [100]:
                self.enterOuterAlt(localctx, 2)
                self.state = 344
                self.domeinDefinition()
                pass
            elif token in [104]:
                self.enterOuterAlt(localctx, 3)
                self.state = 345
                self.parameterDefinition()
                pass
            elif token in [102]:
                self.enterOuterAlt(localctx, 4)
                self.state = 346
                self.dimensieDefinition()
                pass
            elif token in [28, 105]:
                self.enterOuterAlt(localctx, 5)
                self.state = 347
                self.feitTypeDefinition()
                pass
            elif token in [106]:
                self.enterOuterAlt(localctx, 6)
                self.state = 348
                self.dagsoortDefinition()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BeslistabelContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BESLISTABEL(self):
            return self.getToken(RegelSpraakParser.BESLISTABEL, 0)

        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def beslistabelTable(self):
            return self.getTypedRuleContext(RegelSpraakParser.BeslistabelTableContext,0)


        def regelVersie(self):
            return self.getTypedRuleContext(RegelSpraakParser.RegelVersieContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_beslistabel

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBeslistabel" ):
                listener.enterBeslistabel(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBeslistabel" ):
                listener.exitBeslistabel(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBeslistabel" ):
                return visitor.visitBeslistabel(self)
            else:
                return visitor.visitChildren(self)




    def beslistabel(self):

        localctx = RegelSpraakParser.BeslistabelContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_beslistabel)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 351
            self.match(RegelSpraakParser.BESLISTABEL)
            self.state = 352
            self.naamwoord()
            self.state = 354
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==108:
                self.state = 353
                self.regelVersie()


            self.state = 356
            self.beslistabelTable()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BeslistabelTableContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def beslistabelHeader(self):
            return self.getTypedRuleContext(RegelSpraakParser.BeslistabelHeaderContext,0)


        def beslistabelSeparator(self):
            return self.getTypedRuleContext(RegelSpraakParser.BeslistabelSeparatorContext,0)


        def beslistabelRow(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.BeslistabelRowContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.BeslistabelRowContext,i)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_beslistabelTable

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBeslistabelTable" ):
                listener.enterBeslistabelTable(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBeslistabelTable" ):
                listener.exitBeslistabelTable(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBeslistabelTable" ):
                return visitor.visitBeslistabelTable(self)
            else:
                return visitor.visitChildren(self)




    def beslistabelTable(self):

        localctx = RegelSpraakParser.BeslistabelTableContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_beslistabelTable)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 358
            self.beslistabelHeader()
            self.state = 359
            self.beslistabelSeparator()
            self.state = 361 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 360
                self.beslistabelRow()
                self.state = 363 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==293):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BeslistabelHeaderContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.resultColumn = None # BeslistabelColumnTextContext
            self._beslistabelColumnText = None # BeslistabelColumnTextContext
            self.conditionColumns = list() # of BeslistabelColumnTextContexts

        def PIPE(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.PIPE)
            else:
                return self.getToken(RegelSpraakParser.PIPE, i)

        def beslistabelColumnText(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.BeslistabelColumnTextContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.BeslistabelColumnTextContext,i)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_beslistabelHeader

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBeslistabelHeader" ):
                listener.enterBeslistabelHeader(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBeslistabelHeader" ):
                listener.exitBeslistabelHeader(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBeslistabelHeader" ):
                return visitor.visitBeslistabelHeader(self)
            else:
                return visitor.visitChildren(self)




    def beslistabelHeader(self):

        localctx = RegelSpraakParser.BeslistabelHeaderContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_beslistabelHeader)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 365
            self.match(RegelSpraakParser.PIPE)
            self.state = 367
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==293:
                self.state = 366
                self.match(RegelSpraakParser.PIPE)


            self.state = 369
            localctx.resultColumn = self.beslistabelColumnText()
            self.state = 370
            self.match(RegelSpraakParser.PIPE)
            self.state = 371
            localctx._beslistabelColumnText = self.beslistabelColumnText()
            localctx.conditionColumns.append(localctx._beslistabelColumnText)
            self.state = 376
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,6,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 372
                    self.match(RegelSpraakParser.PIPE)
                    self.state = 373
                    localctx._beslistabelColumnText = self.beslistabelColumnText()
                    localctx.conditionColumns.append(localctx._beslistabelColumnText) 
                self.state = 378
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,6,self._ctx)

            self.state = 380
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,7,self._ctx)
            if la_ == 1:
                self.state = 379
                self.match(RegelSpraakParser.PIPE)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BeslistabelSeparatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PIPE(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.PIPE)
            else:
                return self.getToken(RegelSpraakParser.PIPE, i)

        def MINUS(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.MINUS)
            else:
                return self.getToken(RegelSpraakParser.MINUS, i)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_beslistabelSeparator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBeslistabelSeparator" ):
                listener.enterBeslistabelSeparator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBeslistabelSeparator" ):
                listener.exitBeslistabelSeparator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBeslistabelSeparator" ):
                return visitor.visitBeslistabelSeparator(self)
            else:
                return visitor.visitChildren(self)




    def beslistabelSeparator(self):

        localctx = RegelSpraakParser.BeslistabelSeparatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_beslistabelSeparator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 383
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==293:
                self.state = 382
                self.match(RegelSpraakParser.PIPE)


            self.state = 393 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 386 
                    self._errHandler.sync(self)
                    _alt = 1
                    while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                        if _alt == 1:
                            self.state = 385
                            self.match(RegelSpraakParser.MINUS)

                        else:
                            raise NoViableAltException(self)
                        self.state = 388 
                        self._errHandler.sync(self)
                        _alt = self._interp.adaptivePredict(self._input,9,self._ctx)

                    self.state = 391
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,10,self._ctx)
                    if la_ == 1:
                        self.state = 390
                        self.match(RegelSpraakParser.PIPE)



                else:
                    raise NoViableAltException(self)
                self.state = 395 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,11,self._ctx)

            self.state = 400
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==292:
                self.state = 397
                self.match(RegelSpraakParser.MINUS)
                self.state = 402
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BeslistabelRowContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.rowNumber = None # Token
            self.resultExpression = None # ExpressieContext
            self._beslistabelCellValue = None # BeslistabelCellValueContext
            self.conditionValues = list() # of BeslistabelCellValueContexts

        def PIPE(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.PIPE)
            else:
                return self.getToken(RegelSpraakParser.PIPE, i)

        def NUMBER(self):
            return self.getToken(RegelSpraakParser.NUMBER, 0)

        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)


        def beslistabelCellValue(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.BeslistabelCellValueContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.BeslistabelCellValueContext,i)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_beslistabelRow

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBeslistabelRow" ):
                listener.enterBeslistabelRow(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBeslistabelRow" ):
                listener.exitBeslistabelRow(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBeslistabelRow" ):
                return visitor.visitBeslistabelRow(self)
            else:
                return visitor.visitChildren(self)




    def beslistabelRow(self):

        localctx = RegelSpraakParser.BeslistabelRowContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_beslistabelRow)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 403
            self.match(RegelSpraakParser.PIPE)
            self.state = 404
            localctx.rowNumber = self.match(RegelSpraakParser.NUMBER)
            self.state = 405
            self.match(RegelSpraakParser.PIPE)
            self.state = 406
            localctx.resultExpression = self.expressie()
            self.state = 407
            self.match(RegelSpraakParser.PIPE)
            self.state = 408
            localctx._beslistabelCellValue = self.beslistabelCellValue()
            localctx.conditionValues.append(localctx._beslistabelCellValue)
            self.state = 413
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,13,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 409
                    self.match(RegelSpraakParser.PIPE)
                    self.state = 410
                    localctx._beslistabelCellValue = self.beslistabelCellValue()
                    localctx.conditionValues.append(localctx._beslistabelCellValue) 
                self.state = 415
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,13,self._ctx)

            self.state = 417
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,14,self._ctx)
            if la_ == 1:
                self.state = 416
                self.match(RegelSpraakParser.PIPE)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BeslistabelCellValueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)


        def NVT(self):
            return self.getToken(RegelSpraakParser.NVT, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_beslistabelCellValue

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBeslistabelCellValue" ):
                listener.enterBeslistabelCellValue(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBeslistabelCellValue" ):
                listener.exitBeslistabelCellValue(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBeslistabelCellValue" ):
                return visitor.visitBeslistabelCellValue(self)
            else:
                return visitor.visitChildren(self)




    def beslistabelCellValue(self):

        localctx = RegelSpraakParser.BeslistabelCellValueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_beslistabelCellValue)
        try:
            self.state = 421
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [7, 11, 12, 13, 14, 15, 16, 17, 18, 30, 45, 96, 110, 113, 119, 120, 121, 124, 132, 137, 140, 156, 161, 190, 191, 193, 195, 196, 201, 202, 205, 206, 209, 210, 212, 215, 217, 219, 221, 223, 224, 230, 232, 234, 235, 236, 237, 249, 253, 267, 268, 270, 271, 272, 273, 274, 292]:
                self.enterOuterAlt(localctx, 1)
                self.state = 419
                self.expressie()
                pass
            elif token in [294]:
                self.enterOuterAlt(localctx, 2)
                self.state = 420
                self.match(RegelSpraakParser.NVT)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BeslistabelColumnTextContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PIPE(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.PIPE)
            else:
                return self.getToken(RegelSpraakParser.PIPE, i)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_beslistabelColumnText

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBeslistabelColumnText" ):
                listener.enterBeslistabelColumnText(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBeslistabelColumnText" ):
                listener.exitBeslistabelColumnText(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBeslistabelColumnText" ):
                return visitor.visitBeslistabelColumnText(self)
            else:
                return visitor.visitChildren(self)




    def beslistabelColumnText(self):

        localctx = RegelSpraakParser.BeslistabelColumnTextContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_beslistabelColumnText)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 424 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 423
                    _la = self._input.LA(1)
                    if _la <= 0 or _la==293:
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()

                else:
                    raise NoViableAltException(self)
                self.state = 426 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,16,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IdentifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(RegelSpraakParser.IDENTIFIER, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_identifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIdentifier" ):
                listener.enterIdentifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIdentifier" ):
                listener.exitIdentifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIdentifier" ):
                return visitor.visitIdentifier(self)
            else:
                return visitor.visitChildren(self)




    def identifier(self):

        localctx = RegelSpraakParser.IdentifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_identifier)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 428
            self.match(RegelSpraakParser.IDENTIFIER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IdentifierOrKeywordContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(RegelSpraakParser.IDENTIFIER, 0)

        def DAG(self):
            return self.getToken(RegelSpraakParser.DAG, 0)

        def DAGEN(self):
            return self.getToken(RegelSpraakParser.DAGEN, 0)

        def MAAND(self):
            return self.getToken(RegelSpraakParser.MAAND, 0)

        def JAAR(self):
            return self.getToken(RegelSpraakParser.JAAR, 0)

        def AANTAL(self):
            return self.getToken(RegelSpraakParser.AANTAL, 0)

        def PERIODE(self):
            return self.getToken(RegelSpraakParser.PERIODE, 0)

        def REGEL(self):
            return self.getToken(RegelSpraakParser.REGEL, 0)

        def VOORWAARDE(self):
            return self.getToken(RegelSpraakParser.VOORWAARDE, 0)

        def HEEFT(self):
            return self.getToken(RegelSpraakParser.HEEFT, 0)

        def ALLE(self):
            return self.getToken(RegelSpraakParser.ALLE, 0)

        def INCONSISTENT(self):
            return self.getToken(RegelSpraakParser.INCONSISTENT, 0)

        def IS(self):
            return self.getToken(RegelSpraakParser.IS, 0)

        def KWARTAAL(self):
            return self.getToken(RegelSpraakParser.KWARTAAL, 0)

        def METER(self):
            return self.getToken(RegelSpraakParser.METER, 0)

        def EEN_TELWOORD(self):
            return self.getToken(RegelSpraakParser.EEN_TELWOORD, 0)

        def TWEE_TELWOORD(self):
            return self.getToken(RegelSpraakParser.TWEE_TELWOORD, 0)

        def DRIE_TELWOORD(self):
            return self.getToken(RegelSpraakParser.DRIE_TELWOORD, 0)

        def VIER_TELWOORD(self):
            return self.getToken(RegelSpraakParser.VIER_TELWOORD, 0)

        def OUDER(self):
            return self.getToken(RegelSpraakParser.OUDER, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_identifierOrKeyword

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIdentifierOrKeyword" ):
                listener.enterIdentifierOrKeyword(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIdentifierOrKeyword" ):
                listener.exitIdentifierOrKeyword(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIdentifierOrKeyword" ):
                return visitor.visitIdentifierOrKeyword(self)
            else:
                return visitor.visitChildren(self)




    def identifierOrKeyword(self):

        localctx = RegelSpraakParser.IdentifierOrKeywordContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_identifierOrKeyword)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 430
            _la = self._input.LA(1)
            if not(((((_la - 96)) & ~0x3f) == 0 and ((1 << (_la - 96)) & 68988059649) != 0) or ((((_la - 161)) & ~0x3f) == 0 and ((1 << (_la - 161)) & -3457864013260521471) != 0) or ((((_la - 232)) & ~0x3f) == 0 and ((1 << (_la - 232)) & 34361835525) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IdentifierOrKeywordNoIsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(RegelSpraakParser.IDENTIFIER, 0)

        def DAG(self):
            return self.getToken(RegelSpraakParser.DAG, 0)

        def DAGEN(self):
            return self.getToken(RegelSpraakParser.DAGEN, 0)

        def MAAND(self):
            return self.getToken(RegelSpraakParser.MAAND, 0)

        def JAAR(self):
            return self.getToken(RegelSpraakParser.JAAR, 0)

        def AANTAL(self):
            return self.getToken(RegelSpraakParser.AANTAL, 0)

        def PERIODE(self):
            return self.getToken(RegelSpraakParser.PERIODE, 0)

        def REGEL(self):
            return self.getToken(RegelSpraakParser.REGEL, 0)

        def VOORWAARDE(self):
            return self.getToken(RegelSpraakParser.VOORWAARDE, 0)

        def HEEFT(self):
            return self.getToken(RegelSpraakParser.HEEFT, 0)

        def ALLE(self):
            return self.getToken(RegelSpraakParser.ALLE, 0)

        def INCONSISTENT(self):
            return self.getToken(RegelSpraakParser.INCONSISTENT, 0)

        def KWARTAAL(self):
            return self.getToken(RegelSpraakParser.KWARTAAL, 0)

        def METER(self):
            return self.getToken(RegelSpraakParser.METER, 0)

        def EEN_TELWOORD(self):
            return self.getToken(RegelSpraakParser.EEN_TELWOORD, 0)

        def TWEE_TELWOORD(self):
            return self.getToken(RegelSpraakParser.TWEE_TELWOORD, 0)

        def DRIE_TELWOORD(self):
            return self.getToken(RegelSpraakParser.DRIE_TELWOORD, 0)

        def VIER_TELWOORD(self):
            return self.getToken(RegelSpraakParser.VIER_TELWOORD, 0)

        def OUDER(self):
            return self.getToken(RegelSpraakParser.OUDER, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_identifierOrKeywordNoIs

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIdentifierOrKeywordNoIs" ):
                listener.enterIdentifierOrKeywordNoIs(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIdentifierOrKeywordNoIs" ):
                listener.exitIdentifierOrKeywordNoIs(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIdentifierOrKeywordNoIs" ):
                return visitor.visitIdentifierOrKeywordNoIs(self)
            else:
                return visitor.visitChildren(self)




    def identifierOrKeywordNoIs(self):

        localctx = RegelSpraakParser.IdentifierOrKeywordNoIsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_identifierOrKeywordNoIs)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 432
            _la = self._input.LA(1)
            if not(((((_la - 96)) & ~0x3f) == 0 and ((1 << (_la - 96)) & 68987928577) != 0) or ((((_la - 161)) & ~0x3f) == 0 and ((1 << (_la - 161)) & -3457864013260521471) != 0) or ((((_la - 232)) & ~0x3f) == 0 and ((1 << (_la - 232)) & 34361835525) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NaamPhraseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifierOrKeyword(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.IdentifierOrKeywordContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.IdentifierOrKeywordContext,i)


        def DE(self):
            return self.getToken(RegelSpraakParser.DE, 0)

        def HET(self):
            return self.getToken(RegelSpraakParser.HET, 0)

        def EEN(self):
            return self.getToken(RegelSpraakParser.EEN, 0)

        def ZIJN(self):
            return self.getToken(RegelSpraakParser.ZIJN, 0)

        def NIEUWE(self):
            return self.getToken(RegelSpraakParser.NIEUWE, 0)

        def MET(self):
            return self.getToken(RegelSpraakParser.MET, 0)

        def NIET(self):
            return self.getToken(RegelSpraakParser.NIET, 0)

        def AANTAL(self):
            return self.getToken(RegelSpraakParser.AANTAL, 0)

        def DAGEN(self):
            return self.getToken(RegelSpraakParser.DAGEN, 0)

        def IN(self):
            return self.getToken(RegelSpraakParser.IN, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_naamPhrase

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNaamPhrase" ):
                listener.enterNaamPhrase(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNaamPhrase" ):
                listener.exitNaamPhrase(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNaamPhrase" ):
                return visitor.visitNaamPhrase(self)
            else:
                return visitor.visitChildren(self)




    def naamPhrase(self):

        localctx = RegelSpraakParser.NaamPhraseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_naamPhrase)
        self._la = 0 # Token type
        try:
            self.state = 491
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,27,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 435
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==119 or ((((_la - 212)) & ~0x3f) == 0 and ((1 << (_la - 212)) & 41) != 0):
                    self.state = 434
                    _la = self._input.LA(1)
                    if not(_la==119 or ((((_la - 212)) & ~0x3f) == 0 and ((1 << (_la - 212)) & 41) != 0)):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                self.state = 438 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 437
                        self.identifierOrKeyword()

                    else:
                        raise NoViableAltException(self)
                    self.state = 440 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,18,self._ctx)

                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 443 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 442
                        self.identifierOrKeyword()

                    else:
                        raise NoViableAltException(self)
                    self.state = 445 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,19,self._ctx)

                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 447
                self.match(RegelSpraakParser.NIEUWE)
                self.state = 449 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 448
                        self.identifierOrKeyword()

                    else:
                        raise NoViableAltException(self)
                    self.state = 451 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,20,self._ctx)

                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 453
                self.match(RegelSpraakParser.NIEUWE)
                self.state = 455 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 454
                    self.identifierOrKeyword()
                    self.state = 457 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (((((_la - 96)) & ~0x3f) == 0 and ((1 << (_la - 96)) & 68988059649) != 0) or ((((_la - 161)) & ~0x3f) == 0 and ((1 << (_la - 161)) & -3457864013260521471) != 0) or ((((_la - 232)) & ~0x3f) == 0 and ((1 << (_la - 232)) & 34361835525) != 0)):
                        break

                self.state = 459
                self.match(RegelSpraakParser.MET)
                self.state = 461 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 460
                        self.identifierOrKeyword()

                    else:
                        raise NoViableAltException(self)
                    self.state = 463 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,22,self._ctx)

                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 466 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 465
                    self.identifierOrKeyword()
                    self.state = 468 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (((((_la - 96)) & ~0x3f) == 0 and ((1 << (_la - 96)) & 68988059649) != 0) or ((((_la - 161)) & ~0x3f) == 0 and ((1 << (_la - 161)) & -3457864013260521471) != 0) or ((((_la - 232)) & ~0x3f) == 0 and ((1 << (_la - 232)) & 34361835525) != 0)):
                        break

                self.state = 470
                self.match(RegelSpraakParser.MET)
                self.state = 472 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 471
                        self.identifierOrKeyword()

                    else:
                        raise NoViableAltException(self)
                    self.state = 474 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,24,self._ctx)

                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 476
                self.match(RegelSpraakParser.NIET)
                self.state = 478 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 477
                        self.identifierOrKeyword()

                    else:
                        raise NoViableAltException(self)
                    self.state = 480 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,25,self._ctx)

                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 482
                self.match(RegelSpraakParser.HET)
                self.state = 483
                self.match(RegelSpraakParser.AANTAL)
                self.state = 484
                self.match(RegelSpraakParser.DAGEN)
                self.state = 485
                self.match(RegelSpraakParser.IN)
                self.state = 487 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 486
                        self.identifierOrKeyword()

                    else:
                        raise NoViableAltException(self)
                    self.state = 489 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,26,self._ctx)

                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NaamPhraseWithNumbersContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifierOrKeywordWithNumbers(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.IdentifierOrKeywordWithNumbersContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.IdentifierOrKeywordWithNumbersContext,i)


        def DE(self):
            return self.getToken(RegelSpraakParser.DE, 0)

        def HET(self):
            return self.getToken(RegelSpraakParser.HET, 0)

        def EEN(self):
            return self.getToken(RegelSpraakParser.EEN, 0)

        def ZIJN(self):
            return self.getToken(RegelSpraakParser.ZIJN, 0)

        def NIEUWE(self):
            return self.getToken(RegelSpraakParser.NIEUWE, 0)

        def MET(self):
            return self.getToken(RegelSpraakParser.MET, 0)

        def NIET(self):
            return self.getToken(RegelSpraakParser.NIET, 0)

        def AANTAL(self):
            return self.getToken(RegelSpraakParser.AANTAL, 0)

        def DAGEN(self):
            return self.getToken(RegelSpraakParser.DAGEN, 0)

        def IN(self):
            return self.getToken(RegelSpraakParser.IN, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_naamPhraseWithNumbers

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNaamPhraseWithNumbers" ):
                listener.enterNaamPhraseWithNumbers(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNaamPhraseWithNumbers" ):
                listener.exitNaamPhraseWithNumbers(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNaamPhraseWithNumbers" ):
                return visitor.visitNaamPhraseWithNumbers(self)
            else:
                return visitor.visitChildren(self)




    def naamPhraseWithNumbers(self):

        localctx = RegelSpraakParser.NaamPhraseWithNumbersContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_naamPhraseWithNumbers)
        self._la = 0 # Token type
        try:
            self.state = 550
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,38,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 494
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==119 or ((((_la - 212)) & ~0x3f) == 0 and ((1 << (_la - 212)) & 41) != 0):
                    self.state = 493
                    _la = self._input.LA(1)
                    if not(_la==119 or ((((_la - 212)) & ~0x3f) == 0 and ((1 << (_la - 212)) & 41) != 0)):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                self.state = 497 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 496
                        self.identifierOrKeywordWithNumbers()

                    else:
                        raise NoViableAltException(self)
                    self.state = 499 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,29,self._ctx)

                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 502 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 501
                        self.identifierOrKeywordWithNumbers()

                    else:
                        raise NoViableAltException(self)
                    self.state = 504 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,30,self._ctx)

                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 506
                self.match(RegelSpraakParser.NIEUWE)
                self.state = 508 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 507
                        self.identifierOrKeywordWithNumbers()

                    else:
                        raise NoViableAltException(self)
                    self.state = 510 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,31,self._ctx)

                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 512
                self.match(RegelSpraakParser.NIEUWE)
                self.state = 514 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 513
                    self.identifierOrKeywordWithNumbers()
                    self.state = 516 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (((((_la - 96)) & ~0x3f) == 0 and ((1 << (_la - 96)) & 68988059649) != 0) or ((((_la - 161)) & ~0x3f) == 0 and ((1 << (_la - 161)) & -3457864013260521471) != 0) or ((((_la - 232)) & ~0x3f) == 0 and ((1 << (_la - 232)) & 103081312261) != 0)):
                        break

                self.state = 518
                self.match(RegelSpraakParser.MET)
                self.state = 520 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 519
                        self.identifierOrKeywordWithNumbers()

                    else:
                        raise NoViableAltException(self)
                    self.state = 522 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,33,self._ctx)

                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 525 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 524
                    self.identifierOrKeywordWithNumbers()
                    self.state = 527 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (((((_la - 96)) & ~0x3f) == 0 and ((1 << (_la - 96)) & 68988059649) != 0) or ((((_la - 161)) & ~0x3f) == 0 and ((1 << (_la - 161)) & -3457864013260521471) != 0) or ((((_la - 232)) & ~0x3f) == 0 and ((1 << (_la - 232)) & 103081312261) != 0)):
                        break

                self.state = 529
                self.match(RegelSpraakParser.MET)
                self.state = 531 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 530
                        self.identifierOrKeywordWithNumbers()

                    else:
                        raise NoViableAltException(self)
                    self.state = 533 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,35,self._ctx)

                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 535
                self.match(RegelSpraakParser.NIET)
                self.state = 537 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 536
                        self.identifierOrKeywordWithNumbers()

                    else:
                        raise NoViableAltException(self)
                    self.state = 539 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,36,self._ctx)

                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 541
                self.match(RegelSpraakParser.HET)
                self.state = 542
                self.match(RegelSpraakParser.AANTAL)
                self.state = 543
                self.match(RegelSpraakParser.DAGEN)
                self.state = 544
                self.match(RegelSpraakParser.IN)
                self.state = 546 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 545
                        self.identifierOrKeywordWithNumbers()

                    else:
                        raise NoViableAltException(self)
                    self.state = 548 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,37,self._ctx)

                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IdentifierOrKeywordWithNumbersContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifierOrKeyword(self):
            return self.getTypedRuleContext(RegelSpraakParser.IdentifierOrKeywordContext,0)


        def NUMBER(self):
            return self.getToken(RegelSpraakParser.NUMBER, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_identifierOrKeywordWithNumbers

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIdentifierOrKeywordWithNumbers" ):
                listener.enterIdentifierOrKeywordWithNumbers(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIdentifierOrKeywordWithNumbers" ):
                listener.exitIdentifierOrKeywordWithNumbers(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIdentifierOrKeywordWithNumbers" ):
                return visitor.visitIdentifierOrKeywordWithNumbers(self)
            else:
                return visitor.visitChildren(self)




    def identifierOrKeywordWithNumbers(self):

        localctx = RegelSpraakParser.IdentifierOrKeywordWithNumbersContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_identifierOrKeywordWithNumbers)
        try:
            self.state = 554
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [96, 110, 113, 124, 132, 161, 190, 201, 202, 205, 206, 209, 210, 221, 223, 224, 232, 234, 253, 267]:
                self.enterOuterAlt(localctx, 1)
                self.state = 552
                self.identifierOrKeyword()
                pass
            elif token in [268]:
                self.enterOuterAlt(localctx, 2)
                self.state = 553
                self.match(RegelSpraakParser.NUMBER)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NaamPhraseNoIsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifierOrKeywordNoIs(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.IdentifierOrKeywordNoIsContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.IdentifierOrKeywordNoIsContext,i)


        def DE(self):
            return self.getToken(RegelSpraakParser.DE, 0)

        def HET(self):
            return self.getToken(RegelSpraakParser.HET, 0)

        def EEN(self):
            return self.getToken(RegelSpraakParser.EEN, 0)

        def ZIJN(self):
            return self.getToken(RegelSpraakParser.ZIJN, 0)

        def NIEUWE(self):
            return self.getToken(RegelSpraakParser.NIEUWE, 0)

        def MET(self):
            return self.getToken(RegelSpraakParser.MET, 0)

        def NIET(self):
            return self.getToken(RegelSpraakParser.NIET, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_naamPhraseNoIs

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNaamPhraseNoIs" ):
                listener.enterNaamPhraseNoIs(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNaamPhraseNoIs" ):
                listener.exitNaamPhraseNoIs(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNaamPhraseNoIs" ):
                return visitor.visitNaamPhraseNoIs(self)
            else:
                return visitor.visitChildren(self)




    def naamPhraseNoIs(self):

        localctx = RegelSpraakParser.NaamPhraseNoIsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_naamPhraseNoIs)
        self._la = 0 # Token type
        try:
            self.state = 604
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,49,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 557
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==119 or ((((_la - 212)) & ~0x3f) == 0 and ((1 << (_la - 212)) & 41) != 0):
                    self.state = 556
                    _la = self._input.LA(1)
                    if not(_la==119 or ((((_la - 212)) & ~0x3f) == 0 and ((1 << (_la - 212)) & 41) != 0)):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                self.state = 560 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 559
                        self.identifierOrKeywordNoIs()

                    else:
                        raise NoViableAltException(self)
                    self.state = 562 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,41,self._ctx)

                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 565 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 564
                        self.identifierOrKeywordNoIs()

                    else:
                        raise NoViableAltException(self)
                    self.state = 567 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,42,self._ctx)

                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 569
                self.match(RegelSpraakParser.NIEUWE)
                self.state = 571 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 570
                        self.identifierOrKeywordNoIs()

                    else:
                        raise NoViableAltException(self)
                    self.state = 573 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,43,self._ctx)

                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 575
                self.match(RegelSpraakParser.NIEUWE)
                self.state = 577 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 576
                    self.identifierOrKeywordNoIs()
                    self.state = 579 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (((((_la - 96)) & ~0x3f) == 0 and ((1 << (_la - 96)) & 68987928577) != 0) or ((((_la - 161)) & ~0x3f) == 0 and ((1 << (_la - 161)) & -3457864013260521471) != 0) or ((((_la - 232)) & ~0x3f) == 0 and ((1 << (_la - 232)) & 34361835525) != 0)):
                        break

                self.state = 581
                self.match(RegelSpraakParser.MET)
                self.state = 583 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 582
                        self.identifierOrKeywordNoIs()

                    else:
                        raise NoViableAltException(self)
                    self.state = 585 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,45,self._ctx)

                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 588 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 587
                    self.identifierOrKeywordNoIs()
                    self.state = 590 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (((((_la - 96)) & ~0x3f) == 0 and ((1 << (_la - 96)) & 68987928577) != 0) or ((((_la - 161)) & ~0x3f) == 0 and ((1 << (_la - 161)) & -3457864013260521471) != 0) or ((((_la - 232)) & ~0x3f) == 0 and ((1 << (_la - 232)) & 34361835525) != 0)):
                        break

                self.state = 592
                self.match(RegelSpraakParser.MET)
                self.state = 594 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 593
                        self.identifierOrKeywordNoIs()

                    else:
                        raise NoViableAltException(self)
                    self.state = 596 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,47,self._ctx)

                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 598
                self.match(RegelSpraakParser.NIET)
                self.state = 600 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 599
                        self.identifierOrKeywordNoIs()

                    else:
                        raise NoViableAltException(self)
                    self.state = 602 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,48,self._ctx)

                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NaamwoordContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def naamPhrase(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.NaamPhraseContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.NaamPhraseContext,i)


        def voorzetsel(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.VoorzetselContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.VoorzetselContext,i)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_naamwoord

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNaamwoord" ):
                listener.enterNaamwoord(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNaamwoord" ):
                listener.exitNaamwoord(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNaamwoord" ):
                return visitor.visitNaamwoord(self)
            else:
                return visitor.visitChildren(self)




    def naamwoord(self):

        localctx = RegelSpraakParser.NaamwoordContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_naamwoord)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 606
            self.naamPhrase()
            self.state = 612
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,50,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 607
                    self.voorzetsel()
                    self.state = 608
                    self.naamPhrase() 
                self.state = 614
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,50,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NaamwoordWithNumbersContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def naamPhraseWithNumbers(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.NaamPhraseWithNumbersContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.NaamPhraseWithNumbersContext,i)


        def voorzetsel(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.VoorzetselContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.VoorzetselContext,i)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_naamwoordWithNumbers

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNaamwoordWithNumbers" ):
                listener.enterNaamwoordWithNumbers(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNaamwoordWithNumbers" ):
                listener.exitNaamwoordWithNumbers(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNaamwoordWithNumbers" ):
                return visitor.visitNaamwoordWithNumbers(self)
            else:
                return visitor.visitChildren(self)




    def naamwoordWithNumbers(self):

        localctx = RegelSpraakParser.NaamwoordWithNumbersContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_naamwoordWithNumbers)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 615
            self.naamPhraseWithNumbers()
            self.state = 621
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,51,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 616
                    self.voorzetsel()
                    self.state = 617
                    self.naamPhraseWithNumbers() 
                self.state = 623
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,51,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NaamwoordNoIsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def naamPhraseNoIs(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.NaamPhraseNoIsContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.NaamPhraseNoIsContext,i)


        def voorzetsel(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.VoorzetselContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.VoorzetselContext,i)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_naamwoordNoIs

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNaamwoordNoIs" ):
                listener.enterNaamwoordNoIs(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNaamwoordNoIs" ):
                listener.exitNaamwoordNoIs(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNaamwoordNoIs" ):
                return visitor.visitNaamwoordNoIs(self)
            else:
                return visitor.visitChildren(self)




    def naamwoordNoIs(self):

        localctx = RegelSpraakParser.NaamwoordNoIsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_naamwoordNoIs)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 624
            self.naamPhraseNoIs()
            self.state = 630
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,52,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 625
                    self.voorzetsel()
                    self.state = 626
                    self.naamPhraseNoIs() 
                self.state = 632
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,52,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VoorzetselContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def VAN(self):
            return self.getToken(RegelSpraakParser.VAN, 0)

        def IN(self):
            return self.getToken(RegelSpraakParser.IN, 0)

        def VOOR(self):
            return self.getToken(RegelSpraakParser.VOOR, 0)

        def OVER(self):
            return self.getToken(RegelSpraakParser.OVER, 0)

        def OP(self):
            return self.getToken(RegelSpraakParser.OP, 0)

        def BIJ(self):
            return self.getToken(RegelSpraakParser.BIJ, 0)

        def UIT(self):
            return self.getToken(RegelSpraakParser.UIT, 0)

        def TOT(self):
            return self.getToken(RegelSpraakParser.TOT, 0)

        def EN(self):
            return self.getToken(RegelSpraakParser.EN, 0)

        def MET(self):
            return self.getToken(RegelSpraakParser.MET, 0)

        def OF(self):
            return self.getToken(RegelSpraakParser.OF, 0)

        def TOT_EN_MET(self):
            return self.getToken(RegelSpraakParser.TOT_EN_MET, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_voorzetsel

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVoorzetsel" ):
                listener.enterVoorzetsel(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVoorzetsel" ):
                listener.exitVoorzetsel(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVoorzetsel" ):
                return visitor.visitVoorzetsel(self)
            else:
                return visitor.visitChildren(self)




    def voorzetsel(self):

        localctx = RegelSpraakParser.VoorzetselContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_voorzetsel)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 633
            _la = self._input.LA(1)
            if not(((((_la - 146)) & ~0x3f) == 0 and ((1 << (_la - 146)) & 4611686019501129733) != 0) or ((((_la - 216)) & ~0x3f) == 0 and ((1 << (_la - 216)) & 4597129233) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DatumLiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DATE_TIME_LITERAL(self):
            return self.getToken(RegelSpraakParser.DATE_TIME_LITERAL, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_datumLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDatumLiteral" ):
                listener.enterDatumLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDatumLiteral" ):
                listener.exitDatumLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDatumLiteral" ):
                return visitor.visitDatumLiteral(self)
            else:
                return visitor.visitChildren(self)




    def datumLiteral(self):

        localctx = RegelSpraakParser.DatumLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_datumLiteral)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 635
            self.match(RegelSpraakParser.DATE_TIME_LITERAL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UnitContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(RegelSpraakParser.IDENTIFIER, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_unit

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnit" ):
                listener.enterUnit(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnit" ):
                listener.exitUnit(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnit" ):
                return visitor.visitUnit(self)
            else:
                return visitor.visitChildren(self)




    def unit(self):

        localctx = RegelSpraakParser.UnitContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_unit)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 637
            self.match(RegelSpraakParser.IDENTIFIER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TimeUnitContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DAG(self):
            return self.getToken(RegelSpraakParser.DAG, 0)

        def DAGEN(self):
            return self.getToken(RegelSpraakParser.DAGEN, 0)

        def MAAND(self):
            return self.getToken(RegelSpraakParser.MAAND, 0)

        def MAANDEN(self):
            return self.getToken(RegelSpraakParser.MAANDEN, 0)

        def JAAR(self):
            return self.getToken(RegelSpraakParser.JAAR, 0)

        def JAREN(self):
            return self.getToken(RegelSpraakParser.JAREN, 0)

        def WEEK(self):
            return self.getToken(RegelSpraakParser.WEEK, 0)

        def WEKEN(self):
            return self.getToken(RegelSpraakParser.WEKEN, 0)

        def UUR(self):
            return self.getToken(RegelSpraakParser.UUR, 0)

        def UREN(self):
            return self.getToken(RegelSpraakParser.UREN, 0)

        def MINUUT(self):
            return self.getToken(RegelSpraakParser.MINUUT, 0)

        def MINUTEN(self):
            return self.getToken(RegelSpraakParser.MINUTEN, 0)

        def SECONDE(self):
            return self.getToken(RegelSpraakParser.SECONDE, 0)

        def SECONDEN(self):
            return self.getToken(RegelSpraakParser.SECONDEN, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_timeUnit

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTimeUnit" ):
                listener.enterTimeUnit(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTimeUnit" ):
                listener.exitTimeUnit(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTimeUnit" ):
                return visitor.visitTimeUnit(self)
            else:
                return visitor.visitChildren(self)




    def timeUnit(self):

        localctx = RegelSpraakParser.TimeUnitContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_timeUnit)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 639
            _la = self._input.LA(1)
            if not(((((_la - 209)) & ~0x3f) == 0 and ((1 << (_la - 209)) & 6624451080195) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ObjectTypeDefinitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self._IDENTIFIER = None # Token
            self.plural = list() # of Tokens

        def OBJECTTYPE(self):
            return self.getToken(RegelSpraakParser.OBJECTTYPE, 0)

        def naamwoordNoIs(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordNoIsContext,0)


        def MV_START(self):
            return self.getToken(RegelSpraakParser.MV_START, 0)

        def RPAREN(self):
            return self.getToken(RegelSpraakParser.RPAREN, 0)

        def BEZIELD(self):
            return self.getToken(RegelSpraakParser.BEZIELD, 0)

        def objectTypeMember(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.ObjectTypeMemberContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.ObjectTypeMemberContext,i)


        def IDENTIFIER(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.IDENTIFIER)
            else:
                return self.getToken(RegelSpraakParser.IDENTIFIER, i)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_objectTypeDefinition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterObjectTypeDefinition" ):
                listener.enterObjectTypeDefinition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitObjectTypeDefinition" ):
                listener.exitObjectTypeDefinition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitObjectTypeDefinition" ):
                return visitor.visitObjectTypeDefinition(self)
            else:
                return visitor.visitChildren(self)




    def objectTypeDefinition(self):

        localctx = RegelSpraakParser.ObjectTypeDefinitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_objectTypeDefinition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 641
            self.match(RegelSpraakParser.OBJECTTYPE)
            self.state = 642
            self.naamwoordNoIs()
            self.state = 650
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==178:
                self.state = 643
                self.match(RegelSpraakParser.MV_START)
                self.state = 645 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 644
                    localctx._IDENTIFIER = self.match(RegelSpraakParser.IDENTIFIER)
                    localctx.plural.append(localctx._IDENTIFIER)
                    self.state = 647 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==267):
                        break

                self.state = 649
                self.match(RegelSpraakParser.RPAREN)


            self.state = 653
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==165:
                self.state = 652
                self.match(RegelSpraakParser.BEZIELD)


            self.state = 658
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,56,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 655
                    self.objectTypeMember() 
                self.state = 660
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,56,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ObjectTypeMemberContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SEMICOLON(self):
            return self.getToken(RegelSpraakParser.SEMICOLON, 0)

        def kenmerkSpecificatie(self):
            return self.getTypedRuleContext(RegelSpraakParser.KenmerkSpecificatieContext,0)


        def attribuutSpecificatie(self):
            return self.getTypedRuleContext(RegelSpraakParser.AttribuutSpecificatieContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_objectTypeMember

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterObjectTypeMember" ):
                listener.enterObjectTypeMember(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitObjectTypeMember" ):
                listener.exitObjectTypeMember(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitObjectTypeMember" ):
                return visitor.visitObjectTypeMember(self)
            else:
                return visitor.visitChildren(self)




    def objectTypeMember(self):

        localctx = RegelSpraakParser.ObjectTypeMemberContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_objectTypeMember)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 663
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,57,self._ctx)
            if la_ == 1:
                self.state = 661
                self.kenmerkSpecificatie()
                pass

            elif la_ == 2:
                self.state = 662
                self.attribuutSpecificatie()
                pass


            self.state = 665
            self.match(RegelSpraakParser.SEMICOLON)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class KenmerkSpecificatieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KENMERK(self):
            return self.getToken(RegelSpraakParser.KENMERK, 0)

        def identifier(self):
            return self.getTypedRuleContext(RegelSpraakParser.IdentifierContext,0)


        def naamwoordWithNumbers(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordWithNumbersContext,0)


        def tijdlijn(self):
            return self.getTypedRuleContext(RegelSpraakParser.TijdlijnContext,0)


        def BIJVOEGLIJK(self):
            return self.getToken(RegelSpraakParser.BIJVOEGLIJK, 0)

        def BEZITTELIJK(self):
            return self.getToken(RegelSpraakParser.BEZITTELIJK, 0)

        def IS(self):
            return self.getToken(RegelSpraakParser.IS, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_kenmerkSpecificatie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterKenmerkSpecificatie" ):
                listener.enterKenmerkSpecificatie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitKenmerkSpecificatie" ):
                listener.exitKenmerkSpecificatie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitKenmerkSpecificatie" ):
                return visitor.visitKenmerkSpecificatie(self)
            else:
                return visitor.visitChildren(self)




    def kenmerkSpecificatie(self):

        localctx = RegelSpraakParser.KenmerkSpecificatieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_kenmerkSpecificatie)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 672
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,59,self._ctx)
            if la_ == 1:
                self.state = 668
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==113:
                    self.state = 667
                    self.match(RegelSpraakParser.IS)


                self.state = 670
                self.identifier()
                pass

            elif la_ == 2:
                self.state = 671
                self.naamwoordWithNumbers()
                pass


            self.state = 674
            self.match(RegelSpraakParser.KENMERK)
            self.state = 676
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==163 or _la==164:
                self.state = 675
                _la = self._input.LA(1)
                if not(_la==163 or _la==164):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


            self.state = 679
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 187)) & ~0x3f) == 0 and ((1 << (_la - 187)) & 7) != 0):
                self.state = 678
                self.tijdlijn()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AttribuutSpecificatieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def naamwoordWithNumbers(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordWithNumbersContext,0)


        def datatype(self):
            return self.getTypedRuleContext(RegelSpraakParser.DatatypeContext,0)


        def domeinRef(self):
            return self.getTypedRuleContext(RegelSpraakParser.DomeinRefContext,0)


        def objectTypeRef(self):
            return self.getTypedRuleContext(RegelSpraakParser.ObjectTypeRefContext,0)


        def MET_EENHEID(self):
            return self.getToken(RegelSpraakParser.MET_EENHEID, 0)

        def unitIdentifier(self):
            return self.getTypedRuleContext(RegelSpraakParser.UnitIdentifierContext,0)


        def GEDIMENSIONEERD_MET(self):
            return self.getToken(RegelSpraakParser.GEDIMENSIONEERD_MET, 0)

        def dimensieRef(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.DimensieRefContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.DimensieRefContext,i)


        def tijdlijn(self):
            return self.getTypedRuleContext(RegelSpraakParser.TijdlijnContext,0)


        def EN(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.EN)
            else:
                return self.getToken(RegelSpraakParser.EN, i)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_attribuutSpecificatie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAttribuutSpecificatie" ):
                listener.enterAttribuutSpecificatie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAttribuutSpecificatie" ):
                listener.exitAttribuutSpecificatie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAttribuutSpecificatie" ):
                return visitor.visitAttribuutSpecificatie(self)
            else:
                return visitor.visitChildren(self)




    def attribuutSpecificatie(self):

        localctx = RegelSpraakParser.AttribuutSpecificatieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_attribuutSpecificatie)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 681
            self.naamwoordWithNumbers()
            self.state = 685
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,62,self._ctx)
            if la_ == 1:
                self.state = 682
                self.datatype()
                pass

            elif la_ == 2:
                self.state = 683
                self.domeinRef()
                pass

            elif la_ == 3:
                self.state = 684
                self.objectTypeRef()
                pass


            self.state = 689
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==177:
                self.state = 687
                self.match(RegelSpraakParser.MET_EENHEID)
                self.state = 688
                self.unitIdentifier()


            self.state = 700
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==171:
                self.state = 691
                self.match(RegelSpraakParser.GEDIMENSIONEERD_MET)
                self.state = 692
                self.dimensieRef()
                self.state = 697
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==216:
                    self.state = 693
                    self.match(RegelSpraakParser.EN)
                    self.state = 694
                    self.dimensieRef()
                    self.state = 699
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)



            self.state = 703
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 187)) & ~0x3f) == 0 and ((1 << (_la - 187)) & 7) != 0):
                self.state = 702
                self.tijdlijn()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DatatypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def numeriekDatatype(self):
            return self.getTypedRuleContext(RegelSpraakParser.NumeriekDatatypeContext,0)


        def tekstDatatype(self):
            return self.getTypedRuleContext(RegelSpraakParser.TekstDatatypeContext,0)


        def booleanDatatype(self):
            return self.getTypedRuleContext(RegelSpraakParser.BooleanDatatypeContext,0)


        def datumTijdDatatype(self):
            return self.getTypedRuleContext(RegelSpraakParser.DatumTijdDatatypeContext,0)


        def lijstDatatype(self):
            return self.getTypedRuleContext(RegelSpraakParser.LijstDatatypeContext,0)


        def percentageDatatype(self):
            return self.getTypedRuleContext(RegelSpraakParser.PercentageDatatypeContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_datatype

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDatatype" ):
                listener.enterDatatype(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDatatype" ):
                listener.exitDatatype(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDatatype" ):
                return visitor.visitDatatype(self)
            else:
                return visitor.visitChildren(self)




    def datatype(self):

        localctx = RegelSpraakParser.DatatypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_datatype)
        try:
            self.state = 711
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [181]:
                self.enterOuterAlt(localctx, 1)
                self.state = 705
                self.numeriekDatatype()
                pass
            elif token in [186]:
                self.enterOuterAlt(localctx, 2)
                self.state = 706
                self.tekstDatatype()
                pass
            elif token in [166]:
                self.enterOuterAlt(localctx, 3)
                self.state = 707
                self.booleanDatatype()
                pass
            elif token in [3, 168]:
                self.enterOuterAlt(localctx, 4)
                self.state = 708
                self.datumTijdDatatype()
                pass
            elif token in [101]:
                self.enterOuterAlt(localctx, 5)
                self.state = 709
                self.lijstDatatype()
                pass
            elif token in [182]:
                self.enterOuterAlt(localctx, 6)
                self.state = 710
                self.percentageDatatype()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LijstDatatypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LIJST(self):
            return self.getToken(RegelSpraakParser.LIJST, 0)

        def VAN(self):
            return self.getToken(RegelSpraakParser.VAN, 0)

        def datatype(self):
            return self.getTypedRuleContext(RegelSpraakParser.DatatypeContext,0)


        def domeinRef(self):
            return self.getTypedRuleContext(RegelSpraakParser.DomeinRefContext,0)


        def objectTypeRef(self):
            return self.getTypedRuleContext(RegelSpraakParser.ObjectTypeRefContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_lijstDatatype

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLijstDatatype" ):
                listener.enterLijstDatatype(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLijstDatatype" ):
                listener.exitLijstDatatype(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLijstDatatype" ):
                return visitor.visitLijstDatatype(self)
            else:
                return visitor.visitChildren(self)




    def lijstDatatype(self):

        localctx = RegelSpraakParser.LijstDatatypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_lijstDatatype)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 713
            self.match(RegelSpraakParser.LIJST)
            self.state = 714
            self.match(RegelSpraakParser.VAN)
            self.state = 718
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,68,self._ctx)
            if la_ == 1:
                self.state = 715
                self.datatype()
                pass

            elif la_ == 2:
                self.state = 716
                self.domeinRef()
                pass

            elif la_ == 3:
                self.state = 717
                self.objectTypeRef()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NumeriekDatatypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NUMERIEK(self):
            return self.getToken(RegelSpraakParser.NUMERIEK, 0)

        def LPAREN(self):
            return self.getToken(RegelSpraakParser.LPAREN, 0)

        def getalSpecificatie(self):
            return self.getTypedRuleContext(RegelSpraakParser.GetalSpecificatieContext,0)


        def RPAREN(self):
            return self.getToken(RegelSpraakParser.RPAREN, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_numeriekDatatype

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumeriekDatatype" ):
                listener.enterNumeriekDatatype(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumeriekDatatype" ):
                listener.exitNumeriekDatatype(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNumeriekDatatype" ):
                return visitor.visitNumeriekDatatype(self)
            else:
                return visitor.visitChildren(self)




    def numeriekDatatype(self):

        localctx = RegelSpraakParser.NumeriekDatatypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_numeriekDatatype)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 720
            self.match(RegelSpraakParser.NUMERIEK)
            self.state = 725
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==274:
                self.state = 721
                self.match(RegelSpraakParser.LPAREN)
                self.state = 722
                self.getalSpecificatie()
                self.state = 723
                self.match(RegelSpraakParser.RPAREN)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TekstDatatypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TEKST(self):
            return self.getToken(RegelSpraakParser.TEKST, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_tekstDatatype

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTekstDatatype" ):
                listener.enterTekstDatatype(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTekstDatatype" ):
                listener.exitTekstDatatype(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTekstDatatype" ):
                return visitor.visitTekstDatatype(self)
            else:
                return visitor.visitChildren(self)




    def tekstDatatype(self):

        localctx = RegelSpraakParser.TekstDatatypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_tekstDatatype)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 727
            self.match(RegelSpraakParser.TEKST)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PercentageDatatypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PERCENTAGE(self):
            return self.getToken(RegelSpraakParser.PERCENTAGE, 0)

        def LPAREN(self):
            return self.getToken(RegelSpraakParser.LPAREN, 0)

        def getalSpecificatie(self):
            return self.getTypedRuleContext(RegelSpraakParser.GetalSpecificatieContext,0)


        def RPAREN(self):
            return self.getToken(RegelSpraakParser.RPAREN, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_percentageDatatype

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPercentageDatatype" ):
                listener.enterPercentageDatatype(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPercentageDatatype" ):
                listener.exitPercentageDatatype(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPercentageDatatype" ):
                return visitor.visitPercentageDatatype(self)
            else:
                return visitor.visitChildren(self)




    def percentageDatatype(self):

        localctx = RegelSpraakParser.PercentageDatatypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_percentageDatatype)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 729
            self.match(RegelSpraakParser.PERCENTAGE)
            self.state = 734
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==274:
                self.state = 730
                self.match(RegelSpraakParser.LPAREN)
                self.state = 731
                self.getalSpecificatie()
                self.state = 732
                self.match(RegelSpraakParser.RPAREN)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BooleanDatatypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BOOLEAN(self):
            return self.getToken(RegelSpraakParser.BOOLEAN, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_booleanDatatype

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBooleanDatatype" ):
                listener.enterBooleanDatatype(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBooleanDatatype" ):
                listener.exitBooleanDatatype(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBooleanDatatype" ):
                return visitor.visitBooleanDatatype(self)
            else:
                return visitor.visitChildren(self)




    def booleanDatatype(self):

        localctx = RegelSpraakParser.BooleanDatatypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_booleanDatatype)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 736
            self.match(RegelSpraakParser.BOOLEAN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DatumTijdDatatypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DATUM_IN_DAGEN(self):
            return self.getToken(RegelSpraakParser.DATUM_IN_DAGEN, 0)

        def DATUM_TIJD_MILLIS(self):
            return self.getToken(RegelSpraakParser.DATUM_TIJD_MILLIS, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_datumTijdDatatype

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDatumTijdDatatype" ):
                listener.enterDatumTijdDatatype(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDatumTijdDatatype" ):
                listener.exitDatumTijdDatatype(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDatumTijdDatatype" ):
                return visitor.visitDatumTijdDatatype(self)
            else:
                return visitor.visitChildren(self)




    def datumTijdDatatype(self):

        localctx = RegelSpraakParser.DatumTijdDatatypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_datumTijdDatatype)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 738
            _la = self._input.LA(1)
            if not(_la==3 or _la==168):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GetalSpecificatieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GEHEEL_GETAL(self):
            return self.getToken(RegelSpraakParser.GEHEEL_GETAL, 0)

        def GETAL(self):
            return self.getToken(RegelSpraakParser.GETAL, 0)

        def NEGATIEF(self):
            return self.getToken(RegelSpraakParser.NEGATIEF, 0)

        def NIET_NEGATIEF(self):
            return self.getToken(RegelSpraakParser.NIET_NEGATIEF, 0)

        def POSITIEF(self):
            return self.getToken(RegelSpraakParser.POSITIEF, 0)

        def MET(self):
            return self.getToken(RegelSpraakParser.MET, 0)

        def NUMBER(self):
            return self.getToken(RegelSpraakParser.NUMBER, 0)

        def DECIMALEN(self):
            return self.getToken(RegelSpraakParser.DECIMALEN, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_getalSpecificatie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGetalSpecificatie" ):
                listener.enterGetalSpecificatie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGetalSpecificatie" ):
                listener.exitGetalSpecificatie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGetalSpecificatie" ):
                return visitor.visitGetalSpecificatie(self)
            else:
                return visitor.visitChildren(self)




    def getalSpecificatie(self):

        localctx = RegelSpraakParser.GetalSpecificatieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_getalSpecificatie)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 741
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 179)) & ~0x3f) == 0 and ((1 << (_la - 179)) & 19) != 0):
                self.state = 740
                _la = self._input.LA(1)
                if not(((((_la - 179)) & ~0x3f) == 0 and ((1 << (_la - 179)) & 19) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


            self.state = 749
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,72,self._ctx)
            if la_ == 1:
                self.state = 743
                self.match(RegelSpraakParser.GEHEEL_GETAL)
                pass

            elif la_ == 2:
                self.state = 744
                self.match(RegelSpraakParser.GETAL)
                self.state = 745
                self.match(RegelSpraakParser.MET)
                self.state = 746
                self.match(RegelSpraakParser.NUMBER)
                self.state = 747
                self.match(RegelSpraakParser.DECIMALEN)
                pass

            elif la_ == 3:
                self.state = 748
                self.match(RegelSpraakParser.GETAL)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DomeinDefinitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.name = None # Token

        def DOMEIN(self):
            return self.getToken(RegelSpraakParser.DOMEIN, 0)

        def IS_VAN_HET_TYPE(self):
            return self.getToken(RegelSpraakParser.IS_VAN_HET_TYPE, 0)

        def domeinType(self):
            return self.getTypedRuleContext(RegelSpraakParser.DomeinTypeContext,0)


        def IDENTIFIER(self):
            return self.getToken(RegelSpraakParser.IDENTIFIER, 0)

        def MET_EENHEID(self):
            return self.getToken(RegelSpraakParser.MET_EENHEID, 0)

        def eenheidExpressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.EenheidExpressieContext,0)


        def SEMICOLON(self):
            return self.getToken(RegelSpraakParser.SEMICOLON, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_domeinDefinition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDomeinDefinition" ):
                listener.enterDomeinDefinition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDomeinDefinition" ):
                listener.exitDomeinDefinition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDomeinDefinition" ):
                return visitor.visitDomeinDefinition(self)
            else:
                return visitor.visitChildren(self)




    def domeinDefinition(self):

        localctx = RegelSpraakParser.DomeinDefinitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_domeinDefinition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 751
            self.match(RegelSpraakParser.DOMEIN)
            self.state = 752
            localctx.name = self.match(RegelSpraakParser.IDENTIFIER)
            self.state = 753
            self.match(RegelSpraakParser.IS_VAN_HET_TYPE)
            self.state = 754
            self.domeinType()
            self.state = 757
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==177:
                self.state = 755
                self.match(RegelSpraakParser.MET_EENHEID)
                self.state = 756
                self.eenheidExpressie()


            self.state = 760
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==281:
                self.state = 759
                self.match(RegelSpraakParser.SEMICOLON)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DomeinTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def enumeratieSpecificatie(self):
            return self.getTypedRuleContext(RegelSpraakParser.EnumeratieSpecificatieContext,0)


        def numeriekDatatype(self):
            return self.getTypedRuleContext(RegelSpraakParser.NumeriekDatatypeContext,0)


        def tekstDatatype(self):
            return self.getTypedRuleContext(RegelSpraakParser.TekstDatatypeContext,0)


        def booleanDatatype(self):
            return self.getTypedRuleContext(RegelSpraakParser.BooleanDatatypeContext,0)


        def datumTijdDatatype(self):
            return self.getTypedRuleContext(RegelSpraakParser.DatumTijdDatatypeContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_domeinType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDomeinType" ):
                listener.enterDomeinType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDomeinType" ):
                listener.exitDomeinType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDomeinType" ):
                return visitor.visitDomeinType(self)
            else:
                return visitor.visitChildren(self)




    def domeinType(self):

        localctx = RegelSpraakParser.DomeinTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_domeinType)
        try:
            self.state = 767
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [170]:
                self.enterOuterAlt(localctx, 1)
                self.state = 762
                self.enumeratieSpecificatie()
                pass
            elif token in [181]:
                self.enterOuterAlt(localctx, 2)
                self.state = 763
                self.numeriekDatatype()
                pass
            elif token in [186]:
                self.enterOuterAlt(localctx, 3)
                self.state = 764
                self.tekstDatatype()
                pass
            elif token in [166]:
                self.enterOuterAlt(localctx, 4)
                self.state = 765
                self.booleanDatatype()
                pass
            elif token in [3, 168]:
                self.enterOuterAlt(localctx, 5)
                self.state = 766
                self.datumTijdDatatype()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EnumeratieSpecificatieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ENUMERATIE(self):
            return self.getToken(RegelSpraakParser.ENUMERATIE, 0)

        def ENUM_LITERAL(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.ENUM_LITERAL)
            else:
                return self.getToken(RegelSpraakParser.ENUM_LITERAL, i)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_enumeratieSpecificatie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEnumeratieSpecificatie" ):
                listener.enterEnumeratieSpecificatie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEnumeratieSpecificatie" ):
                listener.exitEnumeratieSpecificatie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEnumeratieSpecificatie" ):
                return visitor.visitEnumeratieSpecificatie(self)
            else:
                return visitor.visitChildren(self)




    def enumeratieSpecificatie(self):

        localctx = RegelSpraakParser.EnumeratieSpecificatieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 74, self.RULE_enumeratieSpecificatie)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 769
            self.match(RegelSpraakParser.ENUMERATIE)
            self.state = 771 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 770
                self.match(RegelSpraakParser.ENUM_LITERAL)
                self.state = 773 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==273):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DomeinRefContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.name = None # Token

        def IDENTIFIER(self):
            return self.getToken(RegelSpraakParser.IDENTIFIER, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_domeinRef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDomeinRef" ):
                listener.enterDomeinRef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDomeinRef" ):
                listener.exitDomeinRef(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDomeinRef" ):
                return visitor.visitDomeinRef(self)
            else:
                return visitor.visitChildren(self)




    def domeinRef(self):

        localctx = RegelSpraakParser.DomeinRefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 76, self.RULE_domeinRef)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 775
            localctx.name = self.match(RegelSpraakParser.IDENTIFIER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ObjectTypeRefContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(RegelSpraakParser.IDENTIFIER, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_objectTypeRef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterObjectTypeRef" ):
                listener.enterObjectTypeRef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitObjectTypeRef" ):
                listener.exitObjectTypeRef(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitObjectTypeRef" ):
                return visitor.visitObjectTypeRef(self)
            else:
                return visitor.visitChildren(self)




    def objectTypeRef(self):

        localctx = RegelSpraakParser.ObjectTypeRefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 78, self.RULE_objectTypeRef)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 777
            self.match(RegelSpraakParser.IDENTIFIER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EenheidsysteemDefinitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.name = None # IdentifierContext

        def EENHEIDSYSTEEM(self):
            return self.getToken(RegelSpraakParser.EENHEIDSYSTEEM, 0)

        def identifier(self):
            return self.getTypedRuleContext(RegelSpraakParser.IdentifierContext,0)


        def eenheidEntry(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.EenheidEntryContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.EenheidEntryContext,i)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_eenheidsysteemDefinition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEenheidsysteemDefinition" ):
                listener.enterEenheidsysteemDefinition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEenheidsysteemDefinition" ):
                listener.exitEenheidsysteemDefinition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEenheidsysteemDefinition" ):
                return visitor.visitEenheidsysteemDefinition(self)
            else:
                return visitor.visitChildren(self)




    def eenheidsysteemDefinition(self):

        localctx = RegelSpraakParser.EenheidsysteemDefinitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 80, self.RULE_eenheidsysteemDefinition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 779
            self.match(RegelSpraakParser.EENHEIDSYSTEEM)
            self.state = 780
            localctx.name = self.identifier()
            self.state = 784
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==212 or _la==217:
                self.state = 781
                self.eenheidEntry()
                self.state = 786
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EenheidEntryContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.unitName = None # UnitIdentifierContext
            self.pluralName = None # UnitIdentifierContext
            self.abbrev = None # UnitIdentifierContext
            self.symbol = None # UnitIdentifierContext
            self.value = None # Token
            self.targetUnit = None # UnitIdentifierContext

        def DE(self):
            return self.getToken(RegelSpraakParser.DE, 0)

        def HET(self):
            return self.getToken(RegelSpraakParser.HET, 0)

        def unitIdentifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.UnitIdentifierContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.UnitIdentifierContext,i)


        def MV_START(self):
            return self.getToken(RegelSpraakParser.MV_START, 0)

        def RPAREN(self):
            return self.getToken(RegelSpraakParser.RPAREN, 0)

        def EQUALS(self):
            return self.getToken(RegelSpraakParser.EQUALS, 0)

        def NUMBER(self):
            return self.getToken(RegelSpraakParser.NUMBER, 0)

        def SLASH(self):
            return self.getToken(RegelSpraakParser.SLASH, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_eenheidEntry

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEenheidEntry" ):
                listener.enterEenheidEntry(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEenheidEntry" ):
                listener.exitEenheidEntry(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEenheidEntry" ):
                return visitor.visitEenheidEntry(self)
            else:
                return visitor.visitChildren(self)




    def eenheidEntry(self):

        localctx = RegelSpraakParser.EenheidEntryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 82, self.RULE_eenheidEntry)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 787
            _la = self._input.LA(1)
            if not(_la==212 or _la==217):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 788
            localctx.unitName = self.unitIdentifier()
            self.state = 793
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==178:
                self.state = 789
                self.match(RegelSpraakParser.MV_START)
                self.state = 790
                localctx.pluralName = self.unitIdentifier()
                self.state = 791
                self.match(RegelSpraakParser.RPAREN)


            self.state = 795
            localctx.abbrev = self.unitIdentifier()
            self.state = 797
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==137 or ((((_la - 209)) & ~0x3f) == 0 and ((1 << (_la - 209)) & 576449784568606723) != 0):
                self.state = 796
                localctx.symbol = self.unitIdentifier()


            self.state = 805
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==269:
                self.state = 799
                self.match(RegelSpraakParser.EQUALS)
                self.state = 801
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==282:
                    self.state = 800
                    self.match(RegelSpraakParser.SLASH)


                self.state = 803
                localctx.value = self.match(RegelSpraakParser.NUMBER)
                self.state = 804
                localctx.targetUnit = self.unitIdentifier()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UnitIdentifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(RegelSpraakParser.IDENTIFIER, 0)

        def METER(self):
            return self.getToken(RegelSpraakParser.METER, 0)

        def KILOGRAM(self):
            return self.getToken(RegelSpraakParser.KILOGRAM, 0)

        def MILLISECONDE(self):
            return self.getToken(RegelSpraakParser.MILLISECONDE, 0)

        def SECONDE(self):
            return self.getToken(RegelSpraakParser.SECONDE, 0)

        def MINUUT(self):
            return self.getToken(RegelSpraakParser.MINUUT, 0)

        def MINUTEN(self):
            return self.getToken(RegelSpraakParser.MINUTEN, 0)

        def UUR(self):
            return self.getToken(RegelSpraakParser.UUR, 0)

        def UREN(self):
            return self.getToken(RegelSpraakParser.UREN, 0)

        def VOET(self):
            return self.getToken(RegelSpraakParser.VOET, 0)

        def POND(self):
            return self.getToken(RegelSpraakParser.POND, 0)

        def MIJL(self):
            return self.getToken(RegelSpraakParser.MIJL, 0)

        def M(self):
            return self.getToken(RegelSpraakParser.M, 0)

        def KG(self):
            return self.getToken(RegelSpraakParser.KG, 0)

        def S(self):
            return self.getToken(RegelSpraakParser.S, 0)

        def FT(self):
            return self.getToken(RegelSpraakParser.FT, 0)

        def LB(self):
            return self.getToken(RegelSpraakParser.LB, 0)

        def MIN(self):
            return self.getToken(RegelSpraakParser.MIN, 0)

        def MI(self):
            return self.getToken(RegelSpraakParser.MI, 0)

        def EURO_SYMBOL(self):
            return self.getToken(RegelSpraakParser.EURO_SYMBOL, 0)

        def DOLLAR_SYMBOL(self):
            return self.getToken(RegelSpraakParser.DOLLAR_SYMBOL, 0)

        def DEGREE_SYMBOL(self):
            return self.getToken(RegelSpraakParser.DEGREE_SYMBOL, 0)

        def DAG(self):
            return self.getToken(RegelSpraakParser.DAG, 0)

        def DAGEN(self):
            return self.getToken(RegelSpraakParser.DAGEN, 0)

        def MAAND(self):
            return self.getToken(RegelSpraakParser.MAAND, 0)

        def MAANDEN(self):
            return self.getToken(RegelSpraakParser.MAANDEN, 0)

        def JAAR(self):
            return self.getToken(RegelSpraakParser.JAAR, 0)

        def JAREN(self):
            return self.getToken(RegelSpraakParser.JAREN, 0)

        def WEEK(self):
            return self.getToken(RegelSpraakParser.WEEK, 0)

        def WEKEN(self):
            return self.getToken(RegelSpraakParser.WEKEN, 0)

        def KWARTAAL(self):
            return self.getToken(RegelSpraakParser.KWARTAAL, 0)

        def SECONDEN(self):
            return self.getToken(RegelSpraakParser.SECONDEN, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_unitIdentifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnitIdentifier" ):
                listener.enterUnitIdentifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnitIdentifier" ):
                listener.exitUnitIdentifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnitIdentifier" ):
                return visitor.visitUnitIdentifier(self)
            else:
                return visitor.visitChildren(self)




    def unitIdentifier(self):

        localctx = RegelSpraakParser.UnitIdentifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 84, self.RULE_unitIdentifier)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 807
            _la = self._input.LA(1)
            if not(_la==137 or ((((_la - 209)) & ~0x3f) == 0 and ((1 << (_la - 209)) & 576449784568606723) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EenheidExpressieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def eenheidMacht(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.EenheidMachtContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.EenheidMachtContext,i)


        def SLASH(self):
            return self.getToken(RegelSpraakParser.SLASH, 0)

        def NUMBER(self):
            return self.getToken(RegelSpraakParser.NUMBER, 0)

        def PERCENT_SIGN(self):
            return self.getToken(RegelSpraakParser.PERCENT_SIGN, 0)

        def EURO_SYMBOL(self):
            return self.getToken(RegelSpraakParser.EURO_SYMBOL, 0)

        def DOLLAR_SYMBOL(self):
            return self.getToken(RegelSpraakParser.DOLLAR_SYMBOL, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_eenheidExpressie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEenheidExpressie" ):
                listener.enterEenheidExpressie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEenheidExpressie" ):
                listener.exitEenheidExpressie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEenheidExpressie" ):
                return visitor.visitEenheidExpressie(self)
            else:
                return visitor.visitChildren(self)




    def eenheidExpressie(self):

        localctx = RegelSpraakParser.EenheidExpressieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 86, self.RULE_eenheidExpressie)
        self._la = 0 # Token type
        try:
            self.state = 818
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,83,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 809
                self.eenheidMacht()
                self.state = 812
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==282:
                    self.state = 810
                    self.match(RegelSpraakParser.SLASH)
                    self.state = 811
                    self.eenheidMacht()


                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 814
                self.match(RegelSpraakParser.NUMBER)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 815
                self.match(RegelSpraakParser.PERCENT_SIGN)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 816
                self.match(RegelSpraakParser.EURO_SYMBOL)
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 817
                self.match(RegelSpraakParser.DOLLAR_SYMBOL)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EenheidMachtContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def unitIdentifier(self):
            return self.getTypedRuleContext(RegelSpraakParser.UnitIdentifierContext,0)


        def CARET(self):
            return self.getToken(RegelSpraakParser.CARET, 0)

        def NUMBER(self):
            return self.getToken(RegelSpraakParser.NUMBER, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_eenheidMacht

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEenheidMacht" ):
                listener.enterEenheidMacht(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEenheidMacht" ):
                listener.exitEenheidMacht(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEenheidMacht" ):
                return visitor.visitEenheidMacht(self)
            else:
                return visitor.visitChildren(self)




    def eenheidMacht(self):

        localctx = RegelSpraakParser.EenheidMachtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 88, self.RULE_eenheidMacht)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 820
            self.unitIdentifier()
            self.state = 823
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==288:
                self.state = 821
                self.match(RegelSpraakParser.CARET)
                self.state = 822
                self.match(RegelSpraakParser.NUMBER)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DimensieDefinitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.dimensieNaamMeervoud = None # NaamwoordContext

        def DIMENSIE(self):
            return self.getToken(RegelSpraakParser.DIMENSIE, 0)

        def naamwoord(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.NaamwoordContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,i)


        def BESTAANDE_UIT(self):
            return self.getToken(RegelSpraakParser.BESTAANDE_UIT, 0)

        def voorzetselSpecificatie(self):
            return self.getTypedRuleContext(RegelSpraakParser.VoorzetselSpecificatieContext,0)


        def COMMA(self):
            return self.getToken(RegelSpraakParser.COMMA, 0)

        def labelWaardeSpecificatie(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.LabelWaardeSpecificatieContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.LabelWaardeSpecificatieContext,i)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_dimensieDefinition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDimensieDefinition" ):
                listener.enterDimensieDefinition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDimensieDefinition" ):
                listener.exitDimensieDefinition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDimensieDefinition" ):
                return visitor.visitDimensieDefinition(self)
            else:
                return visitor.visitChildren(self)




    def dimensieDefinition(self):

        localctx = RegelSpraakParser.DimensieDefinitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 90, self.RULE_dimensieDefinition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 825
            self.match(RegelSpraakParser.DIMENSIE)
            self.state = 826
            self.naamwoord()
            self.state = 828
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==278:
                self.state = 827
                self.match(RegelSpraakParser.COMMA)


            self.state = 830
            self.match(RegelSpraakParser.BESTAANDE_UIT)
            self.state = 831
            localctx.dimensieNaamMeervoud = self.naamwoord()
            self.state = 832
            self.voorzetselSpecificatie()
            self.state = 834 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 833
                self.labelWaardeSpecificatie()
                self.state = 836 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==268):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VoorzetselSpecificatieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.vz = None # VoorzetselContext

        def NA_HET_ATTRIBUUT_MET_VOORZETSEL(self):
            return self.getToken(RegelSpraakParser.NA_HET_ATTRIBUUT_MET_VOORZETSEL, 0)

        def RPAREN(self):
            return self.getToken(RegelSpraakParser.RPAREN, 0)

        def voorzetsel(self):
            return self.getTypedRuleContext(RegelSpraakParser.VoorzetselContext,0)


        def COLON(self):
            return self.getToken(RegelSpraakParser.COLON, 0)

        def VOOR_HET_ATTRIBUUT_ZONDER_VOORZETSEL(self):
            return self.getToken(RegelSpraakParser.VOOR_HET_ATTRIBUUT_ZONDER_VOORZETSEL, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_voorzetselSpecificatie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVoorzetselSpecificatie" ):
                listener.enterVoorzetselSpecificatie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVoorzetselSpecificatie" ):
                listener.exitVoorzetselSpecificatie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVoorzetselSpecificatie" ):
                return visitor.visitVoorzetselSpecificatie(self)
            else:
                return visitor.visitChildren(self)




    def voorzetselSpecificatie(self):

        localctx = RegelSpraakParser.VoorzetselSpecificatieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 92, self.RULE_voorzetselSpecificatie)
        self._la = 0 # Token type
        try:
            self.state = 845
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [2]:
                self.enterOuterAlt(localctx, 1)
                self.state = 838
                self.match(RegelSpraakParser.NA_HET_ATTRIBUUT_MET_VOORZETSEL)
                self.state = 839
                localctx.vz = self.voorzetsel()
                self.state = 840
                self.match(RegelSpraakParser.RPAREN)
                self.state = 842
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==280:
                    self.state = 841
                    self.match(RegelSpraakParser.COLON)


                pass
            elif token in [1]:
                self.enterOuterAlt(localctx, 2)
                self.state = 844
                self.match(RegelSpraakParser.VOOR_HET_ATTRIBUUT_ZONDER_VOORZETSEL)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LabelWaardeSpecificatieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.dimWaarde = None # NaamwoordContext

        def NUMBER(self):
            return self.getToken(RegelSpraakParser.NUMBER, 0)

        def DOT(self):
            return self.getToken(RegelSpraakParser.DOT, 0)

        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_labelWaardeSpecificatie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLabelWaardeSpecificatie" ):
                listener.enterLabelWaardeSpecificatie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLabelWaardeSpecificatie" ):
                listener.exitLabelWaardeSpecificatie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLabelWaardeSpecificatie" ):
                return visitor.visitLabelWaardeSpecificatie(self)
            else:
                return visitor.visitChildren(self)




    def labelWaardeSpecificatie(self):

        localctx = RegelSpraakParser.LabelWaardeSpecificatieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 94, self.RULE_labelWaardeSpecificatie)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 847
            self.match(RegelSpraakParser.NUMBER)
            self.state = 848
            self.match(RegelSpraakParser.DOT)
            self.state = 849
            localctx.dimWaarde = self.naamwoord()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TijdlijnContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def VOOR_ELKE_DAG(self):
            return self.getToken(RegelSpraakParser.VOOR_ELKE_DAG, 0)

        def VOOR_ELKE_MAAND(self):
            return self.getToken(RegelSpraakParser.VOOR_ELKE_MAAND, 0)

        def VOOR_ELK_JAAR(self):
            return self.getToken(RegelSpraakParser.VOOR_ELK_JAAR, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_tijdlijn

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTijdlijn" ):
                listener.enterTijdlijn(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTijdlijn" ):
                listener.exitTijdlijn(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTijdlijn" ):
                return visitor.visitTijdlijn(self)
            else:
                return visitor.visitChildren(self)




    def tijdlijn(self):

        localctx = RegelSpraakParser.TijdlijnContext(self, self._ctx, self.state)
        self.enterRule(localctx, 96, self.RULE_tijdlijn)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 851
            _la = self._input.LA(1)
            if not(((((_la - 187)) & ~0x3f) == 0 and ((1 << (_la - 187)) & 7) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DimensieRefContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.name = None # Token

        def IDENTIFIER(self):
            return self.getToken(RegelSpraakParser.IDENTIFIER, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_dimensieRef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDimensieRef" ):
                listener.enterDimensieRef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDimensieRef" ):
                listener.exitDimensieRef(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDimensieRef" ):
                return visitor.visitDimensieRef(self)
            else:
                return visitor.visitChildren(self)




    def dimensieRef(self):

        localctx = RegelSpraakParser.DimensieRefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 98, self.RULE_dimensieRef)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 853
            localctx.name = self.match(RegelSpraakParser.IDENTIFIER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParameterDefinitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PARAMETER(self):
            return self.getToken(RegelSpraakParser.PARAMETER, 0)

        def parameterNamePhrase(self):
            return self.getTypedRuleContext(RegelSpraakParser.ParameterNamePhraseContext,0)


        def COLON(self):
            return self.getToken(RegelSpraakParser.COLON, 0)

        def datatype(self):
            return self.getTypedRuleContext(RegelSpraakParser.DatatypeContext,0)


        def domeinRef(self):
            return self.getTypedRuleContext(RegelSpraakParser.DomeinRefContext,0)


        def MET_EENHEID(self):
            return self.getToken(RegelSpraakParser.MET_EENHEID, 0)

        def eenheidExpressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.EenheidExpressieContext,0)


        def IS(self):
            return self.getToken(RegelSpraakParser.IS, 0)

        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)


        def tijdlijn(self):
            return self.getTypedRuleContext(RegelSpraakParser.TijdlijnContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_parameterDefinition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParameterDefinition" ):
                listener.enterParameterDefinition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParameterDefinition" ):
                listener.exitParameterDefinition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParameterDefinition" ):
                return visitor.visitParameterDefinition(self)
            else:
                return visitor.visitChildren(self)




    def parameterDefinition(self):

        localctx = RegelSpraakParser.ParameterDefinitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 100, self.RULE_parameterDefinition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 855
            self.match(RegelSpraakParser.PARAMETER)
            self.state = 856
            self.parameterNamePhrase()
            self.state = 857
            self.match(RegelSpraakParser.COLON)
            self.state = 860
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [3, 101, 166, 168, 181, 182, 186]:
                self.state = 858
                self.datatype()
                pass
            elif token in [267]:
                self.state = 859
                self.domeinRef()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 864
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==177:
                self.state = 862
                self.match(RegelSpraakParser.MET_EENHEID)
                self.state = 863
                self.eenheidExpressie()


            self.state = 868
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==113:
                self.state = 866
                self.match(RegelSpraakParser.IS)
                self.state = 867
                self.expressie()


            self.state = 871
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 187)) & ~0x3f) == 0 and ((1 << (_la - 187)) & 7) != 0):
                self.state = 870
                self.tijdlijn()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParameterNamePhraseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def parameterNamePart(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.ParameterNamePartContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.ParameterNamePartContext,i)


        def voorzetsel(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.VoorzetselContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.VoorzetselContext,i)


        def DE(self):
            return self.getToken(RegelSpraakParser.DE, 0)

        def HET(self):
            return self.getToken(RegelSpraakParser.HET, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_parameterNamePhrase

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParameterNamePhrase" ):
                listener.enterParameterNamePhrase(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParameterNamePhrase" ):
                listener.exitParameterNamePhrase(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParameterNamePhrase" ):
                return visitor.visitParameterNamePhrase(self)
            else:
                return visitor.visitChildren(self)




    def parameterNamePhrase(self):

        localctx = RegelSpraakParser.ParameterNamePhraseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 102, self.RULE_parameterNamePhrase)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 874
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==212 or _la==217:
                self.state = 873
                _la = self._input.LA(1)
                if not(_la==212 or _la==217):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


            self.state = 876
            self.parameterNamePart()
            self.state = 882
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((((_la - 146)) & ~0x3f) == 0 and ((1 << (_la - 146)) & 4611686019501129733) != 0) or ((((_la - 216)) & ~0x3f) == 0 and ((1 << (_la - 216)) & 4597129233) != 0):
                self.state = 877
                self.voorzetsel()
                self.state = 878
                self.parameterNamePart()
                self.state = 884
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParameterNamePartContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.IDENTIFIER)
            else:
                return self.getToken(RegelSpraakParser.IDENTIFIER, i)

        def AANTAL(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.AANTAL)
            else:
                return self.getToken(RegelSpraakParser.AANTAL, i)

        def NUMBER(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.NUMBER)
            else:
                return self.getToken(RegelSpraakParser.NUMBER, i)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_parameterNamePart

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParameterNamePart" ):
                listener.enterParameterNamePart(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParameterNamePart" ):
                listener.exitParameterNamePart(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParameterNamePart" ):
                return visitor.visitParameterNamePart(self)
            else:
                return visitor.visitChildren(self)




    def parameterNamePart(self):

        localctx = RegelSpraakParser.ParameterNamePartContext(self, self._ctx, self.state)
        self.enterRule(localctx, 104, self.RULE_parameterNamePart)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 885
            _la = self._input.LA(1)
            if not(_la==190 or _la==267):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 889
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,95,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 886
                    _la = self._input.LA(1)
                    if not(_la==190 or _la==267 or _la==268):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume() 
                self.state = 891
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,95,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParameterMetLidwoordContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def parameterNamePart(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.ParameterNamePartContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.ParameterNamePartContext,i)


        def voorzetsel(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.VoorzetselContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.VoorzetselContext,i)


        def DE(self):
            return self.getToken(RegelSpraakParser.DE, 0)

        def HET(self):
            return self.getToken(RegelSpraakParser.HET, 0)

        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_parameterMetLidwoord

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParameterMetLidwoord" ):
                listener.enterParameterMetLidwoord(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParameterMetLidwoord" ):
                listener.exitParameterMetLidwoord(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParameterMetLidwoord" ):
                return visitor.visitParameterMetLidwoord(self)
            else:
                return visitor.visitChildren(self)




    def parameterMetLidwoord(self):

        localctx = RegelSpraakParser.ParameterMetLidwoordContext(self, self._ctx, self.state)
        self.enterRule(localctx, 106, self.RULE_parameterMetLidwoord)
        self._la = 0 # Token type
        try:
            self.state = 905
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,98,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 893
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==212 or _la==217:
                    self.state = 892
                    _la = self._input.LA(1)
                    if not(_la==212 or _la==217):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                self.state = 895
                self.parameterNamePart()
                self.state = 901
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,97,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 896
                        self.voorzetsel()
                        self.state = 897
                        self.parameterNamePart() 
                    self.state = 903
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,97,self._ctx)

                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 904
                self.naamwoord()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FeitTypeDefinitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.feittypenaam = None # NaamwoordContext

        def FEITTYPE(self):
            return self.getToken(RegelSpraakParser.FEITTYPE, 0)

        def rolDefinition(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.RolDefinitionContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.RolDefinitionContext,i)


        def cardinalityLine(self):
            return self.getTypedRuleContext(RegelSpraakParser.CardinalityLineContext,0)


        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def WEDERKERIG_FEITTYPE(self):
            return self.getToken(RegelSpraakParser.WEDERKERIG_FEITTYPE, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_feitTypeDefinition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFeitTypeDefinition" ):
                listener.enterFeitTypeDefinition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFeitTypeDefinition" ):
                listener.exitFeitTypeDefinition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFeitTypeDefinition" ):
                return visitor.visitFeitTypeDefinition(self)
            else:
                return visitor.visitChildren(self)




    def feitTypeDefinition(self):

        localctx = RegelSpraakParser.FeitTypeDefinitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 108, self.RULE_feitTypeDefinition)
        try:
            self.state = 922
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [105]:
                self.enterOuterAlt(localctx, 1)
                self.state = 907
                self.match(RegelSpraakParser.FEITTYPE)
                self.state = 908
                localctx.feittypenaam = self.naamwoord()
                self.state = 909
                self.rolDefinition()
                self.state = 911 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 910
                        self.rolDefinition()

                    else:
                        raise NoViableAltException(self)
                    self.state = 913 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,99,self._ctx)

                self.state = 915
                self.cardinalityLine()
                pass
            elif token in [28]:
                self.enterOuterAlt(localctx, 2)
                self.state = 917
                self.match(RegelSpraakParser.WEDERKERIG_FEITTYPE)
                self.state = 918
                localctx.feittypenaam = self.naamwoord()
                self.state = 919
                self.rolDefinition()
                self.state = 920
                self.cardinalityLine()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RolDefinitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.article = None # Token
            self.content = None # RolContentWordsContext
            self.meervoud = None # NaamwoordContext
            self.objecttype = None # RolObjectTypeContext

        def rolContentWords(self):
            return self.getTypedRuleContext(RegelSpraakParser.RolContentWordsContext,0)


        def DE(self):
            return self.getToken(RegelSpraakParser.DE, 0)

        def HET(self):
            return self.getToken(RegelSpraakParser.HET, 0)

        def MV_START(self):
            return self.getToken(RegelSpraakParser.MV_START, 0)

        def RPAREN(self):
            return self.getToken(RegelSpraakParser.RPAREN, 0)

        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def rolObjectType(self):
            return self.getTypedRuleContext(RegelSpraakParser.RolObjectTypeContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_rolDefinition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRolDefinition" ):
                listener.enterRolDefinition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRolDefinition" ):
                listener.exitRolDefinition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRolDefinition" ):
                return visitor.visitRolDefinition(self)
            else:
                return visitor.visitChildren(self)




    def rolDefinition(self):

        localctx = RegelSpraakParser.RolDefinitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 110, self.RULE_rolDefinition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 924
            localctx.article = self._input.LT(1)
            _la = self._input.LA(1)
            if not(_la==212 or _la==217):
                localctx.article = self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 925
            localctx.content = self.rolContentWords()
            self.state = 930
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,101,self._ctx)
            if la_ == 1:
                self.state = 926
                self.match(RegelSpraakParser.MV_START)
                self.state = 927
                localctx.meervoud = self.naamwoord()
                self.state = 928
                self.match(RegelSpraakParser.RPAREN)


            self.state = 933
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,102,self._ctx)
            if la_ == 1:
                self.state = 932
                localctx.objecttype = self.rolObjectType()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RolObjectTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifierOrKeyword(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.IdentifierOrKeywordContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.IdentifierOrKeywordContext,i)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_rolObjectType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRolObjectType" ):
                listener.enterRolObjectType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRolObjectType" ):
                listener.exitRolObjectType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRolObjectType" ):
                return visitor.visitRolObjectType(self)
            else:
                return visitor.visitChildren(self)




    def rolObjectType(self):

        localctx = RegelSpraakParser.RolObjectTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 112, self.RULE_rolObjectType)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 936 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 935
                    self.identifierOrKeyword()

                else:
                    raise NoViableAltException(self)
                self.state = 938 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,103,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RolContentWordsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifierOrKeyword(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.IdentifierOrKeywordContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.IdentifierOrKeywordContext,i)


        def voorzetsel(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.VoorzetselContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.VoorzetselContext,i)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_rolContentWords

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRolContentWords" ):
                listener.enterRolContentWords(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRolContentWords" ):
                listener.exitRolContentWords(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRolContentWords" ):
                return visitor.visitRolContentWords(self)
            else:
                return visitor.visitChildren(self)




    def rolContentWords(self):

        localctx = RegelSpraakParser.RolContentWordsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 114, self.RULE_rolContentWords)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 942 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 942
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [96, 110, 113, 124, 132, 161, 190, 201, 202, 205, 206, 209, 210, 221, 223, 224, 232, 234, 253, 267]:
                        self.state = 940
                        self.identifierOrKeyword()
                        pass
                    elif token in [146, 148, 176, 208, 216, 220, 229, 231, 233, 241, 244, 248]:
                        self.state = 941
                        self.voorzetsel()
                        pass
                    else:
                        raise NoViableAltException(self)


                else:
                    raise NoViableAltException(self)
                self.state = 944 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,105,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CardinalityLineContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def cardinalityWord(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.CardinalityWordContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.CardinalityWordContext,i)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_cardinalityLine

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCardinalityLine" ):
                listener.enterCardinalityLine(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCardinalityLine" ):
                listener.exitCardinalityLine(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCardinalityLine" ):
                return visitor.visitCardinalityLine(self)
            else:
                return visitor.visitChildren(self)




    def cardinalityLine(self):

        localctx = RegelSpraakParser.CardinalityLineContext(self, self._ctx, self.state)
        self.enterRule(localctx, 116, self.RULE_cardinalityLine)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 947 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 946
                    self.cardinalityWord()

                else:
                    raise NoViableAltException(self)
                self.state = 949 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,106,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CardinalityWordContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OBJECTTYPE(self):
            return self.getToken(RegelSpraakParser.OBJECTTYPE, 0)

        def PARAMETER(self):
            return self.getToken(RegelSpraakParser.PARAMETER, 0)

        def REGEL(self):
            return self.getToken(RegelSpraakParser.REGEL, 0)

        def FEITTYPE(self):
            return self.getToken(RegelSpraakParser.FEITTYPE, 0)

        def WEDERKERIG_FEITTYPE(self):
            return self.getToken(RegelSpraakParser.WEDERKERIG_FEITTYPE, 0)

        def DIMENSIE(self):
            return self.getToken(RegelSpraakParser.DIMENSIE, 0)

        def DOMEIN(self):
            return self.getToken(RegelSpraakParser.DOMEIN, 0)

        def BESLISTABEL(self):
            return self.getToken(RegelSpraakParser.BESLISTABEL, 0)

        def CONSISTENTIEREGEL(self):
            return self.getToken(RegelSpraakParser.CONSISTENTIEREGEL, 0)

        def EENHEIDSYSTEEM(self):
            return self.getToken(RegelSpraakParser.EENHEIDSYSTEEM, 0)

        def DAGSOORT(self):
            return self.getToken(RegelSpraakParser.DAGSOORT, 0)

        def SEMICOLON(self):
            return self.getToken(RegelSpraakParser.SEMICOLON, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_cardinalityWord

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCardinalityWord" ):
                listener.enterCardinalityWord(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCardinalityWord" ):
                listener.exitCardinalityWord(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCardinalityWord" ):
                return visitor.visitCardinalityWord(self)
            else:
                return visitor.visitChildren(self)




    def cardinalityWord(self):

        localctx = RegelSpraakParser.CardinalityWordContext(self, self._ctx, self.state)
        self.enterRule(localctx, 118, self.RULE_cardinalityWord)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 951
            _la = self._input.LA(1)
            if _la <= 0 or _la==28 or ((((_la - 95)) & ~0x3f) == 0 and ((1 << (_la - 95)) & 4027) != 0) or _la==281:
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RegelContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def REGEL(self):
            return self.getToken(RegelSpraakParser.REGEL, 0)

        def regelName(self):
            return self.getTypedRuleContext(RegelSpraakParser.RegelNameContext,0)


        def regelVersie(self):
            return self.getTypedRuleContext(RegelSpraakParser.RegelVersieContext,0)


        def resultaatDeel(self):
            return self.getTypedRuleContext(RegelSpraakParser.ResultaatDeelContext,0)


        def NUMBER(self):
            return self.getToken(RegelSpraakParser.NUMBER, 0)

        def voorwaardeDeel(self):
            return self.getTypedRuleContext(RegelSpraakParser.VoorwaardeDeelContext,0)


        def DOT(self):
            return self.getToken(RegelSpraakParser.DOT, 0)

        def variabeleDeel(self):
            return self.getTypedRuleContext(RegelSpraakParser.VariabeleDeelContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_regel

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRegel" ):
                listener.enterRegel(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRegel" ):
                listener.exitRegel(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRegel" ):
                return visitor.visitRegel(self)
            else:
                return visitor.visitChildren(self)




    def regel(self):

        localctx = RegelSpraakParser.RegelContext(self, self._ctx, self.state)
        self.enterRule(localctx, 120, self.RULE_regel)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 953
            self.match(RegelSpraakParser.REGEL)
            self.state = 954
            self.regelName()
            self.state = 956
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==268:
                self.state = 955
                self.match(RegelSpraakParser.NUMBER)


            self.state = 958
            self.regelVersie()
            self.state = 959
            self.resultaatDeel()
            self.state = 965
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [111]:
                self.state = 960
                self.voorwaardeDeel()
                self.state = 962
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==279:
                    self.state = 961
                    self.match(RegelSpraakParser.DOT)


                pass
            elif token in [279]:
                self.state = 964
                self.match(RegelSpraakParser.DOT)
                pass
            elif token in [-1, 28, 95, 96, 97, 98, 99, 100, 102, 103, 104, 105, 106, 107]:
                pass
            else:
                pass
            self.state = 968
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==107:
                self.state = 967
                self.variabeleDeel()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RegelGroepContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.isRecursive = None # Token

        def REGELGROEP(self):
            return self.getToken(RegelSpraakParser.REGELGROEP, 0)

        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def regel(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.RegelContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.RegelContext,i)


        def consistentieregel(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.ConsistentieregelContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.ConsistentieregelContext,i)


        def IS_RECURSIEF(self):
            return self.getToken(RegelSpraakParser.IS_RECURSIEF, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_regelGroep

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRegelGroep" ):
                listener.enterRegelGroep(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRegelGroep" ):
                listener.exitRegelGroep(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRegelGroep" ):
                return visitor.visitRegelGroep(self)
            else:
                return visitor.visitChildren(self)




    def regelGroep(self):

        localctx = RegelSpraakParser.RegelGroepContext(self, self._ctx, self.state)
        self.enterRule(localctx, 122, self.RULE_regelGroep)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 970
            self.match(RegelSpraakParser.REGELGROEP)
            self.state = 971
            self.naamwoord()
            self.state = 973
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==112:
                self.state = 972
                localctx.isRecursive = self.match(RegelSpraakParser.IS_RECURSIEF)


            self.state = 977 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 977
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [96]:
                        self.state = 975
                        self.regel()
                        pass
                    elif token in [95]:
                        self.state = 976
                        self.consistentieregel()
                        pass
                    else:
                        raise NoViableAltException(self)


                else:
                    raise NoViableAltException(self)
                self.state = 979 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,113,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RegelNameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def naamwoordWithNumbers(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordWithNumbersContext,0)


        def regelNameExtension(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.RegelNameExtensionContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.RegelNameExtensionContext,i)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_regelName

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRegelName" ):
                listener.enterRegelName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRegelName" ):
                listener.exitRegelName(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRegelName" ):
                return visitor.visitRegelName(self)
            else:
                return visitor.visitChildren(self)




    def regelName(self):

        localctx = RegelSpraakParser.RegelNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 124, self.RULE_regelName)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 981
            self.naamwoordWithNumbers()
            self.state = 985
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==113 or ((((_la - 198)) & ~0x3f) == 0 and ((1 << (_la - 198)) & 262209) != 0) or _la==278:
                self.state = 982
                self.regelNameExtension()
                self.state = 987
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RegelNameExtensionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IN_GELIJKE_DELEN(self):
            return self.getToken(RegelSpraakParser.IN_GELIJKE_DELEN, 0)

        def COMMA(self):
            return self.getToken(RegelSpraakParser.COMMA, 0)

        def naamwoordWithNumbers(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordWithNumbersContext,0)


        def MET(self):
            return self.getToken(RegelSpraakParser.MET, 0)

        def EN(self):
            return self.getToken(RegelSpraakParser.EN, 0)

        def IS(self):
            return self.getToken(RegelSpraakParser.IS, 0)

        def GEEN(self):
            return self.getToken(RegelSpraakParser.GEEN, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_regelNameExtension

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRegelNameExtension" ):
                listener.enterRegelNameExtension(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRegelNameExtension" ):
                listener.exitRegelNameExtension(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRegelNameExtension" ):
                return visitor.visitRegelNameExtension(self)
            else:
                return visitor.visitChildren(self)




    def regelNameExtension(self):

        localctx = RegelSpraakParser.RegelNameExtensionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 126, self.RULE_regelNameExtension)
        try:
            self.state = 1002
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,115,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 988
                self.match(RegelSpraakParser.IN_GELIJKE_DELEN)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 989
                self.match(RegelSpraakParser.COMMA)
                self.state = 990
                self.naamwoordWithNumbers()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 991
                self.match(RegelSpraakParser.COMMA)
                self.state = 992
                self.match(RegelSpraakParser.MET)
                self.state = 993
                self.naamwoordWithNumbers()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 994
                self.match(RegelSpraakParser.EN)
                self.state = 995
                self.naamwoordWithNumbers()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 996
                self.match(RegelSpraakParser.IS)
                self.state = 997
                self.naamwoordWithNumbers()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 998
                self.match(RegelSpraakParser.GEEN)
                self.state = 999
                self.naamwoordWithNumbers()
                self.state = 1000
                self.match(RegelSpraakParser.IS)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RegelVersieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GELDIG(self):
            return self.getToken(RegelSpraakParser.GELDIG, 0)

        def versieGeldigheid(self):
            return self.getTypedRuleContext(RegelSpraakParser.VersieGeldigheidContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_regelVersie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRegelVersie" ):
                listener.enterRegelVersie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRegelVersie" ):
                listener.exitRegelVersie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRegelVersie" ):
                return visitor.visitRegelVersie(self)
            else:
                return visitor.visitChildren(self)




    def regelVersie(self):

        localctx = RegelSpraakParser.RegelVersieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 128, self.RULE_regelVersie)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1004
            self.match(RegelSpraakParser.GELDIG)
            self.state = 1005
            self.versieGeldigheid()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VersieGeldigheidContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ALTIJD(self):
            return self.getToken(RegelSpraakParser.ALTIJD, 0)

        def VANAF(self):
            return self.getToken(RegelSpraakParser.VANAF, 0)

        def datumLiteral(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.DatumLiteralContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.DatumLiteralContext,i)


        def TM(self):
            return self.getToken(RegelSpraakParser.TM, 0)

        def TOT_EN_MET(self):
            return self.getToken(RegelSpraakParser.TOT_EN_MET, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_versieGeldigheid

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVersieGeldigheid" ):
                listener.enterVersieGeldigheid(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVersieGeldigheid" ):
                listener.exitVersieGeldigheid(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVersieGeldigheid" ):
                return visitor.visitVersieGeldigheid(self)
            else:
                return visitor.visitChildren(self)




    def versieGeldigheid(self):

        localctx = RegelSpraakParser.VersieGeldigheidContext(self, self._ctx, self.state)
        self.enterRule(localctx, 130, self.RULE_versieGeldigheid)
        self._la = 0 # Token type
        try:
            self.state = 1014
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [207]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1007
                self.match(RegelSpraakParser.ALTIJD)
                pass
            elif token in [150]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1008
                self.match(RegelSpraakParser.VANAF)
                self.state = 1009
                self.datumLiteral()
                self.state = 1012
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==148 or _la==240:
                    self.state = 1010
                    _la = self._input.LA(1)
                    if not(_la==148 or _la==240):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()
                    self.state = 1011
                    self.datumLiteral()


                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ResultaatDeelContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_resultaatDeel

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class GelijkstellingResultaatContext(ResultaatDeelContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.ResultaatDeelContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def attribuutReferentie(self):
            return self.getTypedRuleContext(RegelSpraakParser.AttribuutReferentieContext,0)

        def WORDT_BEREKEND_ALS(self):
            return self.getToken(RegelSpraakParser.WORDT_BEREKEND_ALS, 0)
        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)

        def WORDT_GESTELD_OP(self):
            return self.getToken(RegelSpraakParser.WORDT_GESTELD_OP, 0)
        def WORDT_GEINITIALISEERD_OP(self):
            return self.getToken(RegelSpraakParser.WORDT_GEINITIALISEERD_OP, 0)
        def periodeDefinitie(self):
            return self.getTypedRuleContext(RegelSpraakParser.PeriodeDefinitieContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGelijkstellingResultaat" ):
                listener.enterGelijkstellingResultaat(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGelijkstellingResultaat" ):
                listener.exitGelijkstellingResultaat(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGelijkstellingResultaat" ):
                return visitor.visitGelijkstellingResultaat(self)
            else:
                return visitor.visitChildren(self)


    class RelationshipWithAttributeResultaatContext(ResultaatDeelContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.ResultaatDeelContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def onderwerpReferentie(self):
            return self.getTypedRuleContext(RegelSpraakParser.OnderwerpReferentieContext,0)

        def HEEFT(self):
            return self.getToken(RegelSpraakParser.HEEFT, 0)
        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)

        def MET(self):
            return self.getToken(RegelSpraakParser.MET, 0)
        def attribuutMetLidwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.AttribuutMetLidwoordContext,0)

        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)

        def DE(self):
            return self.getToken(RegelSpraakParser.DE, 0)
        def HET(self):
            return self.getToken(RegelSpraakParser.HET, 0)
        def GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.GELIJK_AAN, 0)
        def IS_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.IS_GELIJK_AAN, 0)
        def GELIJK_IS_AAN(self):
            return self.getToken(RegelSpraakParser.GELIJK_IS_AAN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRelationshipWithAttributeResultaat" ):
                listener.enterRelationshipWithAttributeResultaat(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRelationshipWithAttributeResultaat" ):
                listener.exitRelationshipWithAttributeResultaat(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRelationshipWithAttributeResultaat" ):
                return visitor.visitRelationshipWithAttributeResultaat(self)
            else:
                return visitor.visitChildren(self)


    class ConsistencyCheckResultaatContext(ResultaatDeelContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.ResultaatDeelContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def attribuutReferentie(self):
            return self.getTypedRuleContext(RegelSpraakParser.AttribuutReferentieContext,0)

        def MOET(self):
            return self.getToken(RegelSpraakParser.MOET, 0)
        def consistencyOperator(self):
            return self.getTypedRuleContext(RegelSpraakParser.ConsistencyOperatorContext,0)

        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConsistencyCheckResultaat" ):
                listener.enterConsistencyCheckResultaat(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConsistencyCheckResultaat" ):
                listener.exitConsistencyCheckResultaat(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConsistencyCheckResultaat" ):
                return visitor.visitConsistencyCheckResultaat(self)
            else:
                return visitor.visitChildren(self)


    class VerdelingContext(ResultaatDeelContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.ResultaatDeelContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def verdelingResultaat(self):
            return self.getTypedRuleContext(RegelSpraakParser.VerdelingResultaatContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVerdeling" ):
                listener.enterVerdeling(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVerdeling" ):
                listener.exitVerdeling(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVerdeling" ):
                return visitor.visitVerdeling(self)
            else:
                return visitor.visitChildren(self)


    class ObjectCreatieResultaatContext(ResultaatDeelContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.ResultaatDeelContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def objectCreatie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ObjectCreatieContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterObjectCreatieResultaat" ):
                listener.enterObjectCreatieResultaat(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitObjectCreatieResultaat" ):
                listener.exitObjectCreatieResultaat(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitObjectCreatieResultaat" ):
                return visitor.visitObjectCreatieResultaat(self)
            else:
                return visitor.visitChildren(self)


    class DagsoortdefinitieResultaatContext(ResultaatDeelContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.ResultaatDeelContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def EEN(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.EEN)
            else:
                return self.getToken(RegelSpraakParser.EEN, i)
        def DAG(self):
            return self.getToken(RegelSpraakParser.DAG, 0)
        def IS(self):
            return self.getToken(RegelSpraakParser.IS, 0)
        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDagsoortdefinitieResultaat" ):
                listener.enterDagsoortdefinitieResultaat(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDagsoortdefinitieResultaat" ):
                listener.exitDagsoortdefinitieResultaat(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDagsoortdefinitieResultaat" ):
                return visitor.visitDagsoortdefinitieResultaat(self)
            else:
                return visitor.visitChildren(self)


    class KenmerkFeitResultaatContext(ResultaatDeelContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.ResultaatDeelContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def onderwerpReferentie(self):
            return self.getTypedRuleContext(RegelSpraakParser.OnderwerpReferentieContext,0)

        def kenmerkNaam(self):
            return self.getTypedRuleContext(RegelSpraakParser.KenmerkNaamContext,0)

        def IS(self):
            return self.getToken(RegelSpraakParser.IS, 0)
        def HEEFT(self):
            return self.getToken(RegelSpraakParser.HEEFT, 0)
        def periodeDefinitie(self):
            return self.getTypedRuleContext(RegelSpraakParser.PeriodeDefinitieContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterKenmerkFeitResultaat" ):
                listener.enterKenmerkFeitResultaat(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitKenmerkFeitResultaat" ):
                listener.exitKenmerkFeitResultaat(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitKenmerkFeitResultaat" ):
                return visitor.visitKenmerkFeitResultaat(self)
            else:
                return visitor.visitChildren(self)


    class FeitCreatieResultaatContext(ResultaatDeelContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.ResultaatDeelContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def feitCreatiePattern(self):
            return self.getTypedRuleContext(RegelSpraakParser.FeitCreatiePatternContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFeitCreatieResultaat" ):
                listener.enterFeitCreatieResultaat(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFeitCreatieResultaat" ):
                listener.exitFeitCreatieResultaat(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFeitCreatieResultaat" ):
                return visitor.visitFeitCreatieResultaat(self)
            else:
                return visitor.visitChildren(self)



    def resultaatDeel(self):

        localctx = RegelSpraakParser.ResultaatDeelContext(self, self._ctx, self.state)
        self.enterRule(localctx, 132, self.RULE_resultaatDeel)
        self._la = 0 # Token type
        try:
            self.state = 1056
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,121,self._ctx)
            if la_ == 1:
                localctx = RegelSpraakParser.DagsoortdefinitieResultaatContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1016
                self.match(RegelSpraakParser.EEN)
                self.state = 1017
                self.match(RegelSpraakParser.DAG)
                self.state = 1018
                self.match(RegelSpraakParser.IS)
                self.state = 1019
                self.match(RegelSpraakParser.EEN)
                self.state = 1020
                self.naamwoord()
                pass

            elif la_ == 2:
                localctx = RegelSpraakParser.GelijkstellingResultaatContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1021
                self.attribuutReferentie()
                self.state = 1028
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [8]:
                    self.state = 1022
                    self.match(RegelSpraakParser.WORDT_BEREKEND_ALS)
                    self.state = 1023
                    self.expressie()
                    pass
                elif token in [9]:
                    self.state = 1024
                    self.match(RegelSpraakParser.WORDT_GESTELD_OP)
                    self.state = 1025
                    self.expressie()
                    pass
                elif token in [10]:
                    self.state = 1026
                    self.match(RegelSpraakParser.WORDT_GEINITIALISEERD_OP)
                    self.state = 1027
                    self.expressie()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 1031
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if ((((_la - 146)) & ~0x3f) == 0 and ((1 << (_la - 146)) & 21) != 0) or _la==244:
                    self.state = 1030
                    self.periodeDefinitie()


                pass

            elif la_ == 3:
                localctx = RegelSpraakParser.ConsistencyCheckResultaatContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 1033
                self.attribuutReferentie()
                self.state = 1034
                self.match(RegelSpraakParser.MOET)
                self.state = 1035
                self.consistencyOperator()
                self.state = 1036
                self.expressie()
                pass

            elif la_ == 4:
                localctx = RegelSpraakParser.FeitCreatieResultaatContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 1038
                self.feitCreatiePattern()
                pass

            elif la_ == 5:
                localctx = RegelSpraakParser.KenmerkFeitResultaatContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 1039
                self.onderwerpReferentie()
                self.state = 1040
                _la = self._input.LA(1)
                if not(_la==110 or _la==113):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1041
                self.kenmerkNaam()
                self.state = 1043
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if ((((_la - 146)) & ~0x3f) == 0 and ((1 << (_la - 146)) & 21) != 0) or _la==244:
                    self.state = 1042
                    self.periodeDefinitie()


                pass

            elif la_ == 6:
                localctx = RegelSpraakParser.RelationshipWithAttributeResultaatContext(self, localctx)
                self.enterOuterAlt(localctx, 6)
                self.state = 1045
                self.onderwerpReferentie()
                self.state = 1046
                self.match(RegelSpraakParser.HEEFT)
                self.state = 1047
                _la = self._input.LA(1)
                if not(_la==212 or _la==217):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1048
                self.naamwoord()
                self.state = 1049
                self.match(RegelSpraakParser.MET)
                self.state = 1050
                self.attribuutMetLidwoord()
                self.state = 1051
                _la = self._input.LA(1)
                if not(_la==47 or _la==48 or _la==128):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1052
                self.expressie()
                pass

            elif la_ == 7:
                localctx = RegelSpraakParser.ObjectCreatieResultaatContext(self, localctx)
                self.enterOuterAlt(localctx, 7)
                self.state = 1054
                self.objectCreatie()
                pass

            elif la_ == 8:
                localctx = RegelSpraakParser.VerdelingContext(self, localctx)
                self.enterOuterAlt(localctx, 8)
                self.state = 1055
                self.verdelingResultaat()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConsistencyOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ONGELIJK_ZIJN_AAN(self):
            return self.getToken(RegelSpraakParser.ONGELIJK_ZIJN_AAN, 0)

        def ONGELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.ONGELIJK_AAN, 0)

        def IS_ONGELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.IS_ONGELIJK_AAN, 0)

        def GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.GELIJK_AAN, 0)

        def IS_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.IS_GELIJK_AAN, 0)

        def GROTER_DAN(self):
            return self.getToken(RegelSpraakParser.GROTER_DAN, 0)

        def IS_GROTER_DAN(self):
            return self.getToken(RegelSpraakParser.IS_GROTER_DAN, 0)

        def KLEINER_DAN(self):
            return self.getToken(RegelSpraakParser.KLEINER_DAN, 0)

        def IS_KLEINER_DAN(self):
            return self.getToken(RegelSpraakParser.IS_KLEINER_DAN, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_consistencyOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConsistencyOperator" ):
                listener.enterConsistencyOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConsistencyOperator" ):
                listener.exitConsistencyOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConsistencyOperator" ):
                return visitor.visitConsistencyOperator(self)
            else:
                return visitor.visitChildren(self)




    def consistencyOperator(self):

        localctx = RegelSpraakParser.ConsistencyOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 134, self.RULE_consistencyOperator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1058
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 6473924464345088) != 0) or ((((_la - 128)) & ~0x3f) == 0 and ((1 << (_la - 128)) & 24617) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FeitCreatiePatternContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.role1 = None # FeitCreatieRolPhraseContext
            self.subject1 = None # FeitCreatieSubjectPhraseContext
            self.article2 = None # Token
            self.role2 = None # FeitCreatieRolPhraseContext
            self.article3 = None # Token
            self.subject2 = None # FeitCreatieSubjectPhraseContext

        def EEN(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.EEN)
            else:
                return self.getToken(RegelSpraakParser.EEN, i)

        def VAN(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.VAN)
            else:
                return self.getToken(RegelSpraakParser.VAN, i)

        def IS(self):
            return self.getToken(RegelSpraakParser.IS, 0)

        def feitCreatieRolPhrase(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.FeitCreatieRolPhraseContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.FeitCreatieRolPhraseContext,i)


        def feitCreatieSubjectPhrase(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.FeitCreatieSubjectPhraseContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.FeitCreatieSubjectPhraseContext,i)


        def DE(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.DE)
            else:
                return self.getToken(RegelSpraakParser.DE, i)

        def HET(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.HET)
            else:
                return self.getToken(RegelSpraakParser.HET, i)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_feitCreatiePattern

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFeitCreatiePattern" ):
                listener.enterFeitCreatiePattern(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFeitCreatiePattern" ):
                listener.exitFeitCreatiePattern(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFeitCreatiePattern" ):
                return visitor.visitFeitCreatiePattern(self)
            else:
                return visitor.visitChildren(self)




    def feitCreatiePattern(self):

        localctx = RegelSpraakParser.FeitCreatiePatternContext(self, self._ctx, self.state)
        self.enterRule(localctx, 136, self.RULE_feitCreatiePattern)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1060
            self.match(RegelSpraakParser.EEN)
            self.state = 1061
            localctx.role1 = self.feitCreatieRolPhrase()
            self.state = 1062
            self.match(RegelSpraakParser.VAN)
            self.state = 1063
            self.match(RegelSpraakParser.EEN)
            self.state = 1064
            localctx.subject1 = self.feitCreatieSubjectPhrase()
            self.state = 1065
            self.match(RegelSpraakParser.IS)
            self.state = 1066
            localctx.article2 = self._input.LT(1)
            _la = self._input.LA(1)
            if not(((((_la - 212)) & ~0x3f) == 0 and ((1 << (_la - 212)) & 41) != 0)):
                localctx.article2 = self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 1067
            localctx.role2 = self.feitCreatieRolPhrase()
            self.state = 1068
            self.match(RegelSpraakParser.VAN)
            self.state = 1069
            localctx.article3 = self._input.LT(1)
            _la = self._input.LA(1)
            if not(((((_la - 212)) & ~0x3f) == 0 and ((1 << (_la - 212)) & 41) != 0)):
                localctx.article3 = self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 1070
            localctx.subject2 = self.feitCreatieSubjectPhrase()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FeitCreatieRolPhraseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def feitCreatieWord(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.FeitCreatieWordContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.FeitCreatieWordContext,i)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_feitCreatieRolPhrase

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFeitCreatieRolPhrase" ):
                listener.enterFeitCreatieRolPhrase(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFeitCreatieRolPhrase" ):
                listener.exitFeitCreatieRolPhrase(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFeitCreatieRolPhrase" ):
                return visitor.visitFeitCreatieRolPhrase(self)
            else:
                return visitor.visitChildren(self)




    def feitCreatieRolPhrase(self):

        localctx = RegelSpraakParser.FeitCreatieRolPhraseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 138, self.RULE_feitCreatieRolPhrase)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1073 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 1072
                self.feitCreatieWord()
                self.state = 1075 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (((((_la - 96)) & ~0x3f) == 0 and ((1 << (_la - 96)) & 1125968894902273) != 0) or ((((_la - 161)) & ~0x3f) == 0 and ((1 << (_la - 161)) & -2845233726449745919) != 0) or ((((_la - 231)) & ~0x3f) == 0 and ((1 << (_la - 231)) & 68723803151) != 0)):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FeitCreatieSubjectPhraseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def feitCreatieSubjectWord(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.FeitCreatieSubjectWordContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.FeitCreatieSubjectWordContext,i)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_feitCreatieSubjectPhrase

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFeitCreatieSubjectPhrase" ):
                listener.enterFeitCreatieSubjectPhrase(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFeitCreatieSubjectPhrase" ):
                listener.exitFeitCreatieSubjectPhrase(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFeitCreatieSubjectPhrase" ):
                return visitor.visitFeitCreatieSubjectPhrase(self)
            else:
                return visitor.visitChildren(self)




    def feitCreatieSubjectPhrase(self):

        localctx = RegelSpraakParser.FeitCreatieSubjectPhraseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 140, self.RULE_feitCreatieSubjectPhrase)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1078 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 1077
                    self.feitCreatieSubjectWord()

                else:
                    raise NoViableAltException(self)
                self.state = 1080 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,123,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FeitCreatieSubjectWordContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifierOrKeyword(self):
            return self.getTypedRuleContext(RegelSpraakParser.IdentifierOrKeywordContext,0)


        def voorzetsel(self):
            return self.getTypedRuleContext(RegelSpraakParser.VoorzetselContext,0)


        def DE(self):
            return self.getToken(RegelSpraakParser.DE, 0)

        def HET(self):
            return self.getToken(RegelSpraakParser.HET, 0)

        def EEN(self):
            return self.getToken(RegelSpraakParser.EEN, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_feitCreatieSubjectWord

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFeitCreatieSubjectWord" ):
                listener.enterFeitCreatieSubjectWord(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFeitCreatieSubjectWord" ):
                listener.exitFeitCreatieSubjectWord(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFeitCreatieSubjectWord" ):
                return visitor.visitFeitCreatieSubjectWord(self)
            else:
                return visitor.visitChildren(self)




    def feitCreatieSubjectWord(self):

        localctx = RegelSpraakParser.FeitCreatieSubjectWordContext(self, self._ctx, self.state)
        self.enterRule(localctx, 142, self.RULE_feitCreatieSubjectWord)
        try:
            self.state = 1087
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [96, 110, 113, 124, 132, 161, 190, 201, 202, 205, 206, 209, 210, 221, 223, 224, 232, 234, 253, 267]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1082
                self.identifierOrKeyword()
                pass
            elif token in [146, 148, 176, 208, 216, 220, 229, 231, 233, 241, 244, 248]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1083
                self.voorzetsel()
                pass
            elif token in [212]:
                self.enterOuterAlt(localctx, 3)
                self.state = 1084
                self.match(RegelSpraakParser.DE)
                pass
            elif token in [217]:
                self.enterOuterAlt(localctx, 4)
                self.state = 1085
                self.match(RegelSpraakParser.HET)
                pass
            elif token in [215]:
                self.enterOuterAlt(localctx, 5)
                self.state = 1086
                self.match(RegelSpraakParser.EEN)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FeitCreatieWordContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifierOrKeyword(self):
            return self.getTypedRuleContext(RegelSpraakParser.IdentifierOrKeywordContext,0)


        def voorzetselNietVan(self):
            return self.getTypedRuleContext(RegelSpraakParser.VoorzetselNietVanContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_feitCreatieWord

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFeitCreatieWord" ):
                listener.enterFeitCreatieWord(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFeitCreatieWord" ):
                listener.exitFeitCreatieWord(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFeitCreatieWord" ):
                return visitor.visitFeitCreatieWord(self)
            else:
                return visitor.visitChildren(self)




    def feitCreatieWord(self):

        localctx = RegelSpraakParser.FeitCreatieWordContext(self, self._ctx, self.state)
        self.enterRule(localctx, 144, self.RULE_feitCreatieWord)
        try:
            self.state = 1091
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [96, 110, 113, 124, 132, 161, 190, 201, 202, 205, 206, 209, 210, 221, 223, 224, 232, 234, 253, 267]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1089
                self.identifierOrKeyword()
                pass
            elif token in [146, 176, 208, 216, 220, 231, 233, 241, 248]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1090
                self.voorzetselNietVan()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VoorzetselNietVanContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IN(self):
            return self.getToken(RegelSpraakParser.IN, 0)

        def VOOR(self):
            return self.getToken(RegelSpraakParser.VOOR, 0)

        def OVER(self):
            return self.getToken(RegelSpraakParser.OVER, 0)

        def OP(self):
            return self.getToken(RegelSpraakParser.OP, 0)

        def BIJ(self):
            return self.getToken(RegelSpraakParser.BIJ, 0)

        def UIT(self):
            return self.getToken(RegelSpraakParser.UIT, 0)

        def TOT(self):
            return self.getToken(RegelSpraakParser.TOT, 0)

        def EN(self):
            return self.getToken(RegelSpraakParser.EN, 0)

        def MET(self):
            return self.getToken(RegelSpraakParser.MET, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_voorzetselNietVan

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVoorzetselNietVan" ):
                listener.enterVoorzetselNietVan(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVoorzetselNietVan" ):
                listener.exitVoorzetselNietVan(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVoorzetselNietVan" ):
                return visitor.visitVoorzetselNietVan(self)
            else:
                return visitor.visitChildren(self)




    def voorzetselNietVan(self):

        localctx = RegelSpraakParser.VoorzetselNietVanContext(self, self._ctx, self.state)
        self.enterRule(localctx, 146, self.RULE_voorzetselNietVan)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1093
            _la = self._input.LA(1)
            if not(((((_la - 146)) & ~0x3f) == 0 and ((1 << (_la - 146)) & 4611686019501129729) != 0) or ((((_la - 216)) & ~0x3f) == 0 and ((1 << (_la - 216)) & 4328685585) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ObjectCreatieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.objectType = None # NaamwoordContext

        def ER_WORDT_EEN_NIEUW(self):
            return self.getToken(RegelSpraakParser.ER_WORDT_EEN_NIEUW, 0)

        def AANGEMAAKT(self):
            return self.getToken(RegelSpraakParser.AANGEMAAKT, 0)

        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def objectAttributeInit(self):
            return self.getTypedRuleContext(RegelSpraakParser.ObjectAttributeInitContext,0)


        def DOT(self):
            return self.getToken(RegelSpraakParser.DOT, 0)

        def CREEER(self):
            return self.getToken(RegelSpraakParser.CREEER, 0)

        def EEN(self):
            return self.getToken(RegelSpraakParser.EEN, 0)

        def NIEUWE(self):
            return self.getToken(RegelSpraakParser.NIEUWE, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_objectCreatie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterObjectCreatie" ):
                listener.enterObjectCreatie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitObjectCreatie" ):
                listener.exitObjectCreatie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitObjectCreatie" ):
                return visitor.visitObjectCreatie(self)
            else:
                return visitor.visitChildren(self)




    def objectCreatie(self):

        localctx = RegelSpraakParser.ObjectCreatieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 148, self.RULE_objectCreatie)
        self._la = 0 # Token type
        try:
            self.state = 1114
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [41]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1095
                self.match(RegelSpraakParser.ER_WORDT_EEN_NIEUW)
                self.state = 1096
                localctx.objectType = self.naamwoord()
                self.state = 1097
                self.match(RegelSpraakParser.AANGEMAAKT)
                self.state = 1099
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==176:
                    self.state = 1098
                    self.objectAttributeInit()


                self.state = 1102
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,127,self._ctx)
                if la_ == 1:
                    self.state = 1101
                    self.match(RegelSpraakParser.DOT)


                pass
            elif token in [44]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1104
                self.match(RegelSpraakParser.CREEER)
                self.state = 1105
                self.match(RegelSpraakParser.EEN)
                self.state = 1106
                self.match(RegelSpraakParser.NIEUWE)
                self.state = 1107
                localctx.objectType = self.naamwoord()
                self.state = 1109
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==176:
                    self.state = 1108
                    self.objectAttributeInit()


                self.state = 1112
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,129,self._ctx)
                if la_ == 1:
                    self.state = 1111
                    self.match(RegelSpraakParser.DOT)


                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ObjectAttributeInitContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.attribuut = None # SimpleNaamwoordContext
            self.waarde = None # SimpleExpressieContext

        def MET(self):
            return self.getToken(RegelSpraakParser.MET, 0)

        def GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.GELIJK_AAN, 0)

        def simpleNaamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.SimpleNaamwoordContext,0)


        def simpleExpressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.SimpleExpressieContext,0)


        def attributeInitVervolg(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.AttributeInitVervolgContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.AttributeInitVervolgContext,i)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_objectAttributeInit

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterObjectAttributeInit" ):
                listener.enterObjectAttributeInit(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitObjectAttributeInit" ):
                listener.exitObjectAttributeInit(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitObjectAttributeInit" ):
                return visitor.visitObjectAttributeInit(self)
            else:
                return visitor.visitChildren(self)




    def objectAttributeInit(self):

        localctx = RegelSpraakParser.ObjectAttributeInitContext(self, self._ctx, self.state)
        self.enterRule(localctx, 150, self.RULE_objectAttributeInit)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1116
            self.match(RegelSpraakParser.MET)
            self.state = 1117
            localctx.attribuut = self.simpleNaamwoord()
            self.state = 1118
            self.match(RegelSpraakParser.GELIJK_AAN)
            self.state = 1119
            localctx.waarde = self.simpleExpressie()
            self.state = 1123
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==216:
                self.state = 1120
                self.attributeInitVervolg()
                self.state = 1125
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AttributeInitVervolgContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.attribuut = None # SimpleNaamwoordContext
            self.waarde = None # SimpleExpressieContext

        def EN(self):
            return self.getToken(RegelSpraakParser.EN, 0)

        def GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.GELIJK_AAN, 0)

        def simpleNaamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.SimpleNaamwoordContext,0)


        def simpleExpressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.SimpleExpressieContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_attributeInitVervolg

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAttributeInitVervolg" ):
                listener.enterAttributeInitVervolg(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAttributeInitVervolg" ):
                listener.exitAttributeInitVervolg(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAttributeInitVervolg" ):
                return visitor.visitAttributeInitVervolg(self)
            else:
                return visitor.visitChildren(self)




    def attributeInitVervolg(self):

        localctx = RegelSpraakParser.AttributeInitVervolgContext(self, self._ctx, self.state)
        self.enterRule(localctx, 152, self.RULE_attributeInitVervolg)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1126
            self.match(RegelSpraakParser.EN)
            self.state = 1127
            localctx.attribuut = self.simpleNaamwoord()
            self.state = 1128
            self.match(RegelSpraakParser.GELIJK_AAN)
            self.state = 1129
            localctx.waarde = self.simpleExpressie()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SimpleNaamwoordContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def naamPhrase(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamPhraseContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_simpleNaamwoord

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSimpleNaamwoord" ):
                listener.enterSimpleNaamwoord(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSimpleNaamwoord" ):
                listener.exitSimpleNaamwoord(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSimpleNaamwoord" ):
                return visitor.visitSimpleNaamwoord(self)
            else:
                return visitor.visitChildren(self)




    def simpleNaamwoord(self):

        localctx = RegelSpraakParser.SimpleNaamwoordContext(self, self._ctx, self.state)
        self.enterRule(localctx, 154, self.RULE_simpleNaamwoord)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1131
            self.naamPhrase()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConsistentieregelContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CONSISTENTIEREGEL(self):
            return self.getToken(RegelSpraakParser.CONSISTENTIEREGEL, 0)

        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def uniekzijnResultaat(self):
            return self.getTypedRuleContext(RegelSpraakParser.UniekzijnResultaatContext,0)


        def inconsistentResultaat(self):
            return self.getTypedRuleContext(RegelSpraakParser.InconsistentResultaatContext,0)


        def voorwaardeDeel(self):
            return self.getTypedRuleContext(RegelSpraakParser.VoorwaardeDeelContext,0)


        def DOT(self):
            return self.getToken(RegelSpraakParser.DOT, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_consistentieregel

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConsistentieregel" ):
                listener.enterConsistentieregel(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConsistentieregel" ):
                listener.exitConsistentieregel(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConsistentieregel" ):
                return visitor.visitConsistentieregel(self)
            else:
                return visitor.visitChildren(self)




    def consistentieregel(self):

        localctx = RegelSpraakParser.ConsistentieregelContext(self, self._ctx, self.state)
        self.enterRule(localctx, 156, self.RULE_consistentieregel)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1133
            self.match(RegelSpraakParser.CONSISTENTIEREGEL)
            self.state = 1134
            self.naamwoord()
            self.state = 1144
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,134,self._ctx)
            if la_ == 1:
                self.state = 1135
                self.uniekzijnResultaat()
                pass

            elif la_ == 2:
                self.state = 1136
                self.inconsistentResultaat()
                self.state = 1142
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [111]:
                    self.state = 1137
                    self.voorwaardeDeel()
                    self.state = 1139
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==279:
                        self.state = 1138
                        self.match(RegelSpraakParser.DOT)


                    pass
                elif token in [279]:
                    self.state = 1141
                    self.match(RegelSpraakParser.DOT)
                    pass
                elif token in [-1, 28, 95, 96, 97, 98, 99, 100, 102, 103, 104, 105, 106]:
                    pass
                else:
                    pass
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UniekzijnResultaatContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def alleAttributenVanObjecttype(self):
            return self.getTypedRuleContext(RegelSpraakParser.AlleAttributenVanObjecttypeContext,0)


        def MOETEN_UNIEK_ZIJN(self):
            return self.getToken(RegelSpraakParser.MOETEN_UNIEK_ZIJN, 0)

        def DOT(self):
            return self.getToken(RegelSpraakParser.DOT, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_uniekzijnResultaat

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUniekzijnResultaat" ):
                listener.enterUniekzijnResultaat(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUniekzijnResultaat" ):
                listener.exitUniekzijnResultaat(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUniekzijnResultaat" ):
                return visitor.visitUniekzijnResultaat(self)
            else:
                return visitor.visitChildren(self)




    def uniekzijnResultaat(self):

        localctx = RegelSpraakParser.UniekzijnResultaatContext(self, self._ctx, self.state)
        self.enterRule(localctx, 158, self.RULE_uniekzijnResultaat)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1146
            self.alleAttributenVanObjecttype()
            self.state = 1147
            self.match(RegelSpraakParser.MOETEN_UNIEK_ZIJN)
            self.state = 1149
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==279:
                self.state = 1148
                self.match(RegelSpraakParser.DOT)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AlleAttributenVanObjecttypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DE(self):
            return self.getToken(RegelSpraakParser.DE, 0)

        def naamwoord(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.NaamwoordContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,i)


        def VAN(self):
            return self.getToken(RegelSpraakParser.VAN, 0)

        def ALLE(self):
            return self.getToken(RegelSpraakParser.ALLE, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_alleAttributenVanObjecttype

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAlleAttributenVanObjecttype" ):
                listener.enterAlleAttributenVanObjecttype(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAlleAttributenVanObjecttype" ):
                listener.exitAlleAttributenVanObjecttype(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAlleAttributenVanObjecttype" ):
                return visitor.visitAlleAttributenVanObjecttype(self)
            else:
                return visitor.visitChildren(self)




    def alleAttributenVanObjecttype(self):

        localctx = RegelSpraakParser.AlleAttributenVanObjecttypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 160, self.RULE_alleAttributenVanObjecttype)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1151
            self.match(RegelSpraakParser.DE)
            self.state = 1152
            self.naamwoord()
            self.state = 1153
            self.match(RegelSpraakParser.VAN)
            self.state = 1154
            self.match(RegelSpraakParser.ALLE)
            self.state = 1155
            self.naamwoord()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InconsistentResultaatContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def IS_INCONSISTENT(self):
            return self.getToken(RegelSpraakParser.IS_INCONSISTENT, 0)

        def DE(self):
            return self.getToken(RegelSpraakParser.DE, 0)

        def HET(self):
            return self.getToken(RegelSpraakParser.HET, 0)

        def ER(self):
            return self.getToken(RegelSpraakParser.ER, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_inconsistentResultaat

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInconsistentResultaat" ):
                listener.enterInconsistentResultaat(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInconsistentResultaat" ):
                listener.exitInconsistentResultaat(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInconsistentResultaat" ):
                return visitor.visitInconsistentResultaat(self)
            else:
                return visitor.visitChildren(self)




    def inconsistentResultaat(self):

        localctx = RegelSpraakParser.InconsistentResultaatContext(self, self._ctx, self.state)
        self.enterRule(localctx, 162, self.RULE_inconsistentResultaat)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1158
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,136,self._ctx)
            if la_ == 1:
                self.state = 1157
                _la = self._input.LA(1)
                if not(((((_la - 212)) & ~0x3f) == 0 and ((1 << (_la - 212)) & 1099511627809) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


            self.state = 1160
            self.naamwoord()
            self.state = 1161
            self.match(RegelSpraakParser.IS_INCONSISTENT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VoorwaardeDeelContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INDIEN(self):
            return self.getToken(RegelSpraakParser.INDIEN, 0)

        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)


        def toplevelSamengesteldeVoorwaarde(self):
            return self.getTypedRuleContext(RegelSpraakParser.ToplevelSamengesteldeVoorwaardeContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_voorwaardeDeel

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVoorwaardeDeel" ):
                listener.enterVoorwaardeDeel(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVoorwaardeDeel" ):
                listener.exitVoorwaardeDeel(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVoorwaardeDeel" ):
                return visitor.visitVoorwaardeDeel(self)
            else:
                return visitor.visitChildren(self)




    def voorwaardeDeel(self):

        localctx = RegelSpraakParser.VoorwaardeDeelContext(self, self._ctx, self.state)
        self.enterRule(localctx, 164, self.RULE_voorwaardeDeel)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1163
            self.match(RegelSpraakParser.INDIEN)
            self.state = 1166
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,137,self._ctx)
            if la_ == 1:
                self.state = 1164
                self.expressie()
                pass

            elif la_ == 2:
                self.state = 1165
                self.toplevelSamengesteldeVoorwaarde()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ToplevelSamengesteldeVoorwaardeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ER_AAN(self):
            return self.getToken(RegelSpraakParser.ER_AAN, 0)

        def voorwaardeKwantificatie(self):
            return self.getTypedRuleContext(RegelSpraakParser.VoorwaardeKwantificatieContext,0)


        def WORDT_VOLDAAN(self):
            return self.getToken(RegelSpraakParser.WORDT_VOLDAAN, 0)

        def COLON(self):
            return self.getToken(RegelSpraakParser.COLON, 0)

        def VOLGENDE_VOORWAARDEN(self):
            return self.getToken(RegelSpraakParser.VOLGENDE_VOORWAARDEN, 0)

        def VOLGENDE_VOORWAARDE(self):
            return self.getToken(RegelSpraakParser.VOLGENDE_VOORWAARDE, 0)

        def samengesteldeVoorwaardeOnderdeel(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.SamengesteldeVoorwaardeOnderdeelContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.SamengesteldeVoorwaardeOnderdeelContext,i)


        def AAN(self):
            return self.getToken(RegelSpraakParser.AAN, 0)

        def VOLDOET(self):
            return self.getToken(RegelSpraakParser.VOLDOET, 0)

        def onderwerpReferentie(self):
            return self.getTypedRuleContext(RegelSpraakParser.OnderwerpReferentieContext,0)


        def HIJ(self):
            return self.getToken(RegelSpraakParser.HIJ, 0)

        def HET(self):
            return self.getToken(RegelSpraakParser.HET, 0)

        def ER(self):
            return self.getToken(RegelSpraakParser.ER, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_toplevelSamengesteldeVoorwaarde

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterToplevelSamengesteldeVoorwaarde" ):
                listener.enterToplevelSamengesteldeVoorwaarde(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitToplevelSamengesteldeVoorwaarde" ):
                listener.exitToplevelSamengesteldeVoorwaarde(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitToplevelSamengesteldeVoorwaarde" ):
                return visitor.visitToplevelSamengesteldeVoorwaarde(self)
            else:
                return visitor.visitChildren(self)




    def toplevelSamengesteldeVoorwaarde(self):

        localctx = RegelSpraakParser.ToplevelSamengesteldeVoorwaardeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 166, self.RULE_toplevelSamengesteldeVoorwaarde)
        self._la = 0 # Token type
        try:
            self.state = 1210
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,143,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1168
                self.match(RegelSpraakParser.ER_AAN)
                self.state = 1169
                self.voorwaardeKwantificatie()
                self.state = 1170
                _la = self._input.LA(1)
                if not(_la==245 or _la==246):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1171
                self.match(RegelSpraakParser.WORDT_VOLDAAN)
                self.state = 1172
                self.match(RegelSpraakParser.COLON)
                self.state = 1174 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 1173
                    self.samengesteldeVoorwaardeOnderdeel()
                    self.state = 1176 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (((((_la - 284)) & ~0x3f) == 0 and ((1 << (_la - 284)) & 291) != 0)):
                        break

                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1182
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,139,self._ctx)
                if la_ == 1:
                    self.state = 1178
                    self.onderwerpReferentie()
                    pass

                elif la_ == 2:
                    self.state = 1179
                    self.match(RegelSpraakParser.HIJ)
                    pass

                elif la_ == 3:
                    self.state = 1180
                    self.match(RegelSpraakParser.HET)
                    pass

                elif la_ == 4:
                    self.state = 1181
                    self.match(RegelSpraakParser.ER)
                    pass


                self.state = 1184
                self.match(RegelSpraakParser.AAN)
                self.state = 1185
                self.voorwaardeKwantificatie()
                self.state = 1186
                _la = self._input.LA(1)
                if not(_la==245 or _la==246):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1187
                self.match(RegelSpraakParser.VOLDOET)
                self.state = 1188
                self.match(RegelSpraakParser.COLON)
                self.state = 1190 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 1189
                    self.samengesteldeVoorwaardeOnderdeel()
                    self.state = 1192 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (((((_la - 284)) & ~0x3f) == 0 and ((1 << (_la - 284)) & 291) != 0)):
                        break

                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1198
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,141,self._ctx)
                if la_ == 1:
                    self.state = 1194
                    self.onderwerpReferentie()
                    pass

                elif la_ == 2:
                    self.state = 1195
                    self.match(RegelSpraakParser.HIJ)
                    pass

                elif la_ == 3:
                    self.state = 1196
                    self.match(RegelSpraakParser.HET)
                    pass

                elif la_ == 4:
                    self.state = 1197
                    self.match(RegelSpraakParser.ER)
                    pass


                self.state = 1200
                self.match(RegelSpraakParser.VOLDOET)
                self.state = 1201
                self.match(RegelSpraakParser.AAN)
                self.state = 1202
                self.voorwaardeKwantificatie()
                self.state = 1203
                _la = self._input.LA(1)
                if not(_la==245 or _la==246):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1204
                self.match(RegelSpraakParser.COLON)
                self.state = 1206 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 1205
                    self.samengesteldeVoorwaardeOnderdeel()
                    self.state = 1208 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (((((_la - 284)) & ~0x3f) == 0 and ((1 << (_la - 284)) & 291) != 0)):
                        break

                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VoorwaardeKwantificatieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ALLE(self):
            return self.getToken(RegelSpraakParser.ALLE, 0)

        def GEEN_VAN_DE(self):
            return self.getToken(RegelSpraakParser.GEEN_VAN_DE, 0)

        def VAN(self):
            return self.getToken(RegelSpraakParser.VAN, 0)

        def DE(self):
            return self.getToken(RegelSpraakParser.DE, 0)

        def TEN_MINSTE(self):
            return self.getToken(RegelSpraakParser.TEN_MINSTE, 0)

        def TENMINSTE(self):
            return self.getToken(RegelSpraakParser.TENMINSTE, 0)

        def NUMBER(self):
            return self.getToken(RegelSpraakParser.NUMBER, 0)

        def EEN(self):
            return self.getToken(RegelSpraakParser.EEN, 0)

        def EEN_TELWOORD(self):
            return self.getToken(RegelSpraakParser.EEN_TELWOORD, 0)

        def TWEE_TELWOORD(self):
            return self.getToken(RegelSpraakParser.TWEE_TELWOORD, 0)

        def DRIE_TELWOORD(self):
            return self.getToken(RegelSpraakParser.DRIE_TELWOORD, 0)

        def VIER_TELWOORD(self):
            return self.getToken(RegelSpraakParser.VIER_TELWOORD, 0)

        def TEN_HOOGSTE(self):
            return self.getToken(RegelSpraakParser.TEN_HOOGSTE, 0)

        def PRECIES(self):
            return self.getToken(RegelSpraakParser.PRECIES, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_voorwaardeKwantificatie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVoorwaardeKwantificatie" ):
                listener.enterVoorwaardeKwantificatie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVoorwaardeKwantificatie" ):
                listener.exitVoorwaardeKwantificatie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVoorwaardeKwantificatie" ):
                return visitor.visitVoorwaardeKwantificatie(self)
            else:
                return visitor.visitChildren(self)




    def voorwaardeKwantificatie(self):

        localctx = RegelSpraakParser.VoorwaardeKwantificatieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 168, self.RULE_voorwaardeKwantificatie)
        self._la = 0 # Token type
        try:
            self.state = 1226
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [124]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1212
                self.match(RegelSpraakParser.ALLE)
                pass
            elif token in [203]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1213
                self.match(RegelSpraakParser.GEEN_VAN_DE)
                pass
            elif token in [157, 158]:
                self.enterOuterAlt(localctx, 3)
                self.state = 1214
                _la = self._input.LA(1)
                if not(_la==157 or _la==158):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1215
                _la = self._input.LA(1)
                if not(((((_la - 201)) & ~0x3f) == 0 and ((1 << (_la - 201)) & 16435) != 0) or _la==268):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1216
                self.match(RegelSpraakParser.VAN)
                self.state = 1217
                self.match(RegelSpraakParser.DE)
                pass
            elif token in [159]:
                self.enterOuterAlt(localctx, 4)
                self.state = 1218
                self.match(RegelSpraakParser.TEN_HOOGSTE)
                self.state = 1219
                _la = self._input.LA(1)
                if not(((((_la - 201)) & ~0x3f) == 0 and ((1 << (_la - 201)) & 16435) != 0) or _la==268):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1220
                self.match(RegelSpraakParser.VAN)
                self.state = 1221
                self.match(RegelSpraakParser.DE)
                pass
            elif token in [160]:
                self.enterOuterAlt(localctx, 5)
                self.state = 1222
                self.match(RegelSpraakParser.PRECIES)
                self.state = 1223
                _la = self._input.LA(1)
                if not(((((_la - 201)) & ~0x3f) == 0 and ((1 << (_la - 201)) & 16435) != 0) or _la==268):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1224
                self.match(RegelSpraakParser.VAN)
                self.state = 1225
                self.match(RegelSpraakParser.DE)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SamengesteldeVoorwaardeOnderdeelContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def bulletPrefix(self):
            return self.getTypedRuleContext(RegelSpraakParser.BulletPrefixContext,0)


        def elementaireVoorwaarde(self):
            return self.getTypedRuleContext(RegelSpraakParser.ElementaireVoorwaardeContext,0)


        def genesteSamengesteldeVoorwaarde(self):
            return self.getTypedRuleContext(RegelSpraakParser.GenesteSamengesteldeVoorwaardeContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_samengesteldeVoorwaardeOnderdeel

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSamengesteldeVoorwaardeOnderdeel" ):
                listener.enterSamengesteldeVoorwaardeOnderdeel(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSamengesteldeVoorwaardeOnderdeel" ):
                listener.exitSamengesteldeVoorwaardeOnderdeel(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSamengesteldeVoorwaardeOnderdeel" ):
                return visitor.visitSamengesteldeVoorwaardeOnderdeel(self)
            else:
                return visitor.visitChildren(self)




    def samengesteldeVoorwaardeOnderdeel(self):

        localctx = RegelSpraakParser.SamengesteldeVoorwaardeOnderdeelContext(self, self._ctx, self.state)
        self.enterRule(localctx, 170, self.RULE_samengesteldeVoorwaardeOnderdeel)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1228
            self.bulletPrefix()
            self.state = 1231
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,145,self._ctx)
            if la_ == 1:
                self.state = 1229
                self.elementaireVoorwaarde()
                pass

            elif la_ == 2:
                self.state = 1230
                self.genesteSamengesteldeVoorwaarde()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BulletPrefixContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MINUS(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.MINUS)
            else:
                return self.getToken(RegelSpraakParser.MINUS, i)

        def DOUBLE_DOT(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.DOUBLE_DOT)
            else:
                return self.getToken(RegelSpraakParser.DOUBLE_DOT, i)

        def BULLET(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.BULLET)
            else:
                return self.getToken(RegelSpraakParser.BULLET, i)

        def ASTERISK(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.ASTERISK)
            else:
                return self.getToken(RegelSpraakParser.ASTERISK, i)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_bulletPrefix

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBulletPrefix" ):
                listener.enterBulletPrefix(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBulletPrefix" ):
                listener.exitBulletPrefix(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBulletPrefix" ):
                return visitor.visitBulletPrefix(self)
            else:
                return visitor.visitChildren(self)




    def bulletPrefix(self):

        localctx = RegelSpraakParser.BulletPrefixContext(self, self._ctx, self.state)
        self.enterRule(localctx, 172, self.RULE_bulletPrefix)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1234 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 1233
                    _la = self._input.LA(1)
                    if not(((((_la - 284)) & ~0x3f) == 0 and ((1 << (_la - 284)) & 291) != 0)):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()

                else:
                    raise NoViableAltException(self)
                self.state = 1236 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,146,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ElementaireVoorwaardeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_elementaireVoorwaarde

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterElementaireVoorwaarde" ):
                listener.enterElementaireVoorwaarde(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitElementaireVoorwaarde" ):
                listener.exitElementaireVoorwaarde(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitElementaireVoorwaarde" ):
                return visitor.visitElementaireVoorwaarde(self)
            else:
                return visitor.visitChildren(self)




    def elementaireVoorwaarde(self):

        localctx = RegelSpraakParser.ElementaireVoorwaardeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 174, self.RULE_elementaireVoorwaarde)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1238
            self.expressie()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GenesteSamengesteldeVoorwaardeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def VOLDOET(self):
            return self.getToken(RegelSpraakParser.VOLDOET, 0)

        def AAN(self):
            return self.getToken(RegelSpraakParser.AAN, 0)

        def voorwaardeKwantificatie(self):
            return self.getTypedRuleContext(RegelSpraakParser.VoorwaardeKwantificatieContext,0)


        def COLON(self):
            return self.getToken(RegelSpraakParser.COLON, 0)

        def VOLGENDE_VOORWAARDEN(self):
            return self.getToken(RegelSpraakParser.VOLGENDE_VOORWAARDEN, 0)

        def VOLGENDE_VOORWAARDE(self):
            return self.getToken(RegelSpraakParser.VOLGENDE_VOORWAARDE, 0)

        def onderwerpReferentie(self):
            return self.getTypedRuleContext(RegelSpraakParser.OnderwerpReferentieContext,0)


        def HIJ(self):
            return self.getToken(RegelSpraakParser.HIJ, 0)

        def ER(self):
            return self.getToken(RegelSpraakParser.ER, 0)

        def samengesteldeVoorwaardeOnderdeel(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.SamengesteldeVoorwaardeOnderdeelContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.SamengesteldeVoorwaardeOnderdeelContext,i)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_genesteSamengesteldeVoorwaarde

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGenesteSamengesteldeVoorwaarde" ):
                listener.enterGenesteSamengesteldeVoorwaarde(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGenesteSamengesteldeVoorwaarde" ):
                listener.exitGenesteSamengesteldeVoorwaarde(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGenesteSamengesteldeVoorwaarde" ):
                return visitor.visitGenesteSamengesteldeVoorwaarde(self)
            else:
                return visitor.visitChildren(self)




    def genesteSamengesteldeVoorwaarde(self):

        localctx = RegelSpraakParser.GenesteSamengesteldeVoorwaardeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 176, self.RULE_genesteSamengesteldeVoorwaarde)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1243
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,147,self._ctx)
            if la_ == 1:
                self.state = 1240
                self.onderwerpReferentie()
                pass

            elif la_ == 2:
                self.state = 1241
                self.match(RegelSpraakParser.HIJ)
                pass

            elif la_ == 3:
                self.state = 1242
                self.match(RegelSpraakParser.ER)
                pass


            self.state = 1245
            self.match(RegelSpraakParser.VOLDOET)
            self.state = 1246
            self.match(RegelSpraakParser.AAN)
            self.state = 1247
            self.voorwaardeKwantificatie()
            self.state = 1248
            _la = self._input.LA(1)
            if not(_la==245 or _la==246):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 1249
            self.match(RegelSpraakParser.COLON)
            self.state = 1251 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 1250
                    self.samengesteldeVoorwaardeOnderdeel()

                else:
                    raise NoViableAltException(self)
                self.state = 1253 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,148,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OnderwerpReferentieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def onderwerpBasis(self):
            return self.getTypedRuleContext(RegelSpraakParser.OnderwerpBasisContext,0)


        def predicaat(self):
            return self.getTypedRuleContext(RegelSpraakParser.PredicaatContext,0)


        def DIE(self):
            return self.getToken(RegelSpraakParser.DIE, 0)

        def DAT(self):
            return self.getToken(RegelSpraakParser.DAT, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_onderwerpReferentie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOnderwerpReferentie" ):
                listener.enterOnderwerpReferentie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOnderwerpReferentie" ):
                listener.exitOnderwerpReferentie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOnderwerpReferentie" ):
                return visitor.visitOnderwerpReferentie(self)
            else:
                return visitor.visitChildren(self)




    def onderwerpReferentie(self):

        localctx = RegelSpraakParser.OnderwerpReferentieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 178, self.RULE_onderwerpReferentie)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1255
            self.onderwerpBasis()
            self.state = 1258
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,149,self._ctx)
            if la_ == 1:
                self.state = 1256
                _la = self._input.LA(1)
                if not(_la==211 or _la==214):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1257
                self.predicaat()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OnderwerpReferentieWithNumbersContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def onderwerpBasisWithNumbers(self):
            return self.getTypedRuleContext(RegelSpraakParser.OnderwerpBasisWithNumbersContext,0)


        def predicaat(self):
            return self.getTypedRuleContext(RegelSpraakParser.PredicaatContext,0)


        def DIE(self):
            return self.getToken(RegelSpraakParser.DIE, 0)

        def DAT(self):
            return self.getToken(RegelSpraakParser.DAT, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_onderwerpReferentieWithNumbers

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOnderwerpReferentieWithNumbers" ):
                listener.enterOnderwerpReferentieWithNumbers(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOnderwerpReferentieWithNumbers" ):
                listener.exitOnderwerpReferentieWithNumbers(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOnderwerpReferentieWithNumbers" ):
                return visitor.visitOnderwerpReferentieWithNumbers(self)
            else:
                return visitor.visitChildren(self)




    def onderwerpReferentieWithNumbers(self):

        localctx = RegelSpraakParser.OnderwerpReferentieWithNumbersContext(self, self._ctx, self.state)
        self.enterRule(localctx, 180, self.RULE_onderwerpReferentieWithNumbers)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1260
            self.onderwerpBasisWithNumbers()
            self.state = 1263
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==211 or _la==214:
                self.state = 1261
                _la = self._input.LA(1)
                if not(_la==211 or _la==214):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1262
                self.predicaat()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OnderwerpBasisContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def basisOnderwerp(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.BasisOnderwerpContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.BasisOnderwerpContext,i)


        def voorzetsel(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.VoorzetselContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.VoorzetselContext,i)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_onderwerpBasis

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOnderwerpBasis" ):
                listener.enterOnderwerpBasis(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOnderwerpBasis" ):
                listener.exitOnderwerpBasis(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOnderwerpBasis" ):
                return visitor.visitOnderwerpBasis(self)
            else:
                return visitor.visitChildren(self)




    def onderwerpBasis(self):

        localctx = RegelSpraakParser.OnderwerpBasisContext(self, self._ctx, self.state)
        self.enterRule(localctx, 182, self.RULE_onderwerpBasis)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1265
            self.basisOnderwerp()
            self.state = 1271
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,151,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 1266
                    self.voorzetsel()
                    self.state = 1267
                    self.basisOnderwerp() 
                self.state = 1273
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,151,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OnderwerpBasisWithNumbersContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def basisOnderwerpWithNumbers(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.BasisOnderwerpWithNumbersContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.BasisOnderwerpWithNumbersContext,i)


        def voorzetsel(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.VoorzetselContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.VoorzetselContext,i)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_onderwerpBasisWithNumbers

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOnderwerpBasisWithNumbers" ):
                listener.enterOnderwerpBasisWithNumbers(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOnderwerpBasisWithNumbers" ):
                listener.exitOnderwerpBasisWithNumbers(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOnderwerpBasisWithNumbers" ):
                return visitor.visitOnderwerpBasisWithNumbers(self)
            else:
                return visitor.visitChildren(self)




    def onderwerpBasisWithNumbers(self):

        localctx = RegelSpraakParser.OnderwerpBasisWithNumbersContext(self, self._ctx, self.state)
        self.enterRule(localctx, 184, self.RULE_onderwerpBasisWithNumbers)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1274
            self.basisOnderwerpWithNumbers()
            self.state = 1280
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((((_la - 146)) & ~0x3f) == 0 and ((1 << (_la - 146)) & 4611686019501129733) != 0) or ((((_la - 216)) & ~0x3f) == 0 and ((1 << (_la - 216)) & 4597129233) != 0):
                self.state = 1275
                self.voorzetsel()
                self.state = 1276
                self.basisOnderwerpWithNumbers()
                self.state = 1282
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BasisOnderwerpContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DE(self):
            return self.getToken(RegelSpraakParser.DE, 0)

        def HET(self):
            return self.getToken(RegelSpraakParser.HET, 0)

        def EEN(self):
            return self.getToken(RegelSpraakParser.EEN, 0)

        def ZIJN(self):
            return self.getToken(RegelSpraakParser.ZIJN, 0)

        def identifierOrKeyword(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.IdentifierOrKeywordContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.IdentifierOrKeywordContext,i)


        def HIJ(self):
            return self.getToken(RegelSpraakParser.HIJ, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_basisOnderwerp

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBasisOnderwerp" ):
                listener.enterBasisOnderwerp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBasisOnderwerp" ):
                listener.exitBasisOnderwerp(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBasisOnderwerp" ):
                return visitor.visitBasisOnderwerp(self)
            else:
                return visitor.visitChildren(self)




    def basisOnderwerp(self):

        localctx = RegelSpraakParser.BasisOnderwerpContext(self, self._ctx, self.state)
        self.enterRule(localctx, 186, self.RULE_basisOnderwerp)
        self._la = 0 # Token type
        try:
            self.state = 1290
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [119, 212, 215, 217]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1283
                _la = self._input.LA(1)
                if not(_la==119 or ((((_la - 212)) & ~0x3f) == 0 and ((1 << (_la - 212)) & 41) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1285 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 1284
                        self.identifierOrKeyword()

                    else:
                        raise NoViableAltException(self)
                    self.state = 1287 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,153,self._ctx)

                pass
            elif token in [219]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1289
                self.match(RegelSpraakParser.HIJ)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BasisOnderwerpWithNumbersContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DE(self):
            return self.getToken(RegelSpraakParser.DE, 0)

        def HET(self):
            return self.getToken(RegelSpraakParser.HET, 0)

        def EEN(self):
            return self.getToken(RegelSpraakParser.EEN, 0)

        def ZIJN(self):
            return self.getToken(RegelSpraakParser.ZIJN, 0)

        def identifierOrKeywordWithNumbers(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.IdentifierOrKeywordWithNumbersContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.IdentifierOrKeywordWithNumbersContext,i)


        def HIJ(self):
            return self.getToken(RegelSpraakParser.HIJ, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_basisOnderwerpWithNumbers

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBasisOnderwerpWithNumbers" ):
                listener.enterBasisOnderwerpWithNumbers(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBasisOnderwerpWithNumbers" ):
                listener.exitBasisOnderwerpWithNumbers(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBasisOnderwerpWithNumbers" ):
                return visitor.visitBasisOnderwerpWithNumbers(self)
            else:
                return visitor.visitChildren(self)




    def basisOnderwerpWithNumbers(self):

        localctx = RegelSpraakParser.BasisOnderwerpWithNumbersContext(self, self._ctx, self.state)
        self.enterRule(localctx, 188, self.RULE_basisOnderwerpWithNumbers)
        self._la = 0 # Token type
        try:
            self.state = 1299
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [119, 212, 215, 217]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1292
                _la = self._input.LA(1)
                if not(_la==119 or ((((_la - 212)) & ~0x3f) == 0 and ((1 << (_la - 212)) & 41) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1294 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 1293
                    self.identifierOrKeywordWithNumbers()
                    self.state = 1296 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (((((_la - 96)) & ~0x3f) == 0 and ((1 << (_la - 96)) & 68988059649) != 0) or ((((_la - 161)) & ~0x3f) == 0 and ((1 << (_la - 161)) & -3457864013260521471) != 0) or ((((_la - 232)) & ~0x3f) == 0 and ((1 << (_la - 232)) & 103081312261) != 0)):
                        break

                pass
            elif token in [219]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1298
                self.match(RegelSpraakParser.HIJ)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AttribuutReferentieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def attribuutMetLidwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.AttribuutMetLidwoordContext,0)


        def VAN(self):
            return self.getToken(RegelSpraakParser.VAN, 0)

        def onderwerpReferentie(self):
            return self.getTypedRuleContext(RegelSpraakParser.OnderwerpReferentieContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_attribuutReferentie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAttribuutReferentie" ):
                listener.enterAttribuutReferentie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAttribuutReferentie" ):
                listener.exitAttribuutReferentie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAttribuutReferentie" ):
                return visitor.visitAttribuutReferentie(self)
            else:
                return visitor.visitChildren(self)




    def attribuutReferentie(self):

        localctx = RegelSpraakParser.AttribuutReferentieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 190, self.RULE_attribuutReferentie)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1301
            self.attribuutMetLidwoord()
            self.state = 1302
            self.match(RegelSpraakParser.VAN)
            self.state = 1303
            self.onderwerpReferentie()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AttribuutMetLidwoordContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def naamwoordNoIs(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordNoIsContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_attribuutMetLidwoord

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAttribuutMetLidwoord" ):
                listener.enterAttribuutMetLidwoord(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAttribuutMetLidwoord" ):
                listener.exitAttribuutMetLidwoord(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAttribuutMetLidwoord" ):
                return visitor.visitAttribuutMetLidwoord(self)
            else:
                return visitor.visitChildren(self)




    def attribuutMetLidwoord(self):

        localctx = RegelSpraakParser.AttribuutMetLidwoordContext(self, self._ctx, self.state)
        self.enterRule(localctx, 192, self.RULE_attribuutMetLidwoord)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1305
            self.naamwoordNoIs()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class KenmerkNaamContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def naamwoordWithNumbers(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordWithNumbersContext,0)


        def voorzetsel(self):
            return self.getTypedRuleContext(RegelSpraakParser.VoorzetselContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_kenmerkNaam

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterKenmerkNaam" ):
                listener.enterKenmerkNaam(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitKenmerkNaam" ):
                listener.exitKenmerkNaam(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitKenmerkNaam" ):
                return visitor.visitKenmerkNaam(self)
            else:
                return visitor.visitChildren(self)




    def kenmerkNaam(self):

        localctx = RegelSpraakParser.KenmerkNaamContext(self, self._ctx, self.state)
        self.enterRule(localctx, 194, self.RULE_kenmerkNaam)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1308
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 146)) & ~0x3f) == 0 and ((1 << (_la - 146)) & 4611686019501129733) != 0) or ((((_la - 216)) & ~0x3f) == 0 and ((1 << (_la - 216)) & 4597129233) != 0):
                self.state = 1307
                self.voorzetsel()


            self.state = 1310
            self.naamwoordWithNumbers()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class KenmerkPhraseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def voorzetsel(self):
            return self.getTypedRuleContext(RegelSpraakParser.VoorzetselContext,0)


        def identifierOrKeywordWithNumbers(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.IdentifierOrKeywordWithNumbersContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.IdentifierOrKeywordWithNumbersContext,i)


        def DE(self):
            return self.getToken(RegelSpraakParser.DE, 0)

        def HET(self):
            return self.getToken(RegelSpraakParser.HET, 0)

        def EEN(self):
            return self.getToken(RegelSpraakParser.EEN, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_kenmerkPhrase

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterKenmerkPhrase" ):
                listener.enterKenmerkPhrase(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitKenmerkPhrase" ):
                listener.exitKenmerkPhrase(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitKenmerkPhrase" ):
                return visitor.visitKenmerkPhrase(self)
            else:
                return visitor.visitChildren(self)




    def kenmerkPhrase(self):

        localctx = RegelSpraakParser.KenmerkPhraseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 196, self.RULE_kenmerkPhrase)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1313
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 146)) & ~0x3f) == 0 and ((1 << (_la - 146)) & 4611686019501129733) != 0) or ((((_la - 216)) & ~0x3f) == 0 and ((1 << (_la - 216)) & 4597129233) != 0):
                self.state = 1312
                self.voorzetsel()


            self.state = 1316
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 212)) & ~0x3f) == 0 and ((1 << (_la - 212)) & 41) != 0):
                self.state = 1315
                _la = self._input.LA(1)
                if not(((((_la - 212)) & ~0x3f) == 0 and ((1 << (_la - 212)) & 41) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


            self.state = 1319 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 1318
                self.identifierOrKeywordWithNumbers()
                self.state = 1321 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (((((_la - 96)) & ~0x3f) == 0 and ((1 << (_la - 96)) & 68988059649) != 0) or ((((_la - 161)) & ~0x3f) == 0 and ((1 << (_la - 161)) & -3457864013260521471) != 0) or ((((_la - 232)) & ~0x3f) == 0 and ((1 << (_la - 232)) & 103081312261) != 0)):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BezieldeReferentieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def ZIJN(self):
            return self.getToken(RegelSpraakParser.ZIJN, 0)

        def HAAR(self):
            return self.getToken(RegelSpraakParser.HAAR, 0)

        def HUN(self):
            return self.getToken(RegelSpraakParser.HUN, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_bezieldeReferentie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBezieldeReferentie" ):
                listener.enterBezieldeReferentie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBezieldeReferentie" ):
                listener.exitBezieldeReferentie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBezieldeReferentie" ):
                return visitor.visitBezieldeReferentie(self)
            else:
                return visitor.visitChildren(self)




    def bezieldeReferentie(self):

        localctx = RegelSpraakParser.BezieldeReferentieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 198, self.RULE_bezieldeReferentie)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1323
            _la = self._input.LA(1)
            if not(((((_la - 119)) & ~0x3f) == 0 and ((1 << (_la - 119)) & 7) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 1324
            self.naamwoord()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AggregationSubjectContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ALLE(self):
            return self.getToken(RegelSpraakParser.ALLE, 0)

        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def predicaat(self):
            return self.getTypedRuleContext(RegelSpraakParser.PredicaatContext,0)


        def DIE(self):
            return self.getToken(RegelSpraakParser.DIE, 0)

        def DAT(self):
            return self.getToken(RegelSpraakParser.DAT, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_aggregationSubject

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAggregationSubject" ):
                listener.enterAggregationSubject(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAggregationSubject" ):
                listener.exitAggregationSubject(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAggregationSubject" ):
                return visitor.visitAggregationSubject(self)
            else:
                return visitor.visitChildren(self)




    def aggregationSubject(self):

        localctx = RegelSpraakParser.AggregationSubjectContext(self, self._ctx, self.state)
        self.enterRule(localctx, 200, self.RULE_aggregationSubject)
        self._la = 0 # Token type
        try:
            self.state = 1333
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,162,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1326
                self.match(RegelSpraakParser.ALLE)
                self.state = 1327
                self.naamwoord()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1328
                self.naamwoord()
                self.state = 1331
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,161,self._ctx)
                if la_ == 1:
                    self.state = 1329
                    _la = self._input.LA(1)
                    if not(_la==211 or _la==214):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()
                    self.state = 1330
                    self.predicaat()


                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PredicaatContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def elementairPredicaat(self):
            return self.getTypedRuleContext(RegelSpraakParser.ElementairPredicaatContext,0)


        def samengesteldPredicaat(self):
            return self.getTypedRuleContext(RegelSpraakParser.SamengesteldPredicaatContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_predicaat

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPredicaat" ):
                listener.enterPredicaat(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPredicaat" ):
                listener.exitPredicaat(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPredicaat" ):
                return visitor.visitPredicaat(self)
            else:
                return visitor.visitChildren(self)




    def predicaat(self):

        localctx = RegelSpraakParser.PredicaatContext(self, self._ctx, self.state)
        self.enterRule(localctx, 202, self.RULE_predicaat)
        try:
            self.state = 1337
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [45, 54, 55, 56, 57, 58, 59, 64, 65, 66, 67, 96, 110, 113, 119, 124, 132, 140, 146, 148, 161, 176, 190, 201, 202, 205, 206, 208, 209, 210, 212, 215, 216, 217, 220, 221, 223, 224, 229, 231, 232, 233, 234, 241, 244, 248, 253, 267, 268]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1335
                self.elementairPredicaat()
                pass
            elif token in [122]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1336
                self.samengesteldPredicaat()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ElementairPredicaatContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def attribuutVergelijkingsPredicaat(self):
            return self.getTypedRuleContext(RegelSpraakParser.AttribuutVergelijkingsPredicaatContext,0)


        def objectPredicaat(self):
            return self.getTypedRuleContext(RegelSpraakParser.ObjectPredicaatContext,0)


        def getalPredicaat(self):
            return self.getTypedRuleContext(RegelSpraakParser.GetalPredicaatContext,0)


        def tekstPredicaat(self):
            return self.getTypedRuleContext(RegelSpraakParser.TekstPredicaatContext,0)


        def datumPredicaat(self):
            return self.getTypedRuleContext(RegelSpraakParser.DatumPredicaatContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_elementairPredicaat

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterElementairPredicaat" ):
                listener.enterElementairPredicaat(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitElementairPredicaat" ):
                listener.exitElementairPredicaat(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitElementairPredicaat" ):
                return visitor.visitElementairPredicaat(self)
            else:
                return visitor.visitChildren(self)




    def elementairPredicaat(self):

        localctx = RegelSpraakParser.ElementairPredicaatContext(self, self._ctx, self.state)
        self.enterRule(localctx, 204, self.RULE_elementairPredicaat)
        try:
            self.state = 1344
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,164,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1339
                self.attribuutVergelijkingsPredicaat()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1340
                self.objectPredicaat()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1341
                self.getalPredicaat()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 1342
                self.tekstPredicaat()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 1343
                self.datumPredicaat()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ObjectPredicaatContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def eenzijdigeObjectVergelijking(self):
            return self.getTypedRuleContext(RegelSpraakParser.EenzijdigeObjectVergelijkingContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_objectPredicaat

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterObjectPredicaat" ):
                listener.enterObjectPredicaat(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitObjectPredicaat" ):
                listener.exitObjectPredicaat(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitObjectPredicaat" ):
                return visitor.visitObjectPredicaat(self)
            else:
                return visitor.visitChildren(self)




    def objectPredicaat(self):

        localctx = RegelSpraakParser.ObjectPredicaatContext(self, self._ctx, self.state)
        self.enterRule(localctx, 206, self.RULE_objectPredicaat)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1346
            self.eenzijdigeObjectVergelijking()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EenzijdigeObjectVergelijkingContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ZIJN(self):
            return self.getToken(RegelSpraakParser.ZIJN, 0)

        def HEBBEN(self):
            return self.getToken(RegelSpraakParser.HEBBEN, 0)

        def kenmerkNaam(self):
            return self.getTypedRuleContext(RegelSpraakParser.KenmerkNaamContext,0)


        def rolNaam(self):
            return self.getTypedRuleContext(RegelSpraakParser.RolNaamContext,0)


        def EEN(self):
            return self.getToken(RegelSpraakParser.EEN, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_eenzijdigeObjectVergelijking

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEenzijdigeObjectVergelijking" ):
                listener.enterEenzijdigeObjectVergelijking(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEenzijdigeObjectVergelijking" ):
                listener.exitEenzijdigeObjectVergelijking(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEenzijdigeObjectVergelijking" ):
                return visitor.visitEenzijdigeObjectVergelijking(self)
            else:
                return visitor.visitChildren(self)




    def eenzijdigeObjectVergelijking(self):

        localctx = RegelSpraakParser.EenzijdigeObjectVergelijkingContext(self, self._ctx, self.state)
        self.enterRule(localctx, 208, self.RULE_eenzijdigeObjectVergelijking)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1349
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,165,self._ctx)
            if la_ == 1:
                self.state = 1348
                self.match(RegelSpraakParser.EEN)


            self.state = 1353
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,166,self._ctx)
            if la_ == 1:
                self.state = 1351
                self.kenmerkNaam()
                pass

            elif la_ == 2:
                self.state = 1352
                self.rolNaam()
                pass


            self.state = 1355
            _la = self._input.LA(1)
            if not(_la==109 or _la==119):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RolNaamContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_rolNaam

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRolNaam" ):
                listener.enterRolNaam(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRolNaam" ):
                listener.exitRolNaam(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRolNaam" ):
                return visitor.visitRolNaam(self)
            else:
                return visitor.visitChildren(self)




    def rolNaam(self):

        localctx = RegelSpraakParser.RolNaamContext(self, self._ctx, self.state)
        self.enterRule(localctx, 210, self.RULE_rolNaam)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1357
            self.naamwoord()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AttribuutVergelijkingsPredicaatContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.attribuutNaam = None # NaamwoordContext

        def HEBBEN(self):
            return self.getToken(RegelSpraakParser.HEBBEN, 0)

        def comparisonOperator(self):
            return self.getTypedRuleContext(RegelSpraakParser.ComparisonOperatorContext,0)


        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)


        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def EEN(self):
            return self.getToken(RegelSpraakParser.EEN, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_attribuutVergelijkingsPredicaat

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAttribuutVergelijkingsPredicaat" ):
                listener.enterAttribuutVergelijkingsPredicaat(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAttribuutVergelijkingsPredicaat" ):
                listener.exitAttribuutVergelijkingsPredicaat(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAttribuutVergelijkingsPredicaat" ):
                return visitor.visitAttribuutVergelijkingsPredicaat(self)
            else:
                return visitor.visitChildren(self)




    def attribuutVergelijkingsPredicaat(self):

        localctx = RegelSpraakParser.AttribuutVergelijkingsPredicaatContext(self, self._ctx, self.state)
        self.enterRule(localctx, 212, self.RULE_attribuutVergelijkingsPredicaat)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1360
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,167,self._ctx)
            if la_ == 1:
                self.state = 1359
                self.match(RegelSpraakParser.EEN)


            self.state = 1362
            localctx.attribuutNaam = self.naamwoord()
            self.state = 1363
            self.match(RegelSpraakParser.HEBBEN)
            self.state = 1364
            self.comparisonOperator()
            self.state = 1365
            self.expressie()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GetalPredicaatContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def getalVergelijkingsOperatorMeervoud(self):
            return self.getTypedRuleContext(RegelSpraakParser.GetalVergelijkingsOperatorMeervoudContext,0)


        def getalExpressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.GetalExpressieContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_getalPredicaat

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGetalPredicaat" ):
                listener.enterGetalPredicaat(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGetalPredicaat" ):
                listener.exitGetalPredicaat(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGetalPredicaat" ):
                return visitor.visitGetalPredicaat(self)
            else:
                return visitor.visitChildren(self)




    def getalPredicaat(self):

        localctx = RegelSpraakParser.GetalPredicaatContext(self, self._ctx, self.state)
        self.enterRule(localctx, 214, self.RULE_getalPredicaat)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1367
            self.getalVergelijkingsOperatorMeervoud()
            self.state = 1368
            self.getalExpressie()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TekstPredicaatContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def tekstVergelijkingsOperatorMeervoud(self):
            return self.getTypedRuleContext(RegelSpraakParser.TekstVergelijkingsOperatorMeervoudContext,0)


        def tekstExpressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.TekstExpressieContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_tekstPredicaat

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTekstPredicaat" ):
                listener.enterTekstPredicaat(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTekstPredicaat" ):
                listener.exitTekstPredicaat(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTekstPredicaat" ):
                return visitor.visitTekstPredicaat(self)
            else:
                return visitor.visitChildren(self)




    def tekstPredicaat(self):

        localctx = RegelSpraakParser.TekstPredicaatContext(self, self._ctx, self.state)
        self.enterRule(localctx, 216, self.RULE_tekstPredicaat)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1370
            self.tekstVergelijkingsOperatorMeervoud()
            self.state = 1371
            self.tekstExpressie()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DatumPredicaatContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def datumVergelijkingsOperatorMeervoud(self):
            return self.getTypedRuleContext(RegelSpraakParser.DatumVergelijkingsOperatorMeervoudContext,0)


        def datumExpressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.DatumExpressieContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_datumPredicaat

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDatumPredicaat" ):
                listener.enterDatumPredicaat(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDatumPredicaat" ):
                listener.exitDatumPredicaat(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDatumPredicaat" ):
                return visitor.visitDatumPredicaat(self)
            else:
                return visitor.visitChildren(self)




    def datumPredicaat(self):

        localctx = RegelSpraakParser.DatumPredicaatContext(self, self._ctx, self.state)
        self.enterRule(localctx, 218, self.RULE_datumPredicaat)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1373
            self.datumVergelijkingsOperatorMeervoud()
            self.state = 1374
            self.datumExpressie()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SamengesteldPredicaatContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def AAN(self):
            return self.getToken(RegelSpraakParser.AAN, 0)

        def voorwaardeKwantificatie(self):
            return self.getTypedRuleContext(RegelSpraakParser.VoorwaardeKwantificatieContext,0)


        def VOLGENDE(self):
            return self.getToken(RegelSpraakParser.VOLGENDE, 0)

        def COLON(self):
            return self.getToken(RegelSpraakParser.COLON, 0)

        def VOORWAARDE(self):
            return self.getToken(RegelSpraakParser.VOORWAARDE, 0)

        def VOORWAARDEN(self):
            return self.getToken(RegelSpraakParser.VOORWAARDEN, 0)

        def VOLDOET(self):
            return self.getToken(RegelSpraakParser.VOLDOET, 0)

        def VOLDOEN(self):
            return self.getToken(RegelSpraakParser.VOLDOEN, 0)

        def samengesteldeVoorwaardeOnderdeelInPredicaat(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.SamengesteldeVoorwaardeOnderdeelInPredicaatContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.SamengesteldeVoorwaardeOnderdeelInPredicaatContext,i)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_samengesteldPredicaat

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSamengesteldPredicaat" ):
                listener.enterSamengesteldPredicaat(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSamengesteldPredicaat" ):
                listener.exitSamengesteldPredicaat(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSamengesteldPredicaat" ):
                return visitor.visitSamengesteldPredicaat(self)
            else:
                return visitor.visitChildren(self)




    def samengesteldPredicaat(self):

        localctx = RegelSpraakParser.SamengesteldPredicaatContext(self, self._ctx, self.state)
        self.enterRule(localctx, 220, self.RULE_samengesteldPredicaat)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1376
            self.match(RegelSpraakParser.AAN)
            self.state = 1377
            self.voorwaardeKwantificatie()
            self.state = 1378
            self.match(RegelSpraakParser.VOLGENDE)
            self.state = 1379
            _la = self._input.LA(1)
            if not(_la==161 or _la==162):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 1380
            _la = self._input.LA(1)
            if not(_la==153 or _la==154):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 1381
            self.match(RegelSpraakParser.COLON)
            self.state = 1383 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 1382
                    self.samengesteldeVoorwaardeOnderdeelInPredicaat()

                else:
                    raise NoViableAltException(self)
                self.state = 1385 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,168,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SamengesteldeVoorwaardeOnderdeelInPredicaatContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def bulletPrefix(self):
            return self.getTypedRuleContext(RegelSpraakParser.BulletPrefixContext,0)


        def elementaireVoorwaardeInPredicaat(self):
            return self.getTypedRuleContext(RegelSpraakParser.ElementaireVoorwaardeInPredicaatContext,0)


        def genesteSamengesteldeVoorwaardeInPredicaat(self):
            return self.getTypedRuleContext(RegelSpraakParser.GenesteSamengesteldeVoorwaardeInPredicaatContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_samengesteldeVoorwaardeOnderdeelInPredicaat

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSamengesteldeVoorwaardeOnderdeelInPredicaat" ):
                listener.enterSamengesteldeVoorwaardeOnderdeelInPredicaat(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSamengesteldeVoorwaardeOnderdeelInPredicaat" ):
                listener.exitSamengesteldeVoorwaardeOnderdeelInPredicaat(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSamengesteldeVoorwaardeOnderdeelInPredicaat" ):
                return visitor.visitSamengesteldeVoorwaardeOnderdeelInPredicaat(self)
            else:
                return visitor.visitChildren(self)




    def samengesteldeVoorwaardeOnderdeelInPredicaat(self):

        localctx = RegelSpraakParser.SamengesteldeVoorwaardeOnderdeelInPredicaatContext(self, self._ctx, self.state)
        self.enterRule(localctx, 222, self.RULE_samengesteldeVoorwaardeOnderdeelInPredicaat)
        try:
            self.state = 1393
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,169,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1387
                self.bulletPrefix()
                self.state = 1388
                self.elementaireVoorwaardeInPredicaat()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1390
                self.bulletPrefix()
                self.state = 1391
                self.genesteSamengesteldeVoorwaardeInPredicaat()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ElementaireVoorwaardeInPredicaatContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def vergelijkingInPredicaat(self):
            return self.getTypedRuleContext(RegelSpraakParser.VergelijkingInPredicaatContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_elementaireVoorwaardeInPredicaat

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterElementaireVoorwaardeInPredicaat" ):
                listener.enterElementaireVoorwaardeInPredicaat(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitElementaireVoorwaardeInPredicaat" ):
                listener.exitElementaireVoorwaardeInPredicaat(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitElementaireVoorwaardeInPredicaat" ):
                return visitor.visitElementaireVoorwaardeInPredicaat(self)
            else:
                return visitor.visitChildren(self)




    def elementaireVoorwaardeInPredicaat(self):

        localctx = RegelSpraakParser.ElementaireVoorwaardeInPredicaatContext(self, self._ctx, self.state)
        self.enterRule(localctx, 224, self.RULE_elementaireVoorwaardeInPredicaat)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1395
            self.vergelijkingInPredicaat()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VergelijkingInPredicaatContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def attribuutReferentie(self):
            return self.getTypedRuleContext(RegelSpraakParser.AttribuutReferentieContext,0)


        def comparisonOperator(self):
            return self.getTypedRuleContext(RegelSpraakParser.ComparisonOperatorContext,0)


        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)


        def onderwerpReferentie(self):
            return self.getTypedRuleContext(RegelSpraakParser.OnderwerpReferentieContext,0)


        def eenzijdigeObjectVergelijking(self):
            return self.getTypedRuleContext(RegelSpraakParser.EenzijdigeObjectVergelijkingContext,0)


        def kenmerkNaam(self):
            return self.getTypedRuleContext(RegelSpraakParser.KenmerkNaamContext,0)


        def IS(self):
            return self.getToken(RegelSpraakParser.IS, 0)

        def ZIJN(self):
            return self.getToken(RegelSpraakParser.ZIJN, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_vergelijkingInPredicaat

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVergelijkingInPredicaat" ):
                listener.enterVergelijkingInPredicaat(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVergelijkingInPredicaat" ):
                listener.exitVergelijkingInPredicaat(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVergelijkingInPredicaat" ):
                return visitor.visitVergelijkingInPredicaat(self)
            else:
                return visitor.visitChildren(self)




    def vergelijkingInPredicaat(self):

        localctx = RegelSpraakParser.VergelijkingInPredicaatContext(self, self._ctx, self.state)
        self.enterRule(localctx, 226, self.RULE_vergelijkingInPredicaat)
        self._la = 0 # Token type
        try:
            self.state = 1408
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,170,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1397
                self.attribuutReferentie()
                self.state = 1398
                self.comparisonOperator()
                self.state = 1399
                self.expressie()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1401
                self.onderwerpReferentie()
                self.state = 1402
                self.eenzijdigeObjectVergelijking()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1404
                self.attribuutReferentie()
                self.state = 1405
                _la = self._input.LA(1)
                if not(_la==113 or _la==119):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1406
                self.kenmerkNaam()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GenesteSamengesteldeVoorwaardeInPredicaatContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def AAN(self):
            return self.getToken(RegelSpraakParser.AAN, 0)

        def voorwaardeKwantificatie(self):
            return self.getTypedRuleContext(RegelSpraakParser.VoorwaardeKwantificatieContext,0)


        def VOLGENDE(self):
            return self.getToken(RegelSpraakParser.VOLGENDE, 0)

        def COLON(self):
            return self.getToken(RegelSpraakParser.COLON, 0)

        def VOORWAARDE(self):
            return self.getToken(RegelSpraakParser.VOORWAARDE, 0)

        def VOORWAARDEN(self):
            return self.getToken(RegelSpraakParser.VOORWAARDEN, 0)

        def VOLDOET(self):
            return self.getToken(RegelSpraakParser.VOLDOET, 0)

        def VOLDOEN(self):
            return self.getToken(RegelSpraakParser.VOLDOEN, 0)

        def WORDT(self):
            return self.getToken(RegelSpraakParser.WORDT, 0)

        def VOLDAAN(self):
            return self.getToken(RegelSpraakParser.VOLDAAN, 0)

        def samengesteldeVoorwaardeOnderdeelInPredicaat(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.SamengesteldeVoorwaardeOnderdeelInPredicaatContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.SamengesteldeVoorwaardeOnderdeelInPredicaatContext,i)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_genesteSamengesteldeVoorwaardeInPredicaat

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGenesteSamengesteldeVoorwaardeInPredicaat" ):
                listener.enterGenesteSamengesteldeVoorwaardeInPredicaat(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGenesteSamengesteldeVoorwaardeInPredicaat" ):
                listener.exitGenesteSamengesteldeVoorwaardeInPredicaat(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGenesteSamengesteldeVoorwaardeInPredicaat" ):
                return visitor.visitGenesteSamengesteldeVoorwaardeInPredicaat(self)
            else:
                return visitor.visitChildren(self)




    def genesteSamengesteldeVoorwaardeInPredicaat(self):

        localctx = RegelSpraakParser.GenesteSamengesteldeVoorwaardeInPredicaatContext(self, self._ctx, self.state)
        self.enterRule(localctx, 228, self.RULE_genesteSamengesteldeVoorwaardeInPredicaat)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1414
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [154]:
                self.state = 1410
                self.match(RegelSpraakParser.VOLDOET)
                pass
            elif token in [153]:
                self.state = 1411
                self.match(RegelSpraakParser.VOLDOEN)
                pass
            elif token in [117]:
                self.state = 1412
                self.match(RegelSpraakParser.WORDT)
                self.state = 1413
                self.match(RegelSpraakParser.VOLDAAN)
                pass
            else:
                raise NoViableAltException(self)

            self.state = 1416
            self.match(RegelSpraakParser.AAN)
            self.state = 1417
            self.voorwaardeKwantificatie()
            self.state = 1418
            self.match(RegelSpraakParser.VOLGENDE)
            self.state = 1419
            _la = self._input.LA(1)
            if not(_la==161 or _la==162):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 1420
            self.match(RegelSpraakParser.COLON)
            self.state = 1422 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 1421
                    self.samengesteldeVoorwaardeOnderdeelInPredicaat()

                else:
                    raise NoViableAltException(self)
                self.state = 1424 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,172,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GetalVergelijkingsOperatorMeervoudContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ZIJN_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.ZIJN_GELIJK_AAN, 0)

        def ZIJN_ONGELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.ZIJN_ONGELIJK_AAN, 0)

        def ZIJN_GROTER_DAN(self):
            return self.getToken(RegelSpraakParser.ZIJN_GROTER_DAN, 0)

        def ZIJN_GROTER_OF_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.ZIJN_GROTER_OF_GELIJK_AAN, 0)

        def ZIJN_KLEINER_DAN(self):
            return self.getToken(RegelSpraakParser.ZIJN_KLEINER_DAN, 0)

        def ZIJN_KLEINER_OF_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.ZIJN_KLEINER_OF_GELIJK_AAN, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_getalVergelijkingsOperatorMeervoud

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGetalVergelijkingsOperatorMeervoud" ):
                listener.enterGetalVergelijkingsOperatorMeervoud(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGetalVergelijkingsOperatorMeervoud" ):
                listener.exitGetalVergelijkingsOperatorMeervoud(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGetalVergelijkingsOperatorMeervoud" ):
                return visitor.visitGetalVergelijkingsOperatorMeervoud(self)
            else:
                return visitor.visitChildren(self)




    def getalVergelijkingsOperatorMeervoud(self):

        localctx = RegelSpraakParser.GetalVergelijkingsOperatorMeervoudContext(self, self._ctx, self.state)
        self.enterRule(localctx, 230, self.RULE_getalVergelijkingsOperatorMeervoud)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1426
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 1134907106097364992) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TekstVergelijkingsOperatorMeervoudContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ZIJN_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.ZIJN_GELIJK_AAN, 0)

        def ZIJN_ONGELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.ZIJN_ONGELIJK_AAN, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_tekstVergelijkingsOperatorMeervoud

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTekstVergelijkingsOperatorMeervoud" ):
                listener.enterTekstVergelijkingsOperatorMeervoud(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTekstVergelijkingsOperatorMeervoud" ):
                listener.exitTekstVergelijkingsOperatorMeervoud(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTekstVergelijkingsOperatorMeervoud" ):
                return visitor.visitTekstVergelijkingsOperatorMeervoud(self)
            else:
                return visitor.visitChildren(self)




    def tekstVergelijkingsOperatorMeervoud(self):

        localctx = RegelSpraakParser.TekstVergelijkingsOperatorMeervoudContext(self, self._ctx, self.state)
        self.enterRule(localctx, 232, self.RULE_tekstVergelijkingsOperatorMeervoud)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1428
            _la = self._input.LA(1)
            if not(_la==54 or _la==55):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DatumVergelijkingsOperatorMeervoudContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ZIJN_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.ZIJN_GELIJK_AAN, 0)

        def ZIJN_ONGELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.ZIJN_ONGELIJK_AAN, 0)

        def ZIJN_LATER_DAN(self):
            return self.getToken(RegelSpraakParser.ZIJN_LATER_DAN, 0)

        def ZIJN_LATER_OF_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.ZIJN_LATER_OF_GELIJK_AAN, 0)

        def ZIJN_EERDER_DAN(self):
            return self.getToken(RegelSpraakParser.ZIJN_EERDER_DAN, 0)

        def ZIJN_EERDER_OF_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.ZIJN_EERDER_OF_GELIJK_AAN, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_datumVergelijkingsOperatorMeervoud

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDatumVergelijkingsOperatorMeervoud" ):
                listener.enterDatumVergelijkingsOperatorMeervoud(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDatumVergelijkingsOperatorMeervoud" ):
                listener.exitDatumVergelijkingsOperatorMeervoud(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDatumVergelijkingsOperatorMeervoud" ):
                return visitor.visitDatumVergelijkingsOperatorMeervoud(self)
            else:
                return visitor.visitChildren(self)




    def datumVergelijkingsOperatorMeervoud(self):

        localctx = RegelSpraakParser.DatumVergelijkingsOperatorMeervoudContext(self, self._ctx, self.state)
        self.enterRule(localctx, 234, self.RULE_datumVergelijkingsOperatorMeervoud)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1430
            _la = self._input.LA(1)
            if not(((((_la - 54)) & ~0x3f) == 0 and ((1 << (_la - 54)) & 15363) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GetalExpressieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_getalExpressie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGetalExpressie" ):
                listener.enterGetalExpressie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGetalExpressie" ):
                listener.exitGetalExpressie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGetalExpressie" ):
                return visitor.visitGetalExpressie(self)
            else:
                return visitor.visitChildren(self)




    def getalExpressie(self):

        localctx = RegelSpraakParser.GetalExpressieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 236, self.RULE_getalExpressie)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1432
            self.expressie()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TekstExpressieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_tekstExpressie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTekstExpressie" ):
                listener.enterTekstExpressie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTekstExpressie" ):
                listener.exitTekstExpressie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTekstExpressie" ):
                return visitor.visitTekstExpressie(self)
            else:
                return visitor.visitChildren(self)




    def tekstExpressie(self):

        localctx = RegelSpraakParser.TekstExpressieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 238, self.RULE_tekstExpressie)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1434
            self.expressie()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DatumExpressieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def datumLiteral(self):
            return self.getTypedRuleContext(RegelSpraakParser.DatumLiteralContext,0)


        def REKENDATUM(self):
            return self.getToken(RegelSpraakParser.REKENDATUM, 0)

        def REKENJAAR(self):
            return self.getToken(RegelSpraakParser.REKENJAAR, 0)

        def DE_DATUM_MET(self):
            return self.getToken(RegelSpraakParser.DE_DATUM_MET, 0)

        def LPAREN(self):
            return self.getToken(RegelSpraakParser.LPAREN, 0)

        def primaryExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.PrimaryExpressionContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.COMMA)
            else:
                return self.getToken(RegelSpraakParser.COMMA, i)

        def RPAREN(self):
            return self.getToken(RegelSpraakParser.RPAREN, 0)

        def DE_EERSTE_PAASDAG_VAN(self):
            return self.getToken(RegelSpraakParser.DE_EERSTE_PAASDAG_VAN, 0)

        def attribuutReferentie(self):
            return self.getTypedRuleContext(RegelSpraakParser.AttribuutReferentieContext,0)


        def bezieldeReferentie(self):
            return self.getTypedRuleContext(RegelSpraakParser.BezieldeReferentieContext,0)


        def parameterMetLidwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.ParameterMetLidwoordContext,0)


        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_datumExpressie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDatumExpressie" ):
                listener.enterDatumExpressie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDatumExpressie" ):
                listener.exitDatumExpressie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDatumExpressie" ):
                return visitor.visitDatumExpressie(self)
            else:
                return visitor.visitChildren(self)




    def datumExpressie(self):

        localctx = RegelSpraakParser.DatumExpressieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 240, self.RULE_datumExpressie)
        try:
            self.state = 1460
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,173,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1436
                self.datumLiteral()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1437
                self.match(RegelSpraakParser.REKENDATUM)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1438
                self.match(RegelSpraakParser.REKENJAAR)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 1439
                self.match(RegelSpraakParser.DE_DATUM_MET)
                self.state = 1440
                self.match(RegelSpraakParser.LPAREN)
                self.state = 1441
                self.primaryExpression(0)
                self.state = 1442
                self.match(RegelSpraakParser.COMMA)
                self.state = 1443
                self.primaryExpression(0)
                self.state = 1444
                self.match(RegelSpraakParser.COMMA)
                self.state = 1445
                self.primaryExpression(0)
                self.state = 1446
                self.match(RegelSpraakParser.RPAREN)
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 1448
                self.match(RegelSpraakParser.DE_EERSTE_PAASDAG_VAN)
                self.state = 1449
                self.match(RegelSpraakParser.LPAREN)
                self.state = 1450
                self.primaryExpression(0)
                self.state = 1451
                self.match(RegelSpraakParser.RPAREN)
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 1453
                self.attribuutReferentie()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 1454
                self.bezieldeReferentie()
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 1455
                self.parameterMetLidwoord()
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 1456
                self.match(RegelSpraakParser.LPAREN)
                self.state = 1457
                self.expressie()
                self.state = 1458
                self.match(RegelSpraakParser.RPAREN)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VariabeleDeelContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DAARBIJ_GELDT(self):
            return self.getToken(RegelSpraakParser.DAARBIJ_GELDT, 0)

        def DOT(self):
            return self.getToken(RegelSpraakParser.DOT, 0)

        def variabeleToekenning(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.VariabeleToekenningContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.VariabeleToekenningContext,i)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_variabeleDeel

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVariabeleDeel" ):
                listener.enterVariabeleDeel(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVariabeleDeel" ):
                listener.exitVariabeleDeel(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVariabeleDeel" ):
                return visitor.visitVariabeleDeel(self)
            else:
                return visitor.visitChildren(self)




    def variabeleDeel(self):

        localctx = RegelSpraakParser.VariabeleDeelContext(self, self._ctx, self.state)
        self.enterRule(localctx, 242, self.RULE_variabeleDeel)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1462
            self.match(RegelSpraakParser.DAARBIJ_GELDT)
            self.state = 1466
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((((_la - 212)) & ~0x3f) == 0 and ((1 << (_la - 212)) & 36028797018964001) != 0):
                self.state = 1463
                self.variabeleToekenning()
                self.state = 1468
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1469
            self.match(RegelSpraakParser.DOT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VariabeleToekenningContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.article = None # Token
            self.varName = None # Token
            self.varExpr = None # VariabeleExpressieContext

        def IS(self):
            return self.getToken(RegelSpraakParser.IS, 0)

        def IDENTIFIER(self):
            return self.getToken(RegelSpraakParser.IDENTIFIER, 0)

        def variabeleExpressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.VariabeleExpressieContext,0)


        def DE(self):
            return self.getToken(RegelSpraakParser.DE, 0)

        def HET(self):
            return self.getToken(RegelSpraakParser.HET, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_variabeleToekenning

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVariabeleToekenning" ):
                listener.enterVariabeleToekenning(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVariabeleToekenning" ):
                listener.exitVariabeleToekenning(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVariabeleToekenning" ):
                return visitor.visitVariabeleToekenning(self)
            else:
                return visitor.visitChildren(self)




    def variabeleToekenning(self):

        localctx = RegelSpraakParser.VariabeleToekenningContext(self, self._ctx, self.state)
        self.enterRule(localctx, 244, self.RULE_variabeleToekenning)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1472
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==212 or _la==217:
                self.state = 1471
                localctx.article = self._input.LT(1)
                _la = self._input.LA(1)
                if not(_la==212 or _la==217):
                    localctx.article = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


            self.state = 1474
            localctx.varName = self.match(RegelSpraakParser.IDENTIFIER)
            self.state = 1475
            self.match(RegelSpraakParser.IS)
            self.state = 1476
            localctx.varExpr = self.variabeleExpressie()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VariabeleExpressieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def primaryExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.PrimaryExpressionContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,i)


        def additiveOperator(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.AdditiveOperatorContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.AdditiveOperatorContext,i)


        def multiplicativeOperator(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.MultiplicativeOperatorContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.MultiplicativeOperatorContext,i)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_variabeleExpressie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVariabeleExpressie" ):
                listener.enterVariabeleExpressie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVariabeleExpressie" ):
                listener.exitVariabeleExpressie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVariabeleExpressie" ):
                return visitor.visitVariabeleExpressie(self)
            else:
                return visitor.visitChildren(self)




    def variabeleExpressie(self):

        localctx = RegelSpraakParser.VariabeleExpressieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 246, self.RULE_variabeleExpressie)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1478
            self.primaryExpression(0)
            self.state = 1487
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((((_la - 126)) & ~0x3f) == 0 and ((1 << (_la - 126)) & 67243011) != 0):
                self.state = 1481
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [137, 143, 152]:
                    self.state = 1479
                    self.additiveOperator()
                    pass
                elif token in [126, 127, 136]:
                    self.state = 1480
                    self.multiplicativeOperator()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 1483
                self.primaryExpression(0)
                self.state = 1489
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExpressieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_expressie

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class SimpleExprContext(ExpressieContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.ExpressieContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def logicalExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.LogicalExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSimpleExpr" ):
                listener.enterSimpleExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSimpleExpr" ):
                listener.exitSimpleExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSimpleExpr" ):
                return visitor.visitSimpleExpr(self)
            else:
                return visitor.visitChildren(self)


    class ExprBegrenzingAfrondingContext(ExpressieContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.ExpressieContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def logicalExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.LogicalExpressionContext,0)

        def COMMA(self):
            return self.getToken(RegelSpraakParser.COMMA, 0)
        def begrenzing(self):
            return self.getTypedRuleContext(RegelSpraakParser.BegrenzingContext,0)

        def afronding(self):
            return self.getTypedRuleContext(RegelSpraakParser.AfrondingContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExprBegrenzingAfronding" ):
                listener.enterExprBegrenzingAfronding(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExprBegrenzingAfronding" ):
                listener.exitExprBegrenzingAfronding(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExprBegrenzingAfronding" ):
                return visitor.visitExprBegrenzingAfronding(self)
            else:
                return visitor.visitChildren(self)


    class ExprBegrenzingContext(ExpressieContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.ExpressieContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def logicalExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.LogicalExpressionContext,0)

        def COMMA(self):
            return self.getToken(RegelSpraakParser.COMMA, 0)
        def begrenzing(self):
            return self.getTypedRuleContext(RegelSpraakParser.BegrenzingContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExprBegrenzing" ):
                listener.enterExprBegrenzing(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExprBegrenzing" ):
                listener.exitExprBegrenzing(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExprBegrenzing" ):
                return visitor.visitExprBegrenzing(self)
            else:
                return visitor.visitChildren(self)


    class ExprAfrondingContext(ExpressieContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.ExpressieContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def logicalExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.LogicalExpressionContext,0)

        def afronding(self):
            return self.getTypedRuleContext(RegelSpraakParser.AfrondingContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExprAfronding" ):
                listener.enterExprAfronding(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExprAfronding" ):
                listener.exitExprAfronding(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExprAfronding" ):
                return visitor.visitExprAfronding(self)
            else:
                return visitor.visitChildren(self)



    def expressie(self):

        localctx = RegelSpraakParser.ExpressieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 248, self.RULE_expressie)
        try:
            self.state = 1503
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,178,self._ctx)
            if la_ == 1:
                localctx = RegelSpraakParser.ExprBegrenzingAfrondingContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1490
                self.logicalExpression()
                self.state = 1491
                self.match(RegelSpraakParser.COMMA)
                self.state = 1492
                self.begrenzing()
                self.state = 1493
                self.afronding()
                pass

            elif la_ == 2:
                localctx = RegelSpraakParser.ExprBegrenzingContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1495
                self.logicalExpression()
                self.state = 1496
                self.match(RegelSpraakParser.COMMA)
                self.state = 1497
                self.begrenzing()
                pass

            elif la_ == 3:
                localctx = RegelSpraakParser.ExprAfrondingContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 1499
                self.logicalExpression()
                self.state = 1500
                self.afronding()
                pass

            elif la_ == 4:
                localctx = RegelSpraakParser.SimpleExprContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 1502
                self.logicalExpression()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SimpleExpressieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_simpleExpressie

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class SimpleExprBegrenzingContext(SimpleExpressieContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.SimpleExpressieContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def comparisonExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.ComparisonExpressionContext,0)

        def COMMA(self):
            return self.getToken(RegelSpraakParser.COMMA, 0)
        def begrenzing(self):
            return self.getTypedRuleContext(RegelSpraakParser.BegrenzingContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSimpleExprBegrenzing" ):
                listener.enterSimpleExprBegrenzing(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSimpleExprBegrenzing" ):
                listener.exitSimpleExprBegrenzing(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSimpleExprBegrenzing" ):
                return visitor.visitSimpleExprBegrenzing(self)
            else:
                return visitor.visitChildren(self)


    class SimpleExprAfrondingContext(SimpleExpressieContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.SimpleExpressieContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def comparisonExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.ComparisonExpressionContext,0)

        def afronding(self):
            return self.getTypedRuleContext(RegelSpraakParser.AfrondingContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSimpleExprAfronding" ):
                listener.enterSimpleExprAfronding(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSimpleExprAfronding" ):
                listener.exitSimpleExprAfronding(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSimpleExprAfronding" ):
                return visitor.visitSimpleExprAfronding(self)
            else:
                return visitor.visitChildren(self)


    class SimpleExprBegrenzingAfrondingContext(SimpleExpressieContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.SimpleExpressieContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def comparisonExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.ComparisonExpressionContext,0)

        def COMMA(self):
            return self.getToken(RegelSpraakParser.COMMA, 0)
        def begrenzing(self):
            return self.getTypedRuleContext(RegelSpraakParser.BegrenzingContext,0)

        def afronding(self):
            return self.getTypedRuleContext(RegelSpraakParser.AfrondingContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSimpleExprBegrenzingAfronding" ):
                listener.enterSimpleExprBegrenzingAfronding(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSimpleExprBegrenzingAfronding" ):
                listener.exitSimpleExprBegrenzingAfronding(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSimpleExprBegrenzingAfronding" ):
                return visitor.visitSimpleExprBegrenzingAfronding(self)
            else:
                return visitor.visitChildren(self)


    class SimpleExprBaseContext(SimpleExpressieContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.SimpleExpressieContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def comparisonExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.ComparisonExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSimpleExprBase" ):
                listener.enterSimpleExprBase(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSimpleExprBase" ):
                listener.exitSimpleExprBase(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSimpleExprBase" ):
                return visitor.visitSimpleExprBase(self)
            else:
                return visitor.visitChildren(self)



    def simpleExpressie(self):

        localctx = RegelSpraakParser.SimpleExpressieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 250, self.RULE_simpleExpressie)
        try:
            self.state = 1518
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,179,self._ctx)
            if la_ == 1:
                localctx = RegelSpraakParser.SimpleExprBegrenzingAfrondingContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1505
                self.comparisonExpression()
                self.state = 1506
                self.match(RegelSpraakParser.COMMA)
                self.state = 1507
                self.begrenzing()
                self.state = 1508
                self.afronding()
                pass

            elif la_ == 2:
                localctx = RegelSpraakParser.SimpleExprBegrenzingContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1510
                self.comparisonExpression()
                self.state = 1511
                self.match(RegelSpraakParser.COMMA)
                self.state = 1512
                self.begrenzing()
                pass

            elif la_ == 3:
                localctx = RegelSpraakParser.SimpleExprAfrondingContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 1514
                self.comparisonExpression()
                self.state = 1515
                self.afronding()
                pass

            elif la_ == 4:
                localctx = RegelSpraakParser.SimpleExprBaseContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 1517
                self.comparisonExpression()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LogicalExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_logicalExpression

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class LogicalExprContext(LogicalExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.LogicalExpressionContext
            super().__init__(parser)
            self.left = None # ComparisonExpressionContext
            self.op = None # Token
            self.right = None # LogicalExpressionContext
            self.copyFrom(ctx)

        def comparisonExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.ComparisonExpressionContext,0)

        def logicalExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.LogicalExpressionContext,0)

        def EN(self):
            return self.getToken(RegelSpraakParser.EN, 0)
        def OF(self):
            return self.getToken(RegelSpraakParser.OF, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLogicalExpr" ):
                listener.enterLogicalExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLogicalExpr" ):
                listener.exitLogicalExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLogicalExpr" ):
                return visitor.visitLogicalExpr(self)
            else:
                return visitor.visitChildren(self)



    def logicalExpression(self):

        localctx = RegelSpraakParser.LogicalExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 252, self.RULE_logicalExpression)
        self._la = 0 # Token type
        try:
            localctx = RegelSpraakParser.LogicalExprContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 1520
            localctx.left = self.comparisonExpression()
            self.state = 1523
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,180,self._ctx)
            if la_ == 1:
                self.state = 1521
                localctx.op = self._input.LT(1)
                _la = self._input.LA(1)
                if not(_la==216 or _la==229):
                    localctx.op = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1522
                localctx.right = self.logicalExpression()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ComparisonExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_comparisonExpression

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class GelijkIsAanOfExprContext(ComparisonExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.ComparisonExpressionContext
            super().__init__(parser)
            self.left = None # AdditiveExpressionContext
            self.op = None # GelijkIsAanOperatorContext
            self.firstValue = None # LiteralValueContext
            self._literalValue = None # LiteralValueContext
            self.middleValues = list() # of LiteralValueContexts
            self.lastValue = None # LiteralValueContext
            self.copyFrom(ctx)

        def OF(self):
            return self.getToken(RegelSpraakParser.OF, 0)
        def additiveExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.AdditiveExpressionContext,0)

        def gelijkIsAanOperator(self):
            return self.getTypedRuleContext(RegelSpraakParser.GelijkIsAanOperatorContext,0)

        def literalValue(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.LiteralValueContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.LiteralValueContext,i)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.COMMA)
            else:
                return self.getToken(RegelSpraakParser.COMMA, i)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGelijkIsAanOfExpr" ):
                listener.enterGelijkIsAanOfExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGelijkIsAanOfExpr" ):
                listener.exitGelijkIsAanOfExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGelijkIsAanOfExpr" ):
                return visitor.visitGelijkIsAanOfExpr(self)
            else:
                return visitor.visitChildren(self)


    class SubordinateClauseExprContext(ComparisonExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.ComparisonExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def subordinateClauseExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.SubordinateClauseExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSubordinateClauseExpr" ):
                listener.enterSubordinateClauseExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSubordinateClauseExpr" ):
                listener.exitSubordinateClauseExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSubordinateClauseExpr" ):
                return visitor.visitSubordinateClauseExpr(self)
            else:
                return visitor.visitChildren(self)


    class PeriodeCheckExprContext(ComparisonExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.ComparisonExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def periodevergelijkingElementair(self):
            return self.getTypedRuleContext(RegelSpraakParser.PeriodevergelijkingElementairContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPeriodeCheckExpr" ):
                listener.enterPeriodeCheckExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPeriodeCheckExpr" ):
                listener.exitPeriodeCheckExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPeriodeCheckExpr" ):
                return visitor.visitPeriodeCheckExpr(self)
            else:
                return visitor.visitChildren(self)


    class BinaryComparisonExprContext(ComparisonExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.ComparisonExpressionContext
            super().__init__(parser)
            self.left = None # AdditiveExpressionContext
            self.right = None # AdditiveExpressionContext
            self.copyFrom(ctx)

        def additiveExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.AdditiveExpressionContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.AdditiveExpressionContext,i)

        def comparisonOperator(self):
            return self.getTypedRuleContext(RegelSpraakParser.ComparisonOperatorContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBinaryComparisonExpr" ):
                listener.enterBinaryComparisonExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBinaryComparisonExpr" ):
                listener.exitBinaryComparisonExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBinaryComparisonExpr" ):
                return visitor.visitBinaryComparisonExpr(self)
            else:
                return visitor.visitChildren(self)


    class UnaryConditionExprContext(ComparisonExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.ComparisonExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def unaryCondition(self):
            return self.getTypedRuleContext(RegelSpraakParser.UnaryConditionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnaryConditionExpr" ):
                listener.enterUnaryConditionExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnaryConditionExpr" ):
                listener.exitUnaryConditionExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnaryConditionExpr" ):
                return visitor.visitUnaryConditionExpr(self)
            else:
                return visitor.visitChildren(self)


    class HeeftKenmerkExprContext(ComparisonExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.ComparisonExpressionContext
            super().__init__(parser)
            self.left = None # AdditiveExpressionContext
            self.copyFrom(ctx)

        def HEEFT(self):
            return self.getToken(RegelSpraakParser.HEEFT, 0)
        def naamwoordWithNumbers(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordWithNumbersContext,0)

        def additiveExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.AdditiveExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterHeeftKenmerkExpr" ):
                listener.enterHeeftKenmerkExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitHeeftKenmerkExpr" ):
                listener.exitHeeftKenmerkExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitHeeftKenmerkExpr" ):
                return visitor.visitHeeftKenmerkExpr(self)
            else:
                return visitor.visitChildren(self)


    class IsKenmerkExprContext(ComparisonExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.ComparisonExpressionContext
            super().__init__(parser)
            self.left = None # AdditiveExpressionContext
            self.copyFrom(ctx)

        def IS(self):
            return self.getToken(RegelSpraakParser.IS, 0)
        def naamwoordWithNumbers(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordWithNumbersContext,0)

        def additiveExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.AdditiveExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIsKenmerkExpr" ):
                listener.enterIsKenmerkExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIsKenmerkExpr" ):
                listener.exitIsKenmerkExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIsKenmerkExpr" ):
                return visitor.visitIsKenmerkExpr(self)
            else:
                return visitor.visitChildren(self)


    class RegelStatusConditionExprContext(ComparisonExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.ComparisonExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def regelStatusCondition(self):
            return self.getTypedRuleContext(RegelSpraakParser.RegelStatusConditionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRegelStatusConditionExpr" ):
                listener.enterRegelStatusConditionExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRegelStatusConditionExpr" ):
                listener.exitRegelStatusConditionExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRegelStatusConditionExpr" ):
                return visitor.visitRegelStatusConditionExpr(self)
            else:
                return visitor.visitChildren(self)



    def comparisonExpression(self):

        localctx = RegelSpraakParser.ComparisonExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 254, self.RULE_comparisonExpression)
        self._la = 0 # Token type
        try:
            self.state = 1556
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,183,self._ctx)
            if la_ == 1:
                localctx = RegelSpraakParser.SubordinateClauseExprContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1525
                self.subordinateClauseExpression()
                pass

            elif la_ == 2:
                localctx = RegelSpraakParser.PeriodeCheckExprContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1526
                self.periodevergelijkingElementair()
                pass

            elif la_ == 3:
                localctx = RegelSpraakParser.IsKenmerkExprContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 1527
                localctx.left = self.additiveExpression()
                self.state = 1528
                self.match(RegelSpraakParser.IS)
                self.state = 1529
                self.naamwoordWithNumbers()
                pass

            elif la_ == 4:
                localctx = RegelSpraakParser.HeeftKenmerkExprContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 1531
                localctx.left = self.additiveExpression()
                self.state = 1532
                self.match(RegelSpraakParser.HEEFT)
                self.state = 1533
                self.naamwoordWithNumbers()
                pass

            elif la_ == 5:
                localctx = RegelSpraakParser.GelijkIsAanOfExprContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 1535
                localctx.left = self.additiveExpression()
                self.state = 1536
                localctx.op = self.gelijkIsAanOperator()
                self.state = 1537
                localctx.firstValue = self.literalValue()
                self.state = 1542
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==278:
                    self.state = 1538
                    self.match(RegelSpraakParser.COMMA)
                    self.state = 1539
                    localctx._literalValue = self.literalValue()
                    localctx.middleValues.append(localctx._literalValue)
                    self.state = 1544
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 1545
                self.match(RegelSpraakParser.OF)
                self.state = 1546
                localctx.lastValue = self.literalValue()
                pass

            elif la_ == 6:
                localctx = RegelSpraakParser.BinaryComparisonExprContext(self, localctx)
                self.enterOuterAlt(localctx, 6)
                self.state = 1548
                localctx.left = self.additiveExpression()
                self.state = 1552
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,182,self._ctx)
                if la_ == 1:
                    self.state = 1549
                    self.comparisonOperator()
                    self.state = 1550
                    localctx.right = self.additiveExpression()


                pass

            elif la_ == 7:
                localctx = RegelSpraakParser.UnaryConditionExprContext(self, localctx)
                self.enterOuterAlt(localctx, 7)
                self.state = 1554
                self.unaryCondition()
                pass

            elif la_ == 8:
                localctx = RegelSpraakParser.RegelStatusConditionExprContext(self, localctx)
                self.enterOuterAlt(localctx, 8)
                self.state = 1555
                self.regelStatusCondition()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LiteralValueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ENUM_LITERAL(self):
            return self.getToken(RegelSpraakParser.ENUM_LITERAL, 0)

        def STRING_LITERAL(self):
            return self.getToken(RegelSpraakParser.STRING_LITERAL, 0)

        def NUMBER(self):
            return self.getToken(RegelSpraakParser.NUMBER, 0)

        def unitIdentifier(self):
            return self.getTypedRuleContext(RegelSpraakParser.UnitIdentifierContext,0)


        def PERCENTAGE_LITERAL(self):
            return self.getToken(RegelSpraakParser.PERCENTAGE_LITERAL, 0)

        def datumLiteral(self):
            return self.getTypedRuleContext(RegelSpraakParser.DatumLiteralContext,0)


        def identifier(self):
            return self.getTypedRuleContext(RegelSpraakParser.IdentifierContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_literalValue

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLiteralValue" ):
                listener.enterLiteralValue(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLiteralValue" ):
                listener.exitLiteralValue(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLiteralValue" ):
                return visitor.visitLiteralValue(self)
            else:
                return visitor.visitChildren(self)




    def literalValue(self):

        localctx = RegelSpraakParser.LiteralValueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 256, self.RULE_literalValue)
        try:
            self.state = 1567
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [273]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1558
                self.match(RegelSpraakParser.ENUM_LITERAL)
                pass
            elif token in [272]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1559
                self.match(RegelSpraakParser.STRING_LITERAL)
                pass
            elif token in [268]:
                self.enterOuterAlt(localctx, 3)
                self.state = 1560
                self.match(RegelSpraakParser.NUMBER)
                self.state = 1562
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,184,self._ctx)
                if la_ == 1:
                    self.state = 1561
                    self.unitIdentifier()


                pass
            elif token in [271]:
                self.enterOuterAlt(localctx, 4)
                self.state = 1564
                self.match(RegelSpraakParser.PERCENTAGE_LITERAL)
                pass
            elif token in [270]:
                self.enterOuterAlt(localctx, 5)
                self.state = 1565
                self.datumLiteral()
                pass
            elif token in [267]:
                self.enterOuterAlt(localctx, 6)
                self.state = 1566
                self.identifier()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GelijkIsAanOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GELIJK_IS_AAN(self):
            return self.getToken(RegelSpraakParser.GELIJK_IS_AAN, 0)

        def IS_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.IS_GELIJK_AAN, 0)

        def GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.GELIJK_AAN, 0)

        def ZIJN_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.ZIJN_GELIJK_AAN, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_gelijkIsAanOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGelijkIsAanOperator" ):
                listener.enterGelijkIsAanOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGelijkIsAanOperator" ):
                listener.exitGelijkIsAanOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGelijkIsAanOperator" ):
                return visitor.visitGelijkIsAanOperator(self)
            else:
                return visitor.visitChildren(self)




    def gelijkIsAanOperator(self):

        localctx = RegelSpraakParser.GelijkIsAanOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 258, self.RULE_gelijkIsAanOperator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1569
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 18436610974547968) != 0) or _la==128):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ComparisonOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.GELIJK_AAN, 0)

        def ONGELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.ONGELIJK_AAN, 0)

        def GELIJK_IS_AAN(self):
            return self.getToken(RegelSpraakParser.GELIJK_IS_AAN, 0)

        def GROTER_DAN(self):
            return self.getToken(RegelSpraakParser.GROTER_DAN, 0)

        def GROTER_OF_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.GROTER_OF_GELIJK_AAN, 0)

        def KLEINER_DAN(self):
            return self.getToken(RegelSpraakParser.KLEINER_DAN, 0)

        def KLEINER_OF_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.KLEINER_OF_GELIJK_AAN, 0)

        def KLEINER_IS_DAN(self):
            return self.getToken(RegelSpraakParser.KLEINER_IS_DAN, 0)

        def GROTER_IS_DAN(self):
            return self.getToken(RegelSpraakParser.GROTER_IS_DAN, 0)

        def IS(self):
            return self.getToken(RegelSpraakParser.IS, 0)

        def IN(self):
            return self.getToken(RegelSpraakParser.IN, 0)

        def LATER_DAN(self):
            return self.getToken(RegelSpraakParser.LATER_DAN, 0)

        def LATER_OF_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.LATER_OF_GELIJK_AAN, 0)

        def EERDER_DAN(self):
            return self.getToken(RegelSpraakParser.EERDER_DAN, 0)

        def EERDER_OF_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.EERDER_OF_GELIJK_AAN, 0)

        def NIET(self):
            return self.getToken(RegelSpraakParser.NIET, 0)

        def IS_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.IS_GELIJK_AAN, 0)

        def IS_ONGELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.IS_ONGELIJK_AAN, 0)

        def IS_KLEINER_DAN(self):
            return self.getToken(RegelSpraakParser.IS_KLEINER_DAN, 0)

        def IS_KLEINER_OF_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.IS_KLEINER_OF_GELIJK_AAN, 0)

        def IS_GROTER_DAN(self):
            return self.getToken(RegelSpraakParser.IS_GROTER_DAN, 0)

        def IS_GROTER_OF_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.IS_GROTER_OF_GELIJK_AAN, 0)

        def ZIJN_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.ZIJN_GELIJK_AAN, 0)

        def ZIJN_ONGELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.ZIJN_ONGELIJK_AAN, 0)

        def ZIJN_KLEINER_DAN(self):
            return self.getToken(RegelSpraakParser.ZIJN_KLEINER_DAN, 0)

        def ZIJN_KLEINER_OF_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.ZIJN_KLEINER_OF_GELIJK_AAN, 0)

        def ZIJN_GROTER_DAN(self):
            return self.getToken(RegelSpraakParser.ZIJN_GROTER_DAN, 0)

        def ZIJN_GROTER_OF_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.ZIJN_GROTER_OF_GELIJK_AAN, 0)

        def IS_LATER_DAN(self):
            return self.getToken(RegelSpraakParser.IS_LATER_DAN, 0)

        def IS_LATER_OF_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.IS_LATER_OF_GELIJK_AAN, 0)

        def IS_EERDER_DAN(self):
            return self.getToken(RegelSpraakParser.IS_EERDER_DAN, 0)

        def IS_EERDER_OF_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.IS_EERDER_OF_GELIJK_AAN, 0)

        def ZIJN_LATER_DAN(self):
            return self.getToken(RegelSpraakParser.ZIJN_LATER_DAN, 0)

        def ZIJN_LATER_OF_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.ZIJN_LATER_OF_GELIJK_AAN, 0)

        def ZIJN_EERDER_DAN(self):
            return self.getToken(RegelSpraakParser.ZIJN_EERDER_DAN, 0)

        def ZIJN_EERDER_OF_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.ZIJN_EERDER_OF_GELIJK_AAN, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_comparisonOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterComparisonOperator" ):
                listener.enterComparisonOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitComparisonOperator" ):
                listener.exitComparisonOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitComparisonOperator" ):
                return visitor.visitComparisonOperator(self)
            else:
                return visitor.visitChildren(self)




    def comparisonOperator(self):

        localctx = RegelSpraakParser.ComparisonOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 260, self.RULE_comparisonOperator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1571
            _la = self._input.LA(1)
            if not(((((_la - 22)) & ~0x3f) == 0 and ((1 << (_la - 22)) & 70368710819855) != 0) or ((((_la - 113)) & ~0x3f) == 0 and ((1 << (_la - 113)) & 674533377) != 0) or _la==220):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AdditiveExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.left = None # MultiplicativeExpressionContext
            self.right = None # MultiplicativeExpressionContext

        def multiplicativeExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.MultiplicativeExpressionContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.MultiplicativeExpressionContext,i)


        def additiveOperator(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.AdditiveOperatorContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.AdditiveOperatorContext,i)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_additiveExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAdditiveExpression" ):
                listener.enterAdditiveExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAdditiveExpression" ):
                listener.exitAdditiveExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAdditiveExpression" ):
                return visitor.visitAdditiveExpression(self)
            else:
                return visitor.visitChildren(self)




    def additiveExpression(self):

        localctx = RegelSpraakParser.AdditiveExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 262, self.RULE_additiveExpression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1573
            localctx.left = self.multiplicativeExpression()
            self.state = 1579
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,186,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 1574
                    self.additiveOperator()
                    self.state = 1575
                    localctx.right = self.multiplicativeExpression() 
                self.state = 1581
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,186,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AdditiveOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PLUS(self):
            return self.getToken(RegelSpraakParser.PLUS, 0)

        def MIN(self):
            return self.getToken(RegelSpraakParser.MIN, 0)

        def VERMINDERD_MET(self):
            return self.getToken(RegelSpraakParser.VERMINDERD_MET, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_additiveOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAdditiveOperator" ):
                listener.enterAdditiveOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAdditiveOperator" ):
                listener.exitAdditiveOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAdditiveOperator" ):
                return visitor.visitAdditiveOperator(self)
            else:
                return visitor.visitChildren(self)




    def additiveOperator(self):

        localctx = RegelSpraakParser.AdditiveOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 264, self.RULE_additiveOperator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1582
            _la = self._input.LA(1)
            if not(((((_la - 137)) & ~0x3f) == 0 and ((1 << (_la - 137)) & 32833) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MultiplicativeExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.left = None # PowerExpressionContext
            self.right = None # PowerExpressionContext

        def powerExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.PowerExpressionContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.PowerExpressionContext,i)


        def multiplicativeOperator(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.MultiplicativeOperatorContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.MultiplicativeOperatorContext,i)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_multiplicativeExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMultiplicativeExpression" ):
                listener.enterMultiplicativeExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMultiplicativeExpression" ):
                listener.exitMultiplicativeExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMultiplicativeExpression" ):
                return visitor.visitMultiplicativeExpression(self)
            else:
                return visitor.visitChildren(self)




    def multiplicativeExpression(self):

        localctx = RegelSpraakParser.MultiplicativeExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 266, self.RULE_multiplicativeExpression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1584
            localctx.left = self.powerExpression()
            self.state = 1590
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,187,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 1585
                    self.multiplicativeOperator()
                    self.state = 1586
                    localctx.right = self.powerExpression() 
                self.state = 1592
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,187,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MultiplicativeOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MAAL(self):
            return self.getToken(RegelSpraakParser.MAAL, 0)

        def GEDEELD_DOOR(self):
            return self.getToken(RegelSpraakParser.GEDEELD_DOOR, 0)

        def GEDEELD_DOOR_ABS(self):
            return self.getToken(RegelSpraakParser.GEDEELD_DOOR_ABS, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_multiplicativeOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMultiplicativeOperator" ):
                listener.enterMultiplicativeOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMultiplicativeOperator" ):
                listener.exitMultiplicativeOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMultiplicativeOperator" ):
                return visitor.visitMultiplicativeOperator(self)
            else:
                return visitor.visitChildren(self)




    def multiplicativeOperator(self):

        localctx = RegelSpraakParser.MultiplicativeOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 268, self.RULE_multiplicativeOperator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1593
            _la = self._input.LA(1)
            if not(((((_la - 126)) & ~0x3f) == 0 and ((1 << (_la - 126)) & 1027) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PowerExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.left = None # PrimaryExpressionContext
            self.right = None # PrimaryExpressionContext

        def primaryExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.PrimaryExpressionContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,i)


        def powerOperator(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.PowerOperatorContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.PowerOperatorContext,i)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_powerExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPowerExpression" ):
                listener.enterPowerExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPowerExpression" ):
                listener.exitPowerExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPowerExpression" ):
                return visitor.visitPowerExpression(self)
            else:
                return visitor.visitChildren(self)




    def powerExpression(self):

        localctx = RegelSpraakParser.PowerExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 270, self.RULE_powerExpression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1595
            localctx.left = self.primaryExpression(0)
            self.state = 1601
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,188,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 1596
                    self.powerOperator()
                    self.state = 1597
                    localctx.right = self.primaryExpression(0) 
                self.state = 1603
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,188,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PowerOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TOT_DE_MACHT(self):
            return self.getToken(RegelSpraakParser.TOT_DE_MACHT, 0)

        def CARET(self):
            return self.getToken(RegelSpraakParser.CARET, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_powerOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPowerOperator" ):
                listener.enterPowerOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPowerOperator" ):
                listener.exitPowerOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPowerOperator" ):
                return visitor.visitPowerOperator(self)
            else:
                return visitor.visitChildren(self)




    def powerOperator(self):

        localctx = RegelSpraakParser.PowerOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 272, self.RULE_powerOperator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1604
            _la = self._input.LA(1)
            if not(_la==147 or _la==288):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PrimaryExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_primaryExpression

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)


    class WortelFuncExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def DE_WORTEL_VAN(self):
            return self.getToken(RegelSpraakParser.DE_WORTEL_VAN, 0)
        def primaryExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWortelFuncExpr" ):
                listener.enterWortelFuncExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWortelFuncExpr" ):
                listener.exitWortelFuncExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitWortelFuncExpr" ):
                return visitor.visitWortelFuncExpr(self)
            else:
                return visitor.visitChildren(self)


    class BooleanTrueLiteralExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def WAAR(self):
            return self.getToken(RegelSpraakParser.WAAR, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBooleanTrueLiteralExpr" ):
                listener.enterBooleanTrueLiteralExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBooleanTrueLiteralExpr" ):
                listener.exitBooleanTrueLiteralExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBooleanTrueLiteralExpr" ):
                return visitor.visitBooleanTrueLiteralExpr(self)
            else:
                return visitor.visitChildren(self)


    class AbsValFuncExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def DE_ABSOLUTE_WAARDE_VAN(self):
            return self.getToken(RegelSpraakParser.DE_ABSOLUTE_WAARDE_VAN, 0)
        def LPAREN(self):
            return self.getToken(RegelSpraakParser.LPAREN, 0)
        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)

        def RPAREN(self):
            return self.getToken(RegelSpraakParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAbsValFuncExpr" ):
                listener.enterAbsValFuncExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAbsValFuncExpr" ):
                listener.exitAbsValFuncExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAbsValFuncExpr" ):
                return visitor.visitAbsValFuncExpr(self)
            else:
                return visitor.visitChildren(self)


    class MaxValFuncExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def DE_MAXIMALE_WAARDE_VAN(self):
            return self.getToken(RegelSpraakParser.DE_MAXIMALE_WAARDE_VAN, 0)
        def primaryExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.PrimaryExpressionContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,i)

        def EN(self):
            return self.getToken(RegelSpraakParser.EN, 0)
        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.COMMA)
            else:
                return self.getToken(RegelSpraakParser.COMMA, i)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMaxValFuncExpr" ):
                listener.enterMaxValFuncExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMaxValFuncExpr" ):
                listener.exitMaxValFuncExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMaxValFuncExpr" ):
                return visitor.visitMaxValFuncExpr(self)
            else:
                return visitor.visitChildren(self)


    class RekendatumKeywordExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def REKENDATUM(self):
            return self.getToken(RegelSpraakParser.REKENDATUM, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRekendatumKeywordExpr" ):
                listener.enterRekendatumKeywordExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRekendatumKeywordExpr" ):
                listener.exitRekendatumKeywordExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRekendatumKeywordExpr" ):
                return visitor.visitRekendatumKeywordExpr(self)
            else:
                return visitor.visitChildren(self)


    class EnumLiteralExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ENUM_LITERAL(self):
            return self.getToken(RegelSpraakParser.ENUM_LITERAL, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEnumLiteralExpr" ):
                listener.enterEnumLiteralExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEnumLiteralExpr" ):
                listener.exitEnumLiteralExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEnumLiteralExpr" ):
                return visitor.visitEnumLiteralExpr(self)
            else:
                return visitor.visitChildren(self)


    class NumberLiteralExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def NUMBER(self):
            return self.getToken(RegelSpraakParser.NUMBER, 0)
        def unitIdentifier(self):
            return self.getTypedRuleContext(RegelSpraakParser.UnitIdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumberLiteralExpr" ):
                listener.enterNumberLiteralExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumberLiteralExpr" ):
                listener.exitNumberLiteralExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNumberLiteralExpr" ):
                return visitor.visitNumberLiteralExpr(self)
            else:
                return visitor.visitChildren(self)


    class DatumLiteralExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def datumLiteral(self):
            return self.getTypedRuleContext(RegelSpraakParser.DatumLiteralContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDatumLiteralExpr" ):
                listener.enterDatumLiteralExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDatumLiteralExpr" ):
                listener.exitDatumLiteralExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDatumLiteralExpr" ):
                return visitor.visitDatumLiteralExpr(self)
            else:
                return visitor.visitChildren(self)


    class AantalFuncExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def aggregationSubject(self):
            return self.getTypedRuleContext(RegelSpraakParser.AggregationSubjectContext,0)

        def HET(self):
            return self.getToken(RegelSpraakParser.HET, 0)
        def AANTAL(self):
            return self.getToken(RegelSpraakParser.AANTAL, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAantalFuncExpr" ):
                listener.enterAantalFuncExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAantalFuncExpr" ):
                listener.exitAantalFuncExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAantalFuncExpr" ):
                return visitor.visitAantalFuncExpr(self)
            else:
                return visitor.visitChildren(self)


    class UnaryNietExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def NIET(self):
            return self.getToken(RegelSpraakParser.NIET, 0)
        def primaryExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnaryNietExpr" ):
                listener.enterUnaryNietExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnaryNietExpr" ):
                listener.exitUnaryNietExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnaryNietExpr" ):
                return visitor.visitUnaryNietExpr(self)
            else:
                return visitor.visitChildren(self)


    class ConcatenatieExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def CONCATENATIE_VAN(self):
            return self.getToken(RegelSpraakParser.CONCATENATIE_VAN, 0)
        def primaryExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.PrimaryExpressionContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,i)

        def EN(self):
            return self.getToken(RegelSpraakParser.EN, 0)
        def OF(self):
            return self.getToken(RegelSpraakParser.OF, 0)
        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.COMMA)
            else:
                return self.getToken(RegelSpraakParser.COMMA, i)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConcatenatieExpr" ):
                listener.enterConcatenatieExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConcatenatieExpr" ):
                listener.exitConcatenatieExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConcatenatieExpr" ):
                return visitor.visitConcatenatieExpr(self)
            else:
                return visitor.visitChildren(self)


    class SomAlleAttribuutExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def SOM_VAN(self):
            return self.getToken(RegelSpraakParser.SOM_VAN, 0)
        def ALLE(self):
            return self.getToken(RegelSpraakParser.ALLE, 0)
        def attribuutReferentie(self):
            return self.getTypedRuleContext(RegelSpraakParser.AttribuutReferentieContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSomAlleAttribuutExpr" ):
                listener.enterSomAlleAttribuutExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSomAlleAttribuutExpr" ):
                listener.exitSomAlleAttribuutExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSomAlleAttribuutExpr" ):
                return visitor.visitSomAlleAttribuutExpr(self)
            else:
                return visitor.visitChildren(self)


    class AttrRefExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def attribuutReferentie(self):
            return self.getTypedRuleContext(RegelSpraakParser.AttribuutReferentieContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAttrRefExpr" ):
                listener.enterAttrRefExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAttrRefExpr" ):
                listener.exitAttrRefExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAttrRefExpr" ):
                return visitor.visitAttrRefExpr(self)
            else:
                return visitor.visitChildren(self)


    class DagUitFuncExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def DE(self):
            return self.getToken(RegelSpraakParser.DE, 0)
        def DAG(self):
            return self.getToken(RegelSpraakParser.DAG, 0)
        def UIT(self):
            return self.getToken(RegelSpraakParser.UIT, 0)
        def primaryExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDagUitFuncExpr" ):
                listener.enterDagUitFuncExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDagUitFuncExpr" ):
                listener.exitDagUitFuncExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDagUitFuncExpr" ):
                return visitor.visitDagUitFuncExpr(self)
            else:
                return visitor.visitChildren(self)


    class BegrenzingExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def primaryExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,0)

        def COMMA(self):
            return self.getToken(RegelSpraakParser.COMMA, 0)
        def begrenzing(self):
            return self.getTypedRuleContext(RegelSpraakParser.BegrenzingContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBegrenzingExpr" ):
                listener.enterBegrenzingExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBegrenzingExpr" ):
                listener.exitBegrenzingExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBegrenzingExpr" ):
                return visitor.visitBegrenzingExpr(self)
            else:
                return visitor.visitChildren(self)


    class NaamwoordExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNaamwoordExpr" ):
                listener.enterNaamwoordExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNaamwoordExpr" ):
                listener.exitNaamwoordExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNaamwoordExpr" ):
                return visitor.visitNaamwoordExpr(self)
            else:
                return visitor.visitChildren(self)


    class BooleanFalseLiteralExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ONWAAR(self):
            return self.getToken(RegelSpraakParser.ONWAAR, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBooleanFalseLiteralExpr" ):
                listener.enterBooleanFalseLiteralExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBooleanFalseLiteralExpr" ):
                listener.exitBooleanFalseLiteralExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBooleanFalseLiteralExpr" ):
                return visitor.visitBooleanFalseLiteralExpr(self)
            else:
                return visitor.visitChildren(self)


    class JaarUitFuncExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def HET(self):
            return self.getToken(RegelSpraakParser.HET, 0)
        def JAAR(self):
            return self.getToken(RegelSpraakParser.JAAR, 0)
        def UIT(self):
            return self.getToken(RegelSpraakParser.UIT, 0)
        def primaryExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterJaarUitFuncExpr" ):
                listener.enterJaarUitFuncExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitJaarUitFuncExpr" ):
                listener.exitJaarUitFuncExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitJaarUitFuncExpr" ):
                return visitor.visitJaarUitFuncExpr(self)
            else:
                return visitor.visitChildren(self)


    class TotaalVanExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def HET_TOTAAL_VAN(self):
            return self.getToken(RegelSpraakParser.HET_TOTAAL_VAN, 0)
        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)

        def conditieBijExpressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ConditieBijExpressieContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTotaalVanExpr" ):
                listener.enterTotaalVanExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTotaalVanExpr" ):
                listener.exitTotaalVanExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTotaalVanExpr" ):
                return visitor.visitTotaalVanExpr(self)
            else:
                return visitor.visitChildren(self)


    class TijdsevenredigDeelExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def HET_TIJDSEVENREDIG_DEEL_PER(self):
            return self.getToken(RegelSpraakParser.HET_TIJDSEVENREDIG_DEEL_PER, 0)
        def VAN(self):
            return self.getToken(RegelSpraakParser.VAN, 0)
        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)

        def MAAND(self):
            return self.getToken(RegelSpraakParser.MAAND, 0)
        def JAAR(self):
            return self.getToken(RegelSpraakParser.JAAR, 0)
        def conditieBijExpressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ConditieBijExpressieContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTijdsevenredigDeelExpr" ):
                listener.enterTijdsevenredigDeelExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTijdsevenredigDeelExpr" ):
                listener.exitTijdsevenredigDeelExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTijdsevenredigDeelExpr" ):
                return visitor.visitTijdsevenredigDeelExpr(self)
            else:
                return visitor.visitChildren(self)


    class CapitalizedTijdsevenredigDeelExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def HET_TIJDSEVENREDIG_DEEL_PER(self):
            return self.getToken(RegelSpraakParser.HET_TIJDSEVENREDIG_DEEL_PER, 0)
        def VAN(self):
            return self.getToken(RegelSpraakParser.VAN, 0)
        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)

        def MAAND(self):
            return self.getToken(RegelSpraakParser.MAAND, 0)
        def JAAR(self):
            return self.getToken(RegelSpraakParser.JAAR, 0)
        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.IdentifierContext,i)

        def conditieBijExpressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ConditieBijExpressieContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCapitalizedTijdsevenredigDeelExpr" ):
                listener.enterCapitalizedTijdsevenredigDeelExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCapitalizedTijdsevenredigDeelExpr" ):
                listener.exitCapitalizedTijdsevenredigDeelExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCapitalizedTijdsevenredigDeelExpr" ):
                return visitor.visitCapitalizedTijdsevenredigDeelExpr(self)
            else:
                return visitor.visitChildren(self)


    class AantalAttribuutExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def HET(self):
            return self.getToken(RegelSpraakParser.HET, 0)
        def AANTAL(self):
            return self.getToken(RegelSpraakParser.AANTAL, 0)
        def attribuutReferentie(self):
            return self.getTypedRuleContext(RegelSpraakParser.AttribuutReferentieContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAantalAttribuutExpr" ):
                listener.enterAantalAttribuutExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAantalAttribuutExpr" ):
                listener.exitAantalAttribuutExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAantalAttribuutExpr" ):
                return visitor.visitAantalAttribuutExpr(self)
            else:
                return visitor.visitChildren(self)


    class ParenExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(RegelSpraakParser.LPAREN, 0)
        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)

        def RPAREN(self):
            return self.getToken(RegelSpraakParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParenExpr" ):
                listener.enterParenExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParenExpr" ):
                listener.exitParenExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParenExpr" ):
                return visitor.visitParenExpr(self)
            else:
                return visitor.visitChildren(self)


    class DimensieRangeAggExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def VANAF(self):
            return self.getToken(RegelSpraakParser.VANAF, 0)
        def naamwoord(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.NaamwoordContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,i)

        def TM(self):
            return self.getToken(RegelSpraakParser.TM, 0)
        def getalAggregatieFunctie(self):
            return self.getTypedRuleContext(RegelSpraakParser.GetalAggregatieFunctieContext,0)

        def datumAggregatieFunctie(self):
            return self.getTypedRuleContext(RegelSpraakParser.DatumAggregatieFunctieContext,0)

        def bezieldeReferentie(self):
            return self.getTypedRuleContext(RegelSpraakParser.BezieldeReferentieContext,0)

        def attribuutReferentie(self):
            return self.getTypedRuleContext(RegelSpraakParser.AttribuutReferentieContext,0)

        def DOT(self):
            return self.getToken(RegelSpraakParser.DOT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDimensieRangeAggExpr" ):
                listener.enterDimensieRangeAggExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDimensieRangeAggExpr" ):
                listener.exitDimensieRangeAggExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDimensieRangeAggExpr" ):
                return visitor.visitDimensieRangeAggExpr(self)
            else:
                return visitor.visitChildren(self)


    class DatumMetFuncExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def DE_DATUM_MET(self):
            return self.getToken(RegelSpraakParser.DE_DATUM_MET, 0)
        def LPAREN(self):
            return self.getToken(RegelSpraakParser.LPAREN, 0)
        def primaryExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.PrimaryExpressionContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,i)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.COMMA)
            else:
                return self.getToken(RegelSpraakParser.COMMA, i)
        def RPAREN(self):
            return self.getToken(RegelSpraakParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDatumMetFuncExpr" ):
                listener.enterDatumMetFuncExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDatumMetFuncExpr" ):
                listener.exitDatumMetFuncExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDatumMetFuncExpr" ):
                return visitor.visitDatumMetFuncExpr(self)
            else:
                return visitor.visitChildren(self)


    class PercentageLiteralExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def PERCENTAGE_LITERAL(self):
            return self.getToken(RegelSpraakParser.PERCENTAGE_LITERAL, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPercentageLiteralExpr" ):
                listener.enterPercentageLiteralExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPercentageLiteralExpr" ):
                listener.exitPercentageLiteralExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPercentageLiteralExpr" ):
                return visitor.visitPercentageLiteralExpr(self)
            else:
                return visitor.visitChildren(self)


    class StringLiteralExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def STRING_LITERAL(self):
            return self.getToken(RegelSpraakParser.STRING_LITERAL, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStringLiteralExpr" ):
                listener.enterStringLiteralExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStringLiteralExpr" ):
                listener.exitStringLiteralExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStringLiteralExpr" ):
                return visitor.visitStringLiteralExpr(self)
            else:
                return visitor.visitChildren(self)


    class PercentageFuncExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.p = None # Token
            self.copyFrom(ctx)

        def VAN(self):
            return self.getToken(RegelSpraakParser.VAN, 0)
        def primaryExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,0)

        def NUMBER(self):
            return self.getToken(RegelSpraakParser.NUMBER, 0)
        def PERCENTAGE_LITERAL(self):
            return self.getToken(RegelSpraakParser.PERCENTAGE_LITERAL, 0)
        def PERCENT_SIGN(self):
            return self.getToken(RegelSpraakParser.PERCENT_SIGN, 0)
        def IDENTIFIER(self):
            return self.getToken(RegelSpraakParser.IDENTIFIER, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPercentageFuncExpr" ):
                listener.enterPercentageFuncExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPercentageFuncExpr" ):
                listener.exitPercentageFuncExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPercentageFuncExpr" ):
                return visitor.visitPercentageFuncExpr(self)
            else:
                return visitor.visitChildren(self)


    class EersteDatumFuncExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def EERSTE_VAN(self):
            return self.getToken(RegelSpraakParser.EERSTE_VAN, 0)
        def primaryExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.PrimaryExpressionContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,i)

        def EN(self):
            return self.getToken(RegelSpraakParser.EN, 0)
        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.COMMA)
            else:
                return self.getToken(RegelSpraakParser.COMMA, i)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEersteDatumFuncExpr" ):
                listener.enterEersteDatumFuncExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEersteDatumFuncExpr" ):
                listener.exitEersteDatumFuncExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEersteDatumFuncExpr" ):
                return visitor.visitEersteDatumFuncExpr(self)
            else:
                return visitor.visitChildren(self)


    class PasenFuncExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def DE_EERSTE_PAASDAG_VAN(self):
            return self.getToken(RegelSpraakParser.DE_EERSTE_PAASDAG_VAN, 0)
        def LPAREN(self):
            return self.getToken(RegelSpraakParser.LPAREN, 0)
        def primaryExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,0)

        def RPAREN(self):
            return self.getToken(RegelSpraakParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPasenFuncExpr" ):
                listener.enterPasenFuncExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPasenFuncExpr" ):
                listener.exitPasenFuncExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPasenFuncExpr" ):
                return visitor.visitPasenFuncExpr(self)
            else:
                return visitor.visitChildren(self)


    class AbsTijdsduurFuncExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def DE_ABSOLUTE_TIJDSDUUR_VAN(self):
            return self.getToken(RegelSpraakParser.DE_ABSOLUTE_TIJDSDUUR_VAN, 0)
        def primaryExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.PrimaryExpressionContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,i)

        def TOT(self):
            return self.getToken(RegelSpraakParser.TOT, 0)
        def IN_HELE(self):
            return self.getToken(RegelSpraakParser.IN_HELE, 0)
        def unitIdentifier(self):
            return self.getTypedRuleContext(RegelSpraakParser.UnitIdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAbsTijdsduurFuncExpr" ):
                listener.enterAbsTijdsduurFuncExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAbsTijdsduurFuncExpr" ):
                listener.exitAbsTijdsduurFuncExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAbsTijdsduurFuncExpr" ):
                return visitor.visitAbsTijdsduurFuncExpr(self)
            else:
                return visitor.visitChildren(self)


    class MaandUitFuncExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def DE(self):
            return self.getToken(RegelSpraakParser.DE, 0)
        def MAAND(self):
            return self.getToken(RegelSpraakParser.MAAND, 0)
        def UIT(self):
            return self.getToken(RegelSpraakParser.UIT, 0)
        def primaryExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMaandUitFuncExpr" ):
                listener.enterMaandUitFuncExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMaandUitFuncExpr" ):
                listener.exitMaandUitFuncExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMaandUitFuncExpr" ):
                return visitor.visitMaandUitFuncExpr(self)
            else:
                return visitor.visitChildren(self)


    class CapitalizedTotaalVanExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def HET_TOTAAL_VAN(self):
            return self.getToken(RegelSpraakParser.HET_TOTAAL_VAN, 0)
        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)

        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.IdentifierContext,i)

        def conditieBijExpressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ConditieBijExpressieContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCapitalizedTotaalVanExpr" ):
                listener.enterCapitalizedTotaalVanExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCapitalizedTotaalVanExpr" ):
                listener.exitCapitalizedTotaalVanExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCapitalizedTotaalVanExpr" ):
                return visitor.visitCapitalizedTotaalVanExpr(self)
            else:
                return visitor.visitChildren(self)


    class IdentifierExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(RegelSpraakParser.IdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIdentifierExpr" ):
                listener.enterIdentifierExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIdentifierExpr" ):
                listener.exitIdentifierExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIdentifierExpr" ):
                return visitor.visitIdentifierExpr(self)
            else:
                return visitor.visitChildren(self)


    class DimensieAggExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def attribuutMetLidwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.AttribuutMetLidwoordContext,0)

        def dimensieSelectie(self):
            return self.getTypedRuleContext(RegelSpraakParser.DimensieSelectieContext,0)

        def getalAggregatieFunctie(self):
            return self.getTypedRuleContext(RegelSpraakParser.GetalAggregatieFunctieContext,0)

        def datumAggregatieFunctie(self):
            return self.getTypedRuleContext(RegelSpraakParser.DatumAggregatieFunctieContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDimensieAggExpr" ):
                listener.enterDimensieAggExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDimensieAggExpr" ):
                listener.exitDimensieAggExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDimensieAggExpr" ):
                return visitor.visitDimensieAggExpr(self)
            else:
                return visitor.visitChildren(self)


    class TijdsduurFuncExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def TIJDSDUUR_VAN(self):
            return self.getToken(RegelSpraakParser.TIJDSDUUR_VAN, 0)
        def primaryExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.PrimaryExpressionContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,i)

        def TOT(self):
            return self.getToken(RegelSpraakParser.TOT, 0)
        def IN_HELE(self):
            return self.getToken(RegelSpraakParser.IN_HELE, 0)
        def unitIdentifier(self):
            return self.getTypedRuleContext(RegelSpraakParser.UnitIdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTijdsduurFuncExpr" ):
                listener.enterTijdsduurFuncExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTijdsduurFuncExpr" ):
                listener.exitTijdsduurFuncExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTijdsduurFuncExpr" ):
                return visitor.visitTijdsduurFuncExpr(self)
            else:
                return visitor.visitChildren(self)


    class OnderwerpRefExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def onderwerpReferentie(self):
            return self.getTypedRuleContext(RegelSpraakParser.OnderwerpReferentieContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOnderwerpRefExpr" ):
                listener.enterOnderwerpRefExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOnderwerpRefExpr" ):
                listener.exitOnderwerpRefExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOnderwerpRefExpr" ):
                return visitor.visitOnderwerpRefExpr(self)
            else:
                return visitor.visitChildren(self)


    class SomFuncExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def SOM_VAN(self):
            return self.getToken(RegelSpraakParser.SOM_VAN, 0)
        def primaryExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.PrimaryExpressionContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,i)

        def EN(self):
            return self.getToken(RegelSpraakParser.EN, 0)
        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.COMMA)
            else:
                return self.getToken(RegelSpraakParser.COMMA, i)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSomFuncExpr" ):
                listener.enterSomFuncExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSomFuncExpr" ):
                listener.exitSomFuncExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSomFuncExpr" ):
                return visitor.visitSomFuncExpr(self)
            else:
                return visitor.visitChildren(self)


    class SomAlleExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def SOM_VAN(self):
            return self.getToken(RegelSpraakParser.SOM_VAN, 0)
        def ALLE(self):
            return self.getToken(RegelSpraakParser.ALLE, 0)
        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSomAlleExpr" ):
                listener.enterSomAlleExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSomAlleExpr" ):
                listener.exitSomAlleExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSomAlleExpr" ):
                return visitor.visitSomAlleExpr(self)
            else:
                return visitor.visitChildren(self)


    class SimpleConcatenatieExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def primaryExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.PrimaryExpressionContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,i)

        def EN(self):
            return self.getToken(RegelSpraakParser.EN, 0)
        def OF(self):
            return self.getToken(RegelSpraakParser.OF, 0)
        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.COMMA)
            else:
                return self.getToken(RegelSpraakParser.COMMA, i)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSimpleConcatenatieExpr" ):
                listener.enterSimpleConcatenatieExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSimpleConcatenatieExpr" ):
                listener.exitSimpleConcatenatieExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSimpleConcatenatieExpr" ):
                return visitor.visitSimpleConcatenatieExpr(self)
            else:
                return visitor.visitChildren(self)


    class BegrenzingAfrondingExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def primaryExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,0)

        def COMMA(self):
            return self.getToken(RegelSpraakParser.COMMA, 0)
        def begrenzing(self):
            return self.getTypedRuleContext(RegelSpraakParser.BegrenzingContext,0)

        def afronding(self):
            return self.getTypedRuleContext(RegelSpraakParser.AfrondingContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBegrenzingAfrondingExpr" ):
                listener.enterBegrenzingAfrondingExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBegrenzingAfrondingExpr" ):
                listener.exitBegrenzingAfrondingExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBegrenzingAfrondingExpr" ):
                return visitor.visitBegrenzingAfrondingExpr(self)
            else:
                return visitor.visitChildren(self)


    class PercentageOfExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def PERCENTAGE_LITERAL(self):
            return self.getToken(RegelSpraakParser.PERCENTAGE_LITERAL, 0)
        def VAN(self):
            return self.getToken(RegelSpraakParser.VAN, 0)
        def primaryExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPercentageOfExpr" ):
                listener.enterPercentageOfExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPercentageOfExpr" ):
                listener.exitPercentageOfExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPercentageOfExpr" ):
                return visitor.visitPercentageOfExpr(self)
            else:
                return visitor.visitChildren(self)


    class MinValFuncExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def DE_MINIMALE_WAARDE_VAN(self):
            return self.getToken(RegelSpraakParser.DE_MINIMALE_WAARDE_VAN, 0)
        def primaryExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.PrimaryExpressionContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,i)

        def EN(self):
            return self.getToken(RegelSpraakParser.EN, 0)
        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.COMMA)
            else:
                return self.getToken(RegelSpraakParser.COMMA, i)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMinValFuncExpr" ):
                listener.enterMinValFuncExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMinValFuncExpr" ):
                listener.exitMinValFuncExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMinValFuncExpr" ):
                return visitor.visitMinValFuncExpr(self)
            else:
                return visitor.visitChildren(self)


    class MaxAlleAttribuutExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def DE_MAXIMALE_WAARDE_VAN(self):
            return self.getToken(RegelSpraakParser.DE_MAXIMALE_WAARDE_VAN, 0)
        def ALLE(self):
            return self.getToken(RegelSpraakParser.ALLE, 0)
        def attribuutReferentie(self):
            return self.getTypedRuleContext(RegelSpraakParser.AttribuutReferentieContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMaxAlleAttribuutExpr" ):
                listener.enterMaxAlleAttribuutExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMaxAlleAttribuutExpr" ):
                listener.exitMaxAlleAttribuutExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMaxAlleAttribuutExpr" ):
                return visitor.visitMaxAlleAttribuutExpr(self)
            else:
                return visitor.visitChildren(self)


    class DateCalcExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def datumExpressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.DatumExpressieContext,0)

        def primaryExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,0)

        def timeUnit(self):
            return self.getTypedRuleContext(RegelSpraakParser.TimeUnitContext,0)

        def PLUS(self):
            return self.getToken(RegelSpraakParser.PLUS, 0)
        def MIN(self):
            return self.getToken(RegelSpraakParser.MIN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDateCalcExpr" ):
                listener.enterDateCalcExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDateCalcExpr" ):
                listener.exitDateCalcExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDateCalcExpr" ):
                return visitor.visitDateCalcExpr(self)
            else:
                return visitor.visitChildren(self)


    class BezieldeRefExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def bezieldeReferentie(self):
            return self.getTypedRuleContext(RegelSpraakParser.BezieldeReferentieContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBezieldeRefExpr" ):
                listener.enterBezieldeRefExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBezieldeRefExpr" ):
                listener.exitBezieldeRefExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBezieldeRefExpr" ):
                return visitor.visitBezieldeRefExpr(self)
            else:
                return visitor.visitChildren(self)


    class MinAlleAttribuutExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def DE_MINIMALE_WAARDE_VAN(self):
            return self.getToken(RegelSpraakParser.DE_MINIMALE_WAARDE_VAN, 0)
        def ALLE(self):
            return self.getToken(RegelSpraakParser.ALLE, 0)
        def attribuutReferentie(self):
            return self.getTypedRuleContext(RegelSpraakParser.AttribuutReferentieContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMinAlleAttribuutExpr" ):
                listener.enterMinAlleAttribuutExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMinAlleAttribuutExpr" ):
                listener.exitMinAlleAttribuutExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMinAlleAttribuutExpr" ):
                return visitor.visitMinAlleAttribuutExpr(self)
            else:
                return visitor.visitChildren(self)


    class AfrondingExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def primaryExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,0)

        def afronding(self):
            return self.getTypedRuleContext(RegelSpraakParser.AfrondingContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAfrondingExpr" ):
                listener.enterAfrondingExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAfrondingExpr" ):
                listener.exitAfrondingExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAfrondingExpr" ):
                return visitor.visitAfrondingExpr(self)
            else:
                return visitor.visitChildren(self)


    class LaatsteDatumFuncExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LAATSTE_VAN(self):
            return self.getToken(RegelSpraakParser.LAATSTE_VAN, 0)
        def primaryExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.PrimaryExpressionContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,i)

        def EN(self):
            return self.getToken(RegelSpraakParser.EN, 0)
        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.COMMA)
            else:
                return self.getToken(RegelSpraakParser.COMMA, i)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLaatsteDatumFuncExpr" ):
                listener.enterLaatsteDatumFuncExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLaatsteDatumFuncExpr" ):
                listener.exitLaatsteDatumFuncExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLaatsteDatumFuncExpr" ):
                return visitor.visitLaatsteDatumFuncExpr(self)
            else:
                return visitor.visitChildren(self)


    class HetAantalDagenInExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def HET(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.HET)
            else:
                return self.getToken(RegelSpraakParser.HET, i)
        def AANTAL(self):
            return self.getToken(RegelSpraakParser.AANTAL, 0)
        def DAGEN(self):
            return self.getToken(RegelSpraakParser.DAGEN, 0)
        def IN(self):
            return self.getToken(RegelSpraakParser.IN, 0)
        def DAT(self):
            return self.getToken(RegelSpraakParser.DAT, 0)
        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)

        def MAAND(self):
            return self.getToken(RegelSpraakParser.MAAND, 0)
        def JAAR(self):
            return self.getToken(RegelSpraakParser.JAAR, 0)
        def DE(self):
            return self.getToken(RegelSpraakParser.DE, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterHetAantalDagenInExpr" ):
                listener.enterHetAantalDagenInExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitHetAantalDagenInExpr" ):
                listener.exitHetAantalDagenInExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitHetAantalDagenInExpr" ):
                return visitor.visitHetAantalDagenInExpr(self)
            else:
                return visitor.visitChildren(self)


    class UnaryMinusExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def MIN(self):
            return self.getToken(RegelSpraakParser.MIN, 0)
        def primaryExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,0)

        def MINUS(self):
            return self.getToken(RegelSpraakParser.MINUS, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnaryMinusExpr" ):
                listener.enterUnaryMinusExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnaryMinusExpr" ):
                listener.exitUnaryMinusExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnaryMinusExpr" ):
                return visitor.visitUnaryMinusExpr(self)
            else:
                return visitor.visitChildren(self)


    class ParamRefExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def parameterMetLidwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.ParameterMetLidwoordContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParamRefExpr" ):
                listener.enterParamRefExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParamRefExpr" ):
                listener.exitParamRefExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParamRefExpr" ):
                return visitor.visitParamRefExpr(self)
            else:
                return visitor.visitChildren(self)


    class PronounExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def HIJ(self):
            return self.getToken(RegelSpraakParser.HIJ, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPronounExpr" ):
                listener.enterPronounExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPronounExpr" ):
                listener.exitPronounExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPronounExpr" ):
                return visitor.visitPronounExpr(self)
            else:
                return visitor.visitChildren(self)



    def primaryExpression(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = RegelSpraakParser.PrimaryExpressionContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 274
        self.enterRecursionRule(localctx, 274, self.RULE_primaryExpression, _p)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1869
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,214,self._ctx)
            if la_ == 1:
                localctx = RegelSpraakParser.UnaryMinusExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx

                self.state = 1607
                self.match(RegelSpraakParser.MIN)
                self.state = 1608
                self.primaryExpression(55)
                pass

            elif la_ == 2:
                localctx = RegelSpraakParser.UnaryMinusExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1609
                self.match(RegelSpraakParser.MINUS)
                self.state = 1610
                self.primaryExpression(54)
                pass

            elif la_ == 3:
                localctx = RegelSpraakParser.UnaryNietExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1611
                self.match(RegelSpraakParser.NIET)
                self.state = 1612
                self.primaryExpression(53)
                pass

            elif la_ == 4:
                localctx = RegelSpraakParser.AbsTijdsduurFuncExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1613
                self.match(RegelSpraakParser.DE_ABSOLUTE_TIJDSDUUR_VAN)
                self.state = 1614
                self.primaryExpression(0)
                self.state = 1615
                self.match(RegelSpraakParser.TOT)
                self.state = 1616
                self.primaryExpression(0)
                self.state = 1619
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,189,self._ctx)
                if la_ == 1:
                    self.state = 1617
                    self.match(RegelSpraakParser.IN_HELE)
                    self.state = 1618
                    self.unitIdentifier()


                pass

            elif la_ == 5:
                localctx = RegelSpraakParser.TijdsduurFuncExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1621
                self.match(RegelSpraakParser.TIJDSDUUR_VAN)
                self.state = 1622
                self.primaryExpression(0)
                self.state = 1623
                self.match(RegelSpraakParser.TOT)
                self.state = 1624
                self.primaryExpression(0)
                self.state = 1627
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,190,self._ctx)
                if la_ == 1:
                    self.state = 1625
                    self.match(RegelSpraakParser.IN_HELE)
                    self.state = 1626
                    self.unitIdentifier()


                pass

            elif la_ == 6:
                localctx = RegelSpraakParser.SomFuncExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1629
                self.match(RegelSpraakParser.SOM_VAN)
                self.state = 1630
                self.primaryExpression(0)
                self.state = 1635
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==278:
                    self.state = 1631
                    self.match(RegelSpraakParser.COMMA)
                    self.state = 1632
                    self.primaryExpression(0)
                    self.state = 1637
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 1638
                self.match(RegelSpraakParser.EN)
                self.state = 1639
                self.primaryExpression(50)
                pass

            elif la_ == 7:
                localctx = RegelSpraakParser.SomAlleExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1641
                self.match(RegelSpraakParser.SOM_VAN)
                self.state = 1642
                self.match(RegelSpraakParser.ALLE)
                self.state = 1643
                self.naamwoord()
                pass

            elif la_ == 8:
                localctx = RegelSpraakParser.SomAlleAttribuutExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1644
                self.match(RegelSpraakParser.SOM_VAN)
                self.state = 1645
                self.match(RegelSpraakParser.ALLE)
                self.state = 1646
                self.attribuutReferentie()
                pass

            elif la_ == 9:
                localctx = RegelSpraakParser.AantalFuncExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1650
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [217]:
                    self.state = 1647
                    self.match(RegelSpraakParser.HET)
                    self.state = 1648
                    self.match(RegelSpraakParser.AANTAL)
                    pass
                elif token in [190]:
                    self.state = 1649
                    self.match(RegelSpraakParser.AANTAL)
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 1652
                self.aggregationSubject()
                pass

            elif la_ == 10:
                localctx = RegelSpraakParser.AantalAttribuutExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1653
                self.match(RegelSpraakParser.HET)
                self.state = 1654
                self.match(RegelSpraakParser.AANTAL)
                self.state = 1655
                self.attribuutReferentie()
                pass

            elif la_ == 11:
                localctx = RegelSpraakParser.AantalAttribuutExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1656
                self.match(RegelSpraakParser.AANTAL)
                self.state = 1657
                self.attribuutReferentie()
                pass

            elif la_ == 12:
                localctx = RegelSpraakParser.PercentageFuncExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1664
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [268]:
                    self.state = 1658
                    self.match(RegelSpraakParser.NUMBER)
                    self.state = 1661
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [283]:
                        self.state = 1659
                        self.match(RegelSpraakParser.PERCENT_SIGN)
                        pass
                    elif token in [267]:
                        self.state = 1660
                        localctx.p = self.match(RegelSpraakParser.IDENTIFIER)
                        pass
                    else:
                        raise NoViableAltException(self)

                    pass
                elif token in [271]:
                    self.state = 1663
                    self.match(RegelSpraakParser.PERCENTAGE_LITERAL)
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 1666
                self.match(RegelSpraakParser.VAN)
                self.state = 1667
                self.primaryExpression(44)
                pass

            elif la_ == 13:
                localctx = RegelSpraakParser.PercentageOfExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1668
                self.match(RegelSpraakParser.PERCENTAGE_LITERAL)
                self.state = 1669
                self.match(RegelSpraakParser.VAN)
                self.state = 1670
                self.primaryExpression(43)
                pass

            elif la_ == 14:
                localctx = RegelSpraakParser.ConcatenatieExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1671
                self.match(RegelSpraakParser.CONCATENATIE_VAN)
                self.state = 1672
                self.primaryExpression(0)
                self.state = 1677
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==278:
                    self.state = 1673
                    self.match(RegelSpraakParser.COMMA)
                    self.state = 1674
                    self.primaryExpression(0)
                    self.state = 1679
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 1680
                _la = self._input.LA(1)
                if not(_la==216 or _la==229):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1681
                self.primaryExpression(39)
                pass

            elif la_ == 15:
                localctx = RegelSpraakParser.WortelFuncExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1683
                self.match(RegelSpraakParser.DE_WORTEL_VAN)
                self.state = 1684
                self.primaryExpression(37)
                pass

            elif la_ == 16:
                localctx = RegelSpraakParser.AbsValFuncExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1685
                self.match(RegelSpraakParser.DE_ABSOLUTE_WAARDE_VAN)
                self.state = 1686
                self.match(RegelSpraakParser.LPAREN)
                self.state = 1687
                self.expressie()
                self.state = 1688
                self.match(RegelSpraakParser.RPAREN)
                pass

            elif la_ == 17:
                localctx = RegelSpraakParser.MinValFuncExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1690
                self.match(RegelSpraakParser.DE_MINIMALE_WAARDE_VAN)
                self.state = 1691
                self.primaryExpression(0)
                self.state = 1696
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==278:
                    self.state = 1692
                    self.match(RegelSpraakParser.COMMA)
                    self.state = 1693
                    self.primaryExpression(0)
                    self.state = 1698
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 1699
                self.match(RegelSpraakParser.EN)
                self.state = 1700
                self.primaryExpression(35)
                pass

            elif la_ == 18:
                localctx = RegelSpraakParser.MinAlleAttribuutExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1702
                self.match(RegelSpraakParser.DE_MINIMALE_WAARDE_VAN)
                self.state = 1703
                self.match(RegelSpraakParser.ALLE)
                self.state = 1704
                self.attribuutReferentie()
                pass

            elif la_ == 19:
                localctx = RegelSpraakParser.MaxValFuncExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1705
                self.match(RegelSpraakParser.DE_MAXIMALE_WAARDE_VAN)
                self.state = 1706
                self.primaryExpression(0)
                self.state = 1711
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==278:
                    self.state = 1707
                    self.match(RegelSpraakParser.COMMA)
                    self.state = 1708
                    self.primaryExpression(0)
                    self.state = 1713
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 1714
                self.match(RegelSpraakParser.EN)
                self.state = 1715
                self.primaryExpression(33)
                pass

            elif la_ == 20:
                localctx = RegelSpraakParser.MaxAlleAttribuutExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1717
                self.match(RegelSpraakParser.DE_MAXIMALE_WAARDE_VAN)
                self.state = 1718
                self.match(RegelSpraakParser.ALLE)
                self.state = 1719
                self.attribuutReferentie()
                pass

            elif la_ == 21:
                localctx = RegelSpraakParser.JaarUitFuncExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1720
                self.match(RegelSpraakParser.HET)
                self.state = 1721
                self.match(RegelSpraakParser.JAAR)
                self.state = 1722
                self.match(RegelSpraakParser.UIT)
                self.state = 1723
                self.primaryExpression(31)
                pass

            elif la_ == 22:
                localctx = RegelSpraakParser.MaandUitFuncExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1724
                self.match(RegelSpraakParser.DE)
                self.state = 1725
                self.match(RegelSpraakParser.MAAND)
                self.state = 1726
                self.match(RegelSpraakParser.UIT)
                self.state = 1727
                self.primaryExpression(30)
                pass

            elif la_ == 23:
                localctx = RegelSpraakParser.DagUitFuncExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1728
                self.match(RegelSpraakParser.DE)
                self.state = 1729
                self.match(RegelSpraakParser.DAG)
                self.state = 1730
                self.match(RegelSpraakParser.UIT)
                self.state = 1731
                self.primaryExpression(29)
                pass

            elif la_ == 24:
                localctx = RegelSpraakParser.DatumMetFuncExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1732
                self.match(RegelSpraakParser.DE_DATUM_MET)
                self.state = 1733
                self.match(RegelSpraakParser.LPAREN)
                self.state = 1734
                self.primaryExpression(0)
                self.state = 1735
                self.match(RegelSpraakParser.COMMA)
                self.state = 1736
                self.primaryExpression(0)
                self.state = 1737
                self.match(RegelSpraakParser.COMMA)
                self.state = 1738
                self.primaryExpression(0)
                self.state = 1739
                self.match(RegelSpraakParser.RPAREN)
                pass

            elif la_ == 25:
                localctx = RegelSpraakParser.PasenFuncExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1741
                self.match(RegelSpraakParser.DE_EERSTE_PAASDAG_VAN)
                self.state = 1742
                self.match(RegelSpraakParser.LPAREN)
                self.state = 1743
                self.primaryExpression(0)
                self.state = 1744
                self.match(RegelSpraakParser.RPAREN)
                pass

            elif la_ == 26:
                localctx = RegelSpraakParser.DateCalcExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1746
                self.datumExpressie()
                self.state = 1747
                _la = self._input.LA(1)
                if not(_la==137 or _la==143):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1748
                self.primaryExpression(0)
                self.state = 1749
                self.timeUnit()
                pass

            elif la_ == 27:
                localctx = RegelSpraakParser.EersteDatumFuncExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1751
                self.match(RegelSpraakParser.EERSTE_VAN)
                self.state = 1752
                self.primaryExpression(0)
                self.state = 1757
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==278:
                    self.state = 1753
                    self.match(RegelSpraakParser.COMMA)
                    self.state = 1754
                    self.primaryExpression(0)
                    self.state = 1759
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 1760
                self.match(RegelSpraakParser.EN)
                self.state = 1761
                self.primaryExpression(25)
                pass

            elif la_ == 28:
                localctx = RegelSpraakParser.LaatsteDatumFuncExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1763
                self.match(RegelSpraakParser.LAATSTE_VAN)
                self.state = 1764
                self.primaryExpression(0)
                self.state = 1769
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==278:
                    self.state = 1765
                    self.match(RegelSpraakParser.COMMA)
                    self.state = 1766
                    self.primaryExpression(0)
                    self.state = 1771
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 1772
                self.match(RegelSpraakParser.EN)
                self.state = 1773
                self.primaryExpression(24)
                pass

            elif la_ == 29:
                localctx = RegelSpraakParser.TotaalVanExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1775
                self.match(RegelSpraakParser.HET_TOTAAL_VAN)
                self.state = 1776
                self.expressie()
                self.state = 1778
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,200,self._ctx)
                if la_ == 1:
                    self.state = 1777
                    self.conditieBijExpressie()


                pass

            elif la_ == 30:
                localctx = RegelSpraakParser.HetAantalDagenInExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1780
                self.match(RegelSpraakParser.HET)
                self.state = 1781
                self.match(RegelSpraakParser.AANTAL)
                self.state = 1782
                self.match(RegelSpraakParser.DAGEN)
                self.state = 1783
                self.match(RegelSpraakParser.IN)
                self.state = 1792
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [212, 224]:
                    self.state = 1785
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==212:
                        self.state = 1784
                        self.match(RegelSpraakParser.DE)


                    self.state = 1787
                    self.match(RegelSpraakParser.MAAND)
                    pass
                elif token in [217, 221]:
                    self.state = 1789
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==217:
                        self.state = 1788
                        self.match(RegelSpraakParser.HET)


                    self.state = 1791
                    self.match(RegelSpraakParser.JAAR)
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 1794
                self.match(RegelSpraakParser.DAT)
                self.state = 1795
                self.expressie()
                pass

            elif la_ == 31:
                localctx = RegelSpraakParser.CapitalizedTotaalVanExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1797 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 1796
                    self.identifier()
                    self.state = 1799 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==267):
                        break

                self.state = 1801
                self.match(RegelSpraakParser.HET_TOTAAL_VAN)
                self.state = 1802
                self.expressie()
                self.state = 1804
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,205,self._ctx)
                if la_ == 1:
                    self.state = 1803
                    self.conditieBijExpressie()


                pass

            elif la_ == 32:
                localctx = RegelSpraakParser.TijdsevenredigDeelExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1806
                self.match(RegelSpraakParser.HET_TIJDSEVENREDIG_DEEL_PER)
                self.state = 1807
                _la = self._input.LA(1)
                if not(_la==221 or _la==224):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1808
                self.match(RegelSpraakParser.VAN)
                self.state = 1809
                self.expressie()
                self.state = 1811
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,206,self._ctx)
                if la_ == 1:
                    self.state = 1810
                    self.conditieBijExpressie()


                pass

            elif la_ == 33:
                localctx = RegelSpraakParser.CapitalizedTijdsevenredigDeelExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1814 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 1813
                    self.identifier()
                    self.state = 1816 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==267):
                        break

                self.state = 1818
                self.match(RegelSpraakParser.HET_TIJDSEVENREDIG_DEEL_PER)
                self.state = 1819
                _la = self._input.LA(1)
                if not(_la==221 or _la==224):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1820
                self.match(RegelSpraakParser.VAN)
                self.state = 1821
                self.expressie()
                self.state = 1823
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,208,self._ctx)
                if la_ == 1:
                    self.state = 1822
                    self.conditieBijExpressie()


                pass

            elif la_ == 34:
                localctx = RegelSpraakParser.DimensieAggExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1827
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [13, 14, 190, 195, 217]:
                    self.state = 1825
                    self.getalAggregatieFunctie()
                    pass
                elif token in [191, 193]:
                    self.state = 1826
                    self.datumAggregatieFunctie()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 1829
                self.attribuutMetLidwoord()
                self.state = 1830
                self.dimensieSelectie()
                pass

            elif la_ == 35:
                localctx = RegelSpraakParser.DimensieRangeAggExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1834
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [13, 14, 190, 195, 217]:
                    self.state = 1832
                    self.getalAggregatieFunctie()
                    pass
                elif token in [191, 193]:
                    self.state = 1833
                    self.datumAggregatieFunctie()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 1838
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,211,self._ctx)
                if la_ == 1:
                    self.state = 1836
                    self.bezieldeReferentie()
                    pass

                elif la_ == 2:
                    self.state = 1837
                    self.attribuutReferentie()
                    pass


                self.state = 1840
                self.match(RegelSpraakParser.VANAF)
                self.state = 1841
                self.naamwoord()
                self.state = 1842
                self.match(RegelSpraakParser.TM)
                self.state = 1843
                self.naamwoord()
                self.state = 1845
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,212,self._ctx)
                if la_ == 1:
                    self.state = 1844
                    self.match(RegelSpraakParser.DOT)


                pass

            elif la_ == 36:
                localctx = RegelSpraakParser.NumberLiteralExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1847
                self.match(RegelSpraakParser.NUMBER)
                self.state = 1849
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,213,self._ctx)
                if la_ == 1:
                    self.state = 1848
                    self.unitIdentifier()


                pass

            elif la_ == 37:
                localctx = RegelSpraakParser.RekendatumKeywordExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1851
                self.match(RegelSpraakParser.REKENDATUM)
                pass

            elif la_ == 38:
                localctx = RegelSpraakParser.IdentifierExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1852
                self.identifier()
                pass

            elif la_ == 39:
                localctx = RegelSpraakParser.BezieldeRefExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1853
                self.bezieldeReferentie()
                pass

            elif la_ == 40:
                localctx = RegelSpraakParser.AttrRefExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1854
                self.attribuutReferentie()
                pass

            elif la_ == 41:
                localctx = RegelSpraakParser.OnderwerpRefExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1855
                self.onderwerpReferentie()
                pass

            elif la_ == 42:
                localctx = RegelSpraakParser.NaamwoordExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1856
                self.naamwoord()
                pass

            elif la_ == 43:
                localctx = RegelSpraakParser.ParamRefExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1857
                self.parameterMetLidwoord()
                pass

            elif la_ == 44:
                localctx = RegelSpraakParser.PercentageLiteralExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1858
                self.match(RegelSpraakParser.PERCENTAGE_LITERAL)
                pass

            elif la_ == 45:
                localctx = RegelSpraakParser.StringLiteralExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1859
                self.match(RegelSpraakParser.STRING_LITERAL)
                pass

            elif la_ == 46:
                localctx = RegelSpraakParser.EnumLiteralExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1860
                self.match(RegelSpraakParser.ENUM_LITERAL)
                pass

            elif la_ == 47:
                localctx = RegelSpraakParser.DatumLiteralExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1861
                self.datumLiteral()
                pass

            elif la_ == 48:
                localctx = RegelSpraakParser.BooleanTrueLiteralExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1862
                self.match(RegelSpraakParser.WAAR)
                pass

            elif la_ == 49:
                localctx = RegelSpraakParser.BooleanFalseLiteralExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1863
                self.match(RegelSpraakParser.ONWAAR)
                pass

            elif la_ == 50:
                localctx = RegelSpraakParser.PronounExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1864
                self.match(RegelSpraakParser.HIJ)
                pass

            elif la_ == 51:
                localctx = RegelSpraakParser.ParenExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1865
                self.match(RegelSpraakParser.LPAREN)
                self.state = 1866
                self.expressie()
                self.state = 1867
                self.match(RegelSpraakParser.RPAREN)
                pass


            self._ctx.stop = self._input.LT(-1)
            self.state = 1893
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,217,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    self.state = 1891
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,216,self._ctx)
                    if la_ == 1:
                        localctx = RegelSpraakParser.SimpleConcatenatieExprContext(self, RegelSpraakParser.PrimaryExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_primaryExpression)
                        self.state = 1871
                        if not self.precpred(self._ctx, 38):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 38)")
                        self.state = 1874 
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        while True:
                            self.state = 1872
                            self.match(RegelSpraakParser.COMMA)
                            self.state = 1873
                            self.primaryExpression(0)
                            self.state = 1876 
                            self._errHandler.sync(self)
                            _la = self._input.LA(1)
                            if not (_la==278):
                                break

                        self.state = 1878
                        _la = self._input.LA(1)
                        if not(_la==216 or _la==229):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 1879
                        self.primaryExpression(39)
                        pass

                    elif la_ == 2:
                        localctx = RegelSpraakParser.AfrondingExprContext(self, RegelSpraakParser.PrimaryExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_primaryExpression)
                        self.state = 1881
                        if not self.precpred(self._ctx, 42):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 42)")
                        self.state = 1882
                        self.afronding()
                        pass

                    elif la_ == 3:
                        localctx = RegelSpraakParser.BegrenzingAfrondingExprContext(self, RegelSpraakParser.PrimaryExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_primaryExpression)
                        self.state = 1883
                        if not self.precpred(self._ctx, 41):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 41)")
                        self.state = 1884
                        self.match(RegelSpraakParser.COMMA)
                        self.state = 1885
                        self.begrenzing()
                        self.state = 1886
                        self.afronding()
                        pass

                    elif la_ == 4:
                        localctx = RegelSpraakParser.BegrenzingExprContext(self, RegelSpraakParser.PrimaryExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_primaryExpression)
                        self.state = 1888
                        if not self.precpred(self._ctx, 40):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 40)")
                        self.state = 1889
                        self.match(RegelSpraakParser.COMMA)
                        self.state = 1890
                        self.begrenzing()
                        pass

             
                self.state = 1895
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,217,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class AfrondingContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def AFGEROND_OP(self):
            return self.getToken(RegelSpraakParser.AFGEROND_OP, 0)

        def NUMBER(self):
            return self.getToken(RegelSpraakParser.NUMBER, 0)

        def DECIMALEN(self):
            return self.getToken(RegelSpraakParser.DECIMALEN, 0)

        def NAAR_BENEDEN(self):
            return self.getToken(RegelSpraakParser.NAAR_BENEDEN, 0)

        def NAAR_BOVEN(self):
            return self.getToken(RegelSpraakParser.NAAR_BOVEN, 0)

        def REKENKUNDIG(self):
            return self.getToken(RegelSpraakParser.REKENKUNDIG, 0)

        def RICHTING_NUL(self):
            return self.getToken(RegelSpraakParser.RICHTING_NUL, 0)

        def WEG_VAN_NUL(self):
            return self.getToken(RegelSpraakParser.WEG_VAN_NUL, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_afronding

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAfronding" ):
                listener.enterAfronding(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAfronding" ):
                listener.exitAfronding(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAfronding" ):
                return visitor.visitAfronding(self)
            else:
                return visitor.visitChildren(self)




    def afronding(self):

        localctx = RegelSpraakParser.AfrondingContext(self, self._ctx, self.state)
        self.enterRule(localctx, 276, self.RULE_afronding)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1896
            _la = self._input.LA(1)
            if not(((((_la - 138)) & ~0x3f) == 0 and ((1 << (_la - 138)) & 131267) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 1897
            self.match(RegelSpraakParser.AFGEROND_OP)
            self.state = 1898
            self.match(RegelSpraakParser.NUMBER)
            self.state = 1899
            self.match(RegelSpraakParser.DECIMALEN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BegrenzingContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def begrenzingMinimum(self):
            return self.getTypedRuleContext(RegelSpraakParser.BegrenzingMinimumContext,0)


        def begrenzingMaximum(self):
            return self.getTypedRuleContext(RegelSpraakParser.BegrenzingMaximumContext,0)


        def EN(self):
            return self.getToken(RegelSpraakParser.EN, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_begrenzing

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBegrenzing" ):
                listener.enterBegrenzing(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBegrenzing" ):
                listener.exitBegrenzing(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBegrenzing" ):
                return visitor.visitBegrenzing(self)
            else:
                return visitor.visitChildren(self)




    def begrenzing(self):

        localctx = RegelSpraakParser.BegrenzingContext(self, self._ctx, self.state)
        self.enterRule(localctx, 278, self.RULE_begrenzing)
        try:
            self.state = 1907
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,218,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1901
                self.begrenzingMinimum()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1902
                self.begrenzingMaximum()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1903
                self.begrenzingMinimum()
                self.state = 1904
                self.match(RegelSpraakParser.EN)
                self.state = 1905
                self.begrenzingMaximum()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BegrenzingMinimumContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MET_EEN_MINIMUM_VAN(self):
            return self.getToken(RegelSpraakParser.MET_EEN_MINIMUM_VAN, 0)

        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_begrenzingMinimum

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBegrenzingMinimum" ):
                listener.enterBegrenzingMinimum(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBegrenzingMinimum" ):
                listener.exitBegrenzingMinimum(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBegrenzingMinimum" ):
                return visitor.visitBegrenzingMinimum(self)
            else:
                return visitor.visitChildren(self)




    def begrenzingMinimum(self):

        localctx = RegelSpraakParser.BegrenzingMinimumContext(self, self._ctx, self.state)
        self.enterRule(localctx, 280, self.RULE_begrenzingMinimum)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1909
            self.match(RegelSpraakParser.MET_EEN_MINIMUM_VAN)
            self.state = 1910
            self.expressie()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BegrenzingMaximumContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MET_EEN_MAXIMUM_VAN(self):
            return self.getToken(RegelSpraakParser.MET_EEN_MAXIMUM_VAN, 0)

        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_begrenzingMaximum

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBegrenzingMaximum" ):
                listener.enterBegrenzingMaximum(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBegrenzingMaximum" ):
                listener.exitBegrenzingMaximum(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBegrenzingMaximum" ):
                return visitor.visitBegrenzingMaximum(self)
            else:
                return visitor.visitChildren(self)




    def begrenzingMaximum(self):

        localctx = RegelSpraakParser.BegrenzingMaximumContext(self, self._ctx, self.state)
        self.enterRule(localctx, 282, self.RULE_begrenzingMaximum)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1912
            self.match(RegelSpraakParser.MET_EEN_MAXIMUM_VAN)
            self.state = 1913
            self.expressie()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConditieBijExpressieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.condition = None # ExpressieContext

        def GEDURENDE_DE_TIJD_DAT(self):
            return self.getToken(RegelSpraakParser.GEDURENDE_DE_TIJD_DAT, 0)

        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)


        def periodevergelijkingEnkelvoudig(self):
            return self.getTypedRuleContext(RegelSpraakParser.PeriodevergelijkingEnkelvoudigContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_conditieBijExpressie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConditieBijExpressie" ):
                listener.enterConditieBijExpressie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConditieBijExpressie" ):
                listener.exitConditieBijExpressie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConditieBijExpressie" ):
                return visitor.visitConditieBijExpressie(self)
            else:
                return visitor.visitChildren(self)




    def conditieBijExpressie(self):

        localctx = RegelSpraakParser.ConditieBijExpressieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 284, self.RULE_conditieBijExpressie)
        try:
            self.state = 1918
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [4]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1915
                self.match(RegelSpraakParser.GEDURENDE_DE_TIJD_DAT)
                self.state = 1916
                localctx.condition = self.expressie()
                pass
            elif token in [146, 148, 150, 244]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1917
                self.periodevergelijkingEnkelvoudig()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PeriodevergelijkingElementairContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def HET_IS_DE_PERIODE(self):
            return self.getToken(RegelSpraakParser.HET_IS_DE_PERIODE, 0)

        def periodevergelijkingEnkelvoudig(self):
            return self.getTypedRuleContext(RegelSpraakParser.PeriodevergelijkingEnkelvoudigContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_periodevergelijkingElementair

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPeriodevergelijkingElementair" ):
                listener.enterPeriodevergelijkingElementair(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPeriodevergelijkingElementair" ):
                listener.exitPeriodevergelijkingElementair(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPeriodevergelijkingElementair" ):
                return visitor.visitPeriodevergelijkingElementair(self)
            else:
                return visitor.visitChildren(self)




    def periodevergelijkingElementair(self):

        localctx = RegelSpraakParser.PeriodevergelijkingElementairContext(self, self._ctx, self.state)
        self.enterRule(localctx, 286, self.RULE_periodevergelijkingElementair)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1920
            self.match(RegelSpraakParser.HET_IS_DE_PERIODE)
            self.state = 1921
            self.periodevergelijkingEnkelvoudig()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PeriodevergelijkingEnkelvoudigContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def VANAF(self):
            return self.getToken(RegelSpraakParser.VANAF, 0)

        def datumExpressie(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.DatumExpressieContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.DatumExpressieContext,i)


        def VAN(self):
            return self.getToken(RegelSpraakParser.VAN, 0)

        def TOT(self):
            return self.getToken(RegelSpraakParser.TOT, 0)

        def TOT_EN_MET(self):
            return self.getToken(RegelSpraakParser.TOT_EN_MET, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_periodevergelijkingEnkelvoudig

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPeriodevergelijkingEnkelvoudig" ):
                listener.enterPeriodevergelijkingEnkelvoudig(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPeriodevergelijkingEnkelvoudig" ):
                listener.exitPeriodevergelijkingEnkelvoudig(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPeriodevergelijkingEnkelvoudig" ):
                return visitor.visitPeriodevergelijkingEnkelvoudig(self)
            else:
                return visitor.visitChildren(self)




    def periodevergelijkingEnkelvoudig(self):

        localctx = RegelSpraakParser.PeriodevergelijkingEnkelvoudigContext(self, self._ctx, self.state)
        self.enterRule(localctx, 288, self.RULE_periodevergelijkingEnkelvoudig)
        try:
            self.state = 1939
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,220,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1923
                self.match(RegelSpraakParser.VANAF)
                self.state = 1924
                self.datumExpressie()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1925
                self.match(RegelSpraakParser.VAN)
                self.state = 1926
                self.datumExpressie()
                self.state = 1927
                self.match(RegelSpraakParser.TOT)
                self.state = 1928
                self.datumExpressie()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1930
                self.match(RegelSpraakParser.VAN)
                self.state = 1931
                self.datumExpressie()
                self.state = 1932
                self.match(RegelSpraakParser.TOT_EN_MET)
                self.state = 1933
                self.datumExpressie()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 1935
                self.match(RegelSpraakParser.TOT)
                self.state = 1936
                self.datumExpressie()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 1937
                self.match(RegelSpraakParser.TOT_EN_MET)
                self.state = 1938
                self.datumExpressie()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PeriodeDefinitieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_periodeDefinitie

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class VanafPeriodeContext(PeriodeDefinitieContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PeriodeDefinitieContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def VANAF(self):
            return self.getToken(RegelSpraakParser.VANAF, 0)
        def dateExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.DateExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVanafPeriode" ):
                listener.enterVanafPeriode(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVanafPeriode" ):
                listener.exitVanafPeriode(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVanafPeriode" ):
                return visitor.visitVanafPeriode(self)
            else:
                return visitor.visitChildren(self)


    class VanTotPeriodeContext(PeriodeDefinitieContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PeriodeDefinitieContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def VAN(self):
            return self.getToken(RegelSpraakParser.VAN, 0)
        def dateExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.DateExpressionContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.DateExpressionContext,i)

        def TOT(self):
            return self.getToken(RegelSpraakParser.TOT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVanTotPeriode" ):
                listener.enterVanTotPeriode(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVanTotPeriode" ):
                listener.exitVanTotPeriode(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVanTotPeriode" ):
                return visitor.visitVanTotPeriode(self)
            else:
                return visitor.visitChildren(self)


    class VanTotEnMetPeriodeContext(PeriodeDefinitieContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PeriodeDefinitieContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def VAN(self):
            return self.getToken(RegelSpraakParser.VAN, 0)
        def dateExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.DateExpressionContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.DateExpressionContext,i)

        def TOT_EN_MET(self):
            return self.getToken(RegelSpraakParser.TOT_EN_MET, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVanTotEnMetPeriode" ):
                listener.enterVanTotEnMetPeriode(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVanTotEnMetPeriode" ):
                listener.exitVanTotEnMetPeriode(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVanTotEnMetPeriode" ):
                return visitor.visitVanTotEnMetPeriode(self)
            else:
                return visitor.visitChildren(self)


    class TotPeriodeContext(PeriodeDefinitieContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PeriodeDefinitieContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def TOT(self):
            return self.getToken(RegelSpraakParser.TOT, 0)
        def dateExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.DateExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTotPeriode" ):
                listener.enterTotPeriode(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTotPeriode" ):
                listener.exitTotPeriode(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTotPeriode" ):
                return visitor.visitTotPeriode(self)
            else:
                return visitor.visitChildren(self)


    class TotEnMetPeriodeContext(PeriodeDefinitieContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PeriodeDefinitieContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def TOT_EN_MET(self):
            return self.getToken(RegelSpraakParser.TOT_EN_MET, 0)
        def dateExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.DateExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTotEnMetPeriode" ):
                listener.enterTotEnMetPeriode(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTotEnMetPeriode" ):
                listener.exitTotEnMetPeriode(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTotEnMetPeriode" ):
                return visitor.visitTotEnMetPeriode(self)
            else:
                return visitor.visitChildren(self)



    def periodeDefinitie(self):

        localctx = RegelSpraakParser.PeriodeDefinitieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 290, self.RULE_periodeDefinitie)
        try:
            self.state = 1957
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,221,self._ctx)
            if la_ == 1:
                localctx = RegelSpraakParser.VanafPeriodeContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1941
                self.match(RegelSpraakParser.VANAF)
                self.state = 1942
                self.dateExpression()
                pass

            elif la_ == 2:
                localctx = RegelSpraakParser.TotPeriodeContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1943
                self.match(RegelSpraakParser.TOT)
                self.state = 1944
                self.dateExpression()
                pass

            elif la_ == 3:
                localctx = RegelSpraakParser.TotEnMetPeriodeContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 1945
                self.match(RegelSpraakParser.TOT_EN_MET)
                self.state = 1946
                self.dateExpression()
                pass

            elif la_ == 4:
                localctx = RegelSpraakParser.VanTotPeriodeContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 1947
                self.match(RegelSpraakParser.VAN)
                self.state = 1948
                self.dateExpression()
                self.state = 1949
                self.match(RegelSpraakParser.TOT)
                self.state = 1950
                self.dateExpression()
                pass

            elif la_ == 5:
                localctx = RegelSpraakParser.VanTotEnMetPeriodeContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 1952
                self.match(RegelSpraakParser.VAN)
                self.state = 1953
                self.dateExpression()
                self.state = 1954
                self.match(RegelSpraakParser.TOT_EN_MET)
                self.state = 1955
                self.dateExpression()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DateExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def datumLiteral(self):
            return self.getTypedRuleContext(RegelSpraakParser.DatumLiteralContext,0)


        def REKENDATUM(self):
            return self.getToken(RegelSpraakParser.REKENDATUM, 0)

        def REKENJAAR(self):
            return self.getToken(RegelSpraakParser.REKENJAAR, 0)

        def attribuutReferentie(self):
            return self.getTypedRuleContext(RegelSpraakParser.AttribuutReferentieContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_dateExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDateExpression" ):
                listener.enterDateExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDateExpression" ):
                listener.exitDateExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDateExpression" ):
                return visitor.visitDateExpression(self)
            else:
                return visitor.visitChildren(self)




    def dateExpression(self):

        localctx = RegelSpraakParser.DateExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 292, self.RULE_dateExpression)
        try:
            self.state = 1963
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [270]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1959
                self.datumLiteral()
                pass
            elif token in [235]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1960
                self.match(RegelSpraakParser.REKENDATUM)
                pass
            elif token in [236]:
                self.enterOuterAlt(localctx, 3)
                self.state = 1961
                self.match(RegelSpraakParser.REKENJAAR)
                pass
            elif token in [45, 96, 110, 119, 124, 132, 140, 161, 190, 201, 202, 205, 206, 209, 210, 212, 215, 217, 221, 223, 224, 232, 234, 253, 267]:
                self.enterOuterAlt(localctx, 4)
                self.state = 1962
                self.attribuutReferentie()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GetalAggregatieFunctieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def HET(self):
            return self.getToken(RegelSpraakParser.HET, 0)

        def AANTAL(self):
            return self.getToken(RegelSpraakParser.AANTAL, 0)

        def DE_MAXIMALE_WAARDE_VAN(self):
            return self.getToken(RegelSpraakParser.DE_MAXIMALE_WAARDE_VAN, 0)

        def DE_MINIMALE_WAARDE_VAN(self):
            return self.getToken(RegelSpraakParser.DE_MINIMALE_WAARDE_VAN, 0)

        def SOM_VAN(self):
            return self.getToken(RegelSpraakParser.SOM_VAN, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_getalAggregatieFunctie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGetalAggregatieFunctie" ):
                listener.enterGetalAggregatieFunctie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGetalAggregatieFunctie" ):
                listener.exitGetalAggregatieFunctie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGetalAggregatieFunctie" ):
                return visitor.visitGetalAggregatieFunctie(self)
            else:
                return visitor.visitChildren(self)




    def getalAggregatieFunctie(self):

        localctx = RegelSpraakParser.GetalAggregatieFunctieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 294, self.RULE_getalAggregatieFunctie)
        try:
            self.state = 1971
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [217]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1965
                self.match(RegelSpraakParser.HET)
                self.state = 1966
                self.match(RegelSpraakParser.AANTAL)
                pass
            elif token in [190]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1967
                self.match(RegelSpraakParser.AANTAL)
                pass
            elif token in [13]:
                self.enterOuterAlt(localctx, 3)
                self.state = 1968
                self.match(RegelSpraakParser.DE_MAXIMALE_WAARDE_VAN)
                pass
            elif token in [14]:
                self.enterOuterAlt(localctx, 4)
                self.state = 1969
                self.match(RegelSpraakParser.DE_MINIMALE_WAARDE_VAN)
                pass
            elif token in [195]:
                self.enterOuterAlt(localctx, 5)
                self.state = 1970
                self.match(RegelSpraakParser.SOM_VAN)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DatumAggregatieFunctieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EERSTE_VAN(self):
            return self.getToken(RegelSpraakParser.EERSTE_VAN, 0)

        def LAATSTE_VAN(self):
            return self.getToken(RegelSpraakParser.LAATSTE_VAN, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_datumAggregatieFunctie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDatumAggregatieFunctie" ):
                listener.enterDatumAggregatieFunctie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDatumAggregatieFunctie" ):
                listener.exitDatumAggregatieFunctie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDatumAggregatieFunctie" ):
                return visitor.visitDatumAggregatieFunctie(self)
            else:
                return visitor.visitChildren(self)




    def datumAggregatieFunctie(self):

        localctx = RegelSpraakParser.DatumAggregatieFunctieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 296, self.RULE_datumAggregatieFunctie)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1973
            _la = self._input.LA(1)
            if not(_la==191 or _la==193):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DimensieSelectieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OVER(self):
            return self.getToken(RegelSpraakParser.OVER, 0)

        def DOT(self):
            return self.getToken(RegelSpraakParser.DOT, 0)

        def aggregerenOverAlleDimensies(self):
            return self.getTypedRuleContext(RegelSpraakParser.AggregerenOverAlleDimensiesContext,0)


        def aggregerenOverVerzameling(self):
            return self.getTypedRuleContext(RegelSpraakParser.AggregerenOverVerzamelingContext,0)


        def aggregerenOverBereik(self):
            return self.getTypedRuleContext(RegelSpraakParser.AggregerenOverBereikContext,0)


        def VAN(self):
            return self.getToken(RegelSpraakParser.VAN, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_dimensieSelectie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDimensieSelectie" ):
                listener.enterDimensieSelectie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDimensieSelectie" ):
                listener.exitDimensieSelectie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDimensieSelectie" ):
                return visitor.visitDimensieSelectie(self)
            else:
                return visitor.visitChildren(self)




    def dimensieSelectie(self):

        localctx = RegelSpraakParser.DimensieSelectieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 298, self.RULE_dimensieSelectie)
        try:
            self.state = 1985
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [233]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1975
                self.match(RegelSpraakParser.OVER)
                self.state = 1979
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,224,self._ctx)
                if la_ == 1:
                    self.state = 1976
                    self.aggregerenOverAlleDimensies()
                    pass

                elif la_ == 2:
                    self.state = 1977
                    self.aggregerenOverVerzameling()
                    pass

                elif la_ == 3:
                    self.state = 1978
                    self.aggregerenOverBereik()
                    pass


                self.state = 1981
                self.match(RegelSpraakParser.DOT)
                pass
            elif token in [244]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1983
                self.match(RegelSpraakParser.VAN)
                self.state = 1984
                self.aggregerenOverAlleDimensies()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AggregerenOverAlleDimensiesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ALLE(self):
            return self.getToken(RegelSpraakParser.ALLE, 0)

        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def predicaat(self):
            return self.getTypedRuleContext(RegelSpraakParser.PredicaatContext,0)


        def DIE(self):
            return self.getToken(RegelSpraakParser.DIE, 0)

        def DAT(self):
            return self.getToken(RegelSpraakParser.DAT, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_aggregerenOverAlleDimensies

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAggregerenOverAlleDimensies" ):
                listener.enterAggregerenOverAlleDimensies(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAggregerenOverAlleDimensies" ):
                listener.exitAggregerenOverAlleDimensies(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAggregerenOverAlleDimensies" ):
                return visitor.visitAggregerenOverAlleDimensies(self)
            else:
                return visitor.visitChildren(self)




    def aggregerenOverAlleDimensies(self):

        localctx = RegelSpraakParser.AggregerenOverAlleDimensiesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 300, self.RULE_aggregerenOverAlleDimensies)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1987
            self.match(RegelSpraakParser.ALLE)
            self.state = 1988
            self.naamwoord()
            self.state = 1991
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,226,self._ctx)
            if la_ == 1:
                self.state = 1989
                _la = self._input.LA(1)
                if not(_la==211 or _la==214):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1990
                self.predicaat()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AggregerenOverVerzamelingContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DE(self):
            return self.getToken(RegelSpraakParser.DE, 0)

        def naamwoord(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.NaamwoordContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,i)


        def VANAF(self):
            return self.getToken(RegelSpraakParser.VANAF, 0)

        def TM(self):
            return self.getToken(RegelSpraakParser.TM, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_aggregerenOverVerzameling

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAggregerenOverVerzameling" ):
                listener.enterAggregerenOverVerzameling(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAggregerenOverVerzameling" ):
                listener.exitAggregerenOverVerzameling(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAggregerenOverVerzameling" ):
                return visitor.visitAggregerenOverVerzameling(self)
            else:
                return visitor.visitChildren(self)




    def aggregerenOverVerzameling(self):

        localctx = RegelSpraakParser.AggregerenOverVerzamelingContext(self, self._ctx, self.state)
        self.enterRule(localctx, 302, self.RULE_aggregerenOverVerzameling)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1993
            self.match(RegelSpraakParser.DE)
            self.state = 1994
            self.naamwoord()
            self.state = 1995
            self.match(RegelSpraakParser.VANAF)
            self.state = 1996
            self.naamwoord()
            self.state = 1997
            self.match(RegelSpraakParser.TM)
            self.state = 1998
            self.naamwoord()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AggregerenOverBereikContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DE(self):
            return self.getToken(RegelSpraakParser.DE, 0)

        def naamwoord(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.NaamwoordContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,i)


        def IN(self):
            return self.getToken(RegelSpraakParser.IN, 0)

        def LBRACE(self):
            return self.getToken(RegelSpraakParser.LBRACE, 0)

        def EN(self):
            return self.getToken(RegelSpraakParser.EN, 0)

        def RBRACE(self):
            return self.getToken(RegelSpraakParser.RBRACE, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.COMMA)
            else:
                return self.getToken(RegelSpraakParser.COMMA, i)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_aggregerenOverBereik

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAggregerenOverBereik" ):
                listener.enterAggregerenOverBereik(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAggregerenOverBereik" ):
                listener.exitAggregerenOverBereik(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAggregerenOverBereik" ):
                return visitor.visitAggregerenOverBereik(self)
            else:
                return visitor.visitChildren(self)




    def aggregerenOverBereik(self):

        localctx = RegelSpraakParser.AggregerenOverBereikContext(self, self._ctx, self.state)
        self.enterRule(localctx, 304, self.RULE_aggregerenOverBereik)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2000
            self.match(RegelSpraakParser.DE)
            self.state = 2001
            self.naamwoord()
            self.state = 2002
            self.match(RegelSpraakParser.IN)
            self.state = 2003
            self.match(RegelSpraakParser.LBRACE)
            self.state = 2004
            self.naamwoord()
            self.state = 2009
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==278:
                self.state = 2005
                self.match(RegelSpraakParser.COMMA)
                self.state = 2006
                self.naamwoord()
                self.state = 2011
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 2012
            self.match(RegelSpraakParser.EN)
            self.state = 2013
            self.naamwoord()
            self.state = 2014
            self.match(RegelSpraakParser.RBRACE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UnaryConditionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_unaryCondition

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class UnaryCheckConditionContext(UnaryConditionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.UnaryConditionContext
            super().__init__(parser)
            self.expr = None # PrimaryExpressionContext
            self.op = None # Token
            self.copyFrom(ctx)

        def primaryExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,0)

        def IS_LEEG(self):
            return self.getToken(RegelSpraakParser.IS_LEEG, 0)
        def IS_GEVULD(self):
            return self.getToken(RegelSpraakParser.IS_GEVULD, 0)
        def VOLDOET_AAN_DE_ELFPROEF(self):
            return self.getToken(RegelSpraakParser.VOLDOET_AAN_DE_ELFPROEF, 0)
        def VOLDOET_NIET_AAN_DE_ELFPROEF(self):
            return self.getToken(RegelSpraakParser.VOLDOET_NIET_AAN_DE_ELFPROEF, 0)
        def ZIJN_LEEG(self):
            return self.getToken(RegelSpraakParser.ZIJN_LEEG, 0)
        def ZIJN_GEVULD(self):
            return self.getToken(RegelSpraakParser.ZIJN_GEVULD, 0)
        def VOLDOEN_AAN_DE_ELFPROEF(self):
            return self.getToken(RegelSpraakParser.VOLDOEN_AAN_DE_ELFPROEF, 0)
        def VOLDOEN_NIET_AAN_DE_ELFPROEF(self):
            return self.getToken(RegelSpraakParser.VOLDOEN_NIET_AAN_DE_ELFPROEF, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnaryCheckCondition" ):
                listener.enterUnaryCheckCondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnaryCheckCondition" ):
                listener.exitUnaryCheckCondition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnaryCheckCondition" ):
                return visitor.visitUnaryCheckCondition(self)
            else:
                return visitor.visitChildren(self)


    class UnaryKenmerkConditionContext(UnaryConditionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.UnaryConditionContext
            super().__init__(parser)
            self.expr = None # PrimaryExpressionContext
            self.op = None # Token
            self.kenmerk = None # IdentifierContext
            self.copyFrom(ctx)

        def primaryExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,0)

        def identifier(self):
            return self.getTypedRuleContext(RegelSpraakParser.IdentifierContext,0)

        def IS_KENMERK(self):
            return self.getToken(RegelSpraakParser.IS_KENMERK, 0)
        def ZIJN_KENMERK(self):
            return self.getToken(RegelSpraakParser.ZIJN_KENMERK, 0)
        def IS_NIET_KENMERK(self):
            return self.getToken(RegelSpraakParser.IS_NIET_KENMERK, 0)
        def ZIJN_NIET_KENMERK(self):
            return self.getToken(RegelSpraakParser.ZIJN_NIET_KENMERK, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnaryKenmerkCondition" ):
                listener.enterUnaryKenmerkCondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnaryKenmerkCondition" ):
                listener.exitUnaryKenmerkCondition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnaryKenmerkCondition" ):
                return visitor.visitUnaryKenmerkCondition(self)
            else:
                return visitor.visitChildren(self)


    class UnaryNumeriekExactConditionContext(UnaryConditionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.UnaryConditionContext
            super().__init__(parser)
            self.expr = None # PrimaryExpressionContext
            self.op = None # Token
            self.copyFrom(ctx)

        def NUMBER(self):
            return self.getToken(RegelSpraakParser.NUMBER, 0)
        def CIJFERS(self):
            return self.getToken(RegelSpraakParser.CIJFERS, 0)
        def primaryExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,0)

        def IS_NUMERIEK_MET_EXACT(self):
            return self.getToken(RegelSpraakParser.IS_NUMERIEK_MET_EXACT, 0)
        def IS_NIET_NUMERIEK_MET_EXACT(self):
            return self.getToken(RegelSpraakParser.IS_NIET_NUMERIEK_MET_EXACT, 0)
        def ZIJN_NUMERIEK_MET_EXACT(self):
            return self.getToken(RegelSpraakParser.ZIJN_NUMERIEK_MET_EXACT, 0)
        def ZIJN_NIET_NUMERIEK_MET_EXACT(self):
            return self.getToken(RegelSpraakParser.ZIJN_NIET_NUMERIEK_MET_EXACT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnaryNumeriekExactCondition" ):
                listener.enterUnaryNumeriekExactCondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnaryNumeriekExactCondition" ):
                listener.exitUnaryNumeriekExactCondition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnaryNumeriekExactCondition" ):
                return visitor.visitUnaryNumeriekExactCondition(self)
            else:
                return visitor.visitChildren(self)


    class UnaryRolConditionContext(UnaryConditionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.UnaryConditionContext
            super().__init__(parser)
            self.expr = None # PrimaryExpressionContext
            self.op = None # Token
            self.rol = None # IdentifierContext
            self.copyFrom(ctx)

        def primaryExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,0)

        def identifier(self):
            return self.getTypedRuleContext(RegelSpraakParser.IdentifierContext,0)

        def IS_ROL(self):
            return self.getToken(RegelSpraakParser.IS_ROL, 0)
        def ZIJN_ROL(self):
            return self.getToken(RegelSpraakParser.ZIJN_ROL, 0)
        def IS_NIET_ROL(self):
            return self.getToken(RegelSpraakParser.IS_NIET_ROL, 0)
        def ZIJN_NIET_ROL(self):
            return self.getToken(RegelSpraakParser.ZIJN_NIET_ROL, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnaryRolCondition" ):
                listener.enterUnaryRolCondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnaryRolCondition" ):
                listener.exitUnaryRolCondition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnaryRolCondition" ):
                return visitor.visitUnaryRolCondition(self)
            else:
                return visitor.visitChildren(self)


    class UnaryDagsoortConditionContext(UnaryConditionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.UnaryConditionContext
            super().__init__(parser)
            self.expr = None # PrimaryExpressionContext
            self.op = None # Token
            self.dagsoort = None # IdentifierContext
            self.copyFrom(ctx)

        def primaryExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,0)

        def identifier(self):
            return self.getTypedRuleContext(RegelSpraakParser.IdentifierContext,0)

        def IS_EEN_DAGSOORT(self):
            return self.getToken(RegelSpraakParser.IS_EEN_DAGSOORT, 0)
        def ZIJN_EEN_DAGSOORT(self):
            return self.getToken(RegelSpraakParser.ZIJN_EEN_DAGSOORT, 0)
        def IS_GEEN_DAGSOORT(self):
            return self.getToken(RegelSpraakParser.IS_GEEN_DAGSOORT, 0)
        def ZIJN_GEEN_DAGSOORT(self):
            return self.getToken(RegelSpraakParser.ZIJN_GEEN_DAGSOORT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnaryDagsoortCondition" ):
                listener.enterUnaryDagsoortCondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnaryDagsoortCondition" ):
                listener.exitUnaryDagsoortCondition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnaryDagsoortCondition" ):
                return visitor.visitUnaryDagsoortCondition(self)
            else:
                return visitor.visitChildren(self)


    class UnaryInconsistentDataConditionContext(UnaryConditionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.UnaryConditionContext
            super().__init__(parser)
            self.expr = None # PrimaryExpressionContext
            self.copyFrom(ctx)

        def IS_INCONSISTENT(self):
            return self.getToken(RegelSpraakParser.IS_INCONSISTENT, 0)
        def primaryExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnaryInconsistentDataCondition" ):
                listener.enterUnaryInconsistentDataCondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnaryInconsistentDataCondition" ):
                listener.exitUnaryInconsistentDataCondition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnaryInconsistentDataCondition" ):
                return visitor.visitUnaryInconsistentDataCondition(self)
            else:
                return visitor.visitChildren(self)


    class UnaryUniekConditionContext(UnaryConditionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.UnaryConditionContext
            super().__init__(parser)
            self.ref = None # OnderwerpReferentieContext
            self.copyFrom(ctx)

        def MOETEN_UNIEK_ZIJN(self):
            return self.getToken(RegelSpraakParser.MOETEN_UNIEK_ZIJN, 0)
        def onderwerpReferentie(self):
            return self.getTypedRuleContext(RegelSpraakParser.OnderwerpReferentieContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnaryUniekCondition" ):
                listener.enterUnaryUniekCondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnaryUniekCondition" ):
                listener.exitUnaryUniekCondition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnaryUniekCondition" ):
                return visitor.visitUnaryUniekCondition(self)
            else:
                return visitor.visitChildren(self)



    def unaryCondition(self):

        localctx = RegelSpraakParser.UnaryConditionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 306, self.RULE_unaryCondition)
        self._la = 0 # Token type
        try:
            self.state = 2042
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,228,self._ctx)
            if la_ == 1:
                localctx = RegelSpraakParser.UnaryCheckConditionContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 2016
                localctx.expr = self.primaryExpression(0)
                self.state = 2017
                localctx.op = self._input.LT(1)
                _la = self._input.LA(1)
                if not(((((_la - 68)) & ~0x3f) == 0 and ((1 << (_la - 68)) & 61455) != 0)):
                    localctx.op = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass

            elif la_ == 2:
                localctx = RegelSpraakParser.UnaryNumeriekExactConditionContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 2019
                localctx.expr = self.primaryExpression(0)
                self.state = 2020
                localctx.op = self._input.LT(1)
                _la = self._input.LA(1)
                if not(((((_la - 84)) & ~0x3f) == 0 and ((1 << (_la - 84)) & 15) != 0)):
                    localctx.op = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 2021
                self.match(RegelSpraakParser.NUMBER)
                self.state = 2022
                self.match(RegelSpraakParser.CIJFERS)
                pass

            elif la_ == 3:
                localctx = RegelSpraakParser.UnaryDagsoortConditionContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 2024
                localctx.expr = self.primaryExpression(0)
                self.state = 2025
                localctx.op = self._input.LT(1)
                _la = self._input.LA(1)
                if not(((((_la - 88)) & ~0x3f) == 0 and ((1 << (_la - 88)) & 15) != 0)):
                    localctx.op = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 2026
                localctx.dagsoort = self.identifier()
                pass

            elif la_ == 4:
                localctx = RegelSpraakParser.UnaryKenmerkConditionContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 2028
                localctx.expr = self.primaryExpression(0)
                self.state = 2029
                localctx.op = self._input.LT(1)
                _la = self._input.LA(1)
                if not(((((_la - 72)) & ~0x3f) == 0 and ((1 << (_la - 72)) & 85) != 0)):
                    localctx.op = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 2030
                localctx.kenmerk = self.identifier()
                pass

            elif la_ == 5:
                localctx = RegelSpraakParser.UnaryRolConditionContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 2032
                localctx.expr = self.primaryExpression(0)
                self.state = 2033
                localctx.op = self._input.LT(1)
                _la = self._input.LA(1)
                if not(((((_la - 73)) & ~0x3f) == 0 and ((1 << (_la - 73)) & 85) != 0)):
                    localctx.op = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 2034
                localctx.rol = self.identifier()
                pass

            elif la_ == 6:
                localctx = RegelSpraakParser.UnaryUniekConditionContext(self, localctx)
                self.enterOuterAlt(localctx, 6)
                self.state = 2036
                localctx.ref = self.onderwerpReferentie()
                self.state = 2037
                self.match(RegelSpraakParser.MOETEN_UNIEK_ZIJN)
                pass

            elif la_ == 7:
                localctx = RegelSpraakParser.UnaryInconsistentDataConditionContext(self, localctx)
                self.enterOuterAlt(localctx, 7)
                self.state = 2039
                localctx.expr = self.primaryExpression(0)
                self.state = 2040
                self.match(RegelSpraakParser.IS_INCONSISTENT)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RegelStatusConditionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_regelStatusCondition

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class RegelStatusInconsistentCheckContext(RegelStatusConditionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.RegelStatusConditionContext
            super().__init__(parser)
            self.name = None # NaamwoordContext
            self.copyFrom(ctx)

        def REGELVERSIE(self):
            return self.getToken(RegelSpraakParser.REGELVERSIE, 0)
        def IS_INCONSISTENT(self):
            return self.getToken(RegelSpraakParser.IS_INCONSISTENT, 0)
        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRegelStatusInconsistentCheck" ):
                listener.enterRegelStatusInconsistentCheck(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRegelStatusInconsistentCheck" ):
                listener.exitRegelStatusInconsistentCheck(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRegelStatusInconsistentCheck" ):
                return visitor.visitRegelStatusInconsistentCheck(self)
            else:
                return visitor.visitChildren(self)


    class RegelStatusGevuurdCheckContext(RegelStatusConditionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.RegelStatusConditionContext
            super().__init__(parser)
            self.name = None # NaamwoordContext
            self.copyFrom(ctx)

        def REGELVERSIE(self):
            return self.getToken(RegelSpraakParser.REGELVERSIE, 0)
        def IS_GEVUURD(self):
            return self.getToken(RegelSpraakParser.IS_GEVUURD, 0)
        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRegelStatusGevuurdCheck" ):
                listener.enterRegelStatusGevuurdCheck(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRegelStatusGevuurdCheck" ):
                listener.exitRegelStatusGevuurdCheck(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRegelStatusGevuurdCheck" ):
                return visitor.visitRegelStatusGevuurdCheck(self)
            else:
                return visitor.visitChildren(self)



    def regelStatusCondition(self):

        localctx = RegelSpraakParser.RegelStatusConditionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 308, self.RULE_regelStatusCondition)
        try:
            self.state = 2052
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,229,self._ctx)
            if la_ == 1:
                localctx = RegelSpraakParser.RegelStatusGevuurdCheckContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 2044
                self.match(RegelSpraakParser.REGELVERSIE)
                self.state = 2045
                localctx.name = self.naamwoord()
                self.state = 2046
                self.match(RegelSpraakParser.IS_GEVUURD)
                pass

            elif la_ == 2:
                localctx = RegelSpraakParser.RegelStatusInconsistentCheckContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 2048
                self.match(RegelSpraakParser.REGELVERSIE)
                self.state = 2049
                localctx.name = self.naamwoord()
                self.state = 2050
                self.match(RegelSpraakParser.IS_INCONSISTENT)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SubordinateClauseExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_subordinateClauseExpression

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class SubordinateIsWithExprContext(SubordinateClauseExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.SubordinateClauseExpressionContext
            super().__init__(parser)
            self.subject = None # OnderwerpReferentieContext
            self.prepPhrase = None # NaamwoordWithNumbersContext
            self.verb = None # Token
            self.copyFrom(ctx)

        def onderwerpReferentie(self):
            return self.getTypedRuleContext(RegelSpraakParser.OnderwerpReferentieContext,0)

        def naamwoordWithNumbers(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordWithNumbersContext,0)

        def IS(self):
            return self.getToken(RegelSpraakParser.IS, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSubordinateIsWithExpr" ):
                listener.enterSubordinateIsWithExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSubordinateIsWithExpr" ):
                listener.exitSubordinateIsWithExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSubordinateIsWithExpr" ):
                return visitor.visitSubordinateIsWithExpr(self)
            else:
                return visitor.visitChildren(self)


    class SubordinateHasExprContext(SubordinateClauseExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.SubordinateClauseExpressionContext
            super().__init__(parser)
            self.subject = None # OnderwerpReferentieContext
            self.object_ = None # NaamwoordWithNumbersContext
            self.verb = None # Token
            self.copyFrom(ctx)

        def onderwerpReferentie(self):
            return self.getTypedRuleContext(RegelSpraakParser.OnderwerpReferentieContext,0)

        def naamwoordWithNumbers(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordWithNumbersContext,0)

        def HEEFT(self):
            return self.getToken(RegelSpraakParser.HEEFT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSubordinateHasExpr" ):
                listener.enterSubordinateHasExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSubordinateHasExpr" ):
                listener.exitSubordinateHasExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSubordinateHasExpr" ):
                return visitor.visitSubordinateHasExpr(self)
            else:
                return visitor.visitChildren(self)


    class SubordinateIsKenmerkExprContext(SubordinateClauseExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.SubordinateClauseExpressionContext
            super().__init__(parser)
            self.subject = None # OnderwerpReferentieContext
            self.verb = None # Token
            self.kenmerk = None # NaamwoordWithNumbersContext
            self.copyFrom(ctx)

        def onderwerpReferentie(self):
            return self.getTypedRuleContext(RegelSpraakParser.OnderwerpReferentieContext,0)

        def IS(self):
            return self.getToken(RegelSpraakParser.IS, 0)
        def naamwoordWithNumbers(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordWithNumbersContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSubordinateIsKenmerkExpr" ):
                listener.enterSubordinateIsKenmerkExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSubordinateIsKenmerkExpr" ):
                listener.exitSubordinateIsKenmerkExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSubordinateIsKenmerkExpr" ):
                return visitor.visitSubordinateIsKenmerkExpr(self)
            else:
                return visitor.visitChildren(self)



    def subordinateClauseExpression(self):

        localctx = RegelSpraakParser.SubordinateClauseExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 310, self.RULE_subordinateClauseExpression)
        try:
            self.state = 2066
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,230,self._ctx)
            if la_ == 1:
                localctx = RegelSpraakParser.SubordinateHasExprContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 2054
                localctx.subject = self.onderwerpReferentie()
                self.state = 2055
                localctx.object_ = self.naamwoordWithNumbers()
                self.state = 2056
                localctx.verb = self.match(RegelSpraakParser.HEEFT)
                pass

            elif la_ == 2:
                localctx = RegelSpraakParser.SubordinateIsWithExprContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 2058
                localctx.subject = self.onderwerpReferentie()
                self.state = 2059
                localctx.prepPhrase = self.naamwoordWithNumbers()
                self.state = 2060
                localctx.verb = self.match(RegelSpraakParser.IS)
                pass

            elif la_ == 3:
                localctx = RegelSpraakParser.SubordinateIsKenmerkExprContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 2062
                localctx.subject = self.onderwerpReferentie()
                self.state = 2063
                localctx.verb = self.match(RegelSpraakParser.IS)
                self.state = 2064
                localctx.kenmerk = self.naamwoordWithNumbers()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DagsoortDefinitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self._IDENTIFIER = None # Token
            self.plural = list() # of Tokens

        def DAGSOORT(self):
            return self.getToken(RegelSpraakParser.DAGSOORT, 0)

        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def MV_START(self):
            return self.getToken(RegelSpraakParser.MV_START, 0)

        def RPAREN(self):
            return self.getToken(RegelSpraakParser.RPAREN, 0)

        def SEMICOLON(self):
            return self.getToken(RegelSpraakParser.SEMICOLON, 0)

        def IDENTIFIER(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.IDENTIFIER)
            else:
                return self.getToken(RegelSpraakParser.IDENTIFIER, i)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_dagsoortDefinition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDagsoortDefinition" ):
                listener.enterDagsoortDefinition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDagsoortDefinition" ):
                listener.exitDagsoortDefinition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDagsoortDefinition" ):
                return visitor.visitDagsoortDefinition(self)
            else:
                return visitor.visitChildren(self)




    def dagsoortDefinition(self):

        localctx = RegelSpraakParser.DagsoortDefinitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 312, self.RULE_dagsoortDefinition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2068
            self.match(RegelSpraakParser.DAGSOORT)
            self.state = 2069
            self.naamwoord()
            self.state = 2077
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==178:
                self.state = 2070
                self.match(RegelSpraakParser.MV_START)
                self.state = 2072 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 2071
                    localctx._IDENTIFIER = self.match(RegelSpraakParser.IDENTIFIER)
                    localctx.plural.append(localctx._IDENTIFIER)
                    self.state = 2074 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==267):
                        break

                self.state = 2076
                self.match(RegelSpraakParser.RPAREN)


            self.state = 2080
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==281:
                self.state = 2079
                self.match(RegelSpraakParser.SEMICOLON)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TekstreeksExprContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STRING_LITERAL(self):
            return self.getToken(RegelSpraakParser.STRING_LITERAL, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_tekstreeksExpr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTekstreeksExpr" ):
                listener.enterTekstreeksExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTekstreeksExpr" ):
                listener.exitTekstreeksExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTekstreeksExpr" ):
                return visitor.visitTekstreeksExpr(self)
            else:
                return visitor.visitChildren(self)




    def tekstreeksExpr(self):

        localctx = RegelSpraakParser.TekstreeksExprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 314, self.RULE_tekstreeksExpr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2082
            self.match(RegelSpraakParser.STRING_LITERAL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VerdelingResultaatContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.sourceAmount = None # ExpressieContext
            self.targetCollection = None # ExpressieContext

        def WORDT_VERDEELD_OVER(self):
            return self.getToken(RegelSpraakParser.WORDT_VERDEELD_OVER, 0)

        def COMMA(self):
            return self.getToken(RegelSpraakParser.COMMA, 0)

        def WAARBIJ_WORDT_VERDEELD(self):
            return self.getToken(RegelSpraakParser.WAARBIJ_WORDT_VERDEELD, 0)

        def expressie(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.ExpressieContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,i)


        def verdelingMethodeSimple(self):
            return self.getTypedRuleContext(RegelSpraakParser.VerdelingMethodeSimpleContext,0)


        def verdelingMethodeMultiLine(self):
            return self.getTypedRuleContext(RegelSpraakParser.VerdelingMethodeMultiLineContext,0)


        def verdelingRest(self):
            return self.getTypedRuleContext(RegelSpraakParser.VerdelingRestContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_verdelingResultaat

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVerdelingResultaat" ):
                listener.enterVerdelingResultaat(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVerdelingResultaat" ):
                listener.exitVerdelingResultaat(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVerdelingResultaat" ):
                return visitor.visitVerdelingResultaat(self)
            else:
                return visitor.visitChildren(self)




    def verdelingResultaat(self):

        localctx = RegelSpraakParser.VerdelingResultaatContext(self, self._ctx, self.state)
        self.enterRule(localctx, 316, self.RULE_verdelingResultaat)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2084
            localctx.sourceAmount = self.expressie()
            self.state = 2085
            self.match(RegelSpraakParser.WORDT_VERDEELD_OVER)
            self.state = 2086
            localctx.targetCollection = self.expressie()
            self.state = 2087
            self.match(RegelSpraakParser.COMMA)
            self.state = 2088
            self.match(RegelSpraakParser.WAARBIJ_WORDT_VERDEELD)
            self.state = 2091
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [21, 33, 34, 35, 123, 198]:
                self.state = 2089
                self.verdelingMethodeSimple()
                pass
            elif token in [280]:
                self.state = 2090
                self.verdelingMethodeMultiLine()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 2094
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==19:
                self.state = 2093
                self.verdelingRest()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VerdelingMethodeSimpleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def verdelingMethode(self):
            return self.getTypedRuleContext(RegelSpraakParser.VerdelingMethodeContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_verdelingMethodeSimple

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVerdelingMethodeSimple" ):
                listener.enterVerdelingMethodeSimple(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVerdelingMethodeSimple" ):
                listener.exitVerdelingMethodeSimple(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVerdelingMethodeSimple" ):
                return visitor.visitVerdelingMethodeSimple(self)
            else:
                return visitor.visitChildren(self)




    def verdelingMethodeSimple(self):

        localctx = RegelSpraakParser.VerdelingMethodeSimpleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 318, self.RULE_verdelingMethodeSimple)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2096
            self.verdelingMethode()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VerdelingMethodeMultiLineContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def COLON(self):
            return self.getToken(RegelSpraakParser.COLON, 0)

        def verdelingMethodeBulletList(self):
            return self.getTypedRuleContext(RegelSpraakParser.VerdelingMethodeBulletListContext,0)


        def DOT(self):
            return self.getToken(RegelSpraakParser.DOT, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_verdelingMethodeMultiLine

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVerdelingMethodeMultiLine" ):
                listener.enterVerdelingMethodeMultiLine(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVerdelingMethodeMultiLine" ):
                listener.exitVerdelingMethodeMultiLine(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVerdelingMethodeMultiLine" ):
                return visitor.visitVerdelingMethodeMultiLine(self)
            else:
                return visitor.visitChildren(self)




    def verdelingMethodeMultiLine(self):

        localctx = RegelSpraakParser.VerdelingMethodeMultiLineContext(self, self._ctx, self.state)
        self.enterRule(localctx, 320, self.RULE_verdelingMethodeMultiLine)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2098
            self.match(RegelSpraakParser.COLON)
            self.state = 2099
            self.verdelingMethodeBulletList()
            self.state = 2101
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,236,self._ctx)
            if la_ == 1:
                self.state = 2100
                self.match(RegelSpraakParser.DOT)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VerdelingMethodeBulletListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def verdelingMethodeBullet(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.VerdelingMethodeBulletContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.VerdelingMethodeBulletContext,i)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_verdelingMethodeBulletList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVerdelingMethodeBulletList" ):
                listener.enterVerdelingMethodeBulletList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVerdelingMethodeBulletList" ):
                listener.exitVerdelingMethodeBulletList(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVerdelingMethodeBulletList" ):
                return visitor.visitVerdelingMethodeBulletList(self)
            else:
                return visitor.visitChildren(self)




    def verdelingMethodeBulletList(self):

        localctx = RegelSpraakParser.VerdelingMethodeBulletListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 322, self.RULE_verdelingMethodeBulletList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2103
            self.verdelingMethodeBullet()
            self.state = 2107
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==292:
                self.state = 2104
                self.verdelingMethodeBullet()
                self.state = 2109
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VerdelingMethodeBulletContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MINUS(self):
            return self.getToken(RegelSpraakParser.MINUS, 0)

        def verdelingMethode(self):
            return self.getTypedRuleContext(RegelSpraakParser.VerdelingMethodeContext,0)


        def COMMA(self):
            return self.getToken(RegelSpraakParser.COMMA, 0)

        def DOT(self):
            return self.getToken(RegelSpraakParser.DOT, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_verdelingMethodeBullet

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVerdelingMethodeBullet" ):
                listener.enterVerdelingMethodeBullet(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVerdelingMethodeBullet" ):
                listener.exitVerdelingMethodeBullet(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVerdelingMethodeBullet" ):
                return visitor.visitVerdelingMethodeBullet(self)
            else:
                return visitor.visitChildren(self)




    def verdelingMethodeBullet(self):

        localctx = RegelSpraakParser.VerdelingMethodeBulletContext(self, self._ctx, self.state)
        self.enterRule(localctx, 324, self.RULE_verdelingMethodeBullet)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2110
            self.match(RegelSpraakParser.MINUS)
            self.state = 2111
            self.verdelingMethode()
            self.state = 2113
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,238,self._ctx)
            if la_ == 1:
                self.state = 2112
                _la = self._input.LA(1)
                if not(_la==278 or _la==279):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VerdelingMethodeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_verdelingMethode

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class VerdelingNaarRatoContext(VerdelingMethodeContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.VerdelingMethodeContext
            super().__init__(parser)
            self.ratioExpression = None # ExpressieContext
            self.copyFrom(ctx)

        def NAAR_RATO_VAN(self):
            return self.getToken(RegelSpraakParser.NAAR_RATO_VAN, 0)
        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVerdelingNaarRato" ):
                listener.enterVerdelingNaarRato(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVerdelingNaarRato" ):
                listener.exitVerdelingNaarRato(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVerdelingNaarRato" ):
                return visitor.visitVerdelingNaarRato(self)
            else:
                return visitor.visitChildren(self)


    class VerdelingGelijkeDelenContext(VerdelingMethodeContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.VerdelingMethodeContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def IN_GELIJKE_DELEN(self):
            return self.getToken(RegelSpraakParser.IN_GELIJKE_DELEN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVerdelingGelijkeDelen" ):
                listener.enterVerdelingGelijkeDelen(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVerdelingGelijkeDelen" ):
                listener.exitVerdelingGelijkeDelen(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVerdelingGelijkeDelen" ):
                return visitor.visitVerdelingGelijkeDelen(self)
            else:
                return visitor.visitChildren(self)


    class VerdelingMaximumContext(VerdelingMethodeContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.VerdelingMethodeContext
            super().__init__(parser)
            self.maxExpression = None # ExpressieContext
            self.copyFrom(ctx)

        def MET_EEN_MAXIMUM_VAN(self):
            return self.getToken(RegelSpraakParser.MET_EEN_MAXIMUM_VAN, 0)
        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVerdelingMaximum" ):
                listener.enterVerdelingMaximum(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVerdelingMaximum" ):
                listener.exitVerdelingMaximum(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVerdelingMaximum" ):
                return visitor.visitVerdelingMaximum(self)
            else:
                return visitor.visitChildren(self)


    class VerdelingOpVolgordeContext(VerdelingMethodeContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.VerdelingMethodeContext
            super().__init__(parser)
            self.orderDirection = None # Token
            self.orderExpression = None # ExpressieContext
            self.copyFrom(ctx)

        def OP_VOLGORDE_VAN(self):
            return self.getToken(RegelSpraakParser.OP_VOLGORDE_VAN, 0)
        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)

        def TOENEMENDE(self):
            return self.getToken(RegelSpraakParser.TOENEMENDE, 0)
        def AFNEMENDE(self):
            return self.getToken(RegelSpraakParser.AFNEMENDE, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVerdelingOpVolgorde" ):
                listener.enterVerdelingOpVolgorde(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVerdelingOpVolgorde" ):
                listener.exitVerdelingOpVolgorde(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVerdelingOpVolgorde" ):
                return visitor.visitVerdelingOpVolgorde(self)
            else:
                return visitor.visitChildren(self)


    class VerdelingTieBreakContext(VerdelingMethodeContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.VerdelingMethodeContext
            super().__init__(parser)
            self.tieBreakMethod = None # VerdelingMethodeContext
            self.copyFrom(ctx)

        def BIJ_EVEN_GROOT_CRITERIUM(self):
            return self.getToken(RegelSpraakParser.BIJ_EVEN_GROOT_CRITERIUM, 0)
        def verdelingMethode(self):
            return self.getTypedRuleContext(RegelSpraakParser.VerdelingMethodeContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVerdelingTieBreak" ):
                listener.enterVerdelingTieBreak(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVerdelingTieBreak" ):
                listener.exitVerdelingTieBreak(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVerdelingTieBreak" ):
                return visitor.visitVerdelingTieBreak(self)
            else:
                return visitor.visitChildren(self)


    class VerdelingAfrondingContext(VerdelingMethodeContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.VerdelingMethodeContext
            super().__init__(parser)
            self.decimals = None # Token
            self.roundDirection = None # Token
            self.copyFrom(ctx)

        def AFGEROND_OP(self):
            return self.getToken(RegelSpraakParser.AFGEROND_OP, 0)
        def DECIMALEN(self):
            return self.getToken(RegelSpraakParser.DECIMALEN, 0)
        def NUMBER(self):
            return self.getToken(RegelSpraakParser.NUMBER, 0)
        def NAAR_BENEDEN(self):
            return self.getToken(RegelSpraakParser.NAAR_BENEDEN, 0)
        def NAAR_BOVEN(self):
            return self.getToken(RegelSpraakParser.NAAR_BOVEN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVerdelingAfronding" ):
                listener.enterVerdelingAfronding(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVerdelingAfronding" ):
                listener.exitVerdelingAfronding(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVerdelingAfronding" ):
                return visitor.visitVerdelingAfronding(self)
            else:
                return visitor.visitChildren(self)



    def verdelingMethode(self):

        localctx = RegelSpraakParser.VerdelingMethodeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 326, self.RULE_verdelingMethode)
        self._la = 0 # Token type
        try:
            self.state = 2129
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [198]:
                localctx = RegelSpraakParser.VerdelingGelijkeDelenContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 2115
                self.match(RegelSpraakParser.IN_GELIJKE_DELEN)
                pass
            elif token in [35]:
                localctx = RegelSpraakParser.VerdelingNaarRatoContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 2116
                self.match(RegelSpraakParser.NAAR_RATO_VAN)
                self.state = 2117
                localctx.ratioExpression = self.expressie()
                pass
            elif token in [34]:
                localctx = RegelSpraakParser.VerdelingOpVolgordeContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 2118
                self.match(RegelSpraakParser.OP_VOLGORDE_VAN)
                self.state = 2119
                localctx.orderDirection = self._input.LT(1)
                _la = self._input.LA(1)
                if not(_la==197 or _la==200):
                    localctx.orderDirection = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 2120
                localctx.orderExpression = self.expressie()
                pass
            elif token in [33]:
                localctx = RegelSpraakParser.VerdelingTieBreakContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 2121
                self.match(RegelSpraakParser.BIJ_EVEN_GROOT_CRITERIUM)
                self.state = 2122
                localctx.tieBreakMethod = self.verdelingMethode()
                pass
            elif token in [21]:
                localctx = RegelSpraakParser.VerdelingMaximumContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 2123
                self.match(RegelSpraakParser.MET_EEN_MAXIMUM_VAN)
                self.state = 2124
                localctx.maxExpression = self.expressie()
                pass
            elif token in [123]:
                localctx = RegelSpraakParser.VerdelingAfrondingContext(self, localctx)
                self.enterOuterAlt(localctx, 6)
                self.state = 2125
                self.match(RegelSpraakParser.AFGEROND_OP)
                self.state = 2126
                localctx.decimals = self.match(RegelSpraakParser.NUMBER)
                self.state = 2127
                self.match(RegelSpraakParser.DECIMALEN)
                self.state = 2128
                localctx.roundDirection = self._input.LT(1)
                _la = self._input.LA(1)
                if not(_la==138 or _la==139):
                    localctx.roundDirection = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VerdelingRestContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.remainderTarget = None # ExpressieContext

        def ALS_ONVERDEELDE_REST_BLIJFT(self):
            return self.getToken(RegelSpraakParser.ALS_ONVERDEELDE_REST_BLIJFT, 0)

        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)


        def OVER_VERDELING(self):
            return self.getToken(RegelSpraakParser.OVER_VERDELING, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_verdelingRest

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVerdelingRest" ):
                listener.enterVerdelingRest(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVerdelingRest" ):
                listener.exitVerdelingRest(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVerdelingRest" ):
                return visitor.visitVerdelingRest(self)
            else:
                return visitor.visitChildren(self)




    def verdelingRest(self):

        localctx = RegelSpraakParser.VerdelingRestContext(self, self._ctx, self.state)
        self.enterRule(localctx, 328, self.RULE_verdelingRest)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2131
            self.match(RegelSpraakParser.ALS_ONVERDEELDE_REST_BLIJFT)
            self.state = 2132
            localctx.remainderTarget = self.expressie()
            self.state = 2134
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==199:
                self.state = 2133
                self.match(RegelSpraakParser.OVER_VERDELING)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx



    def sempred(self, localctx:RuleContext, ruleIndex:int, predIndex:int):
        if self._predicates == None:
            self._predicates = dict()
        self._predicates[137] = self.primaryExpression_sempred
        pred = self._predicates.get(ruleIndex, None)
        if pred is None:
            raise Exception("No predicate with index:" + str(ruleIndex))
        else:
            return pred(localctx, predIndex)

    def primaryExpression_sempred(self, localctx:PrimaryExpressionContext, predIndex:int):
            if predIndex == 0:
                return self.precpred(self._ctx, 38)
         

            if predIndex == 1:
                return self.precpred(self._ctx, 42)
         

            if predIndex == 2:
                return self.precpred(self._ctx, 41)
         

            if predIndex == 3:
                return self.precpred(self._ctx, 40)
         




