# Generated from RegelSpraak.g4 by ANTLR 4.13.1
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO

def serializedATN():
    return [
        4,1,294,2135,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,
        7,6,2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,
        13,2,14,7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,
        20,7,20,2,21,7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,
        26,2,27,7,27,2,28,7,28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,
        33,7,33,2,34,7,34,2,35,7,35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,
        39,2,40,7,40,2,41,7,41,2,42,7,42,2,43,7,43,2,44,7,44,2,45,7,45,2,
        46,7,46,2,47,7,47,2,48,7,48,2,49,7,49,2,50,7,50,2,51,7,51,2,52,7,
        52,2,53,7,53,2,54,7,54,2,55,7,55,2,56,7,56,2,57,7,57,2,58,7,58,2,
        59,7,59,2,60,7,60,2,61,7,61,2,62,7,62,2,63,7,63,2,64,7,64,2,65,7,
        65,2,66,7,66,2,67,7,67,2,68,7,68,2,69,7,69,2,70,7,70,2,71,7,71,2,
        72,7,72,2,73,7,73,2,74,7,74,2,75,7,75,2,76,7,76,2,77,7,77,2,78,7,
        78,2,79,7,79,2,80,7,80,2,81,7,81,2,82,7,82,2,83,7,83,2,84,7,84,2,
        85,7,85,2,86,7,86,2,87,7,87,2,88,7,88,2,89,7,89,2,90,7,90,2,91,7,
        91,2,92,7,92,2,93,7,93,2,94,7,94,2,95,7,95,2,96,7,96,2,97,7,97,2,
        98,7,98,2,99,7,99,2,100,7,100,2,101,7,101,2,102,7,102,2,103,7,103,
        2,104,7,104,2,105,7,105,2,106,7,106,2,107,7,107,2,108,7,108,2,109,
        7,109,2,110,7,110,2,111,7,111,2,112,7,112,2,113,7,113,2,114,7,114,
        2,115,7,115,2,116,7,116,2,117,7,117,2,118,7,118,2,119,7,119,2,120,
        7,120,2,121,7,121,2,122,7,122,2,123,7,123,2,124,7,124,2,125,7,125,
        2,126,7,126,2,127,7,127,2,128,7,128,2,129,7,129,2,130,7,130,2,131,
        7,131,2,132,7,132,2,133,7,133,2,134,7,134,2,135,7,135,2,136,7,136,
        2,137,7,137,2,138,7,138,2,139,7,139,2,140,7,140,2,141,7,141,2,142,
        7,142,2,143,7,143,2,144,7,144,2,145,7,145,2,146,7,146,2,147,7,147,
        2,148,7,148,2,149,7,149,2,150,7,150,2,151,7,151,2,152,7,152,2,153,
        7,153,2,154,7,154,2,155,7,155,2,156,7,156,2,157,7,157,2,158,7,158,
        2,159,7,159,2,160,7,160,2,161,7,161,2,162,7,162,2,163,7,163,2,164,
        7,164,1,0,1,0,1,0,1,0,1,0,1,0,5,0,337,8,0,10,0,12,0,340,9,0,1,0,
        1,0,1,1,1,1,1,1,1,1,1,1,1,1,3,1,350,8,1,1,2,1,2,1,2,3,2,355,8,2,
        1,2,1,2,1,3,1,3,1,3,4,3,362,8,3,11,3,12,3,363,1,4,1,4,3,4,368,8,
        4,1,4,1,4,1,4,1,4,1,4,5,4,375,8,4,10,4,12,4,378,9,4,1,4,3,4,381,
        8,4,1,5,3,5,384,8,5,1,5,4,5,387,8,5,11,5,12,5,388,1,5,3,5,392,8,
        5,4,5,394,8,5,11,5,12,5,395,1,5,5,5,399,8,5,10,5,12,5,402,9,5,1,
        6,1,6,1,6,1,6,1,6,1,6,1,6,1,6,5,6,412,8,6,10,6,12,6,415,9,6,1,6,
        3,6,418,8,6,1,7,1,7,3,7,422,8,7,1,8,4,8,425,8,8,11,8,12,8,426,1,
        9,1,9,1,10,1,10,1,11,1,11,1,12,3,12,436,8,12,1,12,4,12,439,8,12,
        11,12,12,12,440,1,12,4,12,444,8,12,11,12,12,12,445,1,12,1,12,4,12,
        450,8,12,11,12,12,12,451,1,12,1,12,4,12,456,8,12,11,12,12,12,457,
        1,12,1,12,4,12,462,8,12,11,12,12,12,463,1,12,4,12,467,8,12,11,12,
        12,12,468,1,12,1,12,4,12,473,8,12,11,12,12,12,474,1,12,1,12,4,12,
        479,8,12,11,12,12,12,480,1,12,1,12,1,12,1,12,1,12,4,12,488,8,12,
        11,12,12,12,489,3,12,492,8,12,1,13,3,13,495,8,13,1,13,4,13,498,8,
        13,11,13,12,13,499,1,13,4,13,503,8,13,11,13,12,13,504,1,13,1,13,
        4,13,509,8,13,11,13,12,13,510,1,13,1,13,4,13,515,8,13,11,13,12,13,
        516,1,13,1,13,4,13,521,8,13,11,13,12,13,522,1,13,4,13,526,8,13,11,
        13,12,13,527,1,13,1,13,4,13,532,8,13,11,13,12,13,533,1,13,1,13,4,
        13,538,8,13,11,13,12,13,539,1,13,1,13,1,13,1,13,1,13,4,13,547,8,
        13,11,13,12,13,548,3,13,551,8,13,1,14,1,14,3,14,555,8,14,1,15,3,
        15,558,8,15,1,15,4,15,561,8,15,11,15,12,15,562,1,15,4,15,566,8,15,
        11,15,12,15,567,1,15,1,15,4,15,572,8,15,11,15,12,15,573,1,15,1,15,
        4,15,578,8,15,11,15,12,15,579,1,15,1,15,4,15,584,8,15,11,15,12,15,
        585,1,15,4,15,589,8,15,11,15,12,15,590,1,15,1,15,4,15,595,8,15,11,
        15,12,15,596,1,15,1,15,4,15,601,8,15,11,15,12,15,602,3,15,605,8,
        15,1,16,1,16,1,16,1,16,5,16,611,8,16,10,16,12,16,614,9,16,1,17,1,
        17,1,17,1,17,5,17,620,8,17,10,17,12,17,623,9,17,1,18,1,18,1,18,1,
        18,5,18,629,8,18,10,18,12,18,632,9,18,1,19,1,19,1,20,1,20,1,21,1,
        21,1,22,1,22,1,23,1,23,1,23,1,23,4,23,646,8,23,11,23,12,23,647,1,
        23,3,23,651,8,23,1,23,3,23,654,8,23,1,23,5,23,657,8,23,10,23,12,
        23,660,9,23,1,24,1,24,3,24,664,8,24,1,24,1,24,1,25,3,25,669,8,25,
        1,25,1,25,3,25,673,8,25,1,25,1,25,3,25,677,8,25,1,25,3,25,680,8,
        25,1,26,1,26,1,26,1,26,3,26,686,8,26,1,26,1,26,3,26,690,8,26,1,26,
        1,26,1,26,1,26,5,26,696,8,26,10,26,12,26,699,9,26,3,26,701,8,26,
        1,26,3,26,704,8,26,1,27,1,27,1,27,1,27,1,27,1,27,3,27,712,8,27,1,
        28,1,28,1,28,1,28,1,28,3,28,719,8,28,1,29,1,29,1,29,1,29,1,29,3,
        29,726,8,29,1,30,1,30,1,31,1,31,1,31,1,31,1,31,3,31,735,8,31,1,32,
        1,32,1,33,1,33,1,34,3,34,742,8,34,1,34,1,34,1,34,1,34,1,34,1,34,
        3,34,750,8,34,1,35,1,35,1,35,1,35,1,35,1,35,3,35,758,8,35,1,35,3,
        35,761,8,35,1,36,1,36,1,36,1,36,1,36,3,36,768,8,36,1,37,1,37,4,37,
        772,8,37,11,37,12,37,773,1,38,1,38,1,39,1,39,1,40,1,40,1,40,5,40,
        783,8,40,10,40,12,40,786,9,40,1,41,1,41,1,41,1,41,1,41,1,41,3,41,
        794,8,41,1,41,1,41,3,41,798,8,41,1,41,1,41,3,41,802,8,41,1,41,1,
        41,3,41,806,8,41,1,42,1,42,1,43,1,43,1,43,3,43,813,8,43,1,43,1,43,
        1,43,1,43,3,43,819,8,43,1,44,1,44,1,44,3,44,824,8,44,1,45,1,45,1,
        45,3,45,829,8,45,1,45,1,45,1,45,1,45,4,45,835,8,45,11,45,12,45,836,
        1,46,1,46,1,46,1,46,3,46,843,8,46,1,46,3,46,846,8,46,1,47,1,47,1,
        47,1,47,1,48,1,48,1,49,1,49,1,50,1,50,1,50,1,50,1,50,3,50,861,8,
        50,1,50,1,50,3,50,865,8,50,1,50,1,50,3,50,869,8,50,1,50,3,50,872,
        8,50,1,51,3,51,875,8,51,1,51,1,51,1,51,1,51,5,51,881,8,51,10,51,
        12,51,884,9,51,1,52,4,52,887,8,52,11,52,12,52,888,1,53,3,53,892,
        8,53,1,53,1,53,1,53,1,53,5,53,898,8,53,10,53,12,53,901,9,53,1,53,
        3,53,904,8,53,1,54,1,54,1,54,1,54,4,54,910,8,54,11,54,12,54,911,
        1,54,1,54,1,54,1,54,1,54,1,54,1,54,3,54,921,8,54,1,55,1,55,1,55,
        1,55,1,55,1,55,3,55,929,8,55,1,55,3,55,932,8,55,1,56,4,56,935,8,
        56,11,56,12,56,936,1,57,1,57,4,57,941,8,57,11,57,12,57,942,1,58,
        4,58,946,8,58,11,58,12,58,947,1,59,1,59,1,60,1,60,1,60,3,60,955,
        8,60,1,60,1,60,1,60,1,60,3,60,961,8,60,1,60,3,60,964,8,60,1,60,3,
        60,967,8,60,1,61,1,61,1,61,3,61,972,8,61,1,61,1,61,4,61,976,8,61,
        11,61,12,61,977,1,62,1,62,5,62,982,8,62,10,62,12,62,985,9,62,1,63,
        1,63,1,63,1,63,1,63,1,63,1,63,1,63,1,63,1,63,1,63,1,63,1,63,1,63,
        3,63,1001,8,63,1,64,1,64,1,64,1,65,1,65,1,65,1,65,1,65,3,65,1011,
        8,65,3,65,1013,8,65,1,66,1,66,1,66,1,66,1,66,1,66,1,66,1,66,1,66,
        1,66,1,66,1,66,3,66,1027,8,66,1,66,3,66,1030,8,66,1,66,1,66,1,66,
        1,66,1,66,1,66,1,66,1,66,1,66,1,66,3,66,1042,8,66,1,66,1,66,1,66,
        1,66,1,66,1,66,1,66,1,66,1,66,1,66,1,66,3,66,1055,8,66,1,67,1,67,
        1,68,1,68,1,68,1,68,1,68,1,68,1,68,1,68,1,68,1,68,1,68,1,68,1,69,
        4,69,1072,8,69,11,69,12,69,1073,1,70,4,70,1077,8,70,11,70,12,70,
        1078,1,71,1,71,1,71,1,71,1,71,3,71,1086,8,71,1,72,1,72,3,72,1090,
        8,72,1,73,1,73,1,74,1,74,1,74,1,74,3,74,1098,8,74,1,74,3,74,1101,
        8,74,1,74,1,74,1,74,1,74,1,74,3,74,1108,8,74,1,74,3,74,1111,8,74,
        3,74,1113,8,74,1,75,1,75,1,75,1,75,1,75,5,75,1120,8,75,10,75,12,
        75,1123,9,75,1,76,1,76,1,76,1,76,1,76,1,77,1,77,1,78,1,78,1,78,1,
        78,1,78,1,78,3,78,1138,8,78,1,78,3,78,1141,8,78,3,78,1143,8,78,1,
        79,1,79,1,79,3,79,1148,8,79,1,80,1,80,1,80,1,80,1,80,1,80,1,81,3,
        81,1157,8,81,1,81,1,81,1,81,1,82,1,82,1,82,3,82,1165,8,82,1,83,1,
        83,1,83,1,83,1,83,1,83,4,83,1173,8,83,11,83,12,83,1174,1,83,1,83,
        1,83,1,83,3,83,1181,8,83,1,83,1,83,1,83,1,83,1,83,1,83,4,83,1189,
        8,83,11,83,12,83,1190,1,83,1,83,1,83,1,83,3,83,1197,8,83,1,83,1,
        83,1,83,1,83,1,83,1,83,4,83,1205,8,83,11,83,12,83,1206,3,83,1209,
        8,83,1,84,1,84,1,84,1,84,1,84,1,84,1,84,1,84,1,84,1,84,1,84,1,84,
        1,84,1,84,3,84,1225,8,84,1,85,1,85,1,85,3,85,1230,8,85,1,86,4,86,
        1233,8,86,11,86,12,86,1234,1,87,1,87,1,88,1,88,1,88,3,88,1242,8,
        88,1,88,1,88,1,88,1,88,1,88,1,88,4,88,1250,8,88,11,88,12,88,1251,
        1,89,1,89,1,89,3,89,1257,8,89,1,90,1,90,1,90,3,90,1262,8,90,1,91,
        1,91,1,91,1,91,5,91,1268,8,91,10,91,12,91,1271,9,91,1,92,1,92,1,
        92,1,92,5,92,1277,8,92,10,92,12,92,1280,9,92,1,93,1,93,4,93,1284,
        8,93,11,93,12,93,1285,1,93,3,93,1289,8,93,1,94,1,94,4,94,1293,8,
        94,11,94,12,94,1294,1,94,3,94,1298,8,94,1,95,1,95,1,95,1,95,1,96,
        1,96,1,97,3,97,1307,8,97,1,97,1,97,1,98,3,98,1312,8,98,1,98,3,98,
        1315,8,98,1,98,4,98,1318,8,98,11,98,12,98,1319,1,99,1,99,1,99,1,
        100,1,100,1,100,1,100,1,100,3,100,1330,8,100,3,100,1332,8,100,1,
        101,1,101,3,101,1336,8,101,1,102,1,102,1,102,1,102,1,102,3,102,1343,
        8,102,1,103,1,103,1,104,3,104,1348,8,104,1,104,1,104,3,104,1352,
        8,104,1,104,1,104,1,105,1,105,1,106,3,106,1359,8,106,1,106,1,106,
        1,106,1,106,1,106,1,107,1,107,1,107,1,108,1,108,1,108,1,109,1,109,
        1,109,1,110,1,110,1,110,1,110,1,110,1,110,1,110,4,110,1382,8,110,
        11,110,12,110,1383,1,111,1,111,1,111,1,111,1,111,1,111,3,111,1392,
        8,111,1,112,1,112,1,113,1,113,1,113,1,113,1,113,1,113,1,113,1,113,
        1,113,1,113,1,113,3,113,1407,8,113,1,114,1,114,1,114,1,114,3,114,
        1413,8,114,1,114,1,114,1,114,1,114,1,114,1,114,4,114,1421,8,114,
        11,114,12,114,1422,1,115,1,115,1,116,1,116,1,117,1,117,1,118,1,118,
        1,119,1,119,1,120,1,120,1,120,1,120,1,120,1,120,1,120,1,120,1,120,
        1,120,1,120,1,120,1,120,1,120,1,120,1,120,1,120,1,120,1,120,1,120,
        1,120,1,120,1,120,1,120,3,120,1459,8,120,1,121,1,121,5,121,1463,
        8,121,10,121,12,121,1466,9,121,1,121,1,121,1,122,3,122,1471,8,122,
        1,122,1,122,1,122,1,122,1,123,1,123,1,123,3,123,1480,8,123,1,123,
        1,123,5,123,1484,8,123,10,123,12,123,1487,9,123,1,124,1,124,1,124,
        1,124,1,124,1,124,1,124,1,124,1,124,1,124,1,124,1,124,1,124,3,124,
        1502,8,124,1,125,1,125,1,125,1,125,1,125,1,125,1,125,1,125,1,125,
        1,125,1,125,1,125,1,125,3,125,1517,8,125,1,126,1,126,1,126,3,126,
        1522,8,126,1,127,1,127,1,127,1,127,1,127,1,127,1,127,1,127,1,127,
        1,127,1,127,1,127,1,127,1,127,1,127,5,127,1539,8,127,10,127,12,127,
        1542,9,127,1,127,1,127,1,127,1,127,1,127,1,127,1,127,3,127,1551,
        8,127,1,127,1,127,3,127,1555,8,127,1,128,1,128,1,128,1,128,3,128,
        1561,8,128,1,128,1,128,1,128,3,128,1566,8,128,1,129,1,129,1,130,
        1,130,1,131,1,131,1,131,1,131,5,131,1576,8,131,10,131,12,131,1579,
        9,131,1,132,1,132,1,133,1,133,1,133,1,133,5,133,1587,8,133,10,133,
        12,133,1590,9,133,1,134,1,134,1,135,1,135,1,135,1,135,5,135,1598,
        8,135,10,135,12,135,1601,9,135,1,136,1,136,1,137,1,137,1,137,1,137,
        1,137,1,137,1,137,1,137,1,137,1,137,1,137,1,137,1,137,3,137,1618,
        8,137,1,137,1,137,1,137,1,137,1,137,1,137,3,137,1626,8,137,1,137,
        1,137,1,137,1,137,5,137,1632,8,137,10,137,12,137,1635,9,137,1,137,
        1,137,1,137,1,137,1,137,1,137,1,137,1,137,1,137,1,137,1,137,1,137,
        3,137,1649,8,137,1,137,1,137,1,137,1,137,1,137,1,137,1,137,1,137,
        1,137,3,137,1660,8,137,1,137,3,137,1663,8,137,1,137,1,137,1,137,
        1,137,1,137,1,137,1,137,1,137,1,137,5,137,1674,8,137,10,137,12,137,
        1677,9,137,1,137,1,137,1,137,1,137,1,137,1,137,1,137,1,137,1,137,
        1,137,1,137,1,137,1,137,1,137,5,137,1693,8,137,10,137,12,137,1696,
        9,137,1,137,1,137,1,137,1,137,1,137,1,137,1,137,1,137,1,137,1,137,
        5,137,1708,8,137,10,137,12,137,1711,9,137,1,137,1,137,1,137,1,137,
        1,137,1,137,1,137,1,137,1,137,1,137,1,137,1,137,1,137,1,137,1,137,
        1,137,1,137,1,137,1,137,1,137,1,137,1,137,1,137,1,137,1,137,1,137,
        1,137,1,137,1,137,1,137,1,137,1,137,1,137,1,137,1,137,1,137,1,137,
        1,137,1,137,1,137,1,137,5,137,1754,8,137,10,137,12,137,1757,9,137,
        1,137,1,137,1,137,1,137,1,137,1,137,1,137,5,137,1766,8,137,10,137,
        12,137,1769,9,137,1,137,1,137,1,137,1,137,1,137,1,137,3,137,1777,
        8,137,1,137,1,137,1,137,1,137,1,137,3,137,1784,8,137,1,137,1,137,
        3,137,1788,8,137,1,137,3,137,1791,8,137,1,137,1,137,1,137,4,137,
        1796,8,137,11,137,12,137,1797,1,137,1,137,1,137,3,137,1803,8,137,
        1,137,1,137,1,137,1,137,1,137,3,137,1810,8,137,1,137,4,137,1813,
        8,137,11,137,12,137,1814,1,137,1,137,1,137,1,137,1,137,3,137,1822,
        8,137,1,137,1,137,3,137,1826,8,137,1,137,1,137,1,137,1,137,1,137,
        3,137,1833,8,137,1,137,1,137,3,137,1837,8,137,1,137,1,137,1,137,
        1,137,1,137,3,137,1844,8,137,1,137,1,137,3,137,1848,8,137,1,137,
        1,137,1,137,1,137,1,137,1,137,1,137,1,137,1,137,1,137,1,137,1,137,
        1,137,1,137,1,137,1,137,1,137,1,137,3,137,1868,8,137,1,137,1,137,
        1,137,4,137,1873,8,137,11,137,12,137,1874,1,137,1,137,1,137,1,137,
        1,137,1,137,1,137,1,137,1,137,1,137,1,137,1,137,1,137,5,137,1890,
        8,137,10,137,12,137,1893,9,137,1,138,1,138,1,138,1,138,1,138,1,139,
        1,139,1,139,1,139,1,139,1,139,3,139,1906,8,139,1,140,1,140,1,140,
        1,141,1,141,1,141,1,142,1,142,1,142,3,142,1917,8,142,1,143,1,143,
        1,143,1,144,1,144,1,144,1,144,1,144,1,144,1,144,1,144,1,144,1,144,
        1,144,1,144,1,144,1,144,1,144,1,144,3,144,1938,8,144,1,145,1,145,
        1,145,1,145,1,145,1,145,1,145,1,145,1,145,1,145,1,145,1,145,1,145,
        1,145,1,145,1,145,3,145,1956,8,145,1,146,1,146,1,146,1,146,3,146,
        1962,8,146,1,147,1,147,1,147,1,147,1,147,1,147,3,147,1970,8,147,
        1,148,1,148,1,149,1,149,1,149,1,149,3,149,1978,8,149,1,149,1,149,
        1,149,1,149,3,149,1984,8,149,1,150,1,150,1,150,1,150,3,150,1990,
        8,150,1,151,1,151,1,151,1,151,1,151,1,151,1,151,1,152,1,152,1,152,
        1,152,1,152,1,152,1,152,5,152,2006,8,152,10,152,12,152,2009,9,152,
        1,152,1,152,1,152,1,152,1,153,1,153,1,153,1,153,1,153,1,153,1,153,
        1,153,1,153,1,153,1,153,1,153,1,153,1,153,1,153,1,153,1,153,1,153,
        1,153,1,153,1,153,1,153,1,153,1,153,1,153,1,153,3,153,2041,8,153,
        1,154,1,154,1,154,1,154,1,154,1,154,1,154,1,154,3,154,2051,8,154,
        1,155,1,155,1,155,1,155,1,155,1,155,1,155,1,155,1,155,1,155,1,155,
        1,155,3,155,2065,8,155,1,156,1,156,1,156,1,156,4,156,2071,8,156,
        11,156,12,156,2072,1,156,3,156,2076,8,156,1,156,3,156,2079,8,156,
        1,157,1,157,1,158,1,158,1,158,1,158,1,158,1,158,1,158,3,158,2090,
        8,158,1,158,3,158,2093,8,158,1,159,1,159,1,160,1,160,1,160,3,160,
        2100,8,160,1,161,1,161,5,161,2104,8,161,10,161,12,161,2107,9,161,
        1,162,1,162,1,162,3,162,2112,8,162,1,163,1,163,1,163,1,163,1,163,
        1,163,1,163,1,163,1,163,1,163,1,163,1,163,1,163,1,163,3,163,2128,
        8,163,1,164,1,164,1,164,3,164,2133,8,164,1,164,0,1,274,165,0,2,4,
        6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,
        50,52,54,56,58,60,62,64,66,68,70,72,74,76,78,80,82,84,86,88,90,92,
        94,96,98,100,102,104,106,108,110,112,114,116,118,120,122,124,126,
        128,130,132,134,136,138,140,142,144,146,148,150,152,154,156,158,
        160,162,164,166,168,170,172,174,176,178,180,182,184,186,188,190,
        192,194,196,198,200,202,204,206,208,210,212,214,216,218,220,222,
        224,226,228,230,232,234,236,238,240,242,244,246,248,250,252,254,
        256,258,260,262,264,266,268,270,272,274,276,278,280,282,284,286,
        288,290,292,294,296,298,300,302,304,306,308,310,312,314,316,318,
        320,322,324,326,328,0,52,1,0,293,293,16,0,96,96,110,110,113,113,
        124,124,132,132,161,161,190,190,201,202,205,206,209,210,221,221,
        223,224,232,232,234,234,253,253,267,267,15,0,96,96,110,110,124,124,
        132,132,161,161,190,190,201,202,205,206,209,210,221,221,223,224,
        232,232,234,234,253,253,267,267,4,0,119,119,212,212,215,215,217,
        217,12,0,146,146,148,148,176,176,208,208,216,216,220,220,229,229,
        231,231,233,233,241,241,244,244,248,248,7,0,209,210,221,222,224,
        225,227,228,238,239,242,243,250,251,1,0,163,164,2,0,3,3,168,168,
        2,0,179,180,183,183,2,0,212,212,217,217,7,0,137,137,209,210,221,
        228,238,239,242,243,250,251,253,267,1,0,187,189,2,0,190,190,267,
        268,5,0,28,28,95,96,98,100,102,106,281,281,2,0,148,148,240,240,2,
        0,110,110,113,113,2,0,47,48,128,128,6,0,48,50,52,52,128,128,131,
        131,133,133,141,142,3,0,212,212,215,215,217,217,9,0,146,146,176,
        176,208,208,216,216,220,220,231,231,233,233,241,241,248,248,3,0,
        212,212,217,217,252,252,1,0,245,246,1,0,157,158,4,0,201,202,205,
        206,215,215,268,268,3,0,284,285,289,289,292,292,2,0,211,211,214,
        214,1,0,119,121,2,0,109,109,119,119,1,0,161,162,1,0,153,154,2,0,
        113,113,119,119,1,0,54,59,1,0,54,55,2,0,54,55,64,67,2,0,216,216,
        229,229,3,0,47,48,54,54,128,128,11,0,22,25,38,39,47,67,113,113,125,
        125,128,128,131,131,133,134,140,140,142,142,220,220,3,0,137,137,
        143,143,152,152,2,0,126,127,136,136,2,0,147,147,288,288,2,0,137,
        137,143,143,2,0,221,221,224,224,3,0,138,139,144,145,155,155,2,0,
        191,191,193,193,2,0,68,71,80,83,1,0,84,87,1,0,88,91,4,0,72,72,74,
        74,76,76,78,78,4,0,73,73,75,75,77,77,79,79,1,0,278,279,2,0,197,197,
        200,200,1,0,138,139,2370,0,338,1,0,0,0,2,349,1,0,0,0,4,351,1,0,0,
        0,6,358,1,0,0,0,8,365,1,0,0,0,10,383,1,0,0,0,12,403,1,0,0,0,14,421,
        1,0,0,0,16,424,1,0,0,0,18,428,1,0,0,0,20,430,1,0,0,0,22,432,1,0,
        0,0,24,491,1,0,0,0,26,550,1,0,0,0,28,554,1,0,0,0,30,604,1,0,0,0,
        32,606,1,0,0,0,34,615,1,0,0,0,36,624,1,0,0,0,38,633,1,0,0,0,40,635,
        1,0,0,0,42,637,1,0,0,0,44,639,1,0,0,0,46,641,1,0,0,0,48,663,1,0,
        0,0,50,672,1,0,0,0,52,681,1,0,0,0,54,711,1,0,0,0,56,713,1,0,0,0,
        58,720,1,0,0,0,60,727,1,0,0,0,62,729,1,0,0,0,64,736,1,0,0,0,66,738,
        1,0,0,0,68,741,1,0,0,0,70,751,1,0,0,0,72,767,1,0,0,0,74,769,1,0,
        0,0,76,775,1,0,0,0,78,777,1,0,0,0,80,779,1,0,0,0,82,787,1,0,0,0,
        84,807,1,0,0,0,86,818,1,0,0,0,88,820,1,0,0,0,90,825,1,0,0,0,92,845,
        1,0,0,0,94,847,1,0,0,0,96,851,1,0,0,0,98,853,1,0,0,0,100,855,1,0,
        0,0,102,874,1,0,0,0,104,886,1,0,0,0,106,903,1,0,0,0,108,920,1,0,
        0,0,110,922,1,0,0,0,112,934,1,0,0,0,114,940,1,0,0,0,116,945,1,0,
        0,0,118,949,1,0,0,0,120,951,1,0,0,0,122,968,1,0,0,0,124,979,1,0,
        0,0,126,1000,1,0,0,0,128,1002,1,0,0,0,130,1012,1,0,0,0,132,1054,
        1,0,0,0,134,1056,1,0,0,0,136,1058,1,0,0,0,138,1071,1,0,0,0,140,1076,
        1,0,0,0,142,1085,1,0,0,0,144,1089,1,0,0,0,146,1091,1,0,0,0,148,1112,
        1,0,0,0,150,1114,1,0,0,0,152,1124,1,0,0,0,154,1129,1,0,0,0,156,1131,
        1,0,0,0,158,1144,1,0,0,0,160,1149,1,0,0,0,162,1156,1,0,0,0,164,1161,
        1,0,0,0,166,1208,1,0,0,0,168,1224,1,0,0,0,170,1226,1,0,0,0,172,1232,
        1,0,0,0,174,1236,1,0,0,0,176,1241,1,0,0,0,178,1253,1,0,0,0,180,1258,
        1,0,0,0,182,1263,1,0,0,0,184,1272,1,0,0,0,186,1288,1,0,0,0,188,1297,
        1,0,0,0,190,1299,1,0,0,0,192,1303,1,0,0,0,194,1306,1,0,0,0,196,1311,
        1,0,0,0,198,1321,1,0,0,0,200,1331,1,0,0,0,202,1335,1,0,0,0,204,1342,
        1,0,0,0,206,1344,1,0,0,0,208,1347,1,0,0,0,210,1355,1,0,0,0,212,1358,
        1,0,0,0,214,1365,1,0,0,0,216,1368,1,0,0,0,218,1371,1,0,0,0,220,1374,
        1,0,0,0,222,1391,1,0,0,0,224,1393,1,0,0,0,226,1406,1,0,0,0,228,1412,
        1,0,0,0,230,1424,1,0,0,0,232,1426,1,0,0,0,234,1428,1,0,0,0,236,1430,
        1,0,0,0,238,1432,1,0,0,0,240,1458,1,0,0,0,242,1460,1,0,0,0,244,1470,
        1,0,0,0,246,1476,1,0,0,0,248,1501,1,0,0,0,250,1516,1,0,0,0,252,1518,
        1,0,0,0,254,1554,1,0,0,0,256,1565,1,0,0,0,258,1567,1,0,0,0,260,1569,
        1,0,0,0,262,1571,1,0,0,0,264,1580,1,0,0,0,266,1582,1,0,0,0,268,1591,
        1,0,0,0,270,1593,1,0,0,0,272,1602,1,0,0,0,274,1867,1,0,0,0,276,1894,
        1,0,0,0,278,1905,1,0,0,0,280,1907,1,0,0,0,282,1910,1,0,0,0,284,1916,
        1,0,0,0,286,1918,1,0,0,0,288,1937,1,0,0,0,290,1955,1,0,0,0,292,1961,
        1,0,0,0,294,1969,1,0,0,0,296,1971,1,0,0,0,298,1983,1,0,0,0,300,1985,
        1,0,0,0,302,1991,1,0,0,0,304,1998,1,0,0,0,306,2040,1,0,0,0,308,2050,
        1,0,0,0,310,2064,1,0,0,0,312,2066,1,0,0,0,314,2080,1,0,0,0,316,2082,
        1,0,0,0,318,2094,1,0,0,0,320,2096,1,0,0,0,322,2101,1,0,0,0,324,2108,
        1,0,0,0,326,2127,1,0,0,0,328,2129,1,0,0,0,330,337,3,2,1,0,331,337,
        3,120,60,0,332,337,3,122,61,0,333,337,3,4,2,0,334,337,3,156,78,0,
        335,337,3,80,40,0,336,330,1,0,0,0,336,331,1,0,0,0,336,332,1,0,0,
        0,336,333,1,0,0,0,336,334,1,0,0,0,336,335,1,0,0,0,337,340,1,0,0,
        0,338,336,1,0,0,0,338,339,1,0,0,0,339,341,1,0,0,0,340,338,1,0,0,
        0,341,342,5,0,0,1,342,1,1,0,0,0,343,350,3,46,23,0,344,350,3,70,35,
        0,345,350,3,100,50,0,346,350,3,90,45,0,347,350,3,108,54,0,348,350,
        3,312,156,0,349,343,1,0,0,0,349,344,1,0,0,0,349,345,1,0,0,0,349,
        346,1,0,0,0,349,347,1,0,0,0,349,348,1,0,0,0,350,3,1,0,0,0,351,352,
        5,98,0,0,352,354,3,32,16,0,353,355,3,128,64,0,354,353,1,0,0,0,354,
        355,1,0,0,0,355,356,1,0,0,0,356,357,3,6,3,0,357,5,1,0,0,0,358,359,
        3,8,4,0,359,361,3,10,5,0,360,362,3,12,6,0,361,360,1,0,0,0,362,363,
        1,0,0,0,363,361,1,0,0,0,363,364,1,0,0,0,364,7,1,0,0,0,365,367,5,
        293,0,0,366,368,5,293,0,0,367,366,1,0,0,0,367,368,1,0,0,0,368,369,
        1,0,0,0,369,370,3,16,8,0,370,371,5,293,0,0,371,376,3,16,8,0,372,
        373,5,293,0,0,373,375,3,16,8,0,374,372,1,0,0,0,375,378,1,0,0,0,376,
        374,1,0,0,0,376,377,1,0,0,0,377,380,1,0,0,0,378,376,1,0,0,0,379,
        381,5,293,0,0,380,379,1,0,0,0,380,381,1,0,0,0,381,9,1,0,0,0,382,
        384,5,293,0,0,383,382,1,0,0,0,383,384,1,0,0,0,384,393,1,0,0,0,385,
        387,5,292,0,0,386,385,1,0,0,0,387,388,1,0,0,0,388,386,1,0,0,0,388,
        389,1,0,0,0,389,391,1,0,0,0,390,392,5,293,0,0,391,390,1,0,0,0,391,
        392,1,0,0,0,392,394,1,0,0,0,393,386,1,0,0,0,394,395,1,0,0,0,395,
        393,1,0,0,0,395,396,1,0,0,0,396,400,1,0,0,0,397,399,5,292,0,0,398,
        397,1,0,0,0,399,402,1,0,0,0,400,398,1,0,0,0,400,401,1,0,0,0,401,
        11,1,0,0,0,402,400,1,0,0,0,403,404,5,293,0,0,404,405,5,268,0,0,405,
        406,5,293,0,0,406,407,3,248,124,0,407,408,5,293,0,0,408,413,3,14,
        7,0,409,410,5,293,0,0,410,412,3,14,7,0,411,409,1,0,0,0,412,415,1,
        0,0,0,413,411,1,0,0,0,413,414,1,0,0,0,414,417,1,0,0,0,415,413,1,
        0,0,0,416,418,5,293,0,0,417,416,1,0,0,0,417,418,1,0,0,0,418,13,1,
        0,0,0,419,422,3,248,124,0,420,422,5,294,0,0,421,419,1,0,0,0,421,
        420,1,0,0,0,422,15,1,0,0,0,423,425,8,0,0,0,424,423,1,0,0,0,425,426,
        1,0,0,0,426,424,1,0,0,0,426,427,1,0,0,0,427,17,1,0,0,0,428,429,5,
        267,0,0,429,19,1,0,0,0,430,431,7,1,0,0,431,21,1,0,0,0,432,433,7,
        2,0,0,433,23,1,0,0,0,434,436,7,3,0,0,435,434,1,0,0,0,435,436,1,0,
        0,0,436,438,1,0,0,0,437,439,3,20,10,0,438,437,1,0,0,0,439,440,1,
        0,0,0,440,438,1,0,0,0,440,441,1,0,0,0,441,492,1,0,0,0,442,444,3,
        20,10,0,443,442,1,0,0,0,444,445,1,0,0,0,445,443,1,0,0,0,445,446,
        1,0,0,0,446,492,1,0,0,0,447,449,5,45,0,0,448,450,3,20,10,0,449,448,
        1,0,0,0,450,451,1,0,0,0,451,449,1,0,0,0,451,452,1,0,0,0,452,492,
        1,0,0,0,453,455,5,45,0,0,454,456,3,20,10,0,455,454,1,0,0,0,456,457,
        1,0,0,0,457,455,1,0,0,0,457,458,1,0,0,0,458,459,1,0,0,0,459,461,
        5,176,0,0,460,462,3,20,10,0,461,460,1,0,0,0,462,463,1,0,0,0,463,
        461,1,0,0,0,463,464,1,0,0,0,464,492,1,0,0,0,465,467,3,20,10,0,466,
        465,1,0,0,0,467,468,1,0,0,0,468,466,1,0,0,0,468,469,1,0,0,0,469,
        470,1,0,0,0,470,472,5,176,0,0,471,473,3,20,10,0,472,471,1,0,0,0,
        473,474,1,0,0,0,474,472,1,0,0,0,474,475,1,0,0,0,475,492,1,0,0,0,
        476,478,5,140,0,0,477,479,3,20,10,0,478,477,1,0,0,0,479,480,1,0,
        0,0,480,478,1,0,0,0,480,481,1,0,0,0,481,492,1,0,0,0,482,483,5,217,
        0,0,483,484,5,190,0,0,484,485,5,210,0,0,485,487,5,220,0,0,486,488,
        3,20,10,0,487,486,1,0,0,0,488,489,1,0,0,0,489,487,1,0,0,0,489,490,
        1,0,0,0,490,492,1,0,0,0,491,435,1,0,0,0,491,443,1,0,0,0,491,447,
        1,0,0,0,491,453,1,0,0,0,491,466,1,0,0,0,491,476,1,0,0,0,491,482,
        1,0,0,0,492,25,1,0,0,0,493,495,7,3,0,0,494,493,1,0,0,0,494,495,1,
        0,0,0,495,497,1,0,0,0,496,498,3,28,14,0,497,496,1,0,0,0,498,499,
        1,0,0,0,499,497,1,0,0,0,499,500,1,0,0,0,500,551,1,0,0,0,501,503,
        3,28,14,0,502,501,1,0,0,0,503,504,1,0,0,0,504,502,1,0,0,0,504,505,
        1,0,0,0,505,551,1,0,0,0,506,508,5,45,0,0,507,509,3,28,14,0,508,507,
        1,0,0,0,509,510,1,0,0,0,510,508,1,0,0,0,510,511,1,0,0,0,511,551,
        1,0,0,0,512,514,5,45,0,0,513,515,3,28,14,0,514,513,1,0,0,0,515,516,
        1,0,0,0,516,514,1,0,0,0,516,517,1,0,0,0,517,518,1,0,0,0,518,520,
        5,176,0,0,519,521,3,28,14,0,520,519,1,0,0,0,521,522,1,0,0,0,522,
        520,1,0,0,0,522,523,1,0,0,0,523,551,1,0,0,0,524,526,3,28,14,0,525,
        524,1,0,0,0,526,527,1,0,0,0,527,525,1,0,0,0,527,528,1,0,0,0,528,
        529,1,0,0,0,529,531,5,176,0,0,530,532,3,28,14,0,531,530,1,0,0,0,
        532,533,1,0,0,0,533,531,1,0,0,0,533,534,1,0,0,0,534,551,1,0,0,0,
        535,537,5,140,0,0,536,538,3,28,14,0,537,536,1,0,0,0,538,539,1,0,
        0,0,539,537,1,0,0,0,539,540,1,0,0,0,540,551,1,0,0,0,541,542,5,217,
        0,0,542,543,5,190,0,0,543,544,5,210,0,0,544,546,5,220,0,0,545,547,
        3,28,14,0,546,545,1,0,0,0,547,548,1,0,0,0,548,546,1,0,0,0,548,549,
        1,0,0,0,549,551,1,0,0,0,550,494,1,0,0,0,550,502,1,0,0,0,550,506,
        1,0,0,0,550,512,1,0,0,0,550,525,1,0,0,0,550,535,1,0,0,0,550,541,
        1,0,0,0,551,27,1,0,0,0,552,555,3,20,10,0,553,555,5,268,0,0,554,552,
        1,0,0,0,554,553,1,0,0,0,555,29,1,0,0,0,556,558,7,3,0,0,557,556,1,
        0,0,0,557,558,1,0,0,0,558,560,1,0,0,0,559,561,3,22,11,0,560,559,
        1,0,0,0,561,562,1,0,0,0,562,560,1,0,0,0,562,563,1,0,0,0,563,605,
        1,0,0,0,564,566,3,22,11,0,565,564,1,0,0,0,566,567,1,0,0,0,567,565,
        1,0,0,0,567,568,1,0,0,0,568,605,1,0,0,0,569,571,5,45,0,0,570,572,
        3,22,11,0,571,570,1,0,0,0,572,573,1,0,0,0,573,571,1,0,0,0,573,574,
        1,0,0,0,574,605,1,0,0,0,575,577,5,45,0,0,576,578,3,22,11,0,577,576,
        1,0,0,0,578,579,1,0,0,0,579,577,1,0,0,0,579,580,1,0,0,0,580,581,
        1,0,0,0,581,583,5,176,0,0,582,584,3,22,11,0,583,582,1,0,0,0,584,
        585,1,0,0,0,585,583,1,0,0,0,585,586,1,0,0,0,586,605,1,0,0,0,587,
        589,3,22,11,0,588,587,1,0,0,0,589,590,1,0,0,0,590,588,1,0,0,0,590,
        591,1,0,0,0,591,592,1,0,0,0,592,594,5,176,0,0,593,595,3,22,11,0,
        594,593,1,0,0,0,595,596,1,0,0,0,596,594,1,0,0,0,596,597,1,0,0,0,
        597,605,1,0,0,0,598,600,5,140,0,0,599,601,3,22,11,0,600,599,1,0,
        0,0,601,602,1,0,0,0,602,600,1,0,0,0,602,603,1,0,0,0,603,605,1,0,
        0,0,604,557,1,0,0,0,604,565,1,0,0,0,604,569,1,0,0,0,604,575,1,0,
        0,0,604,588,1,0,0,0,604,598,1,0,0,0,605,31,1,0,0,0,606,612,3,24,
        12,0,607,608,3,38,19,0,608,609,3,24,12,0,609,611,1,0,0,0,610,607,
        1,0,0,0,611,614,1,0,0,0,612,610,1,0,0,0,612,613,1,0,0,0,613,33,1,
        0,0,0,614,612,1,0,0,0,615,621,3,26,13,0,616,617,3,38,19,0,617,618,
        3,26,13,0,618,620,1,0,0,0,619,616,1,0,0,0,620,623,1,0,0,0,621,619,
        1,0,0,0,621,622,1,0,0,0,622,35,1,0,0,0,623,621,1,0,0,0,624,630,3,
        30,15,0,625,626,3,38,19,0,626,627,3,30,15,0,627,629,1,0,0,0,628,
        625,1,0,0,0,629,632,1,0,0,0,630,628,1,0,0,0,630,631,1,0,0,0,631,
        37,1,0,0,0,632,630,1,0,0,0,633,634,7,4,0,0,634,39,1,0,0,0,635,636,
        5,270,0,0,636,41,1,0,0,0,637,638,5,267,0,0,638,43,1,0,0,0,639,640,
        7,5,0,0,640,45,1,0,0,0,641,642,5,99,0,0,642,650,3,36,18,0,643,645,
        5,178,0,0,644,646,5,267,0,0,645,644,1,0,0,0,646,647,1,0,0,0,647,
        645,1,0,0,0,647,648,1,0,0,0,648,649,1,0,0,0,649,651,5,275,0,0,650,
        643,1,0,0,0,650,651,1,0,0,0,651,653,1,0,0,0,652,654,5,165,0,0,653,
        652,1,0,0,0,653,654,1,0,0,0,654,658,1,0,0,0,655,657,3,48,24,0,656,
        655,1,0,0,0,657,660,1,0,0,0,658,656,1,0,0,0,658,659,1,0,0,0,659,
        47,1,0,0,0,660,658,1,0,0,0,661,664,3,50,25,0,662,664,3,52,26,0,663,
        661,1,0,0,0,663,662,1,0,0,0,664,665,1,0,0,0,665,666,5,281,0,0,666,
        49,1,0,0,0,667,669,5,113,0,0,668,667,1,0,0,0,668,669,1,0,0,0,669,
        670,1,0,0,0,670,673,3,18,9,0,671,673,3,34,17,0,672,668,1,0,0,0,672,
        671,1,0,0,0,673,674,1,0,0,0,674,676,5,174,0,0,675,677,7,6,0,0,676,
        675,1,0,0,0,676,677,1,0,0,0,677,679,1,0,0,0,678,680,3,96,48,0,679,
        678,1,0,0,0,679,680,1,0,0,0,680,51,1,0,0,0,681,685,3,34,17,0,682,
        686,3,54,27,0,683,686,3,76,38,0,684,686,3,78,39,0,685,682,1,0,0,
        0,685,683,1,0,0,0,685,684,1,0,0,0,686,689,1,0,0,0,687,688,5,177,
        0,0,688,690,3,84,42,0,689,687,1,0,0,0,689,690,1,0,0,0,690,700,1,
        0,0,0,691,692,5,171,0,0,692,697,3,98,49,0,693,694,5,216,0,0,694,
        696,3,98,49,0,695,693,1,0,0,0,696,699,1,0,0,0,697,695,1,0,0,0,697,
        698,1,0,0,0,698,701,1,0,0,0,699,697,1,0,0,0,700,691,1,0,0,0,700,
        701,1,0,0,0,701,703,1,0,0,0,702,704,3,96,48,0,703,702,1,0,0,0,703,
        704,1,0,0,0,704,53,1,0,0,0,705,712,3,58,29,0,706,712,3,60,30,0,707,
        712,3,64,32,0,708,712,3,66,33,0,709,712,3,56,28,0,710,712,3,62,31,
        0,711,705,1,0,0,0,711,706,1,0,0,0,711,707,1,0,0,0,711,708,1,0,0,
        0,711,709,1,0,0,0,711,710,1,0,0,0,712,55,1,0,0,0,713,714,5,101,0,
        0,714,718,5,244,0,0,715,719,3,54,27,0,716,719,3,76,38,0,717,719,
        3,78,39,0,718,715,1,0,0,0,718,716,1,0,0,0,718,717,1,0,0,0,719,57,
        1,0,0,0,720,725,5,181,0,0,721,722,5,274,0,0,722,723,3,68,34,0,723,
        724,5,275,0,0,724,726,1,0,0,0,725,721,1,0,0,0,725,726,1,0,0,0,726,
        59,1,0,0,0,727,728,5,186,0,0,728,61,1,0,0,0,729,734,5,182,0,0,730,
        731,5,274,0,0,731,732,3,68,34,0,732,733,5,275,0,0,733,735,1,0,0,
        0,734,730,1,0,0,0,734,735,1,0,0,0,735,63,1,0,0,0,736,737,5,166,0,
        0,737,65,1,0,0,0,738,739,7,7,0,0,739,67,1,0,0,0,740,742,7,8,0,0,
        741,740,1,0,0,0,741,742,1,0,0,0,742,749,1,0,0,0,743,750,5,172,0,
        0,744,745,5,173,0,0,745,746,5,176,0,0,746,747,5,268,0,0,747,750,
        5,169,0,0,748,750,5,173,0,0,749,743,1,0,0,0,749,744,1,0,0,0,749,
        748,1,0,0,0,750,69,1,0,0,0,751,752,5,100,0,0,752,753,5,267,0,0,753,
        754,5,29,0,0,754,757,3,72,36,0,755,756,5,177,0,0,756,758,3,86,43,
        0,757,755,1,0,0,0,757,758,1,0,0,0,758,760,1,0,0,0,759,761,5,281,
        0,0,760,759,1,0,0,0,760,761,1,0,0,0,761,71,1,0,0,0,762,768,3,74,
        37,0,763,768,3,58,29,0,764,768,3,60,30,0,765,768,3,64,32,0,766,768,
        3,66,33,0,767,762,1,0,0,0,767,763,1,0,0,0,767,764,1,0,0,0,767,765,
        1,0,0,0,767,766,1,0,0,0,768,73,1,0,0,0,769,771,5,170,0,0,770,772,
        5,273,0,0,771,770,1,0,0,0,772,773,1,0,0,0,773,771,1,0,0,0,773,774,
        1,0,0,0,774,75,1,0,0,0,775,776,5,267,0,0,776,77,1,0,0,0,777,778,
        5,267,0,0,778,79,1,0,0,0,779,780,5,103,0,0,780,784,3,18,9,0,781,
        783,3,82,41,0,782,781,1,0,0,0,783,786,1,0,0,0,784,782,1,0,0,0,784,
        785,1,0,0,0,785,81,1,0,0,0,786,784,1,0,0,0,787,788,7,9,0,0,788,793,
        3,84,42,0,789,790,5,178,0,0,790,791,3,84,42,0,791,792,5,275,0,0,
        792,794,1,0,0,0,793,789,1,0,0,0,793,794,1,0,0,0,794,795,1,0,0,0,
        795,797,3,84,42,0,796,798,3,84,42,0,797,796,1,0,0,0,797,798,1,0,
        0,0,798,805,1,0,0,0,799,801,5,269,0,0,800,802,5,282,0,0,801,800,
        1,0,0,0,801,802,1,0,0,0,802,803,1,0,0,0,803,804,5,268,0,0,804,806,
        3,84,42,0,805,799,1,0,0,0,805,806,1,0,0,0,806,83,1,0,0,0,807,808,
        7,10,0,0,808,85,1,0,0,0,809,812,3,88,44,0,810,811,5,282,0,0,811,
        813,3,88,44,0,812,810,1,0,0,0,812,813,1,0,0,0,813,819,1,0,0,0,814,
        819,5,268,0,0,815,819,5,283,0,0,816,819,5,264,0,0,817,819,5,265,
        0,0,818,809,1,0,0,0,818,814,1,0,0,0,818,815,1,0,0,0,818,816,1,0,
        0,0,818,817,1,0,0,0,819,87,1,0,0,0,820,823,3,84,42,0,821,822,5,288,
        0,0,822,824,5,268,0,0,823,821,1,0,0,0,823,824,1,0,0,0,824,89,1,0,
        0,0,825,826,5,102,0,0,826,828,3,32,16,0,827,829,5,278,0,0,828,827,
        1,0,0,0,828,829,1,0,0,0,829,830,1,0,0,0,830,831,5,27,0,0,831,832,
        3,32,16,0,832,834,3,92,46,0,833,835,3,94,47,0,834,833,1,0,0,0,835,
        836,1,0,0,0,836,834,1,0,0,0,836,837,1,0,0,0,837,91,1,0,0,0,838,839,
        5,2,0,0,839,840,3,38,19,0,840,842,5,275,0,0,841,843,5,280,0,0,842,
        841,1,0,0,0,842,843,1,0,0,0,843,846,1,0,0,0,844,846,5,1,0,0,845,
        838,1,0,0,0,845,844,1,0,0,0,846,93,1,0,0,0,847,848,5,268,0,0,848,
        849,5,279,0,0,849,850,3,32,16,0,850,95,1,0,0,0,851,852,7,11,0,0,
        852,97,1,0,0,0,853,854,5,267,0,0,854,99,1,0,0,0,855,856,5,104,0,
        0,856,857,3,102,51,0,857,860,5,280,0,0,858,861,3,54,27,0,859,861,
        3,76,38,0,860,858,1,0,0,0,860,859,1,0,0,0,861,864,1,0,0,0,862,863,
        5,177,0,0,863,865,3,86,43,0,864,862,1,0,0,0,864,865,1,0,0,0,865,
        868,1,0,0,0,866,867,5,113,0,0,867,869,3,248,124,0,868,866,1,0,0,
        0,868,869,1,0,0,0,869,871,1,0,0,0,870,872,3,96,48,0,871,870,1,0,
        0,0,871,872,1,0,0,0,872,101,1,0,0,0,873,875,7,9,0,0,874,873,1,0,
        0,0,874,875,1,0,0,0,875,876,1,0,0,0,876,882,3,104,52,0,877,878,3,
        38,19,0,878,879,3,104,52,0,879,881,1,0,0,0,880,877,1,0,0,0,881,884,
        1,0,0,0,882,880,1,0,0,0,882,883,1,0,0,0,883,103,1,0,0,0,884,882,
        1,0,0,0,885,887,7,12,0,0,886,885,1,0,0,0,887,888,1,0,0,0,888,886,
        1,0,0,0,888,889,1,0,0,0,889,105,1,0,0,0,890,892,7,9,0,0,891,890,
        1,0,0,0,891,892,1,0,0,0,892,893,1,0,0,0,893,899,3,104,52,0,894,895,
        3,38,19,0,895,896,3,104,52,0,896,898,1,0,0,0,897,894,1,0,0,0,898,
        901,1,0,0,0,899,897,1,0,0,0,899,900,1,0,0,0,900,904,1,0,0,0,901,
        899,1,0,0,0,902,904,3,32,16,0,903,891,1,0,0,0,903,902,1,0,0,0,904,
        107,1,0,0,0,905,906,5,105,0,0,906,907,3,32,16,0,907,909,3,110,55,
        0,908,910,3,110,55,0,909,908,1,0,0,0,910,911,1,0,0,0,911,909,1,0,
        0,0,911,912,1,0,0,0,912,913,1,0,0,0,913,914,3,116,58,0,914,921,1,
        0,0,0,915,916,5,28,0,0,916,917,3,32,16,0,917,918,3,110,55,0,918,
        919,3,116,58,0,919,921,1,0,0,0,920,905,1,0,0,0,920,915,1,0,0,0,921,
        109,1,0,0,0,922,923,7,9,0,0,923,928,3,114,57,0,924,925,5,178,0,0,
        925,926,3,32,16,0,926,927,5,275,0,0,927,929,1,0,0,0,928,924,1,0,
        0,0,928,929,1,0,0,0,929,931,1,0,0,0,930,932,3,112,56,0,931,930,1,
        0,0,0,931,932,1,0,0,0,932,111,1,0,0,0,933,935,3,20,10,0,934,933,
        1,0,0,0,935,936,1,0,0,0,936,934,1,0,0,0,936,937,1,0,0,0,937,113,
        1,0,0,0,938,941,3,20,10,0,939,941,3,38,19,0,940,938,1,0,0,0,940,
        939,1,0,0,0,941,942,1,0,0,0,942,940,1,0,0,0,942,943,1,0,0,0,943,
        115,1,0,0,0,944,946,3,118,59,0,945,944,1,0,0,0,946,947,1,0,0,0,947,
        945,1,0,0,0,947,948,1,0,0,0,948,117,1,0,0,0,949,950,8,13,0,0,950,
        119,1,0,0,0,951,952,5,96,0,0,952,954,3,124,62,0,953,955,5,268,0,
        0,954,953,1,0,0,0,954,955,1,0,0,0,955,956,1,0,0,0,956,957,3,128,
        64,0,957,963,3,132,66,0,958,960,3,164,82,0,959,961,5,279,0,0,960,
        959,1,0,0,0,960,961,1,0,0,0,961,964,1,0,0,0,962,964,5,279,0,0,963,
        958,1,0,0,0,963,962,1,0,0,0,963,964,1,0,0,0,964,966,1,0,0,0,965,
        967,3,242,121,0,966,965,1,0,0,0,966,967,1,0,0,0,967,121,1,0,0,0,
        968,969,5,97,0,0,969,971,3,32,16,0,970,972,5,112,0,0,971,970,1,0,
        0,0,971,972,1,0,0,0,972,975,1,0,0,0,973,976,3,120,60,0,974,976,3,
        156,78,0,975,973,1,0,0,0,975,974,1,0,0,0,976,977,1,0,0,0,977,975,
        1,0,0,0,977,978,1,0,0,0,978,123,1,0,0,0,979,983,3,34,17,0,980,982,
        3,126,63,0,981,980,1,0,0,0,982,985,1,0,0,0,983,981,1,0,0,0,983,984,
        1,0,0,0,984,125,1,0,0,0,985,983,1,0,0,0,986,1001,5,198,0,0,987,988,
        5,278,0,0,988,1001,3,34,17,0,989,990,5,278,0,0,990,991,5,176,0,0,
        991,1001,3,34,17,0,992,993,5,216,0,0,993,1001,3,34,17,0,994,995,
        5,113,0,0,995,1001,3,34,17,0,996,997,5,204,0,0,997,998,3,34,17,0,
        998,999,5,113,0,0,999,1001,1,0,0,0,1000,986,1,0,0,0,1000,987,1,0,
        0,0,1000,989,1,0,0,0,1000,992,1,0,0,0,1000,994,1,0,0,0,1000,996,
        1,0,0,0,1001,127,1,0,0,0,1002,1003,5,108,0,0,1003,1004,3,130,65,
        0,1004,129,1,0,0,0,1005,1013,5,207,0,0,1006,1007,5,150,0,0,1007,
        1010,3,40,20,0,1008,1009,7,14,0,0,1009,1011,3,40,20,0,1010,1008,
        1,0,0,0,1010,1011,1,0,0,0,1011,1013,1,0,0,0,1012,1005,1,0,0,0,1012,
        1006,1,0,0,0,1013,131,1,0,0,0,1014,1015,5,215,0,0,1015,1016,5,209,
        0,0,1016,1017,5,113,0,0,1017,1018,5,215,0,0,1018,1055,3,32,16,0,
        1019,1026,3,190,95,0,1020,1021,5,8,0,0,1021,1027,3,248,124,0,1022,
        1023,5,9,0,0,1023,1027,3,248,124,0,1024,1025,5,10,0,0,1025,1027,
        3,248,124,0,1026,1020,1,0,0,0,1026,1022,1,0,0,0,1026,1024,1,0,0,
        0,1027,1029,1,0,0,0,1028,1030,3,290,145,0,1029,1028,1,0,0,0,1029,
        1030,1,0,0,0,1030,1055,1,0,0,0,1031,1032,3,190,95,0,1032,1033,5,
        114,0,0,1033,1034,3,134,67,0,1034,1035,3,248,124,0,1035,1055,1,0,
        0,0,1036,1055,3,136,68,0,1037,1038,3,178,89,0,1038,1039,7,15,0,0,
        1039,1041,3,194,97,0,1040,1042,3,290,145,0,1041,1040,1,0,0,0,1041,
        1042,1,0,0,0,1042,1055,1,0,0,0,1043,1044,3,178,89,0,1044,1045,5,
        110,0,0,1045,1046,7,9,0,0,1046,1047,3,32,16,0,1047,1048,5,176,0,
        0,1048,1049,3,192,96,0,1049,1050,7,16,0,0,1050,1051,3,248,124,0,
        1051,1055,1,0,0,0,1052,1055,3,148,74,0,1053,1055,3,316,158,0,1054,
        1014,1,0,0,0,1054,1019,1,0,0,0,1054,1031,1,0,0,0,1054,1036,1,0,0,
        0,1054,1037,1,0,0,0,1054,1043,1,0,0,0,1054,1052,1,0,0,0,1054,1053,
        1,0,0,0,1055,133,1,0,0,0,1056,1057,7,17,0,0,1057,135,1,0,0,0,1058,
        1059,5,215,0,0,1059,1060,3,138,69,0,1060,1061,5,244,0,0,1061,1062,
        5,215,0,0,1062,1063,3,140,70,0,1063,1064,5,113,0,0,1064,1065,7,18,
        0,0,1065,1066,3,138,69,0,1066,1067,5,244,0,0,1067,1068,7,18,0,0,
        1068,1069,3,140,70,0,1069,137,1,0,0,0,1070,1072,3,144,72,0,1071,
        1070,1,0,0,0,1072,1073,1,0,0,0,1073,1071,1,0,0,0,1073,1074,1,0,0,
        0,1074,139,1,0,0,0,1075,1077,3,142,71,0,1076,1075,1,0,0,0,1077,1078,
        1,0,0,0,1078,1076,1,0,0,0,1078,1079,1,0,0,0,1079,141,1,0,0,0,1080,
        1086,3,20,10,0,1081,1086,3,38,19,0,1082,1086,5,212,0,0,1083,1086,
        5,217,0,0,1084,1086,5,215,0,0,1085,1080,1,0,0,0,1085,1081,1,0,0,
        0,1085,1082,1,0,0,0,1085,1083,1,0,0,0,1085,1084,1,0,0,0,1086,143,
        1,0,0,0,1087,1090,3,20,10,0,1088,1090,3,146,73,0,1089,1087,1,0,0,
        0,1089,1088,1,0,0,0,1090,145,1,0,0,0,1091,1092,7,19,0,0,1092,147,
        1,0,0,0,1093,1094,5,41,0,0,1094,1095,3,32,16,0,1095,1097,5,43,0,
        0,1096,1098,3,150,75,0,1097,1096,1,0,0,0,1097,1098,1,0,0,0,1098,
        1100,1,0,0,0,1099,1101,5,279,0,0,1100,1099,1,0,0,0,1100,1101,1,0,
        0,0,1101,1113,1,0,0,0,1102,1103,5,44,0,0,1103,1104,5,215,0,0,1104,
        1105,5,45,0,0,1105,1107,3,32,16,0,1106,1108,3,150,75,0,1107,1106,
        1,0,0,0,1107,1108,1,0,0,0,1108,1110,1,0,0,0,1109,1111,5,279,0,0,
        1110,1109,1,0,0,0,1110,1111,1,0,0,0,1111,1113,1,0,0,0,1112,1093,
        1,0,0,0,1112,1102,1,0,0,0,1113,149,1,0,0,0,1114,1115,5,176,0,0,1115,
        1116,3,154,77,0,1116,1117,5,128,0,0,1117,1121,3,250,125,0,1118,1120,
        3,152,76,0,1119,1118,1,0,0,0,1120,1123,1,0,0,0,1121,1119,1,0,0,0,
        1121,1122,1,0,0,0,1122,151,1,0,0,0,1123,1121,1,0,0,0,1124,1125,5,
        216,0,0,1125,1126,3,154,77,0,1126,1127,5,128,0,0,1127,1128,3,250,
        125,0,1128,153,1,0,0,0,1129,1130,3,24,12,0,1130,155,1,0,0,0,1131,
        1132,5,95,0,0,1132,1142,3,32,16,0,1133,1143,3,158,79,0,1134,1140,
        3,162,81,0,1135,1137,3,164,82,0,1136,1138,5,279,0,0,1137,1136,1,
        0,0,0,1137,1138,1,0,0,0,1138,1141,1,0,0,0,1139,1141,5,279,0,0,1140,
        1135,1,0,0,0,1140,1139,1,0,0,0,1140,1141,1,0,0,0,1141,1143,1,0,0,
        0,1142,1133,1,0,0,0,1142,1134,1,0,0,0,1143,157,1,0,0,0,1144,1145,
        3,160,80,0,1145,1147,5,92,0,0,1146,1148,5,279,0,0,1147,1146,1,0,
        0,0,1147,1148,1,0,0,0,1148,159,1,0,0,0,1149,1150,5,212,0,0,1150,
        1151,3,32,16,0,1151,1152,5,244,0,0,1152,1153,5,124,0,0,1153,1154,
        3,32,16,0,1154,161,1,0,0,0,1155,1157,7,20,0,0,1156,1155,1,0,0,0,
        1156,1157,1,0,0,0,1157,1158,1,0,0,0,1158,1159,3,32,16,0,1159,1160,
        5,94,0,0,1160,163,1,0,0,0,1161,1164,5,111,0,0,1162,1165,3,248,124,
        0,1163,1165,3,166,83,0,1164,1162,1,0,0,0,1164,1163,1,0,0,0,1165,
        165,1,0,0,0,1166,1167,5,46,0,0,1167,1168,3,168,84,0,1168,1169,7,
        21,0,0,1169,1170,5,40,0,0,1170,1172,5,280,0,0,1171,1173,3,170,85,
        0,1172,1171,1,0,0,0,1173,1174,1,0,0,0,1174,1172,1,0,0,0,1174,1175,
        1,0,0,0,1175,1209,1,0,0,0,1176,1181,3,178,89,0,1177,1181,5,219,0,
        0,1178,1181,5,217,0,0,1179,1181,5,252,0,0,1180,1176,1,0,0,0,1180,
        1177,1,0,0,0,1180,1178,1,0,0,0,1180,1179,1,0,0,0,1181,1182,1,0,0,
        0,1182,1183,5,122,0,0,1183,1184,3,168,84,0,1184,1185,7,21,0,0,1185,
        1186,5,154,0,0,1186,1188,5,280,0,0,1187,1189,3,170,85,0,1188,1187,
        1,0,0,0,1189,1190,1,0,0,0,1190,1188,1,0,0,0,1190,1191,1,0,0,0,1191,
        1209,1,0,0,0,1192,1197,3,178,89,0,1193,1197,5,219,0,0,1194,1197,
        5,217,0,0,1195,1197,5,252,0,0,1196,1192,1,0,0,0,1196,1193,1,0,0,
        0,1196,1194,1,0,0,0,1196,1195,1,0,0,0,1197,1198,1,0,0,0,1198,1199,
        5,154,0,0,1199,1200,5,122,0,0,1200,1201,3,168,84,0,1201,1202,7,21,
        0,0,1202,1204,5,280,0,0,1203,1205,3,170,85,0,1204,1203,1,0,0,0,1205,
        1206,1,0,0,0,1206,1204,1,0,0,0,1206,1207,1,0,0,0,1207,1209,1,0,0,
        0,1208,1166,1,0,0,0,1208,1180,1,0,0,0,1208,1196,1,0,0,0,1209,167,
        1,0,0,0,1210,1225,5,124,0,0,1211,1225,5,203,0,0,1212,1213,7,22,0,
        0,1213,1214,7,23,0,0,1214,1215,5,244,0,0,1215,1225,5,212,0,0,1216,
        1217,5,159,0,0,1217,1218,7,23,0,0,1218,1219,5,244,0,0,1219,1225,
        5,212,0,0,1220,1221,5,160,0,0,1221,1222,7,23,0,0,1222,1223,5,244,
        0,0,1223,1225,5,212,0,0,1224,1210,1,0,0,0,1224,1211,1,0,0,0,1224,
        1212,1,0,0,0,1224,1216,1,0,0,0,1224,1220,1,0,0,0,1225,169,1,0,0,
        0,1226,1229,3,172,86,0,1227,1230,3,174,87,0,1228,1230,3,176,88,0,
        1229,1227,1,0,0,0,1229,1228,1,0,0,0,1230,171,1,0,0,0,1231,1233,7,
        24,0,0,1232,1231,1,0,0,0,1233,1234,1,0,0,0,1234,1232,1,0,0,0,1234,
        1235,1,0,0,0,1235,173,1,0,0,0,1236,1237,3,248,124,0,1237,175,1,0,
        0,0,1238,1242,3,178,89,0,1239,1242,5,219,0,0,1240,1242,5,252,0,0,
        1241,1238,1,0,0,0,1241,1239,1,0,0,0,1241,1240,1,0,0,0,1242,1243,
        1,0,0,0,1243,1244,5,154,0,0,1244,1245,5,122,0,0,1245,1246,3,168,
        84,0,1246,1247,7,21,0,0,1247,1249,5,280,0,0,1248,1250,3,170,85,0,
        1249,1248,1,0,0,0,1250,1251,1,0,0,0,1251,1249,1,0,0,0,1251,1252,
        1,0,0,0,1252,177,1,0,0,0,1253,1256,3,182,91,0,1254,1255,7,25,0,0,
        1255,1257,3,202,101,0,1256,1254,1,0,0,0,1256,1257,1,0,0,0,1257,179,
        1,0,0,0,1258,1261,3,184,92,0,1259,1260,7,25,0,0,1260,1262,3,202,
        101,0,1261,1259,1,0,0,0,1261,1262,1,0,0,0,1262,181,1,0,0,0,1263,
        1269,3,186,93,0,1264,1265,3,38,19,0,1265,1266,3,186,93,0,1266,1268,
        1,0,0,0,1267,1264,1,0,0,0,1268,1271,1,0,0,0,1269,1267,1,0,0,0,1269,
        1270,1,0,0,0,1270,183,1,0,0,0,1271,1269,1,0,0,0,1272,1278,3,188,
        94,0,1273,1274,3,38,19,0,1274,1275,3,188,94,0,1275,1277,1,0,0,0,
        1276,1273,1,0,0,0,1277,1280,1,0,0,0,1278,1276,1,0,0,0,1278,1279,
        1,0,0,0,1279,185,1,0,0,0,1280,1278,1,0,0,0,1281,1283,7,3,0,0,1282,
        1284,3,20,10,0,1283,1282,1,0,0,0,1284,1285,1,0,0,0,1285,1283,1,0,
        0,0,1285,1286,1,0,0,0,1286,1289,1,0,0,0,1287,1289,5,219,0,0,1288,
        1281,1,0,0,0,1288,1287,1,0,0,0,1289,187,1,0,0,0,1290,1292,7,3,0,
        0,1291,1293,3,28,14,0,1292,1291,1,0,0,0,1293,1294,1,0,0,0,1294,1292,
        1,0,0,0,1294,1295,1,0,0,0,1295,1298,1,0,0,0,1296,1298,5,219,0,0,
        1297,1290,1,0,0,0,1297,1296,1,0,0,0,1298,189,1,0,0,0,1299,1300,3,
        192,96,0,1300,1301,5,244,0,0,1301,1302,3,178,89,0,1302,191,1,0,0,
        0,1303,1304,3,36,18,0,1304,193,1,0,0,0,1305,1307,3,38,19,0,1306,
        1305,1,0,0,0,1306,1307,1,0,0,0,1307,1308,1,0,0,0,1308,1309,3,34,
        17,0,1309,195,1,0,0,0,1310,1312,3,38,19,0,1311,1310,1,0,0,0,1311,
        1312,1,0,0,0,1312,1314,1,0,0,0,1313,1315,7,18,0,0,1314,1313,1,0,
        0,0,1314,1315,1,0,0,0,1315,1317,1,0,0,0,1316,1318,3,28,14,0,1317,
        1316,1,0,0,0,1318,1319,1,0,0,0,1319,1317,1,0,0,0,1319,1320,1,0,0,
        0,1320,197,1,0,0,0,1321,1322,7,26,0,0,1322,1323,3,32,16,0,1323,199,
        1,0,0,0,1324,1325,5,124,0,0,1325,1332,3,32,16,0,1326,1329,3,32,16,
        0,1327,1328,7,25,0,0,1328,1330,3,202,101,0,1329,1327,1,0,0,0,1329,
        1330,1,0,0,0,1330,1332,1,0,0,0,1331,1324,1,0,0,0,1331,1326,1,0,0,
        0,1332,201,1,0,0,0,1333,1336,3,204,102,0,1334,1336,3,220,110,0,1335,
        1333,1,0,0,0,1335,1334,1,0,0,0,1336,203,1,0,0,0,1337,1343,3,212,
        106,0,1338,1343,3,206,103,0,1339,1343,3,214,107,0,1340,1343,3,216,
        108,0,1341,1343,3,218,109,0,1342,1337,1,0,0,0,1342,1338,1,0,0,0,
        1342,1339,1,0,0,0,1342,1340,1,0,0,0,1342,1341,1,0,0,0,1343,205,1,
        0,0,0,1344,1345,3,208,104,0,1345,207,1,0,0,0,1346,1348,5,215,0,0,
        1347,1346,1,0,0,0,1347,1348,1,0,0,0,1348,1351,1,0,0,0,1349,1352,
        3,194,97,0,1350,1352,3,210,105,0,1351,1349,1,0,0,0,1351,1350,1,0,
        0,0,1352,1353,1,0,0,0,1353,1354,7,27,0,0,1354,209,1,0,0,0,1355,1356,
        3,32,16,0,1356,211,1,0,0,0,1357,1359,5,215,0,0,1358,1357,1,0,0,0,
        1358,1359,1,0,0,0,1359,1360,1,0,0,0,1360,1361,3,32,16,0,1361,1362,
        5,109,0,0,1362,1363,3,260,130,0,1363,1364,3,248,124,0,1364,213,1,
        0,0,0,1365,1366,3,230,115,0,1366,1367,3,236,118,0,1367,215,1,0,0,
        0,1368,1369,3,232,116,0,1369,1370,3,238,119,0,1370,217,1,0,0,0,1371,
        1372,3,234,117,0,1372,1373,3,240,120,0,1373,219,1,0,0,0,1374,1375,
        5,122,0,0,1375,1376,3,168,84,0,1376,1377,5,247,0,0,1377,1378,7,28,
        0,0,1378,1379,7,29,0,0,1379,1381,5,280,0,0,1380,1382,3,222,111,0,
        1381,1380,1,0,0,0,1382,1383,1,0,0,0,1383,1381,1,0,0,0,1383,1384,
        1,0,0,0,1384,221,1,0,0,0,1385,1386,3,172,86,0,1386,1387,3,224,112,
        0,1387,1392,1,0,0,0,1388,1389,3,172,86,0,1389,1390,3,228,114,0,1390,
        1392,1,0,0,0,1391,1385,1,0,0,0,1391,1388,1,0,0,0,1392,223,1,0,0,
        0,1393,1394,3,226,113,0,1394,225,1,0,0,0,1395,1396,3,190,95,0,1396,
        1397,3,260,130,0,1397,1398,3,248,124,0,1398,1407,1,0,0,0,1399,1400,
        3,178,89,0,1400,1401,3,208,104,0,1401,1407,1,0,0,0,1402,1403,3,190,
        95,0,1403,1404,7,30,0,0,1404,1405,3,194,97,0,1405,1407,1,0,0,0,1406,
        1395,1,0,0,0,1406,1399,1,0,0,0,1406,1402,1,0,0,0,1407,227,1,0,0,
        0,1408,1413,5,154,0,0,1409,1413,5,153,0,0,1410,1411,5,117,0,0,1411,
        1413,5,118,0,0,1412,1408,1,0,0,0,1412,1409,1,0,0,0,1412,1410,1,0,
        0,0,1413,1414,1,0,0,0,1414,1415,5,122,0,0,1415,1416,3,168,84,0,1416,
        1417,5,247,0,0,1417,1418,7,28,0,0,1418,1420,5,280,0,0,1419,1421,
        3,222,111,0,1420,1419,1,0,0,0,1421,1422,1,0,0,0,1422,1420,1,0,0,
        0,1422,1423,1,0,0,0,1423,229,1,0,0,0,1424,1425,7,31,0,0,1425,231,
        1,0,0,0,1426,1427,7,32,0,0,1427,233,1,0,0,0,1428,1429,7,33,0,0,1429,
        235,1,0,0,0,1430,1431,3,248,124,0,1431,237,1,0,0,0,1432,1433,3,248,
        124,0,1433,239,1,0,0,0,1434,1459,3,40,20,0,1435,1459,5,235,0,0,1436,
        1459,5,236,0,0,1437,1438,5,17,0,0,1438,1439,5,274,0,0,1439,1440,
        3,274,137,0,1440,1441,5,278,0,0,1441,1442,3,274,137,0,1442,1443,
        5,278,0,0,1443,1444,3,274,137,0,1444,1445,5,275,0,0,1445,1459,1,
        0,0,0,1446,1447,5,18,0,0,1447,1448,5,274,0,0,1448,1449,3,274,137,
        0,1449,1450,5,275,0,0,1450,1459,1,0,0,0,1451,1459,3,190,95,0,1452,
        1459,3,198,99,0,1453,1459,3,106,53,0,1454,1455,5,274,0,0,1455,1456,
        3,248,124,0,1456,1457,5,275,0,0,1457,1459,1,0,0,0,1458,1434,1,0,
        0,0,1458,1435,1,0,0,0,1458,1436,1,0,0,0,1458,1437,1,0,0,0,1458,1446,
        1,0,0,0,1458,1451,1,0,0,0,1458,1452,1,0,0,0,1458,1453,1,0,0,0,1458,
        1454,1,0,0,0,1459,241,1,0,0,0,1460,1464,5,107,0,0,1461,1463,3,244,
        122,0,1462,1461,1,0,0,0,1463,1466,1,0,0,0,1464,1462,1,0,0,0,1464,
        1465,1,0,0,0,1465,1467,1,0,0,0,1466,1464,1,0,0,0,1467,1468,5,279,
        0,0,1468,243,1,0,0,0,1469,1471,7,9,0,0,1470,1469,1,0,0,0,1470,1471,
        1,0,0,0,1471,1472,1,0,0,0,1472,1473,5,267,0,0,1473,1474,5,113,0,
        0,1474,1475,3,246,123,0,1475,245,1,0,0,0,1476,1485,3,274,137,0,1477,
        1480,3,264,132,0,1478,1480,3,268,134,0,1479,1477,1,0,0,0,1479,1478,
        1,0,0,0,1480,1481,1,0,0,0,1481,1482,3,274,137,0,1482,1484,1,0,0,
        0,1483,1479,1,0,0,0,1484,1487,1,0,0,0,1485,1483,1,0,0,0,1485,1486,
        1,0,0,0,1486,247,1,0,0,0,1487,1485,1,0,0,0,1488,1489,3,252,126,0,
        1489,1490,5,278,0,0,1490,1491,3,278,139,0,1491,1492,3,276,138,0,
        1492,1502,1,0,0,0,1493,1494,3,252,126,0,1494,1495,5,278,0,0,1495,
        1496,3,278,139,0,1496,1502,1,0,0,0,1497,1498,3,252,126,0,1498,1499,
        3,276,138,0,1499,1502,1,0,0,0,1500,1502,3,252,126,0,1501,1488,1,
        0,0,0,1501,1493,1,0,0,0,1501,1497,1,0,0,0,1501,1500,1,0,0,0,1502,
        249,1,0,0,0,1503,1504,3,254,127,0,1504,1505,5,278,0,0,1505,1506,
        3,278,139,0,1506,1507,3,276,138,0,1507,1517,1,0,0,0,1508,1509,3,
        254,127,0,1509,1510,5,278,0,0,1510,1511,3,278,139,0,1511,1517,1,
        0,0,0,1512,1513,3,254,127,0,1513,1514,3,276,138,0,1514,1517,1,0,
        0,0,1515,1517,3,254,127,0,1516,1503,1,0,0,0,1516,1508,1,0,0,0,1516,
        1512,1,0,0,0,1516,1515,1,0,0,0,1517,251,1,0,0,0,1518,1521,3,254,
        127,0,1519,1520,7,34,0,0,1520,1522,3,252,126,0,1521,1519,1,0,0,0,
        1521,1522,1,0,0,0,1522,253,1,0,0,0,1523,1555,3,310,155,0,1524,1555,
        3,286,143,0,1525,1526,3,262,131,0,1526,1527,5,113,0,0,1527,1528,
        3,34,17,0,1528,1555,1,0,0,0,1529,1530,3,262,131,0,1530,1531,5,110,
        0,0,1531,1532,3,34,17,0,1532,1555,1,0,0,0,1533,1534,3,262,131,0,
        1534,1535,3,258,129,0,1535,1540,3,256,128,0,1536,1537,5,278,0,0,
        1537,1539,3,256,128,0,1538,1536,1,0,0,0,1539,1542,1,0,0,0,1540,1538,
        1,0,0,0,1540,1541,1,0,0,0,1541,1543,1,0,0,0,1542,1540,1,0,0,0,1543,
        1544,5,229,0,0,1544,1545,3,256,128,0,1545,1555,1,0,0,0,1546,1550,
        3,262,131,0,1547,1548,3,260,130,0,1548,1549,3,262,131,0,1549,1551,
        1,0,0,0,1550,1547,1,0,0,0,1550,1551,1,0,0,0,1551,1555,1,0,0,0,1552,
        1555,3,306,153,0,1553,1555,3,308,154,0,1554,1523,1,0,0,0,1554,1524,
        1,0,0,0,1554,1525,1,0,0,0,1554,1529,1,0,0,0,1554,1533,1,0,0,0,1554,
        1546,1,0,0,0,1554,1552,1,0,0,0,1554,1553,1,0,0,0,1555,255,1,0,0,
        0,1556,1566,5,273,0,0,1557,1566,5,272,0,0,1558,1560,5,268,0,0,1559,
        1561,3,84,42,0,1560,1559,1,0,0,0,1560,1561,1,0,0,0,1561,1566,1,0,
        0,0,1562,1566,5,271,0,0,1563,1566,3,40,20,0,1564,1566,3,18,9,0,1565,
        1556,1,0,0,0,1565,1557,1,0,0,0,1565,1558,1,0,0,0,1565,1562,1,0,0,
        0,1565,1563,1,0,0,0,1565,1564,1,0,0,0,1566,257,1,0,0,0,1567,1568,
        7,35,0,0,1568,259,1,0,0,0,1569,1570,7,36,0,0,1570,261,1,0,0,0,1571,
        1577,3,266,133,0,1572,1573,3,264,132,0,1573,1574,3,266,133,0,1574,
        1576,1,0,0,0,1575,1572,1,0,0,0,1576,1579,1,0,0,0,1577,1575,1,0,0,
        0,1577,1578,1,0,0,0,1578,263,1,0,0,0,1579,1577,1,0,0,0,1580,1581,
        7,37,0,0,1581,265,1,0,0,0,1582,1588,3,270,135,0,1583,1584,3,268,
        134,0,1584,1585,3,270,135,0,1585,1587,1,0,0,0,1586,1583,1,0,0,0,
        1587,1590,1,0,0,0,1588,1586,1,0,0,0,1588,1589,1,0,0,0,1589,267,1,
        0,0,0,1590,1588,1,0,0,0,1591,1592,7,38,0,0,1592,269,1,0,0,0,1593,
        1599,3,274,137,0,1594,1595,3,272,136,0,1595,1596,3,274,137,0,1596,
        1598,1,0,0,0,1597,1594,1,0,0,0,1598,1601,1,0,0,0,1599,1597,1,0,0,
        0,1599,1600,1,0,0,0,1600,271,1,0,0,0,1601,1599,1,0,0,0,1602,1603,
        7,39,0,0,1603,273,1,0,0,0,1604,1605,6,137,-1,0,1605,1606,5,137,0,
        0,1606,1868,3,274,137,55,1607,1608,5,292,0,0,1608,1868,3,274,137,
        54,1609,1610,5,140,0,0,1610,1868,3,274,137,53,1611,1612,5,11,0,0,
        1612,1613,3,274,137,0,1613,1614,5,146,0,0,1614,1617,3,274,137,0,
        1615,1616,5,192,0,0,1616,1618,3,84,42,0,1617,1615,1,0,0,0,1617,1618,
        1,0,0,0,1618,1868,1,0,0,0,1619,1620,5,196,0,0,1620,1621,3,274,137,
        0,1621,1622,5,146,0,0,1622,1625,3,274,137,0,1623,1624,5,192,0,0,
        1624,1626,3,84,42,0,1625,1623,1,0,0,0,1625,1626,1,0,0,0,1626,1868,
        1,0,0,0,1627,1628,5,195,0,0,1628,1633,3,274,137,0,1629,1630,5,278,
        0,0,1630,1632,3,274,137,0,1631,1629,1,0,0,0,1632,1635,1,0,0,0,1633,
        1631,1,0,0,0,1633,1634,1,0,0,0,1634,1636,1,0,0,0,1635,1633,1,0,0,
        0,1636,1637,5,216,0,0,1637,1638,3,274,137,50,1638,1868,1,0,0,0,1639,
        1640,5,195,0,0,1640,1641,5,124,0,0,1641,1868,3,32,16,0,1642,1643,
        5,195,0,0,1643,1644,5,124,0,0,1644,1868,3,190,95,0,1645,1646,5,217,
        0,0,1646,1649,5,190,0,0,1647,1649,5,190,0,0,1648,1645,1,0,0,0,1648,
        1647,1,0,0,0,1649,1650,1,0,0,0,1650,1868,3,200,100,0,1651,1652,5,
        217,0,0,1652,1653,5,190,0,0,1653,1868,3,190,95,0,1654,1655,5,190,
        0,0,1655,1868,3,190,95,0,1656,1659,5,268,0,0,1657,1660,5,283,0,0,
        1658,1660,5,267,0,0,1659,1657,1,0,0,0,1659,1658,1,0,0,0,1660,1663,
        1,0,0,0,1661,1663,5,271,0,0,1662,1656,1,0,0,0,1662,1661,1,0,0,0,
        1663,1664,1,0,0,0,1664,1665,5,244,0,0,1665,1868,3,274,137,44,1666,
        1667,5,271,0,0,1667,1668,5,244,0,0,1668,1868,3,274,137,43,1669,1670,
        5,30,0,0,1670,1675,3,274,137,0,1671,1672,5,278,0,0,1672,1674,3,274,
        137,0,1673,1671,1,0,0,0,1674,1677,1,0,0,0,1675,1673,1,0,0,0,1675,
        1676,1,0,0,0,1676,1678,1,0,0,0,1677,1675,1,0,0,0,1678,1679,7,34,
        0,0,1679,1680,3,274,137,39,1680,1868,1,0,0,0,1681,1682,5,156,0,0,
        1682,1868,3,274,137,37,1683,1684,5,12,0,0,1684,1685,5,274,0,0,1685,
        1686,3,248,124,0,1686,1687,5,275,0,0,1687,1868,1,0,0,0,1688,1689,
        5,14,0,0,1689,1694,3,274,137,0,1690,1691,5,278,0,0,1691,1693,3,274,
        137,0,1692,1690,1,0,0,0,1693,1696,1,0,0,0,1694,1692,1,0,0,0,1694,
        1695,1,0,0,0,1695,1697,1,0,0,0,1696,1694,1,0,0,0,1697,1698,5,216,
        0,0,1698,1699,3,274,137,35,1699,1868,1,0,0,0,1700,1701,5,14,0,0,
        1701,1702,5,124,0,0,1702,1868,3,190,95,0,1703,1704,5,13,0,0,1704,
        1709,3,274,137,0,1705,1706,5,278,0,0,1706,1708,3,274,137,0,1707,
        1705,1,0,0,0,1708,1711,1,0,0,0,1709,1707,1,0,0,0,1709,1710,1,0,0,
        0,1710,1712,1,0,0,0,1711,1709,1,0,0,0,1712,1713,5,216,0,0,1713,1714,
        3,274,137,33,1714,1868,1,0,0,0,1715,1716,5,13,0,0,1716,1717,5,124,
        0,0,1717,1868,3,190,95,0,1718,1719,5,217,0,0,1719,1720,5,221,0,0,
        1720,1721,5,241,0,0,1721,1868,3,274,137,31,1722,1723,5,212,0,0,1723,
        1724,5,224,0,0,1724,1725,5,241,0,0,1725,1868,3,274,137,30,1726,1727,
        5,212,0,0,1727,1728,5,209,0,0,1728,1729,5,241,0,0,1729,1868,3,274,
        137,29,1730,1731,5,17,0,0,1731,1732,5,274,0,0,1732,1733,3,274,137,
        0,1733,1734,5,278,0,0,1734,1735,3,274,137,0,1735,1736,5,278,0,0,
        1736,1737,3,274,137,0,1737,1738,5,275,0,0,1738,1868,1,0,0,0,1739,
        1740,5,18,0,0,1740,1741,5,274,0,0,1741,1742,3,274,137,0,1742,1743,
        5,275,0,0,1743,1868,1,0,0,0,1744,1745,3,240,120,0,1745,1746,7,40,
        0,0,1746,1747,3,274,137,0,1747,1748,3,44,22,0,1748,1868,1,0,0,0,
        1749,1750,5,191,0,0,1750,1755,3,274,137,0,1751,1752,5,278,0,0,1752,
        1754,3,274,137,0,1753,1751,1,0,0,0,1754,1757,1,0,0,0,1755,1753,1,
        0,0,0,1755,1756,1,0,0,0,1756,1758,1,0,0,0,1757,1755,1,0,0,0,1758,
        1759,5,216,0,0,1759,1760,3,274,137,25,1760,1868,1,0,0,0,1761,1762,
        5,193,0,0,1762,1767,3,274,137,0,1763,1764,5,278,0,0,1764,1766,3,
        274,137,0,1765,1763,1,0,0,0,1766,1769,1,0,0,0,1767,1765,1,0,0,0,
        1767,1768,1,0,0,0,1768,1770,1,0,0,0,1769,1767,1,0,0,0,1770,1771,
        5,216,0,0,1771,1772,3,274,137,24,1772,1868,1,0,0,0,1773,1774,5,15,
        0,0,1774,1776,3,248,124,0,1775,1777,3,284,142,0,1776,1775,1,0,0,
        0,1776,1777,1,0,0,0,1777,1868,1,0,0,0,1778,1779,5,217,0,0,1779,1780,
        5,190,0,0,1780,1781,5,210,0,0,1781,1790,5,220,0,0,1782,1784,5,212,
        0,0,1783,1782,1,0,0,0,1783,1784,1,0,0,0,1784,1785,1,0,0,0,1785,1791,
        5,224,0,0,1786,1788,5,217,0,0,1787,1786,1,0,0,0,1787,1788,1,0,0,
        0,1788,1789,1,0,0,0,1789,1791,5,221,0,0,1790,1783,1,0,0,0,1790,1787,
        1,0,0,0,1791,1792,1,0,0,0,1792,1793,5,211,0,0,1793,1868,3,248,124,
        0,1794,1796,3,18,9,0,1795,1794,1,0,0,0,1796,1797,1,0,0,0,1797,1795,
        1,0,0,0,1797,1798,1,0,0,0,1798,1799,1,0,0,0,1799,1800,5,15,0,0,1800,
        1802,3,248,124,0,1801,1803,3,284,142,0,1802,1801,1,0,0,0,1802,1803,
        1,0,0,0,1803,1868,1,0,0,0,1804,1805,5,16,0,0,1805,1806,7,41,0,0,
        1806,1807,5,244,0,0,1807,1809,3,248,124,0,1808,1810,3,284,142,0,
        1809,1808,1,0,0,0,1809,1810,1,0,0,0,1810,1868,1,0,0,0,1811,1813,
        3,18,9,0,1812,1811,1,0,0,0,1813,1814,1,0,0,0,1814,1812,1,0,0,0,1814,
        1815,1,0,0,0,1815,1816,1,0,0,0,1816,1817,5,16,0,0,1817,1818,7,41,
        0,0,1818,1819,5,244,0,0,1819,1821,3,248,124,0,1820,1822,3,284,142,
        0,1821,1820,1,0,0,0,1821,1822,1,0,0,0,1822,1868,1,0,0,0,1823,1826,
        3,294,147,0,1824,1826,3,296,148,0,1825,1823,1,0,0,0,1825,1824,1,
        0,0,0,1826,1827,1,0,0,0,1827,1828,3,192,96,0,1828,1829,3,298,149,
        0,1829,1868,1,0,0,0,1830,1833,3,294,147,0,1831,1833,3,296,148,0,
        1832,1830,1,0,0,0,1832,1831,1,0,0,0,1833,1836,1,0,0,0,1834,1837,
        3,198,99,0,1835,1837,3,190,95,0,1836,1834,1,0,0,0,1836,1835,1,0,
        0,0,1837,1838,1,0,0,0,1838,1839,5,150,0,0,1839,1840,3,32,16,0,1840,
        1841,5,240,0,0,1841,1843,3,32,16,0,1842,1844,5,279,0,0,1843,1842,
        1,0,0,0,1843,1844,1,0,0,0,1844,1868,1,0,0,0,1845,1847,5,268,0,0,
        1846,1848,3,84,42,0,1847,1846,1,0,0,0,1847,1848,1,0,0,0,1848,1868,
        1,0,0,0,1849,1868,5,235,0,0,1850,1868,3,18,9,0,1851,1868,3,198,99,
        0,1852,1868,3,190,95,0,1853,1868,3,178,89,0,1854,1868,3,32,16,0,
        1855,1868,3,106,53,0,1856,1868,5,271,0,0,1857,1868,5,272,0,0,1858,
        1868,5,273,0,0,1859,1868,3,40,20,0,1860,1868,5,249,0,0,1861,1868,
        5,230,0,0,1862,1868,5,219,0,0,1863,1864,5,274,0,0,1864,1865,3,248,
        124,0,1865,1866,5,275,0,0,1866,1868,1,0,0,0,1867,1604,1,0,0,0,1867,
        1607,1,0,0,0,1867,1609,1,0,0,0,1867,1611,1,0,0,0,1867,1619,1,0,0,
        0,1867,1627,1,0,0,0,1867,1639,1,0,0,0,1867,1642,1,0,0,0,1867,1648,
        1,0,0,0,1867,1651,1,0,0,0,1867,1654,1,0,0,0,1867,1662,1,0,0,0,1867,
        1666,1,0,0,0,1867,1669,1,0,0,0,1867,1681,1,0,0,0,1867,1683,1,0,0,
        0,1867,1688,1,0,0,0,1867,1700,1,0,0,0,1867,1703,1,0,0,0,1867,1715,
        1,0,0,0,1867,1718,1,0,0,0,1867,1722,1,0,0,0,1867,1726,1,0,0,0,1867,
        1730,1,0,0,0,1867,1739,1,0,0,0,1867,1744,1,0,0,0,1867,1749,1,0,0,
        0,1867,1761,1,0,0,0,1867,1773,1,0,0,0,1867,1778,1,0,0,0,1867,1795,
        1,0,0,0,1867,1804,1,0,0,0,1867,1812,1,0,0,0,1867,1825,1,0,0,0,1867,
        1832,1,0,0,0,1867,1845,1,0,0,0,1867,1849,1,0,0,0,1867,1850,1,0,0,
        0,1867,1851,1,0,0,0,1867,1852,1,0,0,0,1867,1853,1,0,0,0,1867,1854,
        1,0,0,0,1867,1855,1,0,0,0,1867,1856,1,0,0,0,1867,1857,1,0,0,0,1867,
        1858,1,0,0,0,1867,1859,1,0,0,0,1867,1860,1,0,0,0,1867,1861,1,0,0,
        0,1867,1862,1,0,0,0,1867,1863,1,0,0,0,1868,1891,1,0,0,0,1869,1872,
        10,38,0,0,1870,1871,5,278,0,0,1871,1873,3,274,137,0,1872,1870,1,
        0,0,0,1873,1874,1,0,0,0,1874,1872,1,0,0,0,1874,1875,1,0,0,0,1875,
        1876,1,0,0,0,1876,1877,7,34,0,0,1877,1878,3,274,137,39,1878,1890,
        1,0,0,0,1879,1880,10,42,0,0,1880,1890,3,276,138,0,1881,1882,10,41,
        0,0,1882,1883,5,278,0,0,1883,1884,3,278,139,0,1884,1885,3,276,138,
        0,1885,1890,1,0,0,0,1886,1887,10,40,0,0,1887,1888,5,278,0,0,1888,
        1890,3,278,139,0,1889,1869,1,0,0,0,1889,1879,1,0,0,0,1889,1881,1,
        0,0,0,1889,1886,1,0,0,0,1890,1893,1,0,0,0,1891,1889,1,0,0,0,1891,
        1892,1,0,0,0,1892,275,1,0,0,0,1893,1891,1,0,0,0,1894,1895,7,42,0,
        0,1895,1896,5,123,0,0,1896,1897,5,268,0,0,1897,1898,5,169,0,0,1898,
        277,1,0,0,0,1899,1906,3,280,140,0,1900,1906,3,282,141,0,1901,1902,
        3,280,140,0,1902,1903,5,216,0,0,1903,1904,3,282,141,0,1904,1906,
        1,0,0,0,1905,1899,1,0,0,0,1905,1900,1,0,0,0,1905,1901,1,0,0,0,1906,
        279,1,0,0,0,1907,1908,5,20,0,0,1908,1909,3,248,124,0,1909,281,1,
        0,0,0,1910,1911,5,21,0,0,1911,1912,3,248,124,0,1912,283,1,0,0,0,
        1913,1914,5,4,0,0,1914,1917,3,248,124,0,1915,1917,3,288,144,0,1916,
        1913,1,0,0,0,1916,1915,1,0,0,0,1917,285,1,0,0,0,1918,1919,5,7,0,
        0,1919,1920,3,288,144,0,1920,287,1,0,0,0,1921,1922,5,150,0,0,1922,
        1938,3,240,120,0,1923,1924,5,244,0,0,1924,1925,3,240,120,0,1925,
        1926,5,146,0,0,1926,1927,3,240,120,0,1927,1938,1,0,0,0,1928,1929,
        5,244,0,0,1929,1930,3,240,120,0,1930,1931,5,148,0,0,1931,1932,3,
        240,120,0,1932,1938,1,0,0,0,1933,1934,5,146,0,0,1934,1938,3,240,
        120,0,1935,1936,5,148,0,0,1936,1938,3,240,120,0,1937,1921,1,0,0,
        0,1937,1923,1,0,0,0,1937,1928,1,0,0,0,1937,1933,1,0,0,0,1937,1935,
        1,0,0,0,1938,289,1,0,0,0,1939,1940,5,150,0,0,1940,1956,3,292,146,
        0,1941,1942,5,146,0,0,1942,1956,3,292,146,0,1943,1944,5,148,0,0,
        1944,1956,3,292,146,0,1945,1946,5,244,0,0,1946,1947,3,292,146,0,
        1947,1948,5,146,0,0,1948,1949,3,292,146,0,1949,1956,1,0,0,0,1950,
        1951,5,244,0,0,1951,1952,3,292,146,0,1952,1953,5,148,0,0,1953,1954,
        3,292,146,0,1954,1956,1,0,0,0,1955,1939,1,0,0,0,1955,1941,1,0,0,
        0,1955,1943,1,0,0,0,1955,1945,1,0,0,0,1955,1950,1,0,0,0,1956,291,
        1,0,0,0,1957,1962,3,40,20,0,1958,1962,5,235,0,0,1959,1962,5,236,
        0,0,1960,1962,3,190,95,0,1961,1957,1,0,0,0,1961,1958,1,0,0,0,1961,
        1959,1,0,0,0,1961,1960,1,0,0,0,1962,293,1,0,0,0,1963,1964,5,217,
        0,0,1964,1970,5,190,0,0,1965,1970,5,190,0,0,1966,1970,5,13,0,0,1967,
        1970,5,14,0,0,1968,1970,5,195,0,0,1969,1963,1,0,0,0,1969,1965,1,
        0,0,0,1969,1966,1,0,0,0,1969,1967,1,0,0,0,1969,1968,1,0,0,0,1970,
        295,1,0,0,0,1971,1972,7,43,0,0,1972,297,1,0,0,0,1973,1977,5,233,
        0,0,1974,1978,3,300,150,0,1975,1978,3,302,151,0,1976,1978,3,304,
        152,0,1977,1974,1,0,0,0,1977,1975,1,0,0,0,1977,1976,1,0,0,0,1978,
        1979,1,0,0,0,1979,1980,5,279,0,0,1980,1984,1,0,0,0,1981,1982,5,244,
        0,0,1982,1984,3,300,150,0,1983,1973,1,0,0,0,1983,1981,1,0,0,0,1984,
        299,1,0,0,0,1985,1986,5,124,0,0,1986,1989,3,32,16,0,1987,1988,7,
        25,0,0,1988,1990,3,202,101,0,1989,1987,1,0,0,0,1989,1990,1,0,0,0,
        1990,301,1,0,0,0,1991,1992,5,212,0,0,1992,1993,3,32,16,0,1993,1994,
        5,150,0,0,1994,1995,3,32,16,0,1995,1996,5,240,0,0,1996,1997,3,32,
        16,0,1997,303,1,0,0,0,1998,1999,5,212,0,0,1999,2000,3,32,16,0,2000,
        2001,5,220,0,0,2001,2002,5,276,0,0,2002,2007,3,32,16,0,2003,2004,
        5,278,0,0,2004,2006,3,32,16,0,2005,2003,1,0,0,0,2006,2009,1,0,0,
        0,2007,2005,1,0,0,0,2007,2008,1,0,0,0,2008,2010,1,0,0,0,2009,2007,
        1,0,0,0,2010,2011,5,216,0,0,2011,2012,3,32,16,0,2012,2013,5,277,
        0,0,2013,305,1,0,0,0,2014,2015,3,274,137,0,2015,2016,7,44,0,0,2016,
        2041,1,0,0,0,2017,2018,3,274,137,0,2018,2019,7,45,0,0,2019,2020,
        5,268,0,0,2020,2021,5,167,0,0,2021,2041,1,0,0,0,2022,2023,3,274,
        137,0,2023,2024,7,46,0,0,2024,2025,3,18,9,0,2025,2041,1,0,0,0,2026,
        2027,3,274,137,0,2027,2028,7,47,0,0,2028,2029,3,18,9,0,2029,2041,
        1,0,0,0,2030,2031,3,274,137,0,2031,2032,7,48,0,0,2032,2033,3,18,
        9,0,2033,2041,1,0,0,0,2034,2035,3,178,89,0,2035,2036,5,92,0,0,2036,
        2041,1,0,0,0,2037,2038,3,274,137,0,2038,2039,5,94,0,0,2039,2041,
        1,0,0,0,2040,2014,1,0,0,0,2040,2017,1,0,0,0,2040,2022,1,0,0,0,2040,
        2026,1,0,0,0,2040,2030,1,0,0,0,2040,2034,1,0,0,0,2040,2037,1,0,0,
        0,2041,307,1,0,0,0,2042,2043,5,237,0,0,2043,2044,3,32,16,0,2044,
        2045,5,93,0,0,2045,2051,1,0,0,0,2046,2047,5,237,0,0,2047,2048,3,
        32,16,0,2048,2049,5,94,0,0,2049,2051,1,0,0,0,2050,2042,1,0,0,0,2050,
        2046,1,0,0,0,2051,309,1,0,0,0,2052,2053,3,178,89,0,2053,2054,3,34,
        17,0,2054,2055,5,110,0,0,2055,2065,1,0,0,0,2056,2057,3,178,89,0,
        2057,2058,3,34,17,0,2058,2059,5,113,0,0,2059,2065,1,0,0,0,2060,2061,
        3,178,89,0,2061,2062,5,113,0,0,2062,2063,3,34,17,0,2063,2065,1,0,
        0,0,2064,2052,1,0,0,0,2064,2056,1,0,0,0,2064,2060,1,0,0,0,2065,311,
        1,0,0,0,2066,2067,5,106,0,0,2067,2075,3,32,16,0,2068,2070,5,178,
        0,0,2069,2071,5,267,0,0,2070,2069,1,0,0,0,2071,2072,1,0,0,0,2072,
        2070,1,0,0,0,2072,2073,1,0,0,0,2073,2074,1,0,0,0,2074,2076,5,275,
        0,0,2075,2068,1,0,0,0,2075,2076,1,0,0,0,2076,2078,1,0,0,0,2077,2079,
        5,281,0,0,2078,2077,1,0,0,0,2078,2079,1,0,0,0,2079,313,1,0,0,0,2080,
        2081,5,272,0,0,2081,315,1,0,0,0,2082,2083,3,248,124,0,2083,2084,
        5,116,0,0,2084,2085,3,248,124,0,2085,2086,5,278,0,0,2086,2089,5,
        26,0,0,2087,2090,3,318,159,0,2088,2090,3,320,160,0,2089,2087,1,0,
        0,0,2089,2088,1,0,0,0,2090,2092,1,0,0,0,2091,2093,3,328,164,0,2092,
        2091,1,0,0,0,2092,2093,1,0,0,0,2093,317,1,0,0,0,2094,2095,3,326,
        163,0,2095,319,1,0,0,0,2096,2097,5,280,0,0,2097,2099,3,322,161,0,
        2098,2100,5,279,0,0,2099,2098,1,0,0,0,2099,2100,1,0,0,0,2100,321,
        1,0,0,0,2101,2105,3,324,162,0,2102,2104,3,324,162,0,2103,2102,1,
        0,0,0,2104,2107,1,0,0,0,2105,2103,1,0,0,0,2105,2106,1,0,0,0,2106,
        323,1,0,0,0,2107,2105,1,0,0,0,2108,2109,5,292,0,0,2109,2111,3,326,
        163,0,2110,2112,7,49,0,0,2111,2110,1,0,0,0,2111,2112,1,0,0,0,2112,
        325,1,0,0,0,2113,2128,5,198,0,0,2114,2115,5,35,0,0,2115,2128,3,248,
        124,0,2116,2117,5,34,0,0,2117,2118,7,50,0,0,2118,2128,3,248,124,
        0,2119,2120,5,33,0,0,2120,2128,3,326,163,0,2121,2122,5,21,0,0,2122,
        2128,3,248,124,0,2123,2124,5,123,0,0,2124,2125,5,268,0,0,2125,2126,
        5,169,0,0,2126,2128,7,51,0,0,2127,2113,1,0,0,0,2127,2114,1,0,0,0,
        2127,2116,1,0,0,0,2127,2119,1,0,0,0,2127,2121,1,0,0,0,2127,2123,
        1,0,0,0,2128,327,1,0,0,0,2129,2130,5,19,0,0,2130,2132,3,248,124,
        0,2131,2133,5,199,0,0,2132,2131,1,0,0,0,2132,2133,1,0,0,0,2133,329,
        1,0,0,0,241,336,338,349,354,363,367,376,380,383,388,391,395,400,
        413,417,421,426,435,440,445,451,457,463,468,474,480,489,491,494,
        499,504,510,516,522,527,533,539,548,550,554,557,562,567,573,579,
        585,590,596,602,604,612,621,630,647,650,653,658,663,668,672,676,
        679,685,689,697,700,703,711,718,725,734,741,749,757,760,767,773,
        784,793,797,801,805,812,818,823,828,836,842,845,860,864,868,871,
        874,882,888,891,899,903,911,920,928,931,936,940,942,947,954,960,
        963,966,971,975,977,983,1000,1010,1012,1026,1029,1041,1054,1073,
        1078,1085,1089,1097,1100,1107,1110,1112,1121,1137,1140,1142,1147,
        1156,1164,1174,1180,1190,1196,1206,1208,1224,1229,1234,1241,1251,
        1256,1261,1269,1278,1285,1288,1294,1297,1306,1311,1314,1319,1329,
        1331,1335,1342,1347,1351,1358,1383,1391,1406,1412,1422,1458,1464,
        1470,1479,1485,1501,1516,1521,1540,1550,1554,1560,1565,1577,1588,
        1599,1617,1625,1633,1648,1659,1662,1675,1694,1709,1755,1767,1776,
        1783,1787,1790,1797,1802,1809,1814,1821,1825,1832,1836,1843,1847,
        1867,1874,1889,1891,1905,1916,1937,1955,1961,1969,1977,1983,1989,
        2007,2040,2050,2064,2072,2075,2078,2089,2092,2099,2105,2111,2127,
        2132
    ]

class RegelSpraakParser ( Parser ):

    grammarFileName = "RegelSpraak.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'(voor het attribuut zonder voorzetsel):'", 
                     "'(na het attribuut met voorzetsel'", "'Datum en tijd in millisecondes'", 
                     "'gedurende de tijd dat'", "'gedurende het gehele'", 
                     "'gedurende de gehele'", "<INVALID>", "'moet berekend worden als'", 
                     "'moet gesteld worden op'", "'moet ge\\u00EFnitialiseerd worden op'", 
                     "'de absolute tijdsduur van'", "'de absolute waarde van'", 
                     "'de maximale waarde van'", "'de minimale waarde van'", 
                     "'het totaal van'", "'het tijdsevenredig deel per'", 
                     "'de datum met jaar, maand en dag'", "'de eerste paasdag van'", 
                     "'Als onverdeelde rest blijft'", "'met een minimum van'", 
                     "'met een maximum van'", "'groter of gelijk aan'", 
                     "'kleiner of gelijk aan'", "'later of gelijk aan'", 
                     "'eerder of gelijk aan'", "'waarbij wordt verdeeld'", 
                     "', bestaande uit de'", "'Wederkerig feittype'", "'is van het type'", 
                     "'de concatenatie van'", "'het volgende criterium:'", 
                     "'volgende criteria:'", "'bij een even groot criterium'", 
                     "'op volgorde van'", "'naar rato van'", "'numeriek met exact'", 
                     "'aan de elfproef'", "'groter is dan'", "'kleiner is dan'", 
                     "'wordt voldaan'", "<INVALID>", "'wordt een nieuw'", 
                     "'aangemaakt'", "'Cre\\u00EBer'", "'nieuwe'", "<INVALID>", 
                     "'gelijk is aan'", "'is gelijk aan'", "'is ongelijk aan'", 
                     "'is kleiner dan'", "'is kleiner of gelijk aan'", "'is groter dan'", 
                     "'is groter of gelijk aan'", "'zijn gelijk aan'", "'zijn ongelijk aan'", 
                     "'zijn groter dan'", "'zijn groter of gelijk aan'", 
                     "'zijn kleiner dan'", "'zijn kleiner of gelijk aan'", 
                     "'is later dan'", "'is later of gelijk aan'", "'is eerder dan'", 
                     "'is eerder of gelijk aan'", "'zijn later dan'", "'zijn later of gelijk aan'", 
                     "'zijn eerder dan'", "'zijn eerder of gelijk aan'", 
                     "'is leeg'", "'is gevuld'", "'zijn leeg'", "'zijn gevuld'", 
                     "'is kenmerk'", "'is rol'", "'zijn kenmerk'", "'zijn rol'", 
                     "'is niet kenmerk'", "'is niet rol'", "'zijn niet kenmerk'", 
                     "'zijn niet rol'", "'voldoet aan de elfproef'", "'voldoen aan de elfproef'", 
                     "'voldoet niet aan de elfproef'", "'voldoen niet aan de elfproef'", 
                     "'is numeriek met exact'", "'is niet numeriek met exact'", 
                     "'zijn numeriek met exact'", "'zijn niet numeriek met exact'", 
                     "'is een dagsoort'", "'zijn een dagsoort'", "'is geen dagsoort'", 
                     "'zijn geen dagsoort'", "'moeten uniek zijn'", "'is gevuurd'", 
                     "'is inconsistent'", "'Consistentieregel'", "'Regel'", 
                     "'Regelgroep'", "'Beslistabel'", "'Objecttype'", "'Domein'", 
                     "'Lijst'", "'Dimensie'", "'Eenheidsysteem'", "'Parameter'", 
                     "'Feittype'", "'Dagsoort'", "'Daarbij geldt:'", "'geldig'", 
                     "'hebben'", "'heeft'", "'indien'", "'is recursief'", 
                     "'is'", "'moet'", "'moeten'", "'wordt verdeeld over'", 
                     "'wordt'", "'voldaan'", "'zijn'", "'haar'", "'hun'", 
                     "'aan'", "'afgerond op'", "'alle'", "'eerder dan'", 
                     "'gedeeld door'", "'gedeeld door (ABS)'", "'gelijk aan'", 
                     "'gevuld'", "'gevuurd'", "'groter dan'", "'inconsistent'", 
                     "'kleiner dan'", "'later dan'", "'leeg'", "'maal'", 
                     "'min'", "'naar beneden'", "'naar boven'", "'niet'", 
                     "'ongelijk zijn aan'", "'ongelijk aan'", "'plus'", 
                     "'rekenkundig'", "'richting nul'", "'tot'", "'tot de macht'", 
                     "'tot en met'", "'uniek'", "'vanaf'", "'verenigd met'", 
                     "'verminderd met'", "'voldoen'", "'voldoet'", "'weg van nul'", 
                     "'de wortel van'", "'tenminste'", "'ten minste'", "'ten hoogste'", 
                     "'precies'", "'voorwaarde'", "'voorwaarden'", "'(bezittelijk)'", 
                     "'(bijvoeglijk)'", "'(bezield)'", "'Boolean'", "'cijfers'", 
                     "'Datum in dagen'", "'decimalen'", "'Enumeratie'", 
                     "'gedimensioneerd met'", "'geheel getal'", "'getal'", 
                     "'kenmerk'", "'kenmerken'", "'met'", "'met eenheid'", 
                     "'(mv:'", "'negatief'", "'niet-negatief'", "'Numeriek'", 
                     "'Percentage'", "'positief'", "'rol'", "'rollen'", 
                     "'Tekst'", "'voor elk jaar'", "'voor elke dag'", "'voor elke maand'", 
                     "'aantal'", "'de eerste van'", "'in hele'", "'de laatste van'", 
                     "'reeks van teksten en waarden'", "'de som van'", "'de tijdsduur van'", 
                     "'afnemende'", "'in gelijke delen'", "'over.'", "'toenemende'", 
                     "'drie'", "'\\u00E9\\u00E9n'", "'geen van de'", "'geen'", 
                     "'twee'", "'vier'", "'altijd'", "'bij'", "'dag'", "'dagen'", 
                     "'dat'", "<INVALID>", "'dd.'", "'die'", "<INVALID>", 
                     "'en'", "<INVALID>", "'meerdere'", "'hij'", "'in'", 
                     "'jaar'", "'jaren'", "'kwartaal'", "'maand'", "'maanden'", 
                     "'milliseconde'", "'minuut'", "'minuten'", "'of'", 
                     "'onwaar'", "'op'", "'ouder'", "'over'", "'periode'", 
                     "'Rekendatum'", "'Rekenjaar'", "'regelversie'", "'seconde'", 
                     "'seconden'", "'t/m'", "'uit'", "'uur'", "'uren'", 
                     "'van'", "'volgende voorwaarde'", "'volgende voorwaarden'", 
                     "'volgende'", "'voor'", "'waar'", "'week'", "'weken'", 
                     "'er'", "'meter'", "'kilogram'", "'voet'", "'pond'", 
                     "'mijl'", "'m'", "'kg'", "'s'", "'ft'", "'lb'", "'mi'", 
                     "'\\u20AC'", "'$'", "'\\u00B0'", "<INVALID>", "<INVALID>", 
                     "'='", "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "'('", "')'", "'{'", "'}'", "','", "'.'", "':'", "';'", 
                     "'/'", "'%'", "'\\u2022'", "'*'", "'\\u00AB'", "'\\u00BB'", 
                     "'^'", "'..'", "<INVALID>", "<INVALID>", "'-'", "'|'", 
                     "'n.v.t.'" ]

    symbolicNames = [ "<INVALID>", "VOOR_HET_ATTRIBUUT_ZONDER_VOORZETSEL", 
                      "NA_HET_ATTRIBUUT_MET_VOORZETSEL", "DATUM_TIJD_MILLIS", 
                      "GEDURENDE_DE_TIJD_DAT", "GEDURENDE_HET_GEHELE", "GEDURENDE_DE_GEHELE", 
                      "HET_IS_DE_PERIODE", "WORDT_BEREKEND_ALS", "WORDT_GESTELD_OP", 
                      "WORDT_GEINITIALISEERD_OP", "DE_ABSOLUTE_TIJDSDUUR_VAN", 
                      "DE_ABSOLUTE_WAARDE_VAN", "DE_MAXIMALE_WAARDE_VAN", 
                      "DE_MINIMALE_WAARDE_VAN", "HET_TOTAAL_VAN", "HET_TIJDSEVENREDIG_DEEL_PER", 
                      "DE_DATUM_MET", "DE_EERSTE_PAASDAG_VAN", "ALS_ONVERDEELDE_REST_BLIJFT", 
                      "MET_EEN_MINIMUM_VAN", "MET_EEN_MAXIMUM_VAN", "GROTER_OF_GELIJK_AAN", 
                      "KLEINER_OF_GELIJK_AAN", "LATER_OF_GELIJK_AAN", "EERDER_OF_GELIJK_AAN", 
                      "WAARBIJ_WORDT_VERDEELD", "BESTAANDE_UIT", "WEDERKERIG_FEITTYPE", 
                      "IS_VAN_HET_TYPE", "CONCATENATIE_VAN", "VOLGEND_CRITERIUM", 
                      "VOLGENDE_CRITERIA", "BIJ_EVEN_GROOT_CRITERIUM", "OP_VOLGORDE_VAN", 
                      "NAAR_RATO_VAN", "NUMERIEK_MET_EXACT", "AAN_DE_ELFPROEF", 
                      "GROTER_IS_DAN", "KLEINER_IS_DAN", "WORDT_VOLDAAN", 
                      "ER_WORDT_EEN_NIEUW", "WORDT_EEN_NIEUW", "AANGEMAAKT", 
                      "CREEER", "NIEUWE", "ER_AAN", "GELIJK_IS_AAN", "IS_GELIJK_AAN", 
                      "IS_ONGELIJK_AAN", "IS_KLEINER_DAN", "IS_KLEINER_OF_GELIJK_AAN", 
                      "IS_GROTER_DAN", "IS_GROTER_OF_GELIJK_AAN", "ZIJN_GELIJK_AAN", 
                      "ZIJN_ONGELIJK_AAN", "ZIJN_GROTER_DAN", "ZIJN_GROTER_OF_GELIJK_AAN", 
                      "ZIJN_KLEINER_DAN", "ZIJN_KLEINER_OF_GELIJK_AAN", 
                      "IS_LATER_DAN", "IS_LATER_OF_GELIJK_AAN", "IS_EERDER_DAN", 
                      "IS_EERDER_OF_GELIJK_AAN", "ZIJN_LATER_DAN", "ZIJN_LATER_OF_GELIJK_AAN", 
                      "ZIJN_EERDER_DAN", "ZIJN_EERDER_OF_GELIJK_AAN", "IS_LEEG", 
                      "IS_GEVULD", "ZIJN_LEEG", "ZIJN_GEVULD", "IS_KENMERK", 
                      "IS_ROL", "ZIJN_KENMERK", "ZIJN_ROL", "IS_NIET_KENMERK", 
                      "IS_NIET_ROL", "ZIJN_NIET_KENMERK", "ZIJN_NIET_ROL", 
                      "VOLDOET_AAN_DE_ELFPROEF", "VOLDOEN_AAN_DE_ELFPROEF", 
                      "VOLDOET_NIET_AAN_DE_ELFPROEF", "VOLDOEN_NIET_AAN_DE_ELFPROEF", 
                      "IS_NUMERIEK_MET_EXACT", "IS_NIET_NUMERIEK_MET_EXACT", 
                      "ZIJN_NUMERIEK_MET_EXACT", "ZIJN_NIET_NUMERIEK_MET_EXACT", 
                      "IS_EEN_DAGSOORT", "ZIJN_EEN_DAGSOORT", "IS_GEEN_DAGSOORT", 
                      "ZIJN_GEEN_DAGSOORT", "MOETEN_UNIEK_ZIJN", "IS_GEVUURD", 
                      "IS_INCONSISTENT", "CONSISTENTIEREGEL", "REGEL", "REGELGROEP", 
                      "BESLISTABEL", "OBJECTTYPE", "DOMEIN", "LIJST", "DIMENSIE", 
                      "EENHEIDSYSTEEM", "PARAMETER", "FEITTYPE", "DAGSOORT", 
                      "DAARBIJ_GELDT", "GELDIG", "HEBBEN", "HEEFT", "INDIEN", 
                      "IS_RECURSIEF", "IS", "MOET", "MOETEN", "WORDT_VERDEELD_OVER", 
                      "WORDT", "VOLDAAN", "ZIJN", "HAAR", "HUN", "AAN", 
                      "AFGEROND_OP", "ALLE", "EERDER_DAN", "GEDEELD_DOOR", 
                      "GEDEELD_DOOR_ABS", "GELIJK_AAN", "GEVULD", "GEVUURD", 
                      "GROTER_DAN", "INCONSISTENT", "KLEINER_DAN", "LATER_DAN", 
                      "LEEG", "MAAL", "MIN", "NAAR_BENEDEN", "NAAR_BOVEN", 
                      "NIET", "ONGELIJK_ZIJN_AAN", "ONGELIJK_AAN", "PLUS", 
                      "REKENKUNDIG", "RICHTING_NUL", "TOT", "TOT_DE_MACHT", 
                      "TOT_EN_MET", "UNIEK", "VANAF", "VERENIGD_MET", "VERMINDERD_MET", 
                      "VOLDOEN", "VOLDOET", "WEG_VAN_NUL", "DE_WORTEL_VAN", 
                      "TENMINSTE", "TEN_MINSTE", "TEN_HOOGSTE", "PRECIES", 
                      "VOORWAARDE", "VOORWAARDEN", "BEZITTELIJK", "BIJVOEGLIJK", 
                      "BEZIELD", "BOOLEAN", "CIJFERS", "DATUM_IN_DAGEN", 
                      "DECIMALEN", "ENUMERATIE", "GEDIMENSIONEERD_MET", 
                      "GEHEEL_GETAL", "GETAL", "KENMERK", "KENMERKEN", "MET", 
                      "MET_EENHEID", "MV_START", "NEGATIEF", "NIET_NEGATIEF", 
                      "NUMERIEK", "PERCENTAGE", "POSITIEF", "ROL", "ROLLEN", 
                      "TEKST", "VOOR_ELK_JAAR", "VOOR_ELKE_DAG", "VOOR_ELKE_MAAND", 
                      "AANTAL", "EERSTE_VAN", "IN_HELE", "LAATSTE_VAN", 
                      "REEKS_VAN_TEKSTEN_EN_WAARDEN", "SOM_VAN", "TIJDSDUUR_VAN", 
                      "AFNEMENDE", "IN_GELIJKE_DELEN", "OVER_VERDELING", 
                      "TOENEMENDE", "DRIE_TELWOORD", "EEN_TELWOORD", "GEEN_VAN_DE", 
                      "GEEN", "TWEE_TELWOORD", "VIER_TELWOORD", "ALTIJD", 
                      "BIJ", "DAG", "DAGEN", "DAT", "DE", "DD_PUNT", "DIE", 
                      "EEN", "EN", "HET", "MEERDERE", "HIJ", "IN", "JAAR", 
                      "JAREN", "KWARTAAL", "MAAND", "MAANDEN", "MILLISECONDE", 
                      "MINUUT", "MINUTEN", "OF", "ONWAAR", "OP", "OUDER", 
                      "OVER", "PERIODE", "REKENDATUM", "REKENJAAR", "REGELVERSIE", 
                      "SECONDE", "SECONDEN", "TM", "UIT", "UUR", "UREN", 
                      "VAN", "VOLGENDE_VOORWAARDE", "VOLGENDE_VOORWAARDEN", 
                      "VOLGENDE", "VOOR", "WAAR", "WEEK", "WEKEN", "ER", 
                      "METER", "KILOGRAM", "VOET", "POND", "MIJL", "M", 
                      "KG", "S", "FT", "LB", "MI", "EURO_SYMBOL", "DOLLAR_SYMBOL", 
                      "DEGREE_SYMBOL", "IDENTIFIER", "NUMBER", "EQUALS", 
                      "DATE_TIME_LITERAL", "PERCENTAGE_LITERAL", "STRING_LITERAL", 
                      "ENUM_LITERAL", "LPAREN", "RPAREN", "LBRACE", "RBRACE", 
                      "COMMA", "DOT", "COLON", "SEMICOLON", "SLASH", "PERCENT_SIGN", 
                      "BULLET", "ASTERISK", "L_ANGLE_QUOTE", "R_ANGLE_QUOTE", 
                      "CARET", "DOUBLE_DOT", "WS", "LINE_COMMENT", "MINUS", 
                      "PIPE", "NVT" ]

    RULE_regelSpraakDocument = 0
    RULE_definitie = 1
    RULE_beslistabel = 2
    RULE_beslistabelTable = 3
    RULE_beslistabelHeader = 4
    RULE_beslistabelSeparator = 5
    RULE_beslistabelRow = 6
    RULE_beslistabelCellValue = 7
    RULE_beslistabelColumnText = 8
    RULE_identifier = 9
    RULE_identifierOrKeyword = 10
    RULE_identifierOrKeywordNoIs = 11
    RULE_naamPhrase = 12
    RULE_naamPhraseWithNumbers = 13
    RULE_identifierOrKeywordWithNumbers = 14
    RULE_naamPhraseNoIs = 15
    RULE_naamwoord = 16
    RULE_naamwoordWithNumbers = 17
    RULE_naamwoordNoIs = 18
    RULE_voorzetsel = 19
    RULE_datumLiteral = 20
    RULE_unit = 21
    RULE_timeUnit = 22
    RULE_objectTypeDefinition = 23
    RULE_objectTypeMember = 24
    RULE_kenmerkSpecificatie = 25
    RULE_attribuutSpecificatie = 26
    RULE_datatype = 27
    RULE_lijstDatatype = 28
    RULE_numeriekDatatype = 29
    RULE_tekstDatatype = 30
    RULE_percentageDatatype = 31
    RULE_booleanDatatype = 32
    RULE_datumTijdDatatype = 33
    RULE_getalSpecificatie = 34
    RULE_domeinDefinition = 35
    RULE_domeinType = 36
    RULE_enumeratieSpecificatie = 37
    RULE_domeinRef = 38
    RULE_objectTypeRef = 39
    RULE_eenheidsysteemDefinition = 40
    RULE_eenheidEntry = 41
    RULE_unitIdentifier = 42
    RULE_eenheidExpressie = 43
    RULE_eenheidMacht = 44
    RULE_dimensieDefinition = 45
    RULE_voorzetselSpecificatie = 46
    RULE_labelWaardeSpecificatie = 47
    RULE_tijdlijn = 48
    RULE_dimensieRef = 49
    RULE_parameterDefinition = 50
    RULE_parameterNamePhrase = 51
    RULE_parameterNamePart = 52
    RULE_parameterMetLidwoord = 53
    RULE_feitTypeDefinition = 54
    RULE_rolDefinition = 55
    RULE_rolObjectType = 56
    RULE_rolContentWords = 57
    RULE_cardinalityLine = 58
    RULE_cardinalityWord = 59
    RULE_regel = 60
    RULE_regelGroep = 61
    RULE_regelName = 62
    RULE_regelNameExtension = 63
    RULE_regelVersie = 64
    RULE_versieGeldigheid = 65
    RULE_resultaatDeel = 66
    RULE_consistencyOperator = 67
    RULE_feitCreatiePattern = 68
    RULE_feitCreatieRolPhrase = 69
    RULE_feitCreatieSubjectPhrase = 70
    RULE_feitCreatieSubjectWord = 71
    RULE_feitCreatieWord = 72
    RULE_voorzetselNietVan = 73
    RULE_objectCreatie = 74
    RULE_objectAttributeInit = 75
    RULE_attributeInitVervolg = 76
    RULE_simpleNaamwoord = 77
    RULE_consistentieregel = 78
    RULE_uniekzijnResultaat = 79
    RULE_alleAttributenVanObjecttype = 80
    RULE_inconsistentResultaat = 81
    RULE_voorwaardeDeel = 82
    RULE_toplevelSamengesteldeVoorwaarde = 83
    RULE_voorwaardeKwantificatie = 84
    RULE_samengesteldeVoorwaardeOnderdeel = 85
    RULE_bulletPrefix = 86
    RULE_elementaireVoorwaarde = 87
    RULE_genesteSamengesteldeVoorwaarde = 88
    RULE_onderwerpReferentie = 89
    RULE_onderwerpReferentieWithNumbers = 90
    RULE_onderwerpBasis = 91
    RULE_onderwerpBasisWithNumbers = 92
    RULE_basisOnderwerp = 93
    RULE_basisOnderwerpWithNumbers = 94
    RULE_attribuutReferentie = 95
    RULE_attribuutMetLidwoord = 96
    RULE_kenmerkNaam = 97
    RULE_kenmerkPhrase = 98
    RULE_bezieldeReferentie = 99
    RULE_aggregationSubject = 100
    RULE_predicaat = 101
    RULE_elementairPredicaat = 102
    RULE_objectPredicaat = 103
    RULE_eenzijdigeObjectVergelijking = 104
    RULE_rolNaam = 105
    RULE_attribuutVergelijkingsPredicaat = 106
    RULE_getalPredicaat = 107
    RULE_tekstPredicaat = 108
    RULE_datumPredicaat = 109
    RULE_samengesteldPredicaat = 110
    RULE_samengesteldeVoorwaardeOnderdeelInPredicaat = 111
    RULE_elementaireVoorwaardeInPredicaat = 112
    RULE_vergelijkingInPredicaat = 113
    RULE_genesteSamengesteldeVoorwaardeInPredicaat = 114
    RULE_getalVergelijkingsOperatorMeervoud = 115
    RULE_tekstVergelijkingsOperatorMeervoud = 116
    RULE_datumVergelijkingsOperatorMeervoud = 117
    RULE_getalExpressie = 118
    RULE_tekstExpressie = 119
    RULE_datumExpressie = 120
    RULE_variabeleDeel = 121
    RULE_variabeleToekenning = 122
    RULE_variabeleExpressie = 123
    RULE_expressie = 124
    RULE_simpleExpressie = 125
    RULE_logicalExpression = 126
    RULE_comparisonExpression = 127
    RULE_literalValue = 128
    RULE_gelijkIsAanOperator = 129
    RULE_comparisonOperator = 130
    RULE_additiveExpression = 131
    RULE_additiveOperator = 132
    RULE_multiplicativeExpression = 133
    RULE_multiplicativeOperator = 134
    RULE_powerExpression = 135
    RULE_powerOperator = 136
    RULE_primaryExpression = 137
    RULE_afronding = 138
    RULE_begrenzing = 139
    RULE_begrenzingMinimum = 140
    RULE_begrenzingMaximum = 141
    RULE_conditieBijExpressie = 142
    RULE_periodevergelijkingElementair = 143
    RULE_periodevergelijkingEnkelvoudig = 144
    RULE_periodeDefinitie = 145
    RULE_dateExpression = 146
    RULE_getalAggregatieFunctie = 147
    RULE_datumAggregatieFunctie = 148
    RULE_dimensieSelectie = 149
    RULE_aggregerenOverAlleDimensies = 150
    RULE_aggregerenOverVerzameling = 151
    RULE_aggregerenOverBereik = 152
    RULE_unaryCondition = 153
    RULE_regelStatusCondition = 154
    RULE_subordinateClauseExpression = 155
    RULE_dagsoortDefinition = 156
    RULE_tekstreeksExpr = 157
    RULE_verdelingResultaat = 158
    RULE_verdelingMethodeSimple = 159
    RULE_verdelingMethodeMultiLine = 160
    RULE_verdelingMethodeBulletList = 161
    RULE_verdelingMethodeBullet = 162
    RULE_verdelingMethode = 163
    RULE_verdelingRest = 164

    ruleNames =  [ "regelSpraakDocument", "definitie", "beslistabel", "beslistabelTable", 
                   "beslistabelHeader", "beslistabelSeparator", "beslistabelRow", 
                   "beslistabelCellValue", "beslistabelColumnText", "identifier", 
                   "identifierOrKeyword", "identifierOrKeywordNoIs", "naamPhrase", 
                   "naamPhraseWithNumbers", "identifierOrKeywordWithNumbers", 
                   "naamPhraseNoIs", "naamwoord", "naamwoordWithNumbers", 
                   "naamwoordNoIs", "voorzetsel", "datumLiteral", "unit", 
                   "timeUnit", "objectTypeDefinition", "objectTypeMember", 
                   "kenmerkSpecificatie", "attribuutSpecificatie", "datatype", 
                   "lijstDatatype", "numeriekDatatype", "tekstDatatype", 
                   "percentageDatatype", "booleanDatatype", "datumTijdDatatype", 
                   "getalSpecificatie", "domeinDefinition", "domeinType", 
                   "enumeratieSpecificatie", "domeinRef", "objectTypeRef", 
                   "eenheidsysteemDefinition", "eenheidEntry", "unitIdentifier", 
                   "eenheidExpressie", "eenheidMacht", "dimensieDefinition", 
                   "voorzetselSpecificatie", "labelWaardeSpecificatie", 
                   "tijdlijn", "dimensieRef", "parameterDefinition", "parameterNamePhrase", 
                   "parameterNamePart", "parameterMetLidwoord", "feitTypeDefinition", 
                   "rolDefinition", "rolObjectType", "rolContentWords", 
                   "cardinalityLine", "cardinalityWord", "regel", "regelGroep", 
                   "regelName", "regelNameExtension", "regelVersie", "versieGeldigheid", 
                   "resultaatDeel", "consistencyOperator", "feitCreatiePattern", 
                   "feitCreatieRolPhrase", "feitCreatieSubjectPhrase", "feitCreatieSubjectWord", 
                   "feitCreatieWord", "voorzetselNietVan", "objectCreatie", 
                   "objectAttributeInit", "attributeInitVervolg", "simpleNaamwoord", 
                   "consistentieregel", "uniekzijnResultaat", "alleAttributenVanObjecttype", 
                   "inconsistentResultaat", "voorwaardeDeel", "toplevelSamengesteldeVoorwaarde", 
                   "voorwaardeKwantificatie", "samengesteldeVoorwaardeOnderdeel", 
                   "bulletPrefix", "elementaireVoorwaarde", "genesteSamengesteldeVoorwaarde", 
                   "onderwerpReferentie", "onderwerpReferentieWithNumbers", 
                   "onderwerpBasis", "onderwerpBasisWithNumbers", "basisOnderwerp", 
                   "basisOnderwerpWithNumbers", "attribuutReferentie", "attribuutMetLidwoord", 
                   "kenmerkNaam", "kenmerkPhrase", "bezieldeReferentie", 
                   "aggregationSubject", "predicaat", "elementairPredicaat", 
                   "objectPredicaat", "eenzijdigeObjectVergelijking", "rolNaam", 
                   "attribuutVergelijkingsPredicaat", "getalPredicaat", 
                   "tekstPredicaat", "datumPredicaat", "samengesteldPredicaat", 
                   "samengesteldeVoorwaardeOnderdeelInPredicaat", "elementaireVoorwaardeInPredicaat", 
                   "vergelijkingInPredicaat", "genesteSamengesteldeVoorwaardeInPredicaat", 
                   "getalVergelijkingsOperatorMeervoud", "tekstVergelijkingsOperatorMeervoud", 
                   "datumVergelijkingsOperatorMeervoud", "getalExpressie", 
                   "tekstExpressie", "datumExpressie", "variabeleDeel", 
                   "variabeleToekenning", "variabeleExpressie", "expressie", 
                   "simpleExpressie", "logicalExpression", "comparisonExpression", 
                   "literalValue", "gelijkIsAanOperator", "comparisonOperator", 
                   "additiveExpression", "additiveOperator", "multiplicativeExpression", 
                   "multiplicativeOperator", "powerExpression", "powerOperator", 
                   "primaryExpression", "afronding", "begrenzing", "begrenzingMinimum", 
                   "begrenzingMaximum", "conditieBijExpressie", "periodevergelijkingElementair", 
                   "periodevergelijkingEnkelvoudig", "periodeDefinitie", 
                   "dateExpression", "getalAggregatieFunctie", "datumAggregatieFunctie", 
                   "dimensieSelectie", "aggregerenOverAlleDimensies", "aggregerenOverVerzameling", 
                   "aggregerenOverBereik", "unaryCondition", "regelStatusCondition", 
                   "subordinateClauseExpression", "dagsoortDefinition", 
                   "tekstreeksExpr", "verdelingResultaat", "verdelingMethodeSimple", 
                   "verdelingMethodeMultiLine", "verdelingMethodeBulletList", 
                   "verdelingMethodeBullet", "verdelingMethode", "verdelingRest" ]

    EOF = Token.EOF
    VOOR_HET_ATTRIBUUT_ZONDER_VOORZETSEL=1
    NA_HET_ATTRIBUUT_MET_VOORZETSEL=2
    DATUM_TIJD_MILLIS=3
    GEDURENDE_DE_TIJD_DAT=4
    GEDURENDE_HET_GEHELE=5
    GEDURENDE_DE_GEHELE=6
    HET_IS_DE_PERIODE=7
    WORDT_BEREKEND_ALS=8
    WORDT_GESTELD_OP=9
    WORDT_GEINITIALISEERD_OP=10
    DE_ABSOLUTE_TIJDSDUUR_VAN=11
    DE_ABSOLUTE_WAARDE_VAN=12
    DE_MAXIMALE_WAARDE_VAN=13
    DE_MINIMALE_WAARDE_VAN=14
    HET_TOTAAL_VAN=15
    HET_TIJDSEVENREDIG_DEEL_PER=16
    DE_DATUM_MET=17
    DE_EERSTE_PAASDAG_VAN=18
    ALS_ONVERDEELDE_REST_BLIJFT=19
    MET_EEN_MINIMUM_VAN=20
    MET_EEN_MAXIMUM_VAN=21
    GROTER_OF_GELIJK_AAN=22
    KLEINER_OF_GELIJK_AAN=23
    LATER_OF_GELIJK_AAN=24
    EERDER_OF_GELIJK_AAN=25
    WAARBIJ_WORDT_VERDEELD=26
    BESTAANDE_UIT=27
    WEDERKERIG_FEITTYPE=28
    IS_VAN_HET_TYPE=29
    CONCATENATIE_VAN=30
    VOLGEND_CRITERIUM=31
    VOLGENDE_CRITERIA=32
    BIJ_EVEN_GROOT_CRITERIUM=33
    OP_VOLGORDE_VAN=34
    NAAR_RATO_VAN=35
    NUMERIEK_MET_EXACT=36
    AAN_DE_ELFPROEF=37
    GROTER_IS_DAN=38
    KLEINER_IS_DAN=39
    WORDT_VOLDAAN=40
    ER_WORDT_EEN_NIEUW=41
    WORDT_EEN_NIEUW=42
    AANGEMAAKT=43
    CREEER=44
    NIEUWE=45
    ER_AAN=46
    GELIJK_IS_AAN=47
    IS_GELIJK_AAN=48
    IS_ONGELIJK_AAN=49
    IS_KLEINER_DAN=50
    IS_KLEINER_OF_GELIJK_AAN=51
    IS_GROTER_DAN=52
    IS_GROTER_OF_GELIJK_AAN=53
    ZIJN_GELIJK_AAN=54
    ZIJN_ONGELIJK_AAN=55
    ZIJN_GROTER_DAN=56
    ZIJN_GROTER_OF_GELIJK_AAN=57
    ZIJN_KLEINER_DAN=58
    ZIJN_KLEINER_OF_GELIJK_AAN=59
    IS_LATER_DAN=60
    IS_LATER_OF_GELIJK_AAN=61
    IS_EERDER_DAN=62
    IS_EERDER_OF_GELIJK_AAN=63
    ZIJN_LATER_DAN=64
    ZIJN_LATER_OF_GELIJK_AAN=65
    ZIJN_EERDER_DAN=66
    ZIJN_EERDER_OF_GELIJK_AAN=67
    IS_LEEG=68
    IS_GEVULD=69
    ZIJN_LEEG=70
    ZIJN_GEVULD=71
    IS_KENMERK=72
    IS_ROL=73
    ZIJN_KENMERK=74
    ZIJN_ROL=75
    IS_NIET_KENMERK=76
    IS_NIET_ROL=77
    ZIJN_NIET_KENMERK=78
    ZIJN_NIET_ROL=79
    VOLDOET_AAN_DE_ELFPROEF=80
    VOLDOEN_AAN_DE_ELFPROEF=81
    VOLDOET_NIET_AAN_DE_ELFPROEF=82
    VOLDOEN_NIET_AAN_DE_ELFPROEF=83
    IS_NUMERIEK_MET_EXACT=84
    IS_NIET_NUMERIEK_MET_EXACT=85
    ZIJN_NUMERIEK_MET_EXACT=86
    ZIJN_NIET_NUMERIEK_MET_EXACT=87
    IS_EEN_DAGSOORT=88
    ZIJN_EEN_DAGSOORT=89
    IS_GEEN_DAGSOORT=90
    ZIJN_GEEN_DAGSOORT=91
    MOETEN_UNIEK_ZIJN=92
    IS_GEVUURD=93
    IS_INCONSISTENT=94
    CONSISTENTIEREGEL=95
    REGEL=96
    REGELGROEP=97
    BESLISTABEL=98
    OBJECTTYPE=99
    DOMEIN=100
    LIJST=101
    DIMENSIE=102
    EENHEIDSYSTEEM=103
    PARAMETER=104
    FEITTYPE=105
    DAGSOORT=106
    DAARBIJ_GELDT=107
    GELDIG=108
    HEBBEN=109
    HEEFT=110
    INDIEN=111
    IS_RECURSIEF=112
    IS=113
    MOET=114
    MOETEN=115
    WORDT_VERDEELD_OVER=116
    WORDT=117
    VOLDAAN=118
    ZIJN=119
    HAAR=120
    HUN=121
    AAN=122
    AFGEROND_OP=123
    ALLE=124
    EERDER_DAN=125
    GEDEELD_DOOR=126
    GEDEELD_DOOR_ABS=127
    GELIJK_AAN=128
    GEVULD=129
    GEVUURD=130
    GROTER_DAN=131
    INCONSISTENT=132
    KLEINER_DAN=133
    LATER_DAN=134
    LEEG=135
    MAAL=136
    MIN=137
    NAAR_BENEDEN=138
    NAAR_BOVEN=139
    NIET=140
    ONGELIJK_ZIJN_AAN=141
    ONGELIJK_AAN=142
    PLUS=143
    REKENKUNDIG=144
    RICHTING_NUL=145
    TOT=146
    TOT_DE_MACHT=147
    TOT_EN_MET=148
    UNIEK=149
    VANAF=150
    VERENIGD_MET=151
    VERMINDERD_MET=152
    VOLDOEN=153
    VOLDOET=154
    WEG_VAN_NUL=155
    DE_WORTEL_VAN=156
    TENMINSTE=157
    TEN_MINSTE=158
    TEN_HOOGSTE=159
    PRECIES=160
    VOORWAARDE=161
    VOORWAARDEN=162
    BEZITTELIJK=163
    BIJVOEGLIJK=164
    BEZIELD=165
    BOOLEAN=166
    CIJFERS=167
    DATUM_IN_DAGEN=168
    DECIMALEN=169
    ENUMERATIE=170
    GEDIMENSIONEERD_MET=171
    GEHEEL_GETAL=172
    GETAL=173
    KENMERK=174
    KENMERKEN=175
    MET=176
    MET_EENHEID=177
    MV_START=178
    NEGATIEF=179
    NIET_NEGATIEF=180
    NUMERIEK=181
    PERCENTAGE=182
    POSITIEF=183
    ROL=184
    ROLLEN=185
    TEKST=186
    VOOR_ELK_JAAR=187
    VOOR_ELKE_DAG=188
    VOOR_ELKE_MAAND=189
    AANTAL=190
    EERSTE_VAN=191
    IN_HELE=192
    LAATSTE_VAN=193
    REEKS_VAN_TEKSTEN_EN_WAARDEN=194
    SOM_VAN=195
    TIJDSDUUR_VAN=196
    AFNEMENDE=197
    IN_GELIJKE_DELEN=198
    OVER_VERDELING=199
    TOENEMENDE=200
    DRIE_TELWOORD=201
    EEN_TELWOORD=202
    GEEN_VAN_DE=203
    GEEN=204
    TWEE_TELWOORD=205
    VIER_TELWOORD=206
    ALTIJD=207
    BIJ=208
    DAG=209
    DAGEN=210
    DAT=211
    DE=212
    DD_PUNT=213
    DIE=214
    EEN=215
    EN=216
    HET=217
    MEERDERE=218
    HIJ=219
    IN=220
    JAAR=221
    JAREN=222
    KWARTAAL=223
    MAAND=224
    MAANDEN=225
    MILLISECONDE=226
    MINUUT=227
    MINUTEN=228
    OF=229
    ONWAAR=230
    OP=231
    OUDER=232
    OVER=233
    PERIODE=234
    REKENDATUM=235
    REKENJAAR=236
    REGELVERSIE=237
    SECONDE=238
    SECONDEN=239
    TM=240
    UIT=241
    UUR=242
    UREN=243
    VAN=244
    VOLGENDE_VOORWAARDE=245
    VOLGENDE_VOORWAARDEN=246
    VOLGENDE=247
    VOOR=248
    WAAR=249
    WEEK=250
    WEKEN=251
    ER=252
    METER=253
    KILOGRAM=254
    VOET=255
    POND=256
    MIJL=257
    M=258
    KG=259
    S=260
    FT=261
    LB=262
    MI=263
    EURO_SYMBOL=264
    DOLLAR_SYMBOL=265
    DEGREE_SYMBOL=266
    IDENTIFIER=267
    NUMBER=268
    EQUALS=269
    DATE_TIME_LITERAL=270
    PERCENTAGE_LITERAL=271
    STRING_LITERAL=272
    ENUM_LITERAL=273
    LPAREN=274
    RPAREN=275
    LBRACE=276
    RBRACE=277
    COMMA=278
    DOT=279
    COLON=280
    SEMICOLON=281
    SLASH=282
    PERCENT_SIGN=283
    BULLET=284
    ASTERISK=285
    L_ANGLE_QUOTE=286
    R_ANGLE_QUOTE=287
    CARET=288
    DOUBLE_DOT=289
    WS=290
    LINE_COMMENT=291
    MINUS=292
    PIPE=293
    NVT=294

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.13.1")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class RegelSpraakDocumentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOF(self):
            return self.getToken(RegelSpraakParser.EOF, 0)

        def definitie(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.DefinitieContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.DefinitieContext,i)


        def regel(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.RegelContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.RegelContext,i)


        def regelGroep(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.RegelGroepContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.RegelGroepContext,i)


        def beslistabel(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.BeslistabelContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.BeslistabelContext,i)


        def consistentieregel(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.ConsistentieregelContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.ConsistentieregelContext,i)


        def eenheidsysteemDefinition(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.EenheidsysteemDefinitionContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.EenheidsysteemDefinitionContext,i)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_regelSpraakDocument

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRegelSpraakDocument" ):
                listener.enterRegelSpraakDocument(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRegelSpraakDocument" ):
                listener.exitRegelSpraakDocument(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRegelSpraakDocument" ):
                return visitor.visitRegelSpraakDocument(self)
            else:
                return visitor.visitChildren(self)




    def regelSpraakDocument(self):

        localctx = RegelSpraakParser.RegelSpraakDocumentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_regelSpraakDocument)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 338
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==28 or ((((_la - 95)) & ~0x3f) == 0 and ((1 << (_la - 95)) & 4031) != 0):
                self.state = 336
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [28, 99, 100, 102, 104, 105, 106]:
                    self.state = 330
                    self.definitie()
                    pass
                elif token in [96]:
                    self.state = 331
                    self.regel()
                    pass
                elif token in [97]:
                    self.state = 332
                    self.regelGroep()
                    pass
                elif token in [98]:
                    self.state = 333
                    self.beslistabel()
                    pass
                elif token in [95]:
                    self.state = 334
                    self.consistentieregel()
                    pass
                elif token in [103]:
                    self.state = 335
                    self.eenheidsysteemDefinition()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 340
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 341
            self.match(RegelSpraakParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DefinitieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def objectTypeDefinition(self):
            return self.getTypedRuleContext(RegelSpraakParser.ObjectTypeDefinitionContext,0)


        def domeinDefinition(self):
            return self.getTypedRuleContext(RegelSpraakParser.DomeinDefinitionContext,0)


        def parameterDefinition(self):
            return self.getTypedRuleContext(RegelSpraakParser.ParameterDefinitionContext,0)


        def dimensieDefinition(self):
            return self.getTypedRuleContext(RegelSpraakParser.DimensieDefinitionContext,0)


        def feitTypeDefinition(self):
            return self.getTypedRuleContext(RegelSpraakParser.FeitTypeDefinitionContext,0)


        def dagsoortDefinition(self):
            return self.getTypedRuleContext(RegelSpraakParser.DagsoortDefinitionContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_definitie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDefinitie" ):
                listener.enterDefinitie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDefinitie" ):
                listener.exitDefinitie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDefinitie" ):
                return visitor.visitDefinitie(self)
            else:
                return visitor.visitChildren(self)




    def definitie(self):

        localctx = RegelSpraakParser.DefinitieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_definitie)
        try:
            self.state = 349
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [99]:
                self.enterOuterAlt(localctx, 1)
                self.state = 343
                self.objectTypeDefinition()
                pass
            elif token in [100]:
                self.enterOuterAlt(localctx, 2)
                self.state = 344
                self.domeinDefinition()
                pass
            elif token in [104]:
                self.enterOuterAlt(localctx, 3)
                self.state = 345
                self.parameterDefinition()
                pass
            elif token in [102]:
                self.enterOuterAlt(localctx, 4)
                self.state = 346
                self.dimensieDefinition()
                pass
            elif token in [28, 105]:
                self.enterOuterAlt(localctx, 5)
                self.state = 347
                self.feitTypeDefinition()
                pass
            elif token in [106]:
                self.enterOuterAlt(localctx, 6)
                self.state = 348
                self.dagsoortDefinition()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BeslistabelContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BESLISTABEL(self):
            return self.getToken(RegelSpraakParser.BESLISTABEL, 0)

        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def beslistabelTable(self):
            return self.getTypedRuleContext(RegelSpraakParser.BeslistabelTableContext,0)


        def regelVersie(self):
            return self.getTypedRuleContext(RegelSpraakParser.RegelVersieContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_beslistabel

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBeslistabel" ):
                listener.enterBeslistabel(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBeslistabel" ):
                listener.exitBeslistabel(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBeslistabel" ):
                return visitor.visitBeslistabel(self)
            else:
                return visitor.visitChildren(self)




    def beslistabel(self):

        localctx = RegelSpraakParser.BeslistabelContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_beslistabel)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 351
            self.match(RegelSpraakParser.BESLISTABEL)
            self.state = 352
            self.naamwoord()
            self.state = 354
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==108:
                self.state = 353
                self.regelVersie()


            self.state = 356
            self.beslistabelTable()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BeslistabelTableContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def beslistabelHeader(self):
            return self.getTypedRuleContext(RegelSpraakParser.BeslistabelHeaderContext,0)


        def beslistabelSeparator(self):
            return self.getTypedRuleContext(RegelSpraakParser.BeslistabelSeparatorContext,0)


        def beslistabelRow(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.BeslistabelRowContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.BeslistabelRowContext,i)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_beslistabelTable

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBeslistabelTable" ):
                listener.enterBeslistabelTable(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBeslistabelTable" ):
                listener.exitBeslistabelTable(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBeslistabelTable" ):
                return visitor.visitBeslistabelTable(self)
            else:
                return visitor.visitChildren(self)




    def beslistabelTable(self):

        localctx = RegelSpraakParser.BeslistabelTableContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_beslistabelTable)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 358
            self.beslistabelHeader()
            self.state = 359
            self.beslistabelSeparator()
            self.state = 361 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 360
                self.beslistabelRow()
                self.state = 363 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==293):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BeslistabelHeaderContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.resultColumn = None # BeslistabelColumnTextContext
            self._beslistabelColumnText = None # BeslistabelColumnTextContext
            self.conditionColumns = list() # of BeslistabelColumnTextContexts

        def PIPE(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.PIPE)
            else:
                return self.getToken(RegelSpraakParser.PIPE, i)

        def beslistabelColumnText(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.BeslistabelColumnTextContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.BeslistabelColumnTextContext,i)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_beslistabelHeader

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBeslistabelHeader" ):
                listener.enterBeslistabelHeader(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBeslistabelHeader" ):
                listener.exitBeslistabelHeader(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBeslistabelHeader" ):
                return visitor.visitBeslistabelHeader(self)
            else:
                return visitor.visitChildren(self)




    def beslistabelHeader(self):

        localctx = RegelSpraakParser.BeslistabelHeaderContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_beslistabelHeader)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 365
            self.match(RegelSpraakParser.PIPE)
            self.state = 367
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==293:
                self.state = 366
                self.match(RegelSpraakParser.PIPE)


            self.state = 369
            localctx.resultColumn = self.beslistabelColumnText()
            self.state = 370
            self.match(RegelSpraakParser.PIPE)
            self.state = 371
            localctx._beslistabelColumnText = self.beslistabelColumnText()
            localctx.conditionColumns.append(localctx._beslistabelColumnText)
            self.state = 376
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,6,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 372
                    self.match(RegelSpraakParser.PIPE)
                    self.state = 373
                    localctx._beslistabelColumnText = self.beslistabelColumnText()
                    localctx.conditionColumns.append(localctx._beslistabelColumnText) 
                self.state = 378
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,6,self._ctx)

            self.state = 380
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,7,self._ctx)
            if la_ == 1:
                self.state = 379
                self.match(RegelSpraakParser.PIPE)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BeslistabelSeparatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PIPE(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.PIPE)
            else:
                return self.getToken(RegelSpraakParser.PIPE, i)

        def MINUS(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.MINUS)
            else:
                return self.getToken(RegelSpraakParser.MINUS, i)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_beslistabelSeparator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBeslistabelSeparator" ):
                listener.enterBeslistabelSeparator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBeslistabelSeparator" ):
                listener.exitBeslistabelSeparator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBeslistabelSeparator" ):
                return visitor.visitBeslistabelSeparator(self)
            else:
                return visitor.visitChildren(self)




    def beslistabelSeparator(self):

        localctx = RegelSpraakParser.BeslistabelSeparatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_beslistabelSeparator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 383
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==293:
                self.state = 382
                self.match(RegelSpraakParser.PIPE)


            self.state = 393 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 386 
                    self._errHandler.sync(self)
                    _alt = 1
                    while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                        if _alt == 1:
                            self.state = 385
                            self.match(RegelSpraakParser.MINUS)

                        else:
                            raise NoViableAltException(self)
                        self.state = 388 
                        self._errHandler.sync(self)
                        _alt = self._interp.adaptivePredict(self._input,9,self._ctx)

                    self.state = 391
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,10,self._ctx)
                    if la_ == 1:
                        self.state = 390
                        self.match(RegelSpraakParser.PIPE)



                else:
                    raise NoViableAltException(self)
                self.state = 395 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,11,self._ctx)

            self.state = 400
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==292:
                self.state = 397
                self.match(RegelSpraakParser.MINUS)
                self.state = 402
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BeslistabelRowContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.rowNumber = None # Token
            self.resultExpression = None # ExpressieContext
            self._beslistabelCellValue = None # BeslistabelCellValueContext
            self.conditionValues = list() # of BeslistabelCellValueContexts

        def PIPE(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.PIPE)
            else:
                return self.getToken(RegelSpraakParser.PIPE, i)

        def NUMBER(self):
            return self.getToken(RegelSpraakParser.NUMBER, 0)

        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)


        def beslistabelCellValue(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.BeslistabelCellValueContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.BeslistabelCellValueContext,i)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_beslistabelRow

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBeslistabelRow" ):
                listener.enterBeslistabelRow(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBeslistabelRow" ):
                listener.exitBeslistabelRow(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBeslistabelRow" ):
                return visitor.visitBeslistabelRow(self)
            else:
                return visitor.visitChildren(self)




    def beslistabelRow(self):

        localctx = RegelSpraakParser.BeslistabelRowContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_beslistabelRow)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 403
            self.match(RegelSpraakParser.PIPE)
            self.state = 404
            localctx.rowNumber = self.match(RegelSpraakParser.NUMBER)
            self.state = 405
            self.match(RegelSpraakParser.PIPE)
            self.state = 406
            localctx.resultExpression = self.expressie()
            self.state = 407
            self.match(RegelSpraakParser.PIPE)
            self.state = 408
            localctx._beslistabelCellValue = self.beslistabelCellValue()
            localctx.conditionValues.append(localctx._beslistabelCellValue)
            self.state = 413
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,13,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 409
                    self.match(RegelSpraakParser.PIPE)
                    self.state = 410
                    localctx._beslistabelCellValue = self.beslistabelCellValue()
                    localctx.conditionValues.append(localctx._beslistabelCellValue) 
                self.state = 415
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,13,self._ctx)

            self.state = 417
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,14,self._ctx)
            if la_ == 1:
                self.state = 416
                self.match(RegelSpraakParser.PIPE)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BeslistabelCellValueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)


        def NVT(self):
            return self.getToken(RegelSpraakParser.NVT, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_beslistabelCellValue

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBeslistabelCellValue" ):
                listener.enterBeslistabelCellValue(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBeslistabelCellValue" ):
                listener.exitBeslistabelCellValue(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBeslistabelCellValue" ):
                return visitor.visitBeslistabelCellValue(self)
            else:
                return visitor.visitChildren(self)




    def beslistabelCellValue(self):

        localctx = RegelSpraakParser.BeslistabelCellValueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_beslistabelCellValue)
        try:
            self.state = 421
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [7, 11, 12, 13, 14, 15, 16, 17, 18, 30, 45, 96, 110, 113, 119, 120, 121, 124, 132, 137, 140, 156, 161, 190, 191, 193, 195, 196, 201, 202, 205, 206, 209, 210, 212, 215, 217, 219, 221, 223, 224, 230, 232, 234, 235, 236, 237, 249, 253, 267, 268, 270, 271, 272, 273, 274, 292]:
                self.enterOuterAlt(localctx, 1)
                self.state = 419
                self.expressie()
                pass
            elif token in [294]:
                self.enterOuterAlt(localctx, 2)
                self.state = 420
                self.match(RegelSpraakParser.NVT)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BeslistabelColumnTextContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PIPE(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.PIPE)
            else:
                return self.getToken(RegelSpraakParser.PIPE, i)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_beslistabelColumnText

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBeslistabelColumnText" ):
                listener.enterBeslistabelColumnText(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBeslistabelColumnText" ):
                listener.exitBeslistabelColumnText(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBeslistabelColumnText" ):
                return visitor.visitBeslistabelColumnText(self)
            else:
                return visitor.visitChildren(self)




    def beslistabelColumnText(self):

        localctx = RegelSpraakParser.BeslistabelColumnTextContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_beslistabelColumnText)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 424 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 423
                    _la = self._input.LA(1)
                    if _la <= 0 or _la==293:
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()

                else:
                    raise NoViableAltException(self)
                self.state = 426 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,16,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IdentifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(RegelSpraakParser.IDENTIFIER, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_identifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIdentifier" ):
                listener.enterIdentifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIdentifier" ):
                listener.exitIdentifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIdentifier" ):
                return visitor.visitIdentifier(self)
            else:
                return visitor.visitChildren(self)




    def identifier(self):

        localctx = RegelSpraakParser.IdentifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_identifier)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 428
            self.match(RegelSpraakParser.IDENTIFIER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IdentifierOrKeywordContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(RegelSpraakParser.IDENTIFIER, 0)

        def DAG(self):
            return self.getToken(RegelSpraakParser.DAG, 0)

        def DAGEN(self):
            return self.getToken(RegelSpraakParser.DAGEN, 0)

        def MAAND(self):
            return self.getToken(RegelSpraakParser.MAAND, 0)

        def JAAR(self):
            return self.getToken(RegelSpraakParser.JAAR, 0)

        def AANTAL(self):
            return self.getToken(RegelSpraakParser.AANTAL, 0)

        def PERIODE(self):
            return self.getToken(RegelSpraakParser.PERIODE, 0)

        def REGEL(self):
            return self.getToken(RegelSpraakParser.REGEL, 0)

        def VOORWAARDE(self):
            return self.getToken(RegelSpraakParser.VOORWAARDE, 0)

        def HEEFT(self):
            return self.getToken(RegelSpraakParser.HEEFT, 0)

        def ALLE(self):
            return self.getToken(RegelSpraakParser.ALLE, 0)

        def INCONSISTENT(self):
            return self.getToken(RegelSpraakParser.INCONSISTENT, 0)

        def IS(self):
            return self.getToken(RegelSpraakParser.IS, 0)

        def KWARTAAL(self):
            return self.getToken(RegelSpraakParser.KWARTAAL, 0)

        def METER(self):
            return self.getToken(RegelSpraakParser.METER, 0)

        def EEN_TELWOORD(self):
            return self.getToken(RegelSpraakParser.EEN_TELWOORD, 0)

        def TWEE_TELWOORD(self):
            return self.getToken(RegelSpraakParser.TWEE_TELWOORD, 0)

        def DRIE_TELWOORD(self):
            return self.getToken(RegelSpraakParser.DRIE_TELWOORD, 0)

        def VIER_TELWOORD(self):
            return self.getToken(RegelSpraakParser.VIER_TELWOORD, 0)

        def OUDER(self):
            return self.getToken(RegelSpraakParser.OUDER, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_identifierOrKeyword

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIdentifierOrKeyword" ):
                listener.enterIdentifierOrKeyword(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIdentifierOrKeyword" ):
                listener.exitIdentifierOrKeyword(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIdentifierOrKeyword" ):
                return visitor.visitIdentifierOrKeyword(self)
            else:
                return visitor.visitChildren(self)




    def identifierOrKeyword(self):

        localctx = RegelSpraakParser.IdentifierOrKeywordContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_identifierOrKeyword)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 430
            _la = self._input.LA(1)
            if not(((((_la - 96)) & ~0x3f) == 0 and ((1 << (_la - 96)) & 68988059649) != 0) or ((((_la - 161)) & ~0x3f) == 0 and ((1 << (_la - 161)) & -3457864013260521471) != 0) or ((((_la - 232)) & ~0x3f) == 0 and ((1 << (_la - 232)) & 34361835525) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IdentifierOrKeywordNoIsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(RegelSpraakParser.IDENTIFIER, 0)

        def DAG(self):
            return self.getToken(RegelSpraakParser.DAG, 0)

        def DAGEN(self):
            return self.getToken(RegelSpraakParser.DAGEN, 0)

        def MAAND(self):
            return self.getToken(RegelSpraakParser.MAAND, 0)

        def JAAR(self):
            return self.getToken(RegelSpraakParser.JAAR, 0)

        def AANTAL(self):
            return self.getToken(RegelSpraakParser.AANTAL, 0)

        def PERIODE(self):
            return self.getToken(RegelSpraakParser.PERIODE, 0)

        def REGEL(self):
            return self.getToken(RegelSpraakParser.REGEL, 0)

        def VOORWAARDE(self):
            return self.getToken(RegelSpraakParser.VOORWAARDE, 0)

        def HEEFT(self):
            return self.getToken(RegelSpraakParser.HEEFT, 0)

        def ALLE(self):
            return self.getToken(RegelSpraakParser.ALLE, 0)

        def INCONSISTENT(self):
            return self.getToken(RegelSpraakParser.INCONSISTENT, 0)

        def KWARTAAL(self):
            return self.getToken(RegelSpraakParser.KWARTAAL, 0)

        def METER(self):
            return self.getToken(RegelSpraakParser.METER, 0)

        def EEN_TELWOORD(self):
            return self.getToken(RegelSpraakParser.EEN_TELWOORD, 0)

        def TWEE_TELWOORD(self):
            return self.getToken(RegelSpraakParser.TWEE_TELWOORD, 0)

        def DRIE_TELWOORD(self):
            return self.getToken(RegelSpraakParser.DRIE_TELWOORD, 0)

        def VIER_TELWOORD(self):
            return self.getToken(RegelSpraakParser.VIER_TELWOORD, 0)

        def OUDER(self):
            return self.getToken(RegelSpraakParser.OUDER, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_identifierOrKeywordNoIs

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIdentifierOrKeywordNoIs" ):
                listener.enterIdentifierOrKeywordNoIs(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIdentifierOrKeywordNoIs" ):
                listener.exitIdentifierOrKeywordNoIs(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIdentifierOrKeywordNoIs" ):
                return visitor.visitIdentifierOrKeywordNoIs(self)
            else:
                return visitor.visitChildren(self)




    def identifierOrKeywordNoIs(self):

        localctx = RegelSpraakParser.IdentifierOrKeywordNoIsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_identifierOrKeywordNoIs)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 432
            _la = self._input.LA(1)
            if not(((((_la - 96)) & ~0x3f) == 0 and ((1 << (_la - 96)) & 68987928577) != 0) or ((((_la - 161)) & ~0x3f) == 0 and ((1 << (_la - 161)) & -3457864013260521471) != 0) or ((((_la - 232)) & ~0x3f) == 0 and ((1 << (_la - 232)) & 34361835525) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NaamPhraseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifierOrKeyword(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.IdentifierOrKeywordContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.IdentifierOrKeywordContext,i)


        def DE(self):
            return self.getToken(RegelSpraakParser.DE, 0)

        def HET(self):
            return self.getToken(RegelSpraakParser.HET, 0)

        def EEN(self):
            return self.getToken(RegelSpraakParser.EEN, 0)

        def ZIJN(self):
            return self.getToken(RegelSpraakParser.ZIJN, 0)

        def NIEUWE(self):
            return self.getToken(RegelSpraakParser.NIEUWE, 0)

        def MET(self):
            return self.getToken(RegelSpraakParser.MET, 0)

        def NIET(self):
            return self.getToken(RegelSpraakParser.NIET, 0)

        def AANTAL(self):
            return self.getToken(RegelSpraakParser.AANTAL, 0)

        def DAGEN(self):
            return self.getToken(RegelSpraakParser.DAGEN, 0)

        def IN(self):
            return self.getToken(RegelSpraakParser.IN, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_naamPhrase

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNaamPhrase" ):
                listener.enterNaamPhrase(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNaamPhrase" ):
                listener.exitNaamPhrase(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNaamPhrase" ):
                return visitor.visitNaamPhrase(self)
            else:
                return visitor.visitChildren(self)




    def naamPhrase(self):

        localctx = RegelSpraakParser.NaamPhraseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_naamPhrase)
        self._la = 0 # Token type
        try:
            self.state = 491
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,27,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 435
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==119 or ((((_la - 212)) & ~0x3f) == 0 and ((1 << (_la - 212)) & 41) != 0):
                    self.state = 434
                    _la = self._input.LA(1)
                    if not(_la==119 or ((((_la - 212)) & ~0x3f) == 0 and ((1 << (_la - 212)) & 41) != 0)):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                self.state = 438 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 437
                        self.identifierOrKeyword()

                    else:
                        raise NoViableAltException(self)
                    self.state = 440 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,18,self._ctx)

                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 443 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 442
                        self.identifierOrKeyword()

                    else:
                        raise NoViableAltException(self)
                    self.state = 445 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,19,self._ctx)

                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 447
                self.match(RegelSpraakParser.NIEUWE)
                self.state = 449 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 448
                        self.identifierOrKeyword()

                    else:
                        raise NoViableAltException(self)
                    self.state = 451 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,20,self._ctx)

                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 453
                self.match(RegelSpraakParser.NIEUWE)
                self.state = 455 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 454
                    self.identifierOrKeyword()
                    self.state = 457 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (((((_la - 96)) & ~0x3f) == 0 and ((1 << (_la - 96)) & 68988059649) != 0) or ((((_la - 161)) & ~0x3f) == 0 and ((1 << (_la - 161)) & -3457864013260521471) != 0) or ((((_la - 232)) & ~0x3f) == 0 and ((1 << (_la - 232)) & 34361835525) != 0)):
                        break

                self.state = 459
                self.match(RegelSpraakParser.MET)
                self.state = 461 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 460
                        self.identifierOrKeyword()

                    else:
                        raise NoViableAltException(self)
                    self.state = 463 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,22,self._ctx)

                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 466 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 465
                    self.identifierOrKeyword()
                    self.state = 468 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (((((_la - 96)) & ~0x3f) == 0 and ((1 << (_la - 96)) & 68988059649) != 0) or ((((_la - 161)) & ~0x3f) == 0 and ((1 << (_la - 161)) & -3457864013260521471) != 0) or ((((_la - 232)) & ~0x3f) == 0 and ((1 << (_la - 232)) & 34361835525) != 0)):
                        break

                self.state = 470
                self.match(RegelSpraakParser.MET)
                self.state = 472 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 471
                        self.identifierOrKeyword()

                    else:
                        raise NoViableAltException(self)
                    self.state = 474 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,24,self._ctx)

                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 476
                self.match(RegelSpraakParser.NIET)
                self.state = 478 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 477
                        self.identifierOrKeyword()

                    else:
                        raise NoViableAltException(self)
                    self.state = 480 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,25,self._ctx)

                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 482
                self.match(RegelSpraakParser.HET)
                self.state = 483
                self.match(RegelSpraakParser.AANTAL)
                self.state = 484
                self.match(RegelSpraakParser.DAGEN)
                self.state = 485
                self.match(RegelSpraakParser.IN)
                self.state = 487 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 486
                        self.identifierOrKeyword()

                    else:
                        raise NoViableAltException(self)
                    self.state = 489 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,26,self._ctx)

                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NaamPhraseWithNumbersContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifierOrKeywordWithNumbers(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.IdentifierOrKeywordWithNumbersContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.IdentifierOrKeywordWithNumbersContext,i)


        def DE(self):
            return self.getToken(RegelSpraakParser.DE, 0)

        def HET(self):
            return self.getToken(RegelSpraakParser.HET, 0)

        def EEN(self):
            return self.getToken(RegelSpraakParser.EEN, 0)

        def ZIJN(self):
            return self.getToken(RegelSpraakParser.ZIJN, 0)

        def NIEUWE(self):
            return self.getToken(RegelSpraakParser.NIEUWE, 0)

        def MET(self):
            return self.getToken(RegelSpraakParser.MET, 0)

        def NIET(self):
            return self.getToken(RegelSpraakParser.NIET, 0)

        def AANTAL(self):
            return self.getToken(RegelSpraakParser.AANTAL, 0)

        def DAGEN(self):
            return self.getToken(RegelSpraakParser.DAGEN, 0)

        def IN(self):
            return self.getToken(RegelSpraakParser.IN, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_naamPhraseWithNumbers

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNaamPhraseWithNumbers" ):
                listener.enterNaamPhraseWithNumbers(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNaamPhraseWithNumbers" ):
                listener.exitNaamPhraseWithNumbers(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNaamPhraseWithNumbers" ):
                return visitor.visitNaamPhraseWithNumbers(self)
            else:
                return visitor.visitChildren(self)




    def naamPhraseWithNumbers(self):

        localctx = RegelSpraakParser.NaamPhraseWithNumbersContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_naamPhraseWithNumbers)
        self._la = 0 # Token type
        try:
            self.state = 550
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,38,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 494
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==119 or ((((_la - 212)) & ~0x3f) == 0 and ((1 << (_la - 212)) & 41) != 0):
                    self.state = 493
                    _la = self._input.LA(1)
                    if not(_la==119 or ((((_la - 212)) & ~0x3f) == 0 and ((1 << (_la - 212)) & 41) != 0)):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                self.state = 497 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 496
                        self.identifierOrKeywordWithNumbers()

                    else:
                        raise NoViableAltException(self)
                    self.state = 499 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,29,self._ctx)

                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 502 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 501
                        self.identifierOrKeywordWithNumbers()

                    else:
                        raise NoViableAltException(self)
                    self.state = 504 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,30,self._ctx)

                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 506
                self.match(RegelSpraakParser.NIEUWE)
                self.state = 508 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 507
                        self.identifierOrKeywordWithNumbers()

                    else:
                        raise NoViableAltException(self)
                    self.state = 510 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,31,self._ctx)

                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 512
                self.match(RegelSpraakParser.NIEUWE)
                self.state = 514 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 513
                    self.identifierOrKeywordWithNumbers()
                    self.state = 516 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (((((_la - 96)) & ~0x3f) == 0 and ((1 << (_la - 96)) & 68988059649) != 0) or ((((_la - 161)) & ~0x3f) == 0 and ((1 << (_la - 161)) & -3457864013260521471) != 0) or ((((_la - 232)) & ~0x3f) == 0 and ((1 << (_la - 232)) & 103081312261) != 0)):
                        break

                self.state = 518
                self.match(RegelSpraakParser.MET)
                self.state = 520 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 519
                        self.identifierOrKeywordWithNumbers()

                    else:
                        raise NoViableAltException(self)
                    self.state = 522 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,33,self._ctx)

                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 525 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 524
                    self.identifierOrKeywordWithNumbers()
                    self.state = 527 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (((((_la - 96)) & ~0x3f) == 0 and ((1 << (_la - 96)) & 68988059649) != 0) or ((((_la - 161)) & ~0x3f) == 0 and ((1 << (_la - 161)) & -3457864013260521471) != 0) or ((((_la - 232)) & ~0x3f) == 0 and ((1 << (_la - 232)) & 103081312261) != 0)):
                        break

                self.state = 529
                self.match(RegelSpraakParser.MET)
                self.state = 531 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 530
                        self.identifierOrKeywordWithNumbers()

                    else:
                        raise NoViableAltException(self)
                    self.state = 533 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,35,self._ctx)

                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 535
                self.match(RegelSpraakParser.NIET)
                self.state = 537 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 536
                        self.identifierOrKeywordWithNumbers()

                    else:
                        raise NoViableAltException(self)
                    self.state = 539 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,36,self._ctx)

                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 541
                self.match(RegelSpraakParser.HET)
                self.state = 542
                self.match(RegelSpraakParser.AANTAL)
                self.state = 543
                self.match(RegelSpraakParser.DAGEN)
                self.state = 544
                self.match(RegelSpraakParser.IN)
                self.state = 546 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 545
                        self.identifierOrKeywordWithNumbers()

                    else:
                        raise NoViableAltException(self)
                    self.state = 548 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,37,self._ctx)

                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IdentifierOrKeywordWithNumbersContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifierOrKeyword(self):
            return self.getTypedRuleContext(RegelSpraakParser.IdentifierOrKeywordContext,0)


        def NUMBER(self):
            return self.getToken(RegelSpraakParser.NUMBER, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_identifierOrKeywordWithNumbers

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIdentifierOrKeywordWithNumbers" ):
                listener.enterIdentifierOrKeywordWithNumbers(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIdentifierOrKeywordWithNumbers" ):
                listener.exitIdentifierOrKeywordWithNumbers(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIdentifierOrKeywordWithNumbers" ):
                return visitor.visitIdentifierOrKeywordWithNumbers(self)
            else:
                return visitor.visitChildren(self)




    def identifierOrKeywordWithNumbers(self):

        localctx = RegelSpraakParser.IdentifierOrKeywordWithNumbersContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_identifierOrKeywordWithNumbers)
        try:
            self.state = 554
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [96, 110, 113, 124, 132, 161, 190, 201, 202, 205, 206, 209, 210, 221, 223, 224, 232, 234, 253, 267]:
                self.enterOuterAlt(localctx, 1)
                self.state = 552
                self.identifierOrKeyword()
                pass
            elif token in [268]:
                self.enterOuterAlt(localctx, 2)
                self.state = 553
                self.match(RegelSpraakParser.NUMBER)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NaamPhraseNoIsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifierOrKeywordNoIs(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.IdentifierOrKeywordNoIsContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.IdentifierOrKeywordNoIsContext,i)


        def DE(self):
            return self.getToken(RegelSpraakParser.DE, 0)

        def HET(self):
            return self.getToken(RegelSpraakParser.HET, 0)

        def EEN(self):
            return self.getToken(RegelSpraakParser.EEN, 0)

        def ZIJN(self):
            return self.getToken(RegelSpraakParser.ZIJN, 0)

        def NIEUWE(self):
            return self.getToken(RegelSpraakParser.NIEUWE, 0)

        def MET(self):
            return self.getToken(RegelSpraakParser.MET, 0)

        def NIET(self):
            return self.getToken(RegelSpraakParser.NIET, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_naamPhraseNoIs

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNaamPhraseNoIs" ):
                listener.enterNaamPhraseNoIs(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNaamPhraseNoIs" ):
                listener.exitNaamPhraseNoIs(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNaamPhraseNoIs" ):
                return visitor.visitNaamPhraseNoIs(self)
            else:
                return visitor.visitChildren(self)




    def naamPhraseNoIs(self):

        localctx = RegelSpraakParser.NaamPhraseNoIsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_naamPhraseNoIs)
        self._la = 0 # Token type
        try:
            self.state = 604
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,49,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 557
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==119 or ((((_la - 212)) & ~0x3f) == 0 and ((1 << (_la - 212)) & 41) != 0):
                    self.state = 556
                    _la = self._input.LA(1)
                    if not(_la==119 or ((((_la - 212)) & ~0x3f) == 0 and ((1 << (_la - 212)) & 41) != 0)):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                self.state = 560 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 559
                        self.identifierOrKeywordNoIs()

                    else:
                        raise NoViableAltException(self)
                    self.state = 562 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,41,self._ctx)

                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 565 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 564
                        self.identifierOrKeywordNoIs()

                    else:
                        raise NoViableAltException(self)
                    self.state = 567 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,42,self._ctx)

                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 569
                self.match(RegelSpraakParser.NIEUWE)
                self.state = 571 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 570
                        self.identifierOrKeywordNoIs()

                    else:
                        raise NoViableAltException(self)
                    self.state = 573 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,43,self._ctx)

                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 575
                self.match(RegelSpraakParser.NIEUWE)
                self.state = 577 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 576
                    self.identifierOrKeywordNoIs()
                    self.state = 579 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (((((_la - 96)) & ~0x3f) == 0 and ((1 << (_la - 96)) & 68987928577) != 0) or ((((_la - 161)) & ~0x3f) == 0 and ((1 << (_la - 161)) & -3457864013260521471) != 0) or ((((_la - 232)) & ~0x3f) == 0 and ((1 << (_la - 232)) & 34361835525) != 0)):
                        break

                self.state = 581
                self.match(RegelSpraakParser.MET)
                self.state = 583 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 582
                        self.identifierOrKeywordNoIs()

                    else:
                        raise NoViableAltException(self)
                    self.state = 585 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,45,self._ctx)

                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 588 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 587
                    self.identifierOrKeywordNoIs()
                    self.state = 590 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (((((_la - 96)) & ~0x3f) == 0 and ((1 << (_la - 96)) & 68987928577) != 0) or ((((_la - 161)) & ~0x3f) == 0 and ((1 << (_la - 161)) & -3457864013260521471) != 0) or ((((_la - 232)) & ~0x3f) == 0 and ((1 << (_la - 232)) & 34361835525) != 0)):
                        break

                self.state = 592
                self.match(RegelSpraakParser.MET)
                self.state = 594 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 593
                        self.identifierOrKeywordNoIs()

                    else:
                        raise NoViableAltException(self)
                    self.state = 596 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,47,self._ctx)

                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 598
                self.match(RegelSpraakParser.NIET)
                self.state = 600 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 599
                        self.identifierOrKeywordNoIs()

                    else:
                        raise NoViableAltException(self)
                    self.state = 602 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,48,self._ctx)

                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NaamwoordContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def naamPhrase(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.NaamPhraseContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.NaamPhraseContext,i)


        def voorzetsel(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.VoorzetselContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.VoorzetselContext,i)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_naamwoord

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNaamwoord" ):
                listener.enterNaamwoord(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNaamwoord" ):
                listener.exitNaamwoord(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNaamwoord" ):
                return visitor.visitNaamwoord(self)
            else:
                return visitor.visitChildren(self)




    def naamwoord(self):

        localctx = RegelSpraakParser.NaamwoordContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_naamwoord)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 606
            self.naamPhrase()
            self.state = 612
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,50,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 607
                    self.voorzetsel()
                    self.state = 608
                    self.naamPhrase() 
                self.state = 614
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,50,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NaamwoordWithNumbersContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def naamPhraseWithNumbers(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.NaamPhraseWithNumbersContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.NaamPhraseWithNumbersContext,i)


        def voorzetsel(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.VoorzetselContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.VoorzetselContext,i)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_naamwoordWithNumbers

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNaamwoordWithNumbers" ):
                listener.enterNaamwoordWithNumbers(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNaamwoordWithNumbers" ):
                listener.exitNaamwoordWithNumbers(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNaamwoordWithNumbers" ):
                return visitor.visitNaamwoordWithNumbers(self)
            else:
                return visitor.visitChildren(self)




    def naamwoordWithNumbers(self):

        localctx = RegelSpraakParser.NaamwoordWithNumbersContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_naamwoordWithNumbers)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 615
            self.naamPhraseWithNumbers()
            self.state = 621
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,51,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 616
                    self.voorzetsel()
                    self.state = 617
                    self.naamPhraseWithNumbers() 
                self.state = 623
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,51,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NaamwoordNoIsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def naamPhraseNoIs(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.NaamPhraseNoIsContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.NaamPhraseNoIsContext,i)


        def voorzetsel(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.VoorzetselContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.VoorzetselContext,i)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_naamwoordNoIs

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNaamwoordNoIs" ):
                listener.enterNaamwoordNoIs(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNaamwoordNoIs" ):
                listener.exitNaamwoordNoIs(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNaamwoordNoIs" ):
                return visitor.visitNaamwoordNoIs(self)
            else:
                return visitor.visitChildren(self)




    def naamwoordNoIs(self):

        localctx = RegelSpraakParser.NaamwoordNoIsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_naamwoordNoIs)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 624
            self.naamPhraseNoIs()
            self.state = 630
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,52,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 625
                    self.voorzetsel()
                    self.state = 626
                    self.naamPhraseNoIs() 
                self.state = 632
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,52,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VoorzetselContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def VAN(self):
            return self.getToken(RegelSpraakParser.VAN, 0)

        def IN(self):
            return self.getToken(RegelSpraakParser.IN, 0)

        def VOOR(self):
            return self.getToken(RegelSpraakParser.VOOR, 0)

        def OVER(self):
            return self.getToken(RegelSpraakParser.OVER, 0)

        def OP(self):
            return self.getToken(RegelSpraakParser.OP, 0)

        def BIJ(self):
            return self.getToken(RegelSpraakParser.BIJ, 0)

        def UIT(self):
            return self.getToken(RegelSpraakParser.UIT, 0)

        def TOT(self):
            return self.getToken(RegelSpraakParser.TOT, 0)

        def EN(self):
            return self.getToken(RegelSpraakParser.EN, 0)

        def MET(self):
            return self.getToken(RegelSpraakParser.MET, 0)

        def OF(self):
            return self.getToken(RegelSpraakParser.OF, 0)

        def TOT_EN_MET(self):
            return self.getToken(RegelSpraakParser.TOT_EN_MET, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_voorzetsel

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVoorzetsel" ):
                listener.enterVoorzetsel(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVoorzetsel" ):
                listener.exitVoorzetsel(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVoorzetsel" ):
                return visitor.visitVoorzetsel(self)
            else:
                return visitor.visitChildren(self)




    def voorzetsel(self):

        localctx = RegelSpraakParser.VoorzetselContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_voorzetsel)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 633
            _la = self._input.LA(1)
            if not(((((_la - 146)) & ~0x3f) == 0 and ((1 << (_la - 146)) & 4611686019501129733) != 0) or ((((_la - 216)) & ~0x3f) == 0 and ((1 << (_la - 216)) & 4597129233) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DatumLiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DATE_TIME_LITERAL(self):
            return self.getToken(RegelSpraakParser.DATE_TIME_LITERAL, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_datumLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDatumLiteral" ):
                listener.enterDatumLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDatumLiteral" ):
                listener.exitDatumLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDatumLiteral" ):
                return visitor.visitDatumLiteral(self)
            else:
                return visitor.visitChildren(self)




    def datumLiteral(self):

        localctx = RegelSpraakParser.DatumLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_datumLiteral)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 635
            self.match(RegelSpraakParser.DATE_TIME_LITERAL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UnitContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(RegelSpraakParser.IDENTIFIER, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_unit

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnit" ):
                listener.enterUnit(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnit" ):
                listener.exitUnit(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnit" ):
                return visitor.visitUnit(self)
            else:
                return visitor.visitChildren(self)




    def unit(self):

        localctx = RegelSpraakParser.UnitContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_unit)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 637
            self.match(RegelSpraakParser.IDENTIFIER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TimeUnitContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DAG(self):
            return self.getToken(RegelSpraakParser.DAG, 0)

        def DAGEN(self):
            return self.getToken(RegelSpraakParser.DAGEN, 0)

        def MAAND(self):
            return self.getToken(RegelSpraakParser.MAAND, 0)

        def MAANDEN(self):
            return self.getToken(RegelSpraakParser.MAANDEN, 0)

        def JAAR(self):
            return self.getToken(RegelSpraakParser.JAAR, 0)

        def JAREN(self):
            return self.getToken(RegelSpraakParser.JAREN, 0)

        def WEEK(self):
            return self.getToken(RegelSpraakParser.WEEK, 0)

        def WEKEN(self):
            return self.getToken(RegelSpraakParser.WEKEN, 0)

        def UUR(self):
            return self.getToken(RegelSpraakParser.UUR, 0)

        def UREN(self):
            return self.getToken(RegelSpraakParser.UREN, 0)

        def MINUUT(self):
            return self.getToken(RegelSpraakParser.MINUUT, 0)

        def MINUTEN(self):
            return self.getToken(RegelSpraakParser.MINUTEN, 0)

        def SECONDE(self):
            return self.getToken(RegelSpraakParser.SECONDE, 0)

        def SECONDEN(self):
            return self.getToken(RegelSpraakParser.SECONDEN, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_timeUnit

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTimeUnit" ):
                listener.enterTimeUnit(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTimeUnit" ):
                listener.exitTimeUnit(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTimeUnit" ):
                return visitor.visitTimeUnit(self)
            else:
                return visitor.visitChildren(self)




    def timeUnit(self):

        localctx = RegelSpraakParser.TimeUnitContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_timeUnit)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 639
            _la = self._input.LA(1)
            if not(((((_la - 209)) & ~0x3f) == 0 and ((1 << (_la - 209)) & 6624451080195) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ObjectTypeDefinitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self._IDENTIFIER = None # Token
            self.plural = list() # of Tokens

        def OBJECTTYPE(self):
            return self.getToken(RegelSpraakParser.OBJECTTYPE, 0)

        def naamwoordNoIs(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordNoIsContext,0)


        def MV_START(self):
            return self.getToken(RegelSpraakParser.MV_START, 0)

        def RPAREN(self):
            return self.getToken(RegelSpraakParser.RPAREN, 0)

        def BEZIELD(self):
            return self.getToken(RegelSpraakParser.BEZIELD, 0)

        def objectTypeMember(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.ObjectTypeMemberContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.ObjectTypeMemberContext,i)


        def IDENTIFIER(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.IDENTIFIER)
            else:
                return self.getToken(RegelSpraakParser.IDENTIFIER, i)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_objectTypeDefinition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterObjectTypeDefinition" ):
                listener.enterObjectTypeDefinition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitObjectTypeDefinition" ):
                listener.exitObjectTypeDefinition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitObjectTypeDefinition" ):
                return visitor.visitObjectTypeDefinition(self)
            else:
                return visitor.visitChildren(self)




    def objectTypeDefinition(self):

        localctx = RegelSpraakParser.ObjectTypeDefinitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_objectTypeDefinition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 641
            self.match(RegelSpraakParser.OBJECTTYPE)
            self.state = 642
            self.naamwoordNoIs()
            self.state = 650
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==178:
                self.state = 643
                self.match(RegelSpraakParser.MV_START)
                self.state = 645 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 644
                    localctx._IDENTIFIER = self.match(RegelSpraakParser.IDENTIFIER)
                    localctx.plural.append(localctx._IDENTIFIER)
                    self.state = 647 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==267):
                        break

                self.state = 649
                self.match(RegelSpraakParser.RPAREN)


            self.state = 653
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==165:
                self.state = 652
                self.match(RegelSpraakParser.BEZIELD)


            self.state = 658
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,56,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 655
                    self.objectTypeMember() 
                self.state = 660
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,56,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ObjectTypeMemberContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SEMICOLON(self):
            return self.getToken(RegelSpraakParser.SEMICOLON, 0)

        def kenmerkSpecificatie(self):
            return self.getTypedRuleContext(RegelSpraakParser.KenmerkSpecificatieContext,0)


        def attribuutSpecificatie(self):
            return self.getTypedRuleContext(RegelSpraakParser.AttribuutSpecificatieContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_objectTypeMember

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterObjectTypeMember" ):
                listener.enterObjectTypeMember(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitObjectTypeMember" ):
                listener.exitObjectTypeMember(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitObjectTypeMember" ):
                return visitor.visitObjectTypeMember(self)
            else:
                return visitor.visitChildren(self)




    def objectTypeMember(self):

        localctx = RegelSpraakParser.ObjectTypeMemberContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_objectTypeMember)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 663
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,57,self._ctx)
            if la_ == 1:
                self.state = 661
                self.kenmerkSpecificatie()
                pass

            elif la_ == 2:
                self.state = 662
                self.attribuutSpecificatie()
                pass


            self.state = 665
            self.match(RegelSpraakParser.SEMICOLON)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class KenmerkSpecificatieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KENMERK(self):
            return self.getToken(RegelSpraakParser.KENMERK, 0)

        def identifier(self):
            return self.getTypedRuleContext(RegelSpraakParser.IdentifierContext,0)


        def naamwoordWithNumbers(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordWithNumbersContext,0)


        def tijdlijn(self):
            return self.getTypedRuleContext(RegelSpraakParser.TijdlijnContext,0)


        def BIJVOEGLIJK(self):
            return self.getToken(RegelSpraakParser.BIJVOEGLIJK, 0)

        def BEZITTELIJK(self):
            return self.getToken(RegelSpraakParser.BEZITTELIJK, 0)

        def IS(self):
            return self.getToken(RegelSpraakParser.IS, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_kenmerkSpecificatie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterKenmerkSpecificatie" ):
                listener.enterKenmerkSpecificatie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitKenmerkSpecificatie" ):
                listener.exitKenmerkSpecificatie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitKenmerkSpecificatie" ):
                return visitor.visitKenmerkSpecificatie(self)
            else:
                return visitor.visitChildren(self)




    def kenmerkSpecificatie(self):

        localctx = RegelSpraakParser.KenmerkSpecificatieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_kenmerkSpecificatie)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 672
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,59,self._ctx)
            if la_ == 1:
                self.state = 668
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==113:
                    self.state = 667
                    self.match(RegelSpraakParser.IS)


                self.state = 670
                self.identifier()
                pass

            elif la_ == 2:
                self.state = 671
                self.naamwoordWithNumbers()
                pass


            self.state = 674
            self.match(RegelSpraakParser.KENMERK)
            self.state = 676
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==163 or _la==164:
                self.state = 675
                _la = self._input.LA(1)
                if not(_la==163 or _la==164):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


            self.state = 679
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 187)) & ~0x3f) == 0 and ((1 << (_la - 187)) & 7) != 0):
                self.state = 678
                self.tijdlijn()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AttribuutSpecificatieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def naamwoordWithNumbers(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordWithNumbersContext,0)


        def datatype(self):
            return self.getTypedRuleContext(RegelSpraakParser.DatatypeContext,0)


        def domeinRef(self):
            return self.getTypedRuleContext(RegelSpraakParser.DomeinRefContext,0)


        def objectTypeRef(self):
            return self.getTypedRuleContext(RegelSpraakParser.ObjectTypeRefContext,0)


        def MET_EENHEID(self):
            return self.getToken(RegelSpraakParser.MET_EENHEID, 0)

        def unitIdentifier(self):
            return self.getTypedRuleContext(RegelSpraakParser.UnitIdentifierContext,0)


        def GEDIMENSIONEERD_MET(self):
            return self.getToken(RegelSpraakParser.GEDIMENSIONEERD_MET, 0)

        def dimensieRef(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.DimensieRefContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.DimensieRefContext,i)


        def tijdlijn(self):
            return self.getTypedRuleContext(RegelSpraakParser.TijdlijnContext,0)


        def EN(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.EN)
            else:
                return self.getToken(RegelSpraakParser.EN, i)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_attribuutSpecificatie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAttribuutSpecificatie" ):
                listener.enterAttribuutSpecificatie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAttribuutSpecificatie" ):
                listener.exitAttribuutSpecificatie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAttribuutSpecificatie" ):
                return visitor.visitAttribuutSpecificatie(self)
            else:
                return visitor.visitChildren(self)




    def attribuutSpecificatie(self):

        localctx = RegelSpraakParser.AttribuutSpecificatieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_attribuutSpecificatie)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 681
            self.naamwoordWithNumbers()
            self.state = 685
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,62,self._ctx)
            if la_ == 1:
                self.state = 682
                self.datatype()
                pass

            elif la_ == 2:
                self.state = 683
                self.domeinRef()
                pass

            elif la_ == 3:
                self.state = 684
                self.objectTypeRef()
                pass


            self.state = 689
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==177:
                self.state = 687
                self.match(RegelSpraakParser.MET_EENHEID)
                self.state = 688
                self.unitIdentifier()


            self.state = 700
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==171:
                self.state = 691
                self.match(RegelSpraakParser.GEDIMENSIONEERD_MET)
                self.state = 692
                self.dimensieRef()
                self.state = 697
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==216:
                    self.state = 693
                    self.match(RegelSpraakParser.EN)
                    self.state = 694
                    self.dimensieRef()
                    self.state = 699
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)



            self.state = 703
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 187)) & ~0x3f) == 0 and ((1 << (_la - 187)) & 7) != 0):
                self.state = 702
                self.tijdlijn()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DatatypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def numeriekDatatype(self):
            return self.getTypedRuleContext(RegelSpraakParser.NumeriekDatatypeContext,0)


        def tekstDatatype(self):
            return self.getTypedRuleContext(RegelSpraakParser.TekstDatatypeContext,0)


        def booleanDatatype(self):
            return self.getTypedRuleContext(RegelSpraakParser.BooleanDatatypeContext,0)


        def datumTijdDatatype(self):
            return self.getTypedRuleContext(RegelSpraakParser.DatumTijdDatatypeContext,0)


        def lijstDatatype(self):
            return self.getTypedRuleContext(RegelSpraakParser.LijstDatatypeContext,0)


        def percentageDatatype(self):
            return self.getTypedRuleContext(RegelSpraakParser.PercentageDatatypeContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_datatype

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDatatype" ):
                listener.enterDatatype(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDatatype" ):
                listener.exitDatatype(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDatatype" ):
                return visitor.visitDatatype(self)
            else:
                return visitor.visitChildren(self)




    def datatype(self):

        localctx = RegelSpraakParser.DatatypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_datatype)
        try:
            self.state = 711
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [181]:
                self.enterOuterAlt(localctx, 1)
                self.state = 705
                self.numeriekDatatype()
                pass
            elif token in [186]:
                self.enterOuterAlt(localctx, 2)
                self.state = 706
                self.tekstDatatype()
                pass
            elif token in [166]:
                self.enterOuterAlt(localctx, 3)
                self.state = 707
                self.booleanDatatype()
                pass
            elif token in [3, 168]:
                self.enterOuterAlt(localctx, 4)
                self.state = 708
                self.datumTijdDatatype()
                pass
            elif token in [101]:
                self.enterOuterAlt(localctx, 5)
                self.state = 709
                self.lijstDatatype()
                pass
            elif token in [182]:
                self.enterOuterAlt(localctx, 6)
                self.state = 710
                self.percentageDatatype()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LijstDatatypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LIJST(self):
            return self.getToken(RegelSpraakParser.LIJST, 0)

        def VAN(self):
            return self.getToken(RegelSpraakParser.VAN, 0)

        def datatype(self):
            return self.getTypedRuleContext(RegelSpraakParser.DatatypeContext,0)


        def domeinRef(self):
            return self.getTypedRuleContext(RegelSpraakParser.DomeinRefContext,0)


        def objectTypeRef(self):
            return self.getTypedRuleContext(RegelSpraakParser.ObjectTypeRefContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_lijstDatatype

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLijstDatatype" ):
                listener.enterLijstDatatype(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLijstDatatype" ):
                listener.exitLijstDatatype(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLijstDatatype" ):
                return visitor.visitLijstDatatype(self)
            else:
                return visitor.visitChildren(self)




    def lijstDatatype(self):

        localctx = RegelSpraakParser.LijstDatatypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_lijstDatatype)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 713
            self.match(RegelSpraakParser.LIJST)
            self.state = 714
            self.match(RegelSpraakParser.VAN)
            self.state = 718
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,68,self._ctx)
            if la_ == 1:
                self.state = 715
                self.datatype()
                pass

            elif la_ == 2:
                self.state = 716
                self.domeinRef()
                pass

            elif la_ == 3:
                self.state = 717
                self.objectTypeRef()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NumeriekDatatypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NUMERIEK(self):
            return self.getToken(RegelSpraakParser.NUMERIEK, 0)

        def LPAREN(self):
            return self.getToken(RegelSpraakParser.LPAREN, 0)

        def getalSpecificatie(self):
            return self.getTypedRuleContext(RegelSpraakParser.GetalSpecificatieContext,0)


        def RPAREN(self):
            return self.getToken(RegelSpraakParser.RPAREN, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_numeriekDatatype

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumeriekDatatype" ):
                listener.enterNumeriekDatatype(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumeriekDatatype" ):
                listener.exitNumeriekDatatype(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNumeriekDatatype" ):
                return visitor.visitNumeriekDatatype(self)
            else:
                return visitor.visitChildren(self)




    def numeriekDatatype(self):

        localctx = RegelSpraakParser.NumeriekDatatypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_numeriekDatatype)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 720
            self.match(RegelSpraakParser.NUMERIEK)
            self.state = 725
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==274:
                self.state = 721
                self.match(RegelSpraakParser.LPAREN)
                self.state = 722
                self.getalSpecificatie()
                self.state = 723
                self.match(RegelSpraakParser.RPAREN)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TekstDatatypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TEKST(self):
            return self.getToken(RegelSpraakParser.TEKST, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_tekstDatatype

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTekstDatatype" ):
                listener.enterTekstDatatype(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTekstDatatype" ):
                listener.exitTekstDatatype(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTekstDatatype" ):
                return visitor.visitTekstDatatype(self)
            else:
                return visitor.visitChildren(self)




    def tekstDatatype(self):

        localctx = RegelSpraakParser.TekstDatatypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_tekstDatatype)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 727
            self.match(RegelSpraakParser.TEKST)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PercentageDatatypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PERCENTAGE(self):
            return self.getToken(RegelSpraakParser.PERCENTAGE, 0)

        def LPAREN(self):
            return self.getToken(RegelSpraakParser.LPAREN, 0)

        def getalSpecificatie(self):
            return self.getTypedRuleContext(RegelSpraakParser.GetalSpecificatieContext,0)


        def RPAREN(self):
            return self.getToken(RegelSpraakParser.RPAREN, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_percentageDatatype

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPercentageDatatype" ):
                listener.enterPercentageDatatype(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPercentageDatatype" ):
                listener.exitPercentageDatatype(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPercentageDatatype" ):
                return visitor.visitPercentageDatatype(self)
            else:
                return visitor.visitChildren(self)




    def percentageDatatype(self):

        localctx = RegelSpraakParser.PercentageDatatypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_percentageDatatype)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 729
            self.match(RegelSpraakParser.PERCENTAGE)
            self.state = 734
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==274:
                self.state = 730
                self.match(RegelSpraakParser.LPAREN)
                self.state = 731
                self.getalSpecificatie()
                self.state = 732
                self.match(RegelSpraakParser.RPAREN)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BooleanDatatypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BOOLEAN(self):
            return self.getToken(RegelSpraakParser.BOOLEAN, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_booleanDatatype

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBooleanDatatype" ):
                listener.enterBooleanDatatype(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBooleanDatatype" ):
                listener.exitBooleanDatatype(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBooleanDatatype" ):
                return visitor.visitBooleanDatatype(self)
            else:
                return visitor.visitChildren(self)




    def booleanDatatype(self):

        localctx = RegelSpraakParser.BooleanDatatypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_booleanDatatype)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 736
            self.match(RegelSpraakParser.BOOLEAN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DatumTijdDatatypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DATUM_IN_DAGEN(self):
            return self.getToken(RegelSpraakParser.DATUM_IN_DAGEN, 0)

        def DATUM_TIJD_MILLIS(self):
            return self.getToken(RegelSpraakParser.DATUM_TIJD_MILLIS, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_datumTijdDatatype

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDatumTijdDatatype" ):
                listener.enterDatumTijdDatatype(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDatumTijdDatatype" ):
                listener.exitDatumTijdDatatype(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDatumTijdDatatype" ):
                return visitor.visitDatumTijdDatatype(self)
            else:
                return visitor.visitChildren(self)




    def datumTijdDatatype(self):

        localctx = RegelSpraakParser.DatumTijdDatatypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_datumTijdDatatype)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 738
            _la = self._input.LA(1)
            if not(_la==3 or _la==168):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GetalSpecificatieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GEHEEL_GETAL(self):
            return self.getToken(RegelSpraakParser.GEHEEL_GETAL, 0)

        def GETAL(self):
            return self.getToken(RegelSpraakParser.GETAL, 0)

        def NEGATIEF(self):
            return self.getToken(RegelSpraakParser.NEGATIEF, 0)

        def NIET_NEGATIEF(self):
            return self.getToken(RegelSpraakParser.NIET_NEGATIEF, 0)

        def POSITIEF(self):
            return self.getToken(RegelSpraakParser.POSITIEF, 0)

        def MET(self):
            return self.getToken(RegelSpraakParser.MET, 0)

        def NUMBER(self):
            return self.getToken(RegelSpraakParser.NUMBER, 0)

        def DECIMALEN(self):
            return self.getToken(RegelSpraakParser.DECIMALEN, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_getalSpecificatie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGetalSpecificatie" ):
                listener.enterGetalSpecificatie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGetalSpecificatie" ):
                listener.exitGetalSpecificatie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGetalSpecificatie" ):
                return visitor.visitGetalSpecificatie(self)
            else:
                return visitor.visitChildren(self)




    def getalSpecificatie(self):

        localctx = RegelSpraakParser.GetalSpecificatieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_getalSpecificatie)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 741
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 179)) & ~0x3f) == 0 and ((1 << (_la - 179)) & 19) != 0):
                self.state = 740
                _la = self._input.LA(1)
                if not(((((_la - 179)) & ~0x3f) == 0 and ((1 << (_la - 179)) & 19) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


            self.state = 749
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,72,self._ctx)
            if la_ == 1:
                self.state = 743
                self.match(RegelSpraakParser.GEHEEL_GETAL)
                pass

            elif la_ == 2:
                self.state = 744
                self.match(RegelSpraakParser.GETAL)
                self.state = 745
                self.match(RegelSpraakParser.MET)
                self.state = 746
                self.match(RegelSpraakParser.NUMBER)
                self.state = 747
                self.match(RegelSpraakParser.DECIMALEN)
                pass

            elif la_ == 3:
                self.state = 748
                self.match(RegelSpraakParser.GETAL)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DomeinDefinitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.name = None # Token

        def DOMEIN(self):
            return self.getToken(RegelSpraakParser.DOMEIN, 0)

        def IS_VAN_HET_TYPE(self):
            return self.getToken(RegelSpraakParser.IS_VAN_HET_TYPE, 0)

        def domeinType(self):
            return self.getTypedRuleContext(RegelSpraakParser.DomeinTypeContext,0)


        def IDENTIFIER(self):
            return self.getToken(RegelSpraakParser.IDENTIFIER, 0)

        def MET_EENHEID(self):
            return self.getToken(RegelSpraakParser.MET_EENHEID, 0)

        def eenheidExpressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.EenheidExpressieContext,0)


        def SEMICOLON(self):
            return self.getToken(RegelSpraakParser.SEMICOLON, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_domeinDefinition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDomeinDefinition" ):
                listener.enterDomeinDefinition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDomeinDefinition" ):
                listener.exitDomeinDefinition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDomeinDefinition" ):
                return visitor.visitDomeinDefinition(self)
            else:
                return visitor.visitChildren(self)




    def domeinDefinition(self):

        localctx = RegelSpraakParser.DomeinDefinitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_domeinDefinition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 751
            self.match(RegelSpraakParser.DOMEIN)
            self.state = 752
            localctx.name = self.match(RegelSpraakParser.IDENTIFIER)
            self.state = 753
            self.match(RegelSpraakParser.IS_VAN_HET_TYPE)
            self.state = 754
            self.domeinType()
            self.state = 757
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==177:
                self.state = 755
                self.match(RegelSpraakParser.MET_EENHEID)
                self.state = 756
                self.eenheidExpressie()


            self.state = 760
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==281:
                self.state = 759
                self.match(RegelSpraakParser.SEMICOLON)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DomeinTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def enumeratieSpecificatie(self):
            return self.getTypedRuleContext(RegelSpraakParser.EnumeratieSpecificatieContext,0)


        def numeriekDatatype(self):
            return self.getTypedRuleContext(RegelSpraakParser.NumeriekDatatypeContext,0)


        def tekstDatatype(self):
            return self.getTypedRuleContext(RegelSpraakParser.TekstDatatypeContext,0)


        def booleanDatatype(self):
            return self.getTypedRuleContext(RegelSpraakParser.BooleanDatatypeContext,0)


        def datumTijdDatatype(self):
            return self.getTypedRuleContext(RegelSpraakParser.DatumTijdDatatypeContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_domeinType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDomeinType" ):
                listener.enterDomeinType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDomeinType" ):
                listener.exitDomeinType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDomeinType" ):
                return visitor.visitDomeinType(self)
            else:
                return visitor.visitChildren(self)




    def domeinType(self):

        localctx = RegelSpraakParser.DomeinTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_domeinType)
        try:
            self.state = 767
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [170]:
                self.enterOuterAlt(localctx, 1)
                self.state = 762
                self.enumeratieSpecificatie()
                pass
            elif token in [181]:
                self.enterOuterAlt(localctx, 2)
                self.state = 763
                self.numeriekDatatype()
                pass
            elif token in [186]:
                self.enterOuterAlt(localctx, 3)
                self.state = 764
                self.tekstDatatype()
                pass
            elif token in [166]:
                self.enterOuterAlt(localctx, 4)
                self.state = 765
                self.booleanDatatype()
                pass
            elif token in [3, 168]:
                self.enterOuterAlt(localctx, 5)
                self.state = 766
                self.datumTijdDatatype()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EnumeratieSpecificatieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ENUMERATIE(self):
            return self.getToken(RegelSpraakParser.ENUMERATIE, 0)

        def ENUM_LITERAL(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.ENUM_LITERAL)
            else:
                return self.getToken(RegelSpraakParser.ENUM_LITERAL, i)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_enumeratieSpecificatie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEnumeratieSpecificatie" ):
                listener.enterEnumeratieSpecificatie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEnumeratieSpecificatie" ):
                listener.exitEnumeratieSpecificatie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEnumeratieSpecificatie" ):
                return visitor.visitEnumeratieSpecificatie(self)
            else:
                return visitor.visitChildren(self)




    def enumeratieSpecificatie(self):

        localctx = RegelSpraakParser.EnumeratieSpecificatieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 74, self.RULE_enumeratieSpecificatie)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 769
            self.match(RegelSpraakParser.ENUMERATIE)
            self.state = 771 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 770
                self.match(RegelSpraakParser.ENUM_LITERAL)
                self.state = 773 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==273):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DomeinRefContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.name = None # Token

        def IDENTIFIER(self):
            return self.getToken(RegelSpraakParser.IDENTIFIER, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_domeinRef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDomeinRef" ):
                listener.enterDomeinRef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDomeinRef" ):
                listener.exitDomeinRef(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDomeinRef" ):
                return visitor.visitDomeinRef(self)
            else:
                return visitor.visitChildren(self)




    def domeinRef(self):

        localctx = RegelSpraakParser.DomeinRefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 76, self.RULE_domeinRef)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 775
            localctx.name = self.match(RegelSpraakParser.IDENTIFIER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ObjectTypeRefContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(RegelSpraakParser.IDENTIFIER, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_objectTypeRef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterObjectTypeRef" ):
                listener.enterObjectTypeRef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitObjectTypeRef" ):
                listener.exitObjectTypeRef(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitObjectTypeRef" ):
                return visitor.visitObjectTypeRef(self)
            else:
                return visitor.visitChildren(self)




    def objectTypeRef(self):

        localctx = RegelSpraakParser.ObjectTypeRefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 78, self.RULE_objectTypeRef)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 777
            self.match(RegelSpraakParser.IDENTIFIER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EenheidsysteemDefinitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.name = None # IdentifierContext

        def EENHEIDSYSTEEM(self):
            return self.getToken(RegelSpraakParser.EENHEIDSYSTEEM, 0)

        def identifier(self):
            return self.getTypedRuleContext(RegelSpraakParser.IdentifierContext,0)


        def eenheidEntry(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.EenheidEntryContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.EenheidEntryContext,i)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_eenheidsysteemDefinition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEenheidsysteemDefinition" ):
                listener.enterEenheidsysteemDefinition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEenheidsysteemDefinition" ):
                listener.exitEenheidsysteemDefinition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEenheidsysteemDefinition" ):
                return visitor.visitEenheidsysteemDefinition(self)
            else:
                return visitor.visitChildren(self)




    def eenheidsysteemDefinition(self):

        localctx = RegelSpraakParser.EenheidsysteemDefinitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 80, self.RULE_eenheidsysteemDefinition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 779
            self.match(RegelSpraakParser.EENHEIDSYSTEEM)
            self.state = 780
            localctx.name = self.identifier()
            self.state = 784
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==212 or _la==217:
                self.state = 781
                self.eenheidEntry()
                self.state = 786
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EenheidEntryContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.unitName = None # UnitIdentifierContext
            self.pluralName = None # UnitIdentifierContext
            self.abbrev = None # UnitIdentifierContext
            self.symbol = None # UnitIdentifierContext
            self.value = None # Token
            self.targetUnit = None # UnitIdentifierContext

        def DE(self):
            return self.getToken(RegelSpraakParser.DE, 0)

        def HET(self):
            return self.getToken(RegelSpraakParser.HET, 0)

        def unitIdentifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.UnitIdentifierContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.UnitIdentifierContext,i)


        def MV_START(self):
            return self.getToken(RegelSpraakParser.MV_START, 0)

        def RPAREN(self):
            return self.getToken(RegelSpraakParser.RPAREN, 0)

        def EQUALS(self):
            return self.getToken(RegelSpraakParser.EQUALS, 0)

        def NUMBER(self):
            return self.getToken(RegelSpraakParser.NUMBER, 0)

        def SLASH(self):
            return self.getToken(RegelSpraakParser.SLASH, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_eenheidEntry

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEenheidEntry" ):
                listener.enterEenheidEntry(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEenheidEntry" ):
                listener.exitEenheidEntry(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEenheidEntry" ):
                return visitor.visitEenheidEntry(self)
            else:
                return visitor.visitChildren(self)




    def eenheidEntry(self):

        localctx = RegelSpraakParser.EenheidEntryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 82, self.RULE_eenheidEntry)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 787
            _la = self._input.LA(1)
            if not(_la==212 or _la==217):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 788
            localctx.unitName = self.unitIdentifier()
            self.state = 793
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==178:
                self.state = 789
                self.match(RegelSpraakParser.MV_START)
                self.state = 790
                localctx.pluralName = self.unitIdentifier()
                self.state = 791
                self.match(RegelSpraakParser.RPAREN)


            self.state = 795
            localctx.abbrev = self.unitIdentifier()
            self.state = 797
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==137 or ((((_la - 209)) & ~0x3f) == 0 and ((1 << (_la - 209)) & 576449784568606723) != 0):
                self.state = 796
                localctx.symbol = self.unitIdentifier()


            self.state = 805
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==269:
                self.state = 799
                self.match(RegelSpraakParser.EQUALS)
                self.state = 801
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==282:
                    self.state = 800
                    self.match(RegelSpraakParser.SLASH)


                self.state = 803
                localctx.value = self.match(RegelSpraakParser.NUMBER)
                self.state = 804
                localctx.targetUnit = self.unitIdentifier()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UnitIdentifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(RegelSpraakParser.IDENTIFIER, 0)

        def METER(self):
            return self.getToken(RegelSpraakParser.METER, 0)

        def KILOGRAM(self):
            return self.getToken(RegelSpraakParser.KILOGRAM, 0)

        def MILLISECONDE(self):
            return self.getToken(RegelSpraakParser.MILLISECONDE, 0)

        def SECONDE(self):
            return self.getToken(RegelSpraakParser.SECONDE, 0)

        def MINUUT(self):
            return self.getToken(RegelSpraakParser.MINUUT, 0)

        def MINUTEN(self):
            return self.getToken(RegelSpraakParser.MINUTEN, 0)

        def UUR(self):
            return self.getToken(RegelSpraakParser.UUR, 0)

        def UREN(self):
            return self.getToken(RegelSpraakParser.UREN, 0)

        def VOET(self):
            return self.getToken(RegelSpraakParser.VOET, 0)

        def POND(self):
            return self.getToken(RegelSpraakParser.POND, 0)

        def MIJL(self):
            return self.getToken(RegelSpraakParser.MIJL, 0)

        def M(self):
            return self.getToken(RegelSpraakParser.M, 0)

        def KG(self):
            return self.getToken(RegelSpraakParser.KG, 0)

        def S(self):
            return self.getToken(RegelSpraakParser.S, 0)

        def FT(self):
            return self.getToken(RegelSpraakParser.FT, 0)

        def LB(self):
            return self.getToken(RegelSpraakParser.LB, 0)

        def MIN(self):
            return self.getToken(RegelSpraakParser.MIN, 0)

        def MI(self):
            return self.getToken(RegelSpraakParser.MI, 0)

        def EURO_SYMBOL(self):
            return self.getToken(RegelSpraakParser.EURO_SYMBOL, 0)

        def DOLLAR_SYMBOL(self):
            return self.getToken(RegelSpraakParser.DOLLAR_SYMBOL, 0)

        def DEGREE_SYMBOL(self):
            return self.getToken(RegelSpraakParser.DEGREE_SYMBOL, 0)

        def DAG(self):
            return self.getToken(RegelSpraakParser.DAG, 0)

        def DAGEN(self):
            return self.getToken(RegelSpraakParser.DAGEN, 0)

        def MAAND(self):
            return self.getToken(RegelSpraakParser.MAAND, 0)

        def MAANDEN(self):
            return self.getToken(RegelSpraakParser.MAANDEN, 0)

        def JAAR(self):
            return self.getToken(RegelSpraakParser.JAAR, 0)

        def JAREN(self):
            return self.getToken(RegelSpraakParser.JAREN, 0)

        def WEEK(self):
            return self.getToken(RegelSpraakParser.WEEK, 0)

        def WEKEN(self):
            return self.getToken(RegelSpraakParser.WEKEN, 0)

        def KWARTAAL(self):
            return self.getToken(RegelSpraakParser.KWARTAAL, 0)

        def SECONDEN(self):
            return self.getToken(RegelSpraakParser.SECONDEN, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_unitIdentifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnitIdentifier" ):
                listener.enterUnitIdentifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnitIdentifier" ):
                listener.exitUnitIdentifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnitIdentifier" ):
                return visitor.visitUnitIdentifier(self)
            else:
                return visitor.visitChildren(self)




    def unitIdentifier(self):

        localctx = RegelSpraakParser.UnitIdentifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 84, self.RULE_unitIdentifier)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 807
            _la = self._input.LA(1)
            if not(_la==137 or ((((_la - 209)) & ~0x3f) == 0 and ((1 << (_la - 209)) & 576449784568606723) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EenheidExpressieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def eenheidMacht(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.EenheidMachtContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.EenheidMachtContext,i)


        def SLASH(self):
            return self.getToken(RegelSpraakParser.SLASH, 0)

        def NUMBER(self):
            return self.getToken(RegelSpraakParser.NUMBER, 0)

        def PERCENT_SIGN(self):
            return self.getToken(RegelSpraakParser.PERCENT_SIGN, 0)

        def EURO_SYMBOL(self):
            return self.getToken(RegelSpraakParser.EURO_SYMBOL, 0)

        def DOLLAR_SYMBOL(self):
            return self.getToken(RegelSpraakParser.DOLLAR_SYMBOL, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_eenheidExpressie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEenheidExpressie" ):
                listener.enterEenheidExpressie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEenheidExpressie" ):
                listener.exitEenheidExpressie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEenheidExpressie" ):
                return visitor.visitEenheidExpressie(self)
            else:
                return visitor.visitChildren(self)




    def eenheidExpressie(self):

        localctx = RegelSpraakParser.EenheidExpressieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 86, self.RULE_eenheidExpressie)
        self._la = 0 # Token type
        try:
            self.state = 818
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,83,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 809
                self.eenheidMacht()
                self.state = 812
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==282:
                    self.state = 810
                    self.match(RegelSpraakParser.SLASH)
                    self.state = 811
                    self.eenheidMacht()


                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 814
                self.match(RegelSpraakParser.NUMBER)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 815
                self.match(RegelSpraakParser.PERCENT_SIGN)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 816
                self.match(RegelSpraakParser.EURO_SYMBOL)
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 817
                self.match(RegelSpraakParser.DOLLAR_SYMBOL)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EenheidMachtContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def unitIdentifier(self):
            return self.getTypedRuleContext(RegelSpraakParser.UnitIdentifierContext,0)


        def CARET(self):
            return self.getToken(RegelSpraakParser.CARET, 0)

        def NUMBER(self):
            return self.getToken(RegelSpraakParser.NUMBER, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_eenheidMacht

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEenheidMacht" ):
                listener.enterEenheidMacht(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEenheidMacht" ):
                listener.exitEenheidMacht(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEenheidMacht" ):
                return visitor.visitEenheidMacht(self)
            else:
                return visitor.visitChildren(self)




    def eenheidMacht(self):

        localctx = RegelSpraakParser.EenheidMachtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 88, self.RULE_eenheidMacht)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 820
            self.unitIdentifier()
            self.state = 823
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==288:
                self.state = 821
                self.match(RegelSpraakParser.CARET)
                self.state = 822
                self.match(RegelSpraakParser.NUMBER)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DimensieDefinitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.dimensieNaamMeervoud = None # NaamwoordContext

        def DIMENSIE(self):
            return self.getToken(RegelSpraakParser.DIMENSIE, 0)

        def naamwoord(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.NaamwoordContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,i)


        def BESTAANDE_UIT(self):
            return self.getToken(RegelSpraakParser.BESTAANDE_UIT, 0)

        def voorzetselSpecificatie(self):
            return self.getTypedRuleContext(RegelSpraakParser.VoorzetselSpecificatieContext,0)


        def COMMA(self):
            return self.getToken(RegelSpraakParser.COMMA, 0)

        def labelWaardeSpecificatie(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.LabelWaardeSpecificatieContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.LabelWaardeSpecificatieContext,i)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_dimensieDefinition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDimensieDefinition" ):
                listener.enterDimensieDefinition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDimensieDefinition" ):
                listener.exitDimensieDefinition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDimensieDefinition" ):
                return visitor.visitDimensieDefinition(self)
            else:
                return visitor.visitChildren(self)




    def dimensieDefinition(self):

        localctx = RegelSpraakParser.DimensieDefinitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 90, self.RULE_dimensieDefinition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 825
            self.match(RegelSpraakParser.DIMENSIE)
            self.state = 826
            self.naamwoord()
            self.state = 828
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==278:
                self.state = 827
                self.match(RegelSpraakParser.COMMA)


            self.state = 830
            self.match(RegelSpraakParser.BESTAANDE_UIT)
            self.state = 831
            localctx.dimensieNaamMeervoud = self.naamwoord()
            self.state = 832
            self.voorzetselSpecificatie()
            self.state = 834 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 833
                self.labelWaardeSpecificatie()
                self.state = 836 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==268):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VoorzetselSpecificatieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.vz = None # VoorzetselContext

        def NA_HET_ATTRIBUUT_MET_VOORZETSEL(self):
            return self.getToken(RegelSpraakParser.NA_HET_ATTRIBUUT_MET_VOORZETSEL, 0)

        def RPAREN(self):
            return self.getToken(RegelSpraakParser.RPAREN, 0)

        def voorzetsel(self):
            return self.getTypedRuleContext(RegelSpraakParser.VoorzetselContext,0)


        def COLON(self):
            return self.getToken(RegelSpraakParser.COLON, 0)

        def VOOR_HET_ATTRIBUUT_ZONDER_VOORZETSEL(self):
            return self.getToken(RegelSpraakParser.VOOR_HET_ATTRIBUUT_ZONDER_VOORZETSEL, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_voorzetselSpecificatie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVoorzetselSpecificatie" ):
                listener.enterVoorzetselSpecificatie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVoorzetselSpecificatie" ):
                listener.exitVoorzetselSpecificatie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVoorzetselSpecificatie" ):
                return visitor.visitVoorzetselSpecificatie(self)
            else:
                return visitor.visitChildren(self)




    def voorzetselSpecificatie(self):

        localctx = RegelSpraakParser.VoorzetselSpecificatieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 92, self.RULE_voorzetselSpecificatie)
        self._la = 0 # Token type
        try:
            self.state = 845
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [2]:
                self.enterOuterAlt(localctx, 1)
                self.state = 838
                self.match(RegelSpraakParser.NA_HET_ATTRIBUUT_MET_VOORZETSEL)
                self.state = 839
                localctx.vz = self.voorzetsel()
                self.state = 840
                self.match(RegelSpraakParser.RPAREN)
                self.state = 842
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==280:
                    self.state = 841
                    self.match(RegelSpraakParser.COLON)


                pass
            elif token in [1]:
                self.enterOuterAlt(localctx, 2)
                self.state = 844
                self.match(RegelSpraakParser.VOOR_HET_ATTRIBUUT_ZONDER_VOORZETSEL)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LabelWaardeSpecificatieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.dimWaarde = None # NaamwoordContext

        def NUMBER(self):
            return self.getToken(RegelSpraakParser.NUMBER, 0)

        def DOT(self):
            return self.getToken(RegelSpraakParser.DOT, 0)

        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_labelWaardeSpecificatie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLabelWaardeSpecificatie" ):
                listener.enterLabelWaardeSpecificatie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLabelWaardeSpecificatie" ):
                listener.exitLabelWaardeSpecificatie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLabelWaardeSpecificatie" ):
                return visitor.visitLabelWaardeSpecificatie(self)
            else:
                return visitor.visitChildren(self)




    def labelWaardeSpecificatie(self):

        localctx = RegelSpraakParser.LabelWaardeSpecificatieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 94, self.RULE_labelWaardeSpecificatie)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 847
            self.match(RegelSpraakParser.NUMBER)
            self.state = 848
            self.match(RegelSpraakParser.DOT)
            self.state = 849
            localctx.dimWaarde = self.naamwoord()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TijdlijnContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def VOOR_ELKE_DAG(self):
            return self.getToken(RegelSpraakParser.VOOR_ELKE_DAG, 0)

        def VOOR_ELKE_MAAND(self):
            return self.getToken(RegelSpraakParser.VOOR_ELKE_MAAND, 0)

        def VOOR_ELK_JAAR(self):
            return self.getToken(RegelSpraakParser.VOOR_ELK_JAAR, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_tijdlijn

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTijdlijn" ):
                listener.enterTijdlijn(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTijdlijn" ):
                listener.exitTijdlijn(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTijdlijn" ):
                return visitor.visitTijdlijn(self)
            else:
                return visitor.visitChildren(self)




    def tijdlijn(self):

        localctx = RegelSpraakParser.TijdlijnContext(self, self._ctx, self.state)
        self.enterRule(localctx, 96, self.RULE_tijdlijn)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 851
            _la = self._input.LA(1)
            if not(((((_la - 187)) & ~0x3f) == 0 and ((1 << (_la - 187)) & 7) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DimensieRefContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.name = None # Token

        def IDENTIFIER(self):
            return self.getToken(RegelSpraakParser.IDENTIFIER, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_dimensieRef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDimensieRef" ):
                listener.enterDimensieRef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDimensieRef" ):
                listener.exitDimensieRef(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDimensieRef" ):
                return visitor.visitDimensieRef(self)
            else:
                return visitor.visitChildren(self)




    def dimensieRef(self):

        localctx = RegelSpraakParser.DimensieRefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 98, self.RULE_dimensieRef)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 853
            localctx.name = self.match(RegelSpraakParser.IDENTIFIER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParameterDefinitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PARAMETER(self):
            return self.getToken(RegelSpraakParser.PARAMETER, 0)

        def parameterNamePhrase(self):
            return self.getTypedRuleContext(RegelSpraakParser.ParameterNamePhraseContext,0)


        def COLON(self):
            return self.getToken(RegelSpraakParser.COLON, 0)

        def datatype(self):
            return self.getTypedRuleContext(RegelSpraakParser.DatatypeContext,0)


        def domeinRef(self):
            return self.getTypedRuleContext(RegelSpraakParser.DomeinRefContext,0)


        def MET_EENHEID(self):
            return self.getToken(RegelSpraakParser.MET_EENHEID, 0)

        def eenheidExpressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.EenheidExpressieContext,0)


        def IS(self):
            return self.getToken(RegelSpraakParser.IS, 0)

        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)


        def tijdlijn(self):
            return self.getTypedRuleContext(RegelSpraakParser.TijdlijnContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_parameterDefinition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParameterDefinition" ):
                listener.enterParameterDefinition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParameterDefinition" ):
                listener.exitParameterDefinition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParameterDefinition" ):
                return visitor.visitParameterDefinition(self)
            else:
                return visitor.visitChildren(self)




    def parameterDefinition(self):

        localctx = RegelSpraakParser.ParameterDefinitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 100, self.RULE_parameterDefinition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 855
            self.match(RegelSpraakParser.PARAMETER)
            self.state = 856
            self.parameterNamePhrase()
            self.state = 857
            self.match(RegelSpraakParser.COLON)
            self.state = 860
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [3, 101, 166, 168, 181, 182, 186]:
                self.state = 858
                self.datatype()
                pass
            elif token in [267]:
                self.state = 859
                self.domeinRef()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 864
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==177:
                self.state = 862
                self.match(RegelSpraakParser.MET_EENHEID)
                self.state = 863
                self.eenheidExpressie()


            self.state = 868
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==113:
                self.state = 866
                self.match(RegelSpraakParser.IS)
                self.state = 867
                self.expressie()


            self.state = 871
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 187)) & ~0x3f) == 0 and ((1 << (_la - 187)) & 7) != 0):
                self.state = 870
                self.tijdlijn()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParameterNamePhraseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def parameterNamePart(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.ParameterNamePartContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.ParameterNamePartContext,i)


        def voorzetsel(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.VoorzetselContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.VoorzetselContext,i)


        def DE(self):
            return self.getToken(RegelSpraakParser.DE, 0)

        def HET(self):
            return self.getToken(RegelSpraakParser.HET, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_parameterNamePhrase

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParameterNamePhrase" ):
                listener.enterParameterNamePhrase(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParameterNamePhrase" ):
                listener.exitParameterNamePhrase(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParameterNamePhrase" ):
                return visitor.visitParameterNamePhrase(self)
            else:
                return visitor.visitChildren(self)




    def parameterNamePhrase(self):

        localctx = RegelSpraakParser.ParameterNamePhraseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 102, self.RULE_parameterNamePhrase)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 874
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==212 or _la==217:
                self.state = 873
                _la = self._input.LA(1)
                if not(_la==212 or _la==217):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


            self.state = 876
            self.parameterNamePart()
            self.state = 882
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((((_la - 146)) & ~0x3f) == 0 and ((1 << (_la - 146)) & 4611686019501129733) != 0) or ((((_la - 216)) & ~0x3f) == 0 and ((1 << (_la - 216)) & 4597129233) != 0):
                self.state = 877
                self.voorzetsel()
                self.state = 878
                self.parameterNamePart()
                self.state = 884
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParameterNamePartContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.IDENTIFIER)
            else:
                return self.getToken(RegelSpraakParser.IDENTIFIER, i)

        def AANTAL(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.AANTAL)
            else:
                return self.getToken(RegelSpraakParser.AANTAL, i)

        def NUMBER(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.NUMBER)
            else:
                return self.getToken(RegelSpraakParser.NUMBER, i)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_parameterNamePart

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParameterNamePart" ):
                listener.enterParameterNamePart(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParameterNamePart" ):
                listener.exitParameterNamePart(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParameterNamePart" ):
                return visitor.visitParameterNamePart(self)
            else:
                return visitor.visitChildren(self)




    def parameterNamePart(self):

        localctx = RegelSpraakParser.ParameterNamePartContext(self, self._ctx, self.state)
        self.enterRule(localctx, 104, self.RULE_parameterNamePart)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 886 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 885
                    _la = self._input.LA(1)
                    if not(_la==190 or _la==267 or _la==268):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()

                else:
                    raise NoViableAltException(self)
                self.state = 888 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,95,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParameterMetLidwoordContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def parameterNamePart(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.ParameterNamePartContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.ParameterNamePartContext,i)


        def voorzetsel(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.VoorzetselContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.VoorzetselContext,i)


        def DE(self):
            return self.getToken(RegelSpraakParser.DE, 0)

        def HET(self):
            return self.getToken(RegelSpraakParser.HET, 0)

        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_parameterMetLidwoord

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParameterMetLidwoord" ):
                listener.enterParameterMetLidwoord(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParameterMetLidwoord" ):
                listener.exitParameterMetLidwoord(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParameterMetLidwoord" ):
                return visitor.visitParameterMetLidwoord(self)
            else:
                return visitor.visitChildren(self)




    def parameterMetLidwoord(self):

        localctx = RegelSpraakParser.ParameterMetLidwoordContext(self, self._ctx, self.state)
        self.enterRule(localctx, 106, self.RULE_parameterMetLidwoord)
        self._la = 0 # Token type
        try:
            self.state = 903
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,98,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 891
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==212 or _la==217:
                    self.state = 890
                    _la = self._input.LA(1)
                    if not(_la==212 or _la==217):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                self.state = 893
                self.parameterNamePart()
                self.state = 899
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,97,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 894
                        self.voorzetsel()
                        self.state = 895
                        self.parameterNamePart() 
                    self.state = 901
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,97,self._ctx)

                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 902
                self.naamwoord()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FeitTypeDefinitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.feittypenaam = None # NaamwoordContext

        def FEITTYPE(self):
            return self.getToken(RegelSpraakParser.FEITTYPE, 0)

        def rolDefinition(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.RolDefinitionContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.RolDefinitionContext,i)


        def cardinalityLine(self):
            return self.getTypedRuleContext(RegelSpraakParser.CardinalityLineContext,0)


        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def WEDERKERIG_FEITTYPE(self):
            return self.getToken(RegelSpraakParser.WEDERKERIG_FEITTYPE, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_feitTypeDefinition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFeitTypeDefinition" ):
                listener.enterFeitTypeDefinition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFeitTypeDefinition" ):
                listener.exitFeitTypeDefinition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFeitTypeDefinition" ):
                return visitor.visitFeitTypeDefinition(self)
            else:
                return visitor.visitChildren(self)




    def feitTypeDefinition(self):

        localctx = RegelSpraakParser.FeitTypeDefinitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 108, self.RULE_feitTypeDefinition)
        try:
            self.state = 920
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [105]:
                self.enterOuterAlt(localctx, 1)
                self.state = 905
                self.match(RegelSpraakParser.FEITTYPE)
                self.state = 906
                localctx.feittypenaam = self.naamwoord()
                self.state = 907
                self.rolDefinition()
                self.state = 909 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 908
                        self.rolDefinition()

                    else:
                        raise NoViableAltException(self)
                    self.state = 911 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,99,self._ctx)

                self.state = 913
                self.cardinalityLine()
                pass
            elif token in [28]:
                self.enterOuterAlt(localctx, 2)
                self.state = 915
                self.match(RegelSpraakParser.WEDERKERIG_FEITTYPE)
                self.state = 916
                localctx.feittypenaam = self.naamwoord()
                self.state = 917
                self.rolDefinition()
                self.state = 918
                self.cardinalityLine()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RolDefinitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.article = None # Token
            self.content = None # RolContentWordsContext
            self.meervoud = None # NaamwoordContext
            self.objecttype = None # RolObjectTypeContext

        def rolContentWords(self):
            return self.getTypedRuleContext(RegelSpraakParser.RolContentWordsContext,0)


        def DE(self):
            return self.getToken(RegelSpraakParser.DE, 0)

        def HET(self):
            return self.getToken(RegelSpraakParser.HET, 0)

        def MV_START(self):
            return self.getToken(RegelSpraakParser.MV_START, 0)

        def RPAREN(self):
            return self.getToken(RegelSpraakParser.RPAREN, 0)

        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def rolObjectType(self):
            return self.getTypedRuleContext(RegelSpraakParser.RolObjectTypeContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_rolDefinition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRolDefinition" ):
                listener.enterRolDefinition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRolDefinition" ):
                listener.exitRolDefinition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRolDefinition" ):
                return visitor.visitRolDefinition(self)
            else:
                return visitor.visitChildren(self)




    def rolDefinition(self):

        localctx = RegelSpraakParser.RolDefinitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 110, self.RULE_rolDefinition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 922
            localctx.article = self._input.LT(1)
            _la = self._input.LA(1)
            if not(_la==212 or _la==217):
                localctx.article = self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 923
            localctx.content = self.rolContentWords()
            self.state = 928
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,101,self._ctx)
            if la_ == 1:
                self.state = 924
                self.match(RegelSpraakParser.MV_START)
                self.state = 925
                localctx.meervoud = self.naamwoord()
                self.state = 926
                self.match(RegelSpraakParser.RPAREN)


            self.state = 931
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,102,self._ctx)
            if la_ == 1:
                self.state = 930
                localctx.objecttype = self.rolObjectType()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RolObjectTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifierOrKeyword(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.IdentifierOrKeywordContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.IdentifierOrKeywordContext,i)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_rolObjectType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRolObjectType" ):
                listener.enterRolObjectType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRolObjectType" ):
                listener.exitRolObjectType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRolObjectType" ):
                return visitor.visitRolObjectType(self)
            else:
                return visitor.visitChildren(self)




    def rolObjectType(self):

        localctx = RegelSpraakParser.RolObjectTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 112, self.RULE_rolObjectType)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 934 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 933
                    self.identifierOrKeyword()

                else:
                    raise NoViableAltException(self)
                self.state = 936 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,103,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RolContentWordsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifierOrKeyword(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.IdentifierOrKeywordContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.IdentifierOrKeywordContext,i)


        def voorzetsel(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.VoorzetselContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.VoorzetselContext,i)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_rolContentWords

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRolContentWords" ):
                listener.enterRolContentWords(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRolContentWords" ):
                listener.exitRolContentWords(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRolContentWords" ):
                return visitor.visitRolContentWords(self)
            else:
                return visitor.visitChildren(self)




    def rolContentWords(self):

        localctx = RegelSpraakParser.RolContentWordsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 114, self.RULE_rolContentWords)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 940 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 940
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [96, 110, 113, 124, 132, 161, 190, 201, 202, 205, 206, 209, 210, 221, 223, 224, 232, 234, 253, 267]:
                        self.state = 938
                        self.identifierOrKeyword()
                        pass
                    elif token in [146, 148, 176, 208, 216, 220, 229, 231, 233, 241, 244, 248]:
                        self.state = 939
                        self.voorzetsel()
                        pass
                    else:
                        raise NoViableAltException(self)


                else:
                    raise NoViableAltException(self)
                self.state = 942 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,105,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CardinalityLineContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def cardinalityWord(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.CardinalityWordContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.CardinalityWordContext,i)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_cardinalityLine

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCardinalityLine" ):
                listener.enterCardinalityLine(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCardinalityLine" ):
                listener.exitCardinalityLine(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCardinalityLine" ):
                return visitor.visitCardinalityLine(self)
            else:
                return visitor.visitChildren(self)




    def cardinalityLine(self):

        localctx = RegelSpraakParser.CardinalityLineContext(self, self._ctx, self.state)
        self.enterRule(localctx, 116, self.RULE_cardinalityLine)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 945 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 944
                    self.cardinalityWord()

                else:
                    raise NoViableAltException(self)
                self.state = 947 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,106,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CardinalityWordContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OBJECTTYPE(self):
            return self.getToken(RegelSpraakParser.OBJECTTYPE, 0)

        def PARAMETER(self):
            return self.getToken(RegelSpraakParser.PARAMETER, 0)

        def REGEL(self):
            return self.getToken(RegelSpraakParser.REGEL, 0)

        def FEITTYPE(self):
            return self.getToken(RegelSpraakParser.FEITTYPE, 0)

        def WEDERKERIG_FEITTYPE(self):
            return self.getToken(RegelSpraakParser.WEDERKERIG_FEITTYPE, 0)

        def DIMENSIE(self):
            return self.getToken(RegelSpraakParser.DIMENSIE, 0)

        def DOMEIN(self):
            return self.getToken(RegelSpraakParser.DOMEIN, 0)

        def BESLISTABEL(self):
            return self.getToken(RegelSpraakParser.BESLISTABEL, 0)

        def CONSISTENTIEREGEL(self):
            return self.getToken(RegelSpraakParser.CONSISTENTIEREGEL, 0)

        def EENHEIDSYSTEEM(self):
            return self.getToken(RegelSpraakParser.EENHEIDSYSTEEM, 0)

        def DAGSOORT(self):
            return self.getToken(RegelSpraakParser.DAGSOORT, 0)

        def SEMICOLON(self):
            return self.getToken(RegelSpraakParser.SEMICOLON, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_cardinalityWord

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCardinalityWord" ):
                listener.enterCardinalityWord(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCardinalityWord" ):
                listener.exitCardinalityWord(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCardinalityWord" ):
                return visitor.visitCardinalityWord(self)
            else:
                return visitor.visitChildren(self)




    def cardinalityWord(self):

        localctx = RegelSpraakParser.CardinalityWordContext(self, self._ctx, self.state)
        self.enterRule(localctx, 118, self.RULE_cardinalityWord)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 949
            _la = self._input.LA(1)
            if _la <= 0 or _la==28 or ((((_la - 95)) & ~0x3f) == 0 and ((1 << (_la - 95)) & 4027) != 0) or _la==281:
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RegelContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def REGEL(self):
            return self.getToken(RegelSpraakParser.REGEL, 0)

        def regelName(self):
            return self.getTypedRuleContext(RegelSpraakParser.RegelNameContext,0)


        def regelVersie(self):
            return self.getTypedRuleContext(RegelSpraakParser.RegelVersieContext,0)


        def resultaatDeel(self):
            return self.getTypedRuleContext(RegelSpraakParser.ResultaatDeelContext,0)


        def NUMBER(self):
            return self.getToken(RegelSpraakParser.NUMBER, 0)

        def voorwaardeDeel(self):
            return self.getTypedRuleContext(RegelSpraakParser.VoorwaardeDeelContext,0)


        def DOT(self):
            return self.getToken(RegelSpraakParser.DOT, 0)

        def variabeleDeel(self):
            return self.getTypedRuleContext(RegelSpraakParser.VariabeleDeelContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_regel

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRegel" ):
                listener.enterRegel(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRegel" ):
                listener.exitRegel(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRegel" ):
                return visitor.visitRegel(self)
            else:
                return visitor.visitChildren(self)




    def regel(self):

        localctx = RegelSpraakParser.RegelContext(self, self._ctx, self.state)
        self.enterRule(localctx, 120, self.RULE_regel)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 951
            self.match(RegelSpraakParser.REGEL)
            self.state = 952
            self.regelName()
            self.state = 954
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==268:
                self.state = 953
                self.match(RegelSpraakParser.NUMBER)


            self.state = 956
            self.regelVersie()
            self.state = 957
            self.resultaatDeel()
            self.state = 963
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [111]:
                self.state = 958
                self.voorwaardeDeel()
                self.state = 960
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==279:
                    self.state = 959
                    self.match(RegelSpraakParser.DOT)


                pass
            elif token in [279]:
                self.state = 962
                self.match(RegelSpraakParser.DOT)
                pass
            elif token in [-1, 28, 95, 96, 97, 98, 99, 100, 102, 103, 104, 105, 106, 107]:
                pass
            else:
                pass
            self.state = 966
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==107:
                self.state = 965
                self.variabeleDeel()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RegelGroepContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.isRecursive = None # Token

        def REGELGROEP(self):
            return self.getToken(RegelSpraakParser.REGELGROEP, 0)

        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def regel(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.RegelContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.RegelContext,i)


        def consistentieregel(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.ConsistentieregelContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.ConsistentieregelContext,i)


        def IS_RECURSIEF(self):
            return self.getToken(RegelSpraakParser.IS_RECURSIEF, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_regelGroep

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRegelGroep" ):
                listener.enterRegelGroep(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRegelGroep" ):
                listener.exitRegelGroep(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRegelGroep" ):
                return visitor.visitRegelGroep(self)
            else:
                return visitor.visitChildren(self)




    def regelGroep(self):

        localctx = RegelSpraakParser.RegelGroepContext(self, self._ctx, self.state)
        self.enterRule(localctx, 122, self.RULE_regelGroep)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 968
            self.match(RegelSpraakParser.REGELGROEP)
            self.state = 969
            self.naamwoord()
            self.state = 971
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==112:
                self.state = 970
                localctx.isRecursive = self.match(RegelSpraakParser.IS_RECURSIEF)


            self.state = 975 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 975
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [96]:
                        self.state = 973
                        self.regel()
                        pass
                    elif token in [95]:
                        self.state = 974
                        self.consistentieregel()
                        pass
                    else:
                        raise NoViableAltException(self)


                else:
                    raise NoViableAltException(self)
                self.state = 977 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,113,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RegelNameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def naamwoordWithNumbers(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordWithNumbersContext,0)


        def regelNameExtension(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.RegelNameExtensionContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.RegelNameExtensionContext,i)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_regelName

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRegelName" ):
                listener.enterRegelName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRegelName" ):
                listener.exitRegelName(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRegelName" ):
                return visitor.visitRegelName(self)
            else:
                return visitor.visitChildren(self)




    def regelName(self):

        localctx = RegelSpraakParser.RegelNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 124, self.RULE_regelName)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 979
            self.naamwoordWithNumbers()
            self.state = 983
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==113 or ((((_la - 198)) & ~0x3f) == 0 and ((1 << (_la - 198)) & 262209) != 0) or _la==278:
                self.state = 980
                self.regelNameExtension()
                self.state = 985
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RegelNameExtensionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IN_GELIJKE_DELEN(self):
            return self.getToken(RegelSpraakParser.IN_GELIJKE_DELEN, 0)

        def COMMA(self):
            return self.getToken(RegelSpraakParser.COMMA, 0)

        def naamwoordWithNumbers(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordWithNumbersContext,0)


        def MET(self):
            return self.getToken(RegelSpraakParser.MET, 0)

        def EN(self):
            return self.getToken(RegelSpraakParser.EN, 0)

        def IS(self):
            return self.getToken(RegelSpraakParser.IS, 0)

        def GEEN(self):
            return self.getToken(RegelSpraakParser.GEEN, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_regelNameExtension

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRegelNameExtension" ):
                listener.enterRegelNameExtension(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRegelNameExtension" ):
                listener.exitRegelNameExtension(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRegelNameExtension" ):
                return visitor.visitRegelNameExtension(self)
            else:
                return visitor.visitChildren(self)




    def regelNameExtension(self):

        localctx = RegelSpraakParser.RegelNameExtensionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 126, self.RULE_regelNameExtension)
        try:
            self.state = 1000
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,115,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 986
                self.match(RegelSpraakParser.IN_GELIJKE_DELEN)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 987
                self.match(RegelSpraakParser.COMMA)
                self.state = 988
                self.naamwoordWithNumbers()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 989
                self.match(RegelSpraakParser.COMMA)
                self.state = 990
                self.match(RegelSpraakParser.MET)
                self.state = 991
                self.naamwoordWithNumbers()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 992
                self.match(RegelSpraakParser.EN)
                self.state = 993
                self.naamwoordWithNumbers()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 994
                self.match(RegelSpraakParser.IS)
                self.state = 995
                self.naamwoordWithNumbers()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 996
                self.match(RegelSpraakParser.GEEN)
                self.state = 997
                self.naamwoordWithNumbers()
                self.state = 998
                self.match(RegelSpraakParser.IS)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RegelVersieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GELDIG(self):
            return self.getToken(RegelSpraakParser.GELDIG, 0)

        def versieGeldigheid(self):
            return self.getTypedRuleContext(RegelSpraakParser.VersieGeldigheidContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_regelVersie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRegelVersie" ):
                listener.enterRegelVersie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRegelVersie" ):
                listener.exitRegelVersie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRegelVersie" ):
                return visitor.visitRegelVersie(self)
            else:
                return visitor.visitChildren(self)




    def regelVersie(self):

        localctx = RegelSpraakParser.RegelVersieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 128, self.RULE_regelVersie)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1002
            self.match(RegelSpraakParser.GELDIG)
            self.state = 1003
            self.versieGeldigheid()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VersieGeldigheidContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ALTIJD(self):
            return self.getToken(RegelSpraakParser.ALTIJD, 0)

        def VANAF(self):
            return self.getToken(RegelSpraakParser.VANAF, 0)

        def datumLiteral(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.DatumLiteralContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.DatumLiteralContext,i)


        def TM(self):
            return self.getToken(RegelSpraakParser.TM, 0)

        def TOT_EN_MET(self):
            return self.getToken(RegelSpraakParser.TOT_EN_MET, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_versieGeldigheid

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVersieGeldigheid" ):
                listener.enterVersieGeldigheid(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVersieGeldigheid" ):
                listener.exitVersieGeldigheid(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVersieGeldigheid" ):
                return visitor.visitVersieGeldigheid(self)
            else:
                return visitor.visitChildren(self)




    def versieGeldigheid(self):

        localctx = RegelSpraakParser.VersieGeldigheidContext(self, self._ctx, self.state)
        self.enterRule(localctx, 130, self.RULE_versieGeldigheid)
        self._la = 0 # Token type
        try:
            self.state = 1012
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [207]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1005
                self.match(RegelSpraakParser.ALTIJD)
                pass
            elif token in [150]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1006
                self.match(RegelSpraakParser.VANAF)
                self.state = 1007
                self.datumLiteral()
                self.state = 1010
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==148 or _la==240:
                    self.state = 1008
                    _la = self._input.LA(1)
                    if not(_la==148 or _la==240):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()
                    self.state = 1009
                    self.datumLiteral()


                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ResultaatDeelContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_resultaatDeel

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class GelijkstellingResultaatContext(ResultaatDeelContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.ResultaatDeelContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def attribuutReferentie(self):
            return self.getTypedRuleContext(RegelSpraakParser.AttribuutReferentieContext,0)

        def WORDT_BEREKEND_ALS(self):
            return self.getToken(RegelSpraakParser.WORDT_BEREKEND_ALS, 0)
        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)

        def WORDT_GESTELD_OP(self):
            return self.getToken(RegelSpraakParser.WORDT_GESTELD_OP, 0)
        def WORDT_GEINITIALISEERD_OP(self):
            return self.getToken(RegelSpraakParser.WORDT_GEINITIALISEERD_OP, 0)
        def periodeDefinitie(self):
            return self.getTypedRuleContext(RegelSpraakParser.PeriodeDefinitieContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGelijkstellingResultaat" ):
                listener.enterGelijkstellingResultaat(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGelijkstellingResultaat" ):
                listener.exitGelijkstellingResultaat(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGelijkstellingResultaat" ):
                return visitor.visitGelijkstellingResultaat(self)
            else:
                return visitor.visitChildren(self)


    class RelationshipWithAttributeResultaatContext(ResultaatDeelContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.ResultaatDeelContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def onderwerpReferentie(self):
            return self.getTypedRuleContext(RegelSpraakParser.OnderwerpReferentieContext,0)

        def HEEFT(self):
            return self.getToken(RegelSpraakParser.HEEFT, 0)
        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)

        def MET(self):
            return self.getToken(RegelSpraakParser.MET, 0)
        def attribuutMetLidwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.AttribuutMetLidwoordContext,0)

        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)

        def DE(self):
            return self.getToken(RegelSpraakParser.DE, 0)
        def HET(self):
            return self.getToken(RegelSpraakParser.HET, 0)
        def GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.GELIJK_AAN, 0)
        def IS_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.IS_GELIJK_AAN, 0)
        def GELIJK_IS_AAN(self):
            return self.getToken(RegelSpraakParser.GELIJK_IS_AAN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRelationshipWithAttributeResultaat" ):
                listener.enterRelationshipWithAttributeResultaat(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRelationshipWithAttributeResultaat" ):
                listener.exitRelationshipWithAttributeResultaat(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRelationshipWithAttributeResultaat" ):
                return visitor.visitRelationshipWithAttributeResultaat(self)
            else:
                return visitor.visitChildren(self)


    class ConsistencyCheckResultaatContext(ResultaatDeelContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.ResultaatDeelContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def attribuutReferentie(self):
            return self.getTypedRuleContext(RegelSpraakParser.AttribuutReferentieContext,0)

        def MOET(self):
            return self.getToken(RegelSpraakParser.MOET, 0)
        def consistencyOperator(self):
            return self.getTypedRuleContext(RegelSpraakParser.ConsistencyOperatorContext,0)

        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConsistencyCheckResultaat" ):
                listener.enterConsistencyCheckResultaat(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConsistencyCheckResultaat" ):
                listener.exitConsistencyCheckResultaat(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConsistencyCheckResultaat" ):
                return visitor.visitConsistencyCheckResultaat(self)
            else:
                return visitor.visitChildren(self)


    class VerdelingContext(ResultaatDeelContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.ResultaatDeelContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def verdelingResultaat(self):
            return self.getTypedRuleContext(RegelSpraakParser.VerdelingResultaatContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVerdeling" ):
                listener.enterVerdeling(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVerdeling" ):
                listener.exitVerdeling(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVerdeling" ):
                return visitor.visitVerdeling(self)
            else:
                return visitor.visitChildren(self)


    class ObjectCreatieResultaatContext(ResultaatDeelContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.ResultaatDeelContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def objectCreatie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ObjectCreatieContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterObjectCreatieResultaat" ):
                listener.enterObjectCreatieResultaat(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitObjectCreatieResultaat" ):
                listener.exitObjectCreatieResultaat(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitObjectCreatieResultaat" ):
                return visitor.visitObjectCreatieResultaat(self)
            else:
                return visitor.visitChildren(self)


    class DagsoortdefinitieResultaatContext(ResultaatDeelContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.ResultaatDeelContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def EEN(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.EEN)
            else:
                return self.getToken(RegelSpraakParser.EEN, i)
        def DAG(self):
            return self.getToken(RegelSpraakParser.DAG, 0)
        def IS(self):
            return self.getToken(RegelSpraakParser.IS, 0)
        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDagsoortdefinitieResultaat" ):
                listener.enterDagsoortdefinitieResultaat(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDagsoortdefinitieResultaat" ):
                listener.exitDagsoortdefinitieResultaat(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDagsoortdefinitieResultaat" ):
                return visitor.visitDagsoortdefinitieResultaat(self)
            else:
                return visitor.visitChildren(self)


    class KenmerkFeitResultaatContext(ResultaatDeelContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.ResultaatDeelContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def onderwerpReferentie(self):
            return self.getTypedRuleContext(RegelSpraakParser.OnderwerpReferentieContext,0)

        def kenmerkNaam(self):
            return self.getTypedRuleContext(RegelSpraakParser.KenmerkNaamContext,0)

        def IS(self):
            return self.getToken(RegelSpraakParser.IS, 0)
        def HEEFT(self):
            return self.getToken(RegelSpraakParser.HEEFT, 0)
        def periodeDefinitie(self):
            return self.getTypedRuleContext(RegelSpraakParser.PeriodeDefinitieContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterKenmerkFeitResultaat" ):
                listener.enterKenmerkFeitResultaat(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitKenmerkFeitResultaat" ):
                listener.exitKenmerkFeitResultaat(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitKenmerkFeitResultaat" ):
                return visitor.visitKenmerkFeitResultaat(self)
            else:
                return visitor.visitChildren(self)


    class FeitCreatieResultaatContext(ResultaatDeelContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.ResultaatDeelContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def feitCreatiePattern(self):
            return self.getTypedRuleContext(RegelSpraakParser.FeitCreatiePatternContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFeitCreatieResultaat" ):
                listener.enterFeitCreatieResultaat(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFeitCreatieResultaat" ):
                listener.exitFeitCreatieResultaat(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFeitCreatieResultaat" ):
                return visitor.visitFeitCreatieResultaat(self)
            else:
                return visitor.visitChildren(self)



    def resultaatDeel(self):

        localctx = RegelSpraakParser.ResultaatDeelContext(self, self._ctx, self.state)
        self.enterRule(localctx, 132, self.RULE_resultaatDeel)
        self._la = 0 # Token type
        try:
            self.state = 1054
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,121,self._ctx)
            if la_ == 1:
                localctx = RegelSpraakParser.DagsoortdefinitieResultaatContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1014
                self.match(RegelSpraakParser.EEN)
                self.state = 1015
                self.match(RegelSpraakParser.DAG)
                self.state = 1016
                self.match(RegelSpraakParser.IS)
                self.state = 1017
                self.match(RegelSpraakParser.EEN)
                self.state = 1018
                self.naamwoord()
                pass

            elif la_ == 2:
                localctx = RegelSpraakParser.GelijkstellingResultaatContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1019
                self.attribuutReferentie()
                self.state = 1026
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [8]:
                    self.state = 1020
                    self.match(RegelSpraakParser.WORDT_BEREKEND_ALS)
                    self.state = 1021
                    self.expressie()
                    pass
                elif token in [9]:
                    self.state = 1022
                    self.match(RegelSpraakParser.WORDT_GESTELD_OP)
                    self.state = 1023
                    self.expressie()
                    pass
                elif token in [10]:
                    self.state = 1024
                    self.match(RegelSpraakParser.WORDT_GEINITIALISEERD_OP)
                    self.state = 1025
                    self.expressie()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 1029
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if ((((_la - 146)) & ~0x3f) == 0 and ((1 << (_la - 146)) & 21) != 0) or _la==244:
                    self.state = 1028
                    self.periodeDefinitie()


                pass

            elif la_ == 3:
                localctx = RegelSpraakParser.ConsistencyCheckResultaatContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 1031
                self.attribuutReferentie()
                self.state = 1032
                self.match(RegelSpraakParser.MOET)
                self.state = 1033
                self.consistencyOperator()
                self.state = 1034
                self.expressie()
                pass

            elif la_ == 4:
                localctx = RegelSpraakParser.FeitCreatieResultaatContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 1036
                self.feitCreatiePattern()
                pass

            elif la_ == 5:
                localctx = RegelSpraakParser.KenmerkFeitResultaatContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 1037
                self.onderwerpReferentie()
                self.state = 1038
                _la = self._input.LA(1)
                if not(_la==110 or _la==113):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1039
                self.kenmerkNaam()
                self.state = 1041
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if ((((_la - 146)) & ~0x3f) == 0 and ((1 << (_la - 146)) & 21) != 0) or _la==244:
                    self.state = 1040
                    self.periodeDefinitie()


                pass

            elif la_ == 6:
                localctx = RegelSpraakParser.RelationshipWithAttributeResultaatContext(self, localctx)
                self.enterOuterAlt(localctx, 6)
                self.state = 1043
                self.onderwerpReferentie()
                self.state = 1044
                self.match(RegelSpraakParser.HEEFT)
                self.state = 1045
                _la = self._input.LA(1)
                if not(_la==212 or _la==217):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1046
                self.naamwoord()
                self.state = 1047
                self.match(RegelSpraakParser.MET)
                self.state = 1048
                self.attribuutMetLidwoord()
                self.state = 1049
                _la = self._input.LA(1)
                if not(_la==47 or _la==48 or _la==128):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1050
                self.expressie()
                pass

            elif la_ == 7:
                localctx = RegelSpraakParser.ObjectCreatieResultaatContext(self, localctx)
                self.enterOuterAlt(localctx, 7)
                self.state = 1052
                self.objectCreatie()
                pass

            elif la_ == 8:
                localctx = RegelSpraakParser.VerdelingContext(self, localctx)
                self.enterOuterAlt(localctx, 8)
                self.state = 1053
                self.verdelingResultaat()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConsistencyOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ONGELIJK_ZIJN_AAN(self):
            return self.getToken(RegelSpraakParser.ONGELIJK_ZIJN_AAN, 0)

        def ONGELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.ONGELIJK_AAN, 0)

        def IS_ONGELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.IS_ONGELIJK_AAN, 0)

        def GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.GELIJK_AAN, 0)

        def IS_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.IS_GELIJK_AAN, 0)

        def GROTER_DAN(self):
            return self.getToken(RegelSpraakParser.GROTER_DAN, 0)

        def IS_GROTER_DAN(self):
            return self.getToken(RegelSpraakParser.IS_GROTER_DAN, 0)

        def KLEINER_DAN(self):
            return self.getToken(RegelSpraakParser.KLEINER_DAN, 0)

        def IS_KLEINER_DAN(self):
            return self.getToken(RegelSpraakParser.IS_KLEINER_DAN, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_consistencyOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConsistencyOperator" ):
                listener.enterConsistencyOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConsistencyOperator" ):
                listener.exitConsistencyOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConsistencyOperator" ):
                return visitor.visitConsistencyOperator(self)
            else:
                return visitor.visitChildren(self)




    def consistencyOperator(self):

        localctx = RegelSpraakParser.ConsistencyOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 134, self.RULE_consistencyOperator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1056
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 6473924464345088) != 0) or ((((_la - 128)) & ~0x3f) == 0 and ((1 << (_la - 128)) & 24617) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FeitCreatiePatternContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.role1 = None # FeitCreatieRolPhraseContext
            self.subject1 = None # FeitCreatieSubjectPhraseContext
            self.article2 = None # Token
            self.role2 = None # FeitCreatieRolPhraseContext
            self.article3 = None # Token
            self.subject2 = None # FeitCreatieSubjectPhraseContext

        def EEN(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.EEN)
            else:
                return self.getToken(RegelSpraakParser.EEN, i)

        def VAN(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.VAN)
            else:
                return self.getToken(RegelSpraakParser.VAN, i)

        def IS(self):
            return self.getToken(RegelSpraakParser.IS, 0)

        def feitCreatieRolPhrase(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.FeitCreatieRolPhraseContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.FeitCreatieRolPhraseContext,i)


        def feitCreatieSubjectPhrase(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.FeitCreatieSubjectPhraseContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.FeitCreatieSubjectPhraseContext,i)


        def DE(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.DE)
            else:
                return self.getToken(RegelSpraakParser.DE, i)

        def HET(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.HET)
            else:
                return self.getToken(RegelSpraakParser.HET, i)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_feitCreatiePattern

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFeitCreatiePattern" ):
                listener.enterFeitCreatiePattern(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFeitCreatiePattern" ):
                listener.exitFeitCreatiePattern(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFeitCreatiePattern" ):
                return visitor.visitFeitCreatiePattern(self)
            else:
                return visitor.visitChildren(self)




    def feitCreatiePattern(self):

        localctx = RegelSpraakParser.FeitCreatiePatternContext(self, self._ctx, self.state)
        self.enterRule(localctx, 136, self.RULE_feitCreatiePattern)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1058
            self.match(RegelSpraakParser.EEN)
            self.state = 1059
            localctx.role1 = self.feitCreatieRolPhrase()
            self.state = 1060
            self.match(RegelSpraakParser.VAN)
            self.state = 1061
            self.match(RegelSpraakParser.EEN)
            self.state = 1062
            localctx.subject1 = self.feitCreatieSubjectPhrase()
            self.state = 1063
            self.match(RegelSpraakParser.IS)
            self.state = 1064
            localctx.article2 = self._input.LT(1)
            _la = self._input.LA(1)
            if not(((((_la - 212)) & ~0x3f) == 0 and ((1 << (_la - 212)) & 41) != 0)):
                localctx.article2 = self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 1065
            localctx.role2 = self.feitCreatieRolPhrase()
            self.state = 1066
            self.match(RegelSpraakParser.VAN)
            self.state = 1067
            localctx.article3 = self._input.LT(1)
            _la = self._input.LA(1)
            if not(((((_la - 212)) & ~0x3f) == 0 and ((1 << (_la - 212)) & 41) != 0)):
                localctx.article3 = self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 1068
            localctx.subject2 = self.feitCreatieSubjectPhrase()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FeitCreatieRolPhraseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def feitCreatieWord(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.FeitCreatieWordContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.FeitCreatieWordContext,i)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_feitCreatieRolPhrase

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFeitCreatieRolPhrase" ):
                listener.enterFeitCreatieRolPhrase(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFeitCreatieRolPhrase" ):
                listener.exitFeitCreatieRolPhrase(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFeitCreatieRolPhrase" ):
                return visitor.visitFeitCreatieRolPhrase(self)
            else:
                return visitor.visitChildren(self)




    def feitCreatieRolPhrase(self):

        localctx = RegelSpraakParser.FeitCreatieRolPhraseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 138, self.RULE_feitCreatieRolPhrase)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1071 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 1070
                self.feitCreatieWord()
                self.state = 1073 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (((((_la - 96)) & ~0x3f) == 0 and ((1 << (_la - 96)) & 1125968894902273) != 0) or ((((_la - 161)) & ~0x3f) == 0 and ((1 << (_la - 161)) & -2845233726449745919) != 0) or ((((_la - 231)) & ~0x3f) == 0 and ((1 << (_la - 231)) & 68723803151) != 0)):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FeitCreatieSubjectPhraseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def feitCreatieSubjectWord(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.FeitCreatieSubjectWordContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.FeitCreatieSubjectWordContext,i)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_feitCreatieSubjectPhrase

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFeitCreatieSubjectPhrase" ):
                listener.enterFeitCreatieSubjectPhrase(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFeitCreatieSubjectPhrase" ):
                listener.exitFeitCreatieSubjectPhrase(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFeitCreatieSubjectPhrase" ):
                return visitor.visitFeitCreatieSubjectPhrase(self)
            else:
                return visitor.visitChildren(self)




    def feitCreatieSubjectPhrase(self):

        localctx = RegelSpraakParser.FeitCreatieSubjectPhraseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 140, self.RULE_feitCreatieSubjectPhrase)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1076 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 1075
                    self.feitCreatieSubjectWord()

                else:
                    raise NoViableAltException(self)
                self.state = 1078 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,123,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FeitCreatieSubjectWordContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifierOrKeyword(self):
            return self.getTypedRuleContext(RegelSpraakParser.IdentifierOrKeywordContext,0)


        def voorzetsel(self):
            return self.getTypedRuleContext(RegelSpraakParser.VoorzetselContext,0)


        def DE(self):
            return self.getToken(RegelSpraakParser.DE, 0)

        def HET(self):
            return self.getToken(RegelSpraakParser.HET, 0)

        def EEN(self):
            return self.getToken(RegelSpraakParser.EEN, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_feitCreatieSubjectWord

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFeitCreatieSubjectWord" ):
                listener.enterFeitCreatieSubjectWord(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFeitCreatieSubjectWord" ):
                listener.exitFeitCreatieSubjectWord(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFeitCreatieSubjectWord" ):
                return visitor.visitFeitCreatieSubjectWord(self)
            else:
                return visitor.visitChildren(self)




    def feitCreatieSubjectWord(self):

        localctx = RegelSpraakParser.FeitCreatieSubjectWordContext(self, self._ctx, self.state)
        self.enterRule(localctx, 142, self.RULE_feitCreatieSubjectWord)
        try:
            self.state = 1085
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [96, 110, 113, 124, 132, 161, 190, 201, 202, 205, 206, 209, 210, 221, 223, 224, 232, 234, 253, 267]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1080
                self.identifierOrKeyword()
                pass
            elif token in [146, 148, 176, 208, 216, 220, 229, 231, 233, 241, 244, 248]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1081
                self.voorzetsel()
                pass
            elif token in [212]:
                self.enterOuterAlt(localctx, 3)
                self.state = 1082
                self.match(RegelSpraakParser.DE)
                pass
            elif token in [217]:
                self.enterOuterAlt(localctx, 4)
                self.state = 1083
                self.match(RegelSpraakParser.HET)
                pass
            elif token in [215]:
                self.enterOuterAlt(localctx, 5)
                self.state = 1084
                self.match(RegelSpraakParser.EEN)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FeitCreatieWordContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifierOrKeyword(self):
            return self.getTypedRuleContext(RegelSpraakParser.IdentifierOrKeywordContext,0)


        def voorzetselNietVan(self):
            return self.getTypedRuleContext(RegelSpraakParser.VoorzetselNietVanContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_feitCreatieWord

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFeitCreatieWord" ):
                listener.enterFeitCreatieWord(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFeitCreatieWord" ):
                listener.exitFeitCreatieWord(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFeitCreatieWord" ):
                return visitor.visitFeitCreatieWord(self)
            else:
                return visitor.visitChildren(self)




    def feitCreatieWord(self):

        localctx = RegelSpraakParser.FeitCreatieWordContext(self, self._ctx, self.state)
        self.enterRule(localctx, 144, self.RULE_feitCreatieWord)
        try:
            self.state = 1089
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [96, 110, 113, 124, 132, 161, 190, 201, 202, 205, 206, 209, 210, 221, 223, 224, 232, 234, 253, 267]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1087
                self.identifierOrKeyword()
                pass
            elif token in [146, 176, 208, 216, 220, 231, 233, 241, 248]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1088
                self.voorzetselNietVan()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VoorzetselNietVanContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IN(self):
            return self.getToken(RegelSpraakParser.IN, 0)

        def VOOR(self):
            return self.getToken(RegelSpraakParser.VOOR, 0)

        def OVER(self):
            return self.getToken(RegelSpraakParser.OVER, 0)

        def OP(self):
            return self.getToken(RegelSpraakParser.OP, 0)

        def BIJ(self):
            return self.getToken(RegelSpraakParser.BIJ, 0)

        def UIT(self):
            return self.getToken(RegelSpraakParser.UIT, 0)

        def TOT(self):
            return self.getToken(RegelSpraakParser.TOT, 0)

        def EN(self):
            return self.getToken(RegelSpraakParser.EN, 0)

        def MET(self):
            return self.getToken(RegelSpraakParser.MET, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_voorzetselNietVan

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVoorzetselNietVan" ):
                listener.enterVoorzetselNietVan(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVoorzetselNietVan" ):
                listener.exitVoorzetselNietVan(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVoorzetselNietVan" ):
                return visitor.visitVoorzetselNietVan(self)
            else:
                return visitor.visitChildren(self)




    def voorzetselNietVan(self):

        localctx = RegelSpraakParser.VoorzetselNietVanContext(self, self._ctx, self.state)
        self.enterRule(localctx, 146, self.RULE_voorzetselNietVan)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1091
            _la = self._input.LA(1)
            if not(((((_la - 146)) & ~0x3f) == 0 and ((1 << (_la - 146)) & 4611686019501129729) != 0) or ((((_la - 216)) & ~0x3f) == 0 and ((1 << (_la - 216)) & 4328685585) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ObjectCreatieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.objectType = None # NaamwoordContext

        def ER_WORDT_EEN_NIEUW(self):
            return self.getToken(RegelSpraakParser.ER_WORDT_EEN_NIEUW, 0)

        def AANGEMAAKT(self):
            return self.getToken(RegelSpraakParser.AANGEMAAKT, 0)

        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def objectAttributeInit(self):
            return self.getTypedRuleContext(RegelSpraakParser.ObjectAttributeInitContext,0)


        def DOT(self):
            return self.getToken(RegelSpraakParser.DOT, 0)

        def CREEER(self):
            return self.getToken(RegelSpraakParser.CREEER, 0)

        def EEN(self):
            return self.getToken(RegelSpraakParser.EEN, 0)

        def NIEUWE(self):
            return self.getToken(RegelSpraakParser.NIEUWE, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_objectCreatie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterObjectCreatie" ):
                listener.enterObjectCreatie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitObjectCreatie" ):
                listener.exitObjectCreatie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitObjectCreatie" ):
                return visitor.visitObjectCreatie(self)
            else:
                return visitor.visitChildren(self)




    def objectCreatie(self):

        localctx = RegelSpraakParser.ObjectCreatieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 148, self.RULE_objectCreatie)
        self._la = 0 # Token type
        try:
            self.state = 1112
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [41]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1093
                self.match(RegelSpraakParser.ER_WORDT_EEN_NIEUW)
                self.state = 1094
                localctx.objectType = self.naamwoord()
                self.state = 1095
                self.match(RegelSpraakParser.AANGEMAAKT)
                self.state = 1097
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==176:
                    self.state = 1096
                    self.objectAttributeInit()


                self.state = 1100
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,127,self._ctx)
                if la_ == 1:
                    self.state = 1099
                    self.match(RegelSpraakParser.DOT)


                pass
            elif token in [44]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1102
                self.match(RegelSpraakParser.CREEER)
                self.state = 1103
                self.match(RegelSpraakParser.EEN)
                self.state = 1104
                self.match(RegelSpraakParser.NIEUWE)
                self.state = 1105
                localctx.objectType = self.naamwoord()
                self.state = 1107
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==176:
                    self.state = 1106
                    self.objectAttributeInit()


                self.state = 1110
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,129,self._ctx)
                if la_ == 1:
                    self.state = 1109
                    self.match(RegelSpraakParser.DOT)


                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ObjectAttributeInitContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.attribuut = None # SimpleNaamwoordContext
            self.waarde = None # SimpleExpressieContext

        def MET(self):
            return self.getToken(RegelSpraakParser.MET, 0)

        def GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.GELIJK_AAN, 0)

        def simpleNaamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.SimpleNaamwoordContext,0)


        def simpleExpressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.SimpleExpressieContext,0)


        def attributeInitVervolg(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.AttributeInitVervolgContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.AttributeInitVervolgContext,i)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_objectAttributeInit

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterObjectAttributeInit" ):
                listener.enterObjectAttributeInit(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitObjectAttributeInit" ):
                listener.exitObjectAttributeInit(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitObjectAttributeInit" ):
                return visitor.visitObjectAttributeInit(self)
            else:
                return visitor.visitChildren(self)




    def objectAttributeInit(self):

        localctx = RegelSpraakParser.ObjectAttributeInitContext(self, self._ctx, self.state)
        self.enterRule(localctx, 150, self.RULE_objectAttributeInit)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1114
            self.match(RegelSpraakParser.MET)
            self.state = 1115
            localctx.attribuut = self.simpleNaamwoord()
            self.state = 1116
            self.match(RegelSpraakParser.GELIJK_AAN)
            self.state = 1117
            localctx.waarde = self.simpleExpressie()
            self.state = 1121
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==216:
                self.state = 1118
                self.attributeInitVervolg()
                self.state = 1123
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AttributeInitVervolgContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.attribuut = None # SimpleNaamwoordContext
            self.waarde = None # SimpleExpressieContext

        def EN(self):
            return self.getToken(RegelSpraakParser.EN, 0)

        def GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.GELIJK_AAN, 0)

        def simpleNaamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.SimpleNaamwoordContext,0)


        def simpleExpressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.SimpleExpressieContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_attributeInitVervolg

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAttributeInitVervolg" ):
                listener.enterAttributeInitVervolg(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAttributeInitVervolg" ):
                listener.exitAttributeInitVervolg(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAttributeInitVervolg" ):
                return visitor.visitAttributeInitVervolg(self)
            else:
                return visitor.visitChildren(self)




    def attributeInitVervolg(self):

        localctx = RegelSpraakParser.AttributeInitVervolgContext(self, self._ctx, self.state)
        self.enterRule(localctx, 152, self.RULE_attributeInitVervolg)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1124
            self.match(RegelSpraakParser.EN)
            self.state = 1125
            localctx.attribuut = self.simpleNaamwoord()
            self.state = 1126
            self.match(RegelSpraakParser.GELIJK_AAN)
            self.state = 1127
            localctx.waarde = self.simpleExpressie()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SimpleNaamwoordContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def naamPhrase(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamPhraseContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_simpleNaamwoord

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSimpleNaamwoord" ):
                listener.enterSimpleNaamwoord(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSimpleNaamwoord" ):
                listener.exitSimpleNaamwoord(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSimpleNaamwoord" ):
                return visitor.visitSimpleNaamwoord(self)
            else:
                return visitor.visitChildren(self)




    def simpleNaamwoord(self):

        localctx = RegelSpraakParser.SimpleNaamwoordContext(self, self._ctx, self.state)
        self.enterRule(localctx, 154, self.RULE_simpleNaamwoord)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1129
            self.naamPhrase()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConsistentieregelContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CONSISTENTIEREGEL(self):
            return self.getToken(RegelSpraakParser.CONSISTENTIEREGEL, 0)

        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def uniekzijnResultaat(self):
            return self.getTypedRuleContext(RegelSpraakParser.UniekzijnResultaatContext,0)


        def inconsistentResultaat(self):
            return self.getTypedRuleContext(RegelSpraakParser.InconsistentResultaatContext,0)


        def voorwaardeDeel(self):
            return self.getTypedRuleContext(RegelSpraakParser.VoorwaardeDeelContext,0)


        def DOT(self):
            return self.getToken(RegelSpraakParser.DOT, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_consistentieregel

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConsistentieregel" ):
                listener.enterConsistentieregel(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConsistentieregel" ):
                listener.exitConsistentieregel(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConsistentieregel" ):
                return visitor.visitConsistentieregel(self)
            else:
                return visitor.visitChildren(self)




    def consistentieregel(self):

        localctx = RegelSpraakParser.ConsistentieregelContext(self, self._ctx, self.state)
        self.enterRule(localctx, 156, self.RULE_consistentieregel)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1131
            self.match(RegelSpraakParser.CONSISTENTIEREGEL)
            self.state = 1132
            self.naamwoord()
            self.state = 1142
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,134,self._ctx)
            if la_ == 1:
                self.state = 1133
                self.uniekzijnResultaat()
                pass

            elif la_ == 2:
                self.state = 1134
                self.inconsistentResultaat()
                self.state = 1140
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [111]:
                    self.state = 1135
                    self.voorwaardeDeel()
                    self.state = 1137
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==279:
                        self.state = 1136
                        self.match(RegelSpraakParser.DOT)


                    pass
                elif token in [279]:
                    self.state = 1139
                    self.match(RegelSpraakParser.DOT)
                    pass
                elif token in [-1, 28, 95, 96, 97, 98, 99, 100, 102, 103, 104, 105, 106]:
                    pass
                else:
                    pass
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UniekzijnResultaatContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def alleAttributenVanObjecttype(self):
            return self.getTypedRuleContext(RegelSpraakParser.AlleAttributenVanObjecttypeContext,0)


        def MOETEN_UNIEK_ZIJN(self):
            return self.getToken(RegelSpraakParser.MOETEN_UNIEK_ZIJN, 0)

        def DOT(self):
            return self.getToken(RegelSpraakParser.DOT, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_uniekzijnResultaat

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUniekzijnResultaat" ):
                listener.enterUniekzijnResultaat(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUniekzijnResultaat" ):
                listener.exitUniekzijnResultaat(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUniekzijnResultaat" ):
                return visitor.visitUniekzijnResultaat(self)
            else:
                return visitor.visitChildren(self)




    def uniekzijnResultaat(self):

        localctx = RegelSpraakParser.UniekzijnResultaatContext(self, self._ctx, self.state)
        self.enterRule(localctx, 158, self.RULE_uniekzijnResultaat)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1144
            self.alleAttributenVanObjecttype()
            self.state = 1145
            self.match(RegelSpraakParser.MOETEN_UNIEK_ZIJN)
            self.state = 1147
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==279:
                self.state = 1146
                self.match(RegelSpraakParser.DOT)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AlleAttributenVanObjecttypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DE(self):
            return self.getToken(RegelSpraakParser.DE, 0)

        def naamwoord(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.NaamwoordContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,i)


        def VAN(self):
            return self.getToken(RegelSpraakParser.VAN, 0)

        def ALLE(self):
            return self.getToken(RegelSpraakParser.ALLE, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_alleAttributenVanObjecttype

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAlleAttributenVanObjecttype" ):
                listener.enterAlleAttributenVanObjecttype(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAlleAttributenVanObjecttype" ):
                listener.exitAlleAttributenVanObjecttype(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAlleAttributenVanObjecttype" ):
                return visitor.visitAlleAttributenVanObjecttype(self)
            else:
                return visitor.visitChildren(self)




    def alleAttributenVanObjecttype(self):

        localctx = RegelSpraakParser.AlleAttributenVanObjecttypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 160, self.RULE_alleAttributenVanObjecttype)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1149
            self.match(RegelSpraakParser.DE)
            self.state = 1150
            self.naamwoord()
            self.state = 1151
            self.match(RegelSpraakParser.VAN)
            self.state = 1152
            self.match(RegelSpraakParser.ALLE)
            self.state = 1153
            self.naamwoord()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InconsistentResultaatContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def IS_INCONSISTENT(self):
            return self.getToken(RegelSpraakParser.IS_INCONSISTENT, 0)

        def DE(self):
            return self.getToken(RegelSpraakParser.DE, 0)

        def HET(self):
            return self.getToken(RegelSpraakParser.HET, 0)

        def ER(self):
            return self.getToken(RegelSpraakParser.ER, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_inconsistentResultaat

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInconsistentResultaat" ):
                listener.enterInconsistentResultaat(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInconsistentResultaat" ):
                listener.exitInconsistentResultaat(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInconsistentResultaat" ):
                return visitor.visitInconsistentResultaat(self)
            else:
                return visitor.visitChildren(self)




    def inconsistentResultaat(self):

        localctx = RegelSpraakParser.InconsistentResultaatContext(self, self._ctx, self.state)
        self.enterRule(localctx, 162, self.RULE_inconsistentResultaat)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1156
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,136,self._ctx)
            if la_ == 1:
                self.state = 1155
                _la = self._input.LA(1)
                if not(((((_la - 212)) & ~0x3f) == 0 and ((1 << (_la - 212)) & 1099511627809) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


            self.state = 1158
            self.naamwoord()
            self.state = 1159
            self.match(RegelSpraakParser.IS_INCONSISTENT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VoorwaardeDeelContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INDIEN(self):
            return self.getToken(RegelSpraakParser.INDIEN, 0)

        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)


        def toplevelSamengesteldeVoorwaarde(self):
            return self.getTypedRuleContext(RegelSpraakParser.ToplevelSamengesteldeVoorwaardeContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_voorwaardeDeel

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVoorwaardeDeel" ):
                listener.enterVoorwaardeDeel(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVoorwaardeDeel" ):
                listener.exitVoorwaardeDeel(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVoorwaardeDeel" ):
                return visitor.visitVoorwaardeDeel(self)
            else:
                return visitor.visitChildren(self)




    def voorwaardeDeel(self):

        localctx = RegelSpraakParser.VoorwaardeDeelContext(self, self._ctx, self.state)
        self.enterRule(localctx, 164, self.RULE_voorwaardeDeel)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1161
            self.match(RegelSpraakParser.INDIEN)
            self.state = 1164
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,137,self._ctx)
            if la_ == 1:
                self.state = 1162
                self.expressie()
                pass

            elif la_ == 2:
                self.state = 1163
                self.toplevelSamengesteldeVoorwaarde()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ToplevelSamengesteldeVoorwaardeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ER_AAN(self):
            return self.getToken(RegelSpraakParser.ER_AAN, 0)

        def voorwaardeKwantificatie(self):
            return self.getTypedRuleContext(RegelSpraakParser.VoorwaardeKwantificatieContext,0)


        def WORDT_VOLDAAN(self):
            return self.getToken(RegelSpraakParser.WORDT_VOLDAAN, 0)

        def COLON(self):
            return self.getToken(RegelSpraakParser.COLON, 0)

        def VOLGENDE_VOORWAARDEN(self):
            return self.getToken(RegelSpraakParser.VOLGENDE_VOORWAARDEN, 0)

        def VOLGENDE_VOORWAARDE(self):
            return self.getToken(RegelSpraakParser.VOLGENDE_VOORWAARDE, 0)

        def samengesteldeVoorwaardeOnderdeel(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.SamengesteldeVoorwaardeOnderdeelContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.SamengesteldeVoorwaardeOnderdeelContext,i)


        def AAN(self):
            return self.getToken(RegelSpraakParser.AAN, 0)

        def VOLDOET(self):
            return self.getToken(RegelSpraakParser.VOLDOET, 0)

        def onderwerpReferentie(self):
            return self.getTypedRuleContext(RegelSpraakParser.OnderwerpReferentieContext,0)


        def HIJ(self):
            return self.getToken(RegelSpraakParser.HIJ, 0)

        def HET(self):
            return self.getToken(RegelSpraakParser.HET, 0)

        def ER(self):
            return self.getToken(RegelSpraakParser.ER, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_toplevelSamengesteldeVoorwaarde

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterToplevelSamengesteldeVoorwaarde" ):
                listener.enterToplevelSamengesteldeVoorwaarde(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitToplevelSamengesteldeVoorwaarde" ):
                listener.exitToplevelSamengesteldeVoorwaarde(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitToplevelSamengesteldeVoorwaarde" ):
                return visitor.visitToplevelSamengesteldeVoorwaarde(self)
            else:
                return visitor.visitChildren(self)




    def toplevelSamengesteldeVoorwaarde(self):

        localctx = RegelSpraakParser.ToplevelSamengesteldeVoorwaardeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 166, self.RULE_toplevelSamengesteldeVoorwaarde)
        self._la = 0 # Token type
        try:
            self.state = 1208
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,143,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1166
                self.match(RegelSpraakParser.ER_AAN)
                self.state = 1167
                self.voorwaardeKwantificatie()
                self.state = 1168
                _la = self._input.LA(1)
                if not(_la==245 or _la==246):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1169
                self.match(RegelSpraakParser.WORDT_VOLDAAN)
                self.state = 1170
                self.match(RegelSpraakParser.COLON)
                self.state = 1172 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 1171
                    self.samengesteldeVoorwaardeOnderdeel()
                    self.state = 1174 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (((((_la - 284)) & ~0x3f) == 0 and ((1 << (_la - 284)) & 291) != 0)):
                        break

                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1180
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,139,self._ctx)
                if la_ == 1:
                    self.state = 1176
                    self.onderwerpReferentie()
                    pass

                elif la_ == 2:
                    self.state = 1177
                    self.match(RegelSpraakParser.HIJ)
                    pass

                elif la_ == 3:
                    self.state = 1178
                    self.match(RegelSpraakParser.HET)
                    pass

                elif la_ == 4:
                    self.state = 1179
                    self.match(RegelSpraakParser.ER)
                    pass


                self.state = 1182
                self.match(RegelSpraakParser.AAN)
                self.state = 1183
                self.voorwaardeKwantificatie()
                self.state = 1184
                _la = self._input.LA(1)
                if not(_la==245 or _la==246):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1185
                self.match(RegelSpraakParser.VOLDOET)
                self.state = 1186
                self.match(RegelSpraakParser.COLON)
                self.state = 1188 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 1187
                    self.samengesteldeVoorwaardeOnderdeel()
                    self.state = 1190 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (((((_la - 284)) & ~0x3f) == 0 and ((1 << (_la - 284)) & 291) != 0)):
                        break

                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1196
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,141,self._ctx)
                if la_ == 1:
                    self.state = 1192
                    self.onderwerpReferentie()
                    pass

                elif la_ == 2:
                    self.state = 1193
                    self.match(RegelSpraakParser.HIJ)
                    pass

                elif la_ == 3:
                    self.state = 1194
                    self.match(RegelSpraakParser.HET)
                    pass

                elif la_ == 4:
                    self.state = 1195
                    self.match(RegelSpraakParser.ER)
                    pass


                self.state = 1198
                self.match(RegelSpraakParser.VOLDOET)
                self.state = 1199
                self.match(RegelSpraakParser.AAN)
                self.state = 1200
                self.voorwaardeKwantificatie()
                self.state = 1201
                _la = self._input.LA(1)
                if not(_la==245 or _la==246):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1202
                self.match(RegelSpraakParser.COLON)
                self.state = 1204 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 1203
                    self.samengesteldeVoorwaardeOnderdeel()
                    self.state = 1206 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (((((_la - 284)) & ~0x3f) == 0 and ((1 << (_la - 284)) & 291) != 0)):
                        break

                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VoorwaardeKwantificatieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ALLE(self):
            return self.getToken(RegelSpraakParser.ALLE, 0)

        def GEEN_VAN_DE(self):
            return self.getToken(RegelSpraakParser.GEEN_VAN_DE, 0)

        def VAN(self):
            return self.getToken(RegelSpraakParser.VAN, 0)

        def DE(self):
            return self.getToken(RegelSpraakParser.DE, 0)

        def TEN_MINSTE(self):
            return self.getToken(RegelSpraakParser.TEN_MINSTE, 0)

        def TENMINSTE(self):
            return self.getToken(RegelSpraakParser.TENMINSTE, 0)

        def NUMBER(self):
            return self.getToken(RegelSpraakParser.NUMBER, 0)

        def EEN(self):
            return self.getToken(RegelSpraakParser.EEN, 0)

        def EEN_TELWOORD(self):
            return self.getToken(RegelSpraakParser.EEN_TELWOORD, 0)

        def TWEE_TELWOORD(self):
            return self.getToken(RegelSpraakParser.TWEE_TELWOORD, 0)

        def DRIE_TELWOORD(self):
            return self.getToken(RegelSpraakParser.DRIE_TELWOORD, 0)

        def VIER_TELWOORD(self):
            return self.getToken(RegelSpraakParser.VIER_TELWOORD, 0)

        def TEN_HOOGSTE(self):
            return self.getToken(RegelSpraakParser.TEN_HOOGSTE, 0)

        def PRECIES(self):
            return self.getToken(RegelSpraakParser.PRECIES, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_voorwaardeKwantificatie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVoorwaardeKwantificatie" ):
                listener.enterVoorwaardeKwantificatie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVoorwaardeKwantificatie" ):
                listener.exitVoorwaardeKwantificatie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVoorwaardeKwantificatie" ):
                return visitor.visitVoorwaardeKwantificatie(self)
            else:
                return visitor.visitChildren(self)




    def voorwaardeKwantificatie(self):

        localctx = RegelSpraakParser.VoorwaardeKwantificatieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 168, self.RULE_voorwaardeKwantificatie)
        self._la = 0 # Token type
        try:
            self.state = 1224
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [124]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1210
                self.match(RegelSpraakParser.ALLE)
                pass
            elif token in [203]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1211
                self.match(RegelSpraakParser.GEEN_VAN_DE)
                pass
            elif token in [157, 158]:
                self.enterOuterAlt(localctx, 3)
                self.state = 1212
                _la = self._input.LA(1)
                if not(_la==157 or _la==158):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1213
                _la = self._input.LA(1)
                if not(((((_la - 201)) & ~0x3f) == 0 and ((1 << (_la - 201)) & 16435) != 0) or _la==268):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1214
                self.match(RegelSpraakParser.VAN)
                self.state = 1215
                self.match(RegelSpraakParser.DE)
                pass
            elif token in [159]:
                self.enterOuterAlt(localctx, 4)
                self.state = 1216
                self.match(RegelSpraakParser.TEN_HOOGSTE)
                self.state = 1217
                _la = self._input.LA(1)
                if not(((((_la - 201)) & ~0x3f) == 0 and ((1 << (_la - 201)) & 16435) != 0) or _la==268):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1218
                self.match(RegelSpraakParser.VAN)
                self.state = 1219
                self.match(RegelSpraakParser.DE)
                pass
            elif token in [160]:
                self.enterOuterAlt(localctx, 5)
                self.state = 1220
                self.match(RegelSpraakParser.PRECIES)
                self.state = 1221
                _la = self._input.LA(1)
                if not(((((_la - 201)) & ~0x3f) == 0 and ((1 << (_la - 201)) & 16435) != 0) or _la==268):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1222
                self.match(RegelSpraakParser.VAN)
                self.state = 1223
                self.match(RegelSpraakParser.DE)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SamengesteldeVoorwaardeOnderdeelContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def bulletPrefix(self):
            return self.getTypedRuleContext(RegelSpraakParser.BulletPrefixContext,0)


        def elementaireVoorwaarde(self):
            return self.getTypedRuleContext(RegelSpraakParser.ElementaireVoorwaardeContext,0)


        def genesteSamengesteldeVoorwaarde(self):
            return self.getTypedRuleContext(RegelSpraakParser.GenesteSamengesteldeVoorwaardeContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_samengesteldeVoorwaardeOnderdeel

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSamengesteldeVoorwaardeOnderdeel" ):
                listener.enterSamengesteldeVoorwaardeOnderdeel(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSamengesteldeVoorwaardeOnderdeel" ):
                listener.exitSamengesteldeVoorwaardeOnderdeel(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSamengesteldeVoorwaardeOnderdeel" ):
                return visitor.visitSamengesteldeVoorwaardeOnderdeel(self)
            else:
                return visitor.visitChildren(self)




    def samengesteldeVoorwaardeOnderdeel(self):

        localctx = RegelSpraakParser.SamengesteldeVoorwaardeOnderdeelContext(self, self._ctx, self.state)
        self.enterRule(localctx, 170, self.RULE_samengesteldeVoorwaardeOnderdeel)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1226
            self.bulletPrefix()
            self.state = 1229
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,145,self._ctx)
            if la_ == 1:
                self.state = 1227
                self.elementaireVoorwaarde()
                pass

            elif la_ == 2:
                self.state = 1228
                self.genesteSamengesteldeVoorwaarde()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BulletPrefixContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MINUS(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.MINUS)
            else:
                return self.getToken(RegelSpraakParser.MINUS, i)

        def DOUBLE_DOT(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.DOUBLE_DOT)
            else:
                return self.getToken(RegelSpraakParser.DOUBLE_DOT, i)

        def BULLET(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.BULLET)
            else:
                return self.getToken(RegelSpraakParser.BULLET, i)

        def ASTERISK(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.ASTERISK)
            else:
                return self.getToken(RegelSpraakParser.ASTERISK, i)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_bulletPrefix

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBulletPrefix" ):
                listener.enterBulletPrefix(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBulletPrefix" ):
                listener.exitBulletPrefix(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBulletPrefix" ):
                return visitor.visitBulletPrefix(self)
            else:
                return visitor.visitChildren(self)




    def bulletPrefix(self):

        localctx = RegelSpraakParser.BulletPrefixContext(self, self._ctx, self.state)
        self.enterRule(localctx, 172, self.RULE_bulletPrefix)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1232 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 1231
                    _la = self._input.LA(1)
                    if not(((((_la - 284)) & ~0x3f) == 0 and ((1 << (_la - 284)) & 291) != 0)):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()

                else:
                    raise NoViableAltException(self)
                self.state = 1234 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,146,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ElementaireVoorwaardeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_elementaireVoorwaarde

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterElementaireVoorwaarde" ):
                listener.enterElementaireVoorwaarde(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitElementaireVoorwaarde" ):
                listener.exitElementaireVoorwaarde(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitElementaireVoorwaarde" ):
                return visitor.visitElementaireVoorwaarde(self)
            else:
                return visitor.visitChildren(self)




    def elementaireVoorwaarde(self):

        localctx = RegelSpraakParser.ElementaireVoorwaardeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 174, self.RULE_elementaireVoorwaarde)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1236
            self.expressie()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GenesteSamengesteldeVoorwaardeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def VOLDOET(self):
            return self.getToken(RegelSpraakParser.VOLDOET, 0)

        def AAN(self):
            return self.getToken(RegelSpraakParser.AAN, 0)

        def voorwaardeKwantificatie(self):
            return self.getTypedRuleContext(RegelSpraakParser.VoorwaardeKwantificatieContext,0)


        def COLON(self):
            return self.getToken(RegelSpraakParser.COLON, 0)

        def VOLGENDE_VOORWAARDEN(self):
            return self.getToken(RegelSpraakParser.VOLGENDE_VOORWAARDEN, 0)

        def VOLGENDE_VOORWAARDE(self):
            return self.getToken(RegelSpraakParser.VOLGENDE_VOORWAARDE, 0)

        def onderwerpReferentie(self):
            return self.getTypedRuleContext(RegelSpraakParser.OnderwerpReferentieContext,0)


        def HIJ(self):
            return self.getToken(RegelSpraakParser.HIJ, 0)

        def ER(self):
            return self.getToken(RegelSpraakParser.ER, 0)

        def samengesteldeVoorwaardeOnderdeel(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.SamengesteldeVoorwaardeOnderdeelContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.SamengesteldeVoorwaardeOnderdeelContext,i)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_genesteSamengesteldeVoorwaarde

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGenesteSamengesteldeVoorwaarde" ):
                listener.enterGenesteSamengesteldeVoorwaarde(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGenesteSamengesteldeVoorwaarde" ):
                listener.exitGenesteSamengesteldeVoorwaarde(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGenesteSamengesteldeVoorwaarde" ):
                return visitor.visitGenesteSamengesteldeVoorwaarde(self)
            else:
                return visitor.visitChildren(self)




    def genesteSamengesteldeVoorwaarde(self):

        localctx = RegelSpraakParser.GenesteSamengesteldeVoorwaardeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 176, self.RULE_genesteSamengesteldeVoorwaarde)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1241
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,147,self._ctx)
            if la_ == 1:
                self.state = 1238
                self.onderwerpReferentie()
                pass

            elif la_ == 2:
                self.state = 1239
                self.match(RegelSpraakParser.HIJ)
                pass

            elif la_ == 3:
                self.state = 1240
                self.match(RegelSpraakParser.ER)
                pass


            self.state = 1243
            self.match(RegelSpraakParser.VOLDOET)
            self.state = 1244
            self.match(RegelSpraakParser.AAN)
            self.state = 1245
            self.voorwaardeKwantificatie()
            self.state = 1246
            _la = self._input.LA(1)
            if not(_la==245 or _la==246):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 1247
            self.match(RegelSpraakParser.COLON)
            self.state = 1249 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 1248
                    self.samengesteldeVoorwaardeOnderdeel()

                else:
                    raise NoViableAltException(self)
                self.state = 1251 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,148,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OnderwerpReferentieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def onderwerpBasis(self):
            return self.getTypedRuleContext(RegelSpraakParser.OnderwerpBasisContext,0)


        def predicaat(self):
            return self.getTypedRuleContext(RegelSpraakParser.PredicaatContext,0)


        def DIE(self):
            return self.getToken(RegelSpraakParser.DIE, 0)

        def DAT(self):
            return self.getToken(RegelSpraakParser.DAT, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_onderwerpReferentie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOnderwerpReferentie" ):
                listener.enterOnderwerpReferentie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOnderwerpReferentie" ):
                listener.exitOnderwerpReferentie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOnderwerpReferentie" ):
                return visitor.visitOnderwerpReferentie(self)
            else:
                return visitor.visitChildren(self)




    def onderwerpReferentie(self):

        localctx = RegelSpraakParser.OnderwerpReferentieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 178, self.RULE_onderwerpReferentie)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1253
            self.onderwerpBasis()
            self.state = 1256
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,149,self._ctx)
            if la_ == 1:
                self.state = 1254
                _la = self._input.LA(1)
                if not(_la==211 or _la==214):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1255
                self.predicaat()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OnderwerpReferentieWithNumbersContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def onderwerpBasisWithNumbers(self):
            return self.getTypedRuleContext(RegelSpraakParser.OnderwerpBasisWithNumbersContext,0)


        def predicaat(self):
            return self.getTypedRuleContext(RegelSpraakParser.PredicaatContext,0)


        def DIE(self):
            return self.getToken(RegelSpraakParser.DIE, 0)

        def DAT(self):
            return self.getToken(RegelSpraakParser.DAT, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_onderwerpReferentieWithNumbers

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOnderwerpReferentieWithNumbers" ):
                listener.enterOnderwerpReferentieWithNumbers(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOnderwerpReferentieWithNumbers" ):
                listener.exitOnderwerpReferentieWithNumbers(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOnderwerpReferentieWithNumbers" ):
                return visitor.visitOnderwerpReferentieWithNumbers(self)
            else:
                return visitor.visitChildren(self)




    def onderwerpReferentieWithNumbers(self):

        localctx = RegelSpraakParser.OnderwerpReferentieWithNumbersContext(self, self._ctx, self.state)
        self.enterRule(localctx, 180, self.RULE_onderwerpReferentieWithNumbers)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1258
            self.onderwerpBasisWithNumbers()
            self.state = 1261
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==211 or _la==214:
                self.state = 1259
                _la = self._input.LA(1)
                if not(_la==211 or _la==214):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1260
                self.predicaat()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OnderwerpBasisContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def basisOnderwerp(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.BasisOnderwerpContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.BasisOnderwerpContext,i)


        def voorzetsel(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.VoorzetselContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.VoorzetselContext,i)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_onderwerpBasis

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOnderwerpBasis" ):
                listener.enterOnderwerpBasis(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOnderwerpBasis" ):
                listener.exitOnderwerpBasis(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOnderwerpBasis" ):
                return visitor.visitOnderwerpBasis(self)
            else:
                return visitor.visitChildren(self)




    def onderwerpBasis(self):

        localctx = RegelSpraakParser.OnderwerpBasisContext(self, self._ctx, self.state)
        self.enterRule(localctx, 182, self.RULE_onderwerpBasis)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1263
            self.basisOnderwerp()
            self.state = 1269
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,151,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 1264
                    self.voorzetsel()
                    self.state = 1265
                    self.basisOnderwerp() 
                self.state = 1271
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,151,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OnderwerpBasisWithNumbersContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def basisOnderwerpWithNumbers(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.BasisOnderwerpWithNumbersContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.BasisOnderwerpWithNumbersContext,i)


        def voorzetsel(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.VoorzetselContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.VoorzetselContext,i)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_onderwerpBasisWithNumbers

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOnderwerpBasisWithNumbers" ):
                listener.enterOnderwerpBasisWithNumbers(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOnderwerpBasisWithNumbers" ):
                listener.exitOnderwerpBasisWithNumbers(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOnderwerpBasisWithNumbers" ):
                return visitor.visitOnderwerpBasisWithNumbers(self)
            else:
                return visitor.visitChildren(self)




    def onderwerpBasisWithNumbers(self):

        localctx = RegelSpraakParser.OnderwerpBasisWithNumbersContext(self, self._ctx, self.state)
        self.enterRule(localctx, 184, self.RULE_onderwerpBasisWithNumbers)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1272
            self.basisOnderwerpWithNumbers()
            self.state = 1278
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((((_la - 146)) & ~0x3f) == 0 and ((1 << (_la - 146)) & 4611686019501129733) != 0) or ((((_la - 216)) & ~0x3f) == 0 and ((1 << (_la - 216)) & 4597129233) != 0):
                self.state = 1273
                self.voorzetsel()
                self.state = 1274
                self.basisOnderwerpWithNumbers()
                self.state = 1280
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BasisOnderwerpContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DE(self):
            return self.getToken(RegelSpraakParser.DE, 0)

        def HET(self):
            return self.getToken(RegelSpraakParser.HET, 0)

        def EEN(self):
            return self.getToken(RegelSpraakParser.EEN, 0)

        def ZIJN(self):
            return self.getToken(RegelSpraakParser.ZIJN, 0)

        def identifierOrKeyword(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.IdentifierOrKeywordContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.IdentifierOrKeywordContext,i)


        def HIJ(self):
            return self.getToken(RegelSpraakParser.HIJ, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_basisOnderwerp

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBasisOnderwerp" ):
                listener.enterBasisOnderwerp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBasisOnderwerp" ):
                listener.exitBasisOnderwerp(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBasisOnderwerp" ):
                return visitor.visitBasisOnderwerp(self)
            else:
                return visitor.visitChildren(self)




    def basisOnderwerp(self):

        localctx = RegelSpraakParser.BasisOnderwerpContext(self, self._ctx, self.state)
        self.enterRule(localctx, 186, self.RULE_basisOnderwerp)
        self._la = 0 # Token type
        try:
            self.state = 1288
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [119, 212, 215, 217]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1281
                _la = self._input.LA(1)
                if not(_la==119 or ((((_la - 212)) & ~0x3f) == 0 and ((1 << (_la - 212)) & 41) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1283 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 1282
                        self.identifierOrKeyword()

                    else:
                        raise NoViableAltException(self)
                    self.state = 1285 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,153,self._ctx)

                pass
            elif token in [219]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1287
                self.match(RegelSpraakParser.HIJ)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BasisOnderwerpWithNumbersContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DE(self):
            return self.getToken(RegelSpraakParser.DE, 0)

        def HET(self):
            return self.getToken(RegelSpraakParser.HET, 0)

        def EEN(self):
            return self.getToken(RegelSpraakParser.EEN, 0)

        def ZIJN(self):
            return self.getToken(RegelSpraakParser.ZIJN, 0)

        def identifierOrKeywordWithNumbers(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.IdentifierOrKeywordWithNumbersContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.IdentifierOrKeywordWithNumbersContext,i)


        def HIJ(self):
            return self.getToken(RegelSpraakParser.HIJ, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_basisOnderwerpWithNumbers

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBasisOnderwerpWithNumbers" ):
                listener.enterBasisOnderwerpWithNumbers(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBasisOnderwerpWithNumbers" ):
                listener.exitBasisOnderwerpWithNumbers(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBasisOnderwerpWithNumbers" ):
                return visitor.visitBasisOnderwerpWithNumbers(self)
            else:
                return visitor.visitChildren(self)




    def basisOnderwerpWithNumbers(self):

        localctx = RegelSpraakParser.BasisOnderwerpWithNumbersContext(self, self._ctx, self.state)
        self.enterRule(localctx, 188, self.RULE_basisOnderwerpWithNumbers)
        self._la = 0 # Token type
        try:
            self.state = 1297
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [119, 212, 215, 217]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1290
                _la = self._input.LA(1)
                if not(_la==119 or ((((_la - 212)) & ~0x3f) == 0 and ((1 << (_la - 212)) & 41) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1292 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 1291
                    self.identifierOrKeywordWithNumbers()
                    self.state = 1294 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (((((_la - 96)) & ~0x3f) == 0 and ((1 << (_la - 96)) & 68988059649) != 0) or ((((_la - 161)) & ~0x3f) == 0 and ((1 << (_la - 161)) & -3457864013260521471) != 0) or ((((_la - 232)) & ~0x3f) == 0 and ((1 << (_la - 232)) & 103081312261) != 0)):
                        break

                pass
            elif token in [219]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1296
                self.match(RegelSpraakParser.HIJ)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AttribuutReferentieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def attribuutMetLidwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.AttribuutMetLidwoordContext,0)


        def VAN(self):
            return self.getToken(RegelSpraakParser.VAN, 0)

        def onderwerpReferentie(self):
            return self.getTypedRuleContext(RegelSpraakParser.OnderwerpReferentieContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_attribuutReferentie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAttribuutReferentie" ):
                listener.enterAttribuutReferentie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAttribuutReferentie" ):
                listener.exitAttribuutReferentie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAttribuutReferentie" ):
                return visitor.visitAttribuutReferentie(self)
            else:
                return visitor.visitChildren(self)




    def attribuutReferentie(self):

        localctx = RegelSpraakParser.AttribuutReferentieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 190, self.RULE_attribuutReferentie)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1299
            self.attribuutMetLidwoord()
            self.state = 1300
            self.match(RegelSpraakParser.VAN)
            self.state = 1301
            self.onderwerpReferentie()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AttribuutMetLidwoordContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def naamwoordNoIs(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordNoIsContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_attribuutMetLidwoord

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAttribuutMetLidwoord" ):
                listener.enterAttribuutMetLidwoord(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAttribuutMetLidwoord" ):
                listener.exitAttribuutMetLidwoord(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAttribuutMetLidwoord" ):
                return visitor.visitAttribuutMetLidwoord(self)
            else:
                return visitor.visitChildren(self)




    def attribuutMetLidwoord(self):

        localctx = RegelSpraakParser.AttribuutMetLidwoordContext(self, self._ctx, self.state)
        self.enterRule(localctx, 192, self.RULE_attribuutMetLidwoord)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1303
            self.naamwoordNoIs()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class KenmerkNaamContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def naamwoordWithNumbers(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordWithNumbersContext,0)


        def voorzetsel(self):
            return self.getTypedRuleContext(RegelSpraakParser.VoorzetselContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_kenmerkNaam

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterKenmerkNaam" ):
                listener.enterKenmerkNaam(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitKenmerkNaam" ):
                listener.exitKenmerkNaam(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitKenmerkNaam" ):
                return visitor.visitKenmerkNaam(self)
            else:
                return visitor.visitChildren(self)




    def kenmerkNaam(self):

        localctx = RegelSpraakParser.KenmerkNaamContext(self, self._ctx, self.state)
        self.enterRule(localctx, 194, self.RULE_kenmerkNaam)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1306
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 146)) & ~0x3f) == 0 and ((1 << (_la - 146)) & 4611686019501129733) != 0) or ((((_la - 216)) & ~0x3f) == 0 and ((1 << (_la - 216)) & 4597129233) != 0):
                self.state = 1305
                self.voorzetsel()


            self.state = 1308
            self.naamwoordWithNumbers()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class KenmerkPhraseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def voorzetsel(self):
            return self.getTypedRuleContext(RegelSpraakParser.VoorzetselContext,0)


        def identifierOrKeywordWithNumbers(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.IdentifierOrKeywordWithNumbersContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.IdentifierOrKeywordWithNumbersContext,i)


        def DE(self):
            return self.getToken(RegelSpraakParser.DE, 0)

        def HET(self):
            return self.getToken(RegelSpraakParser.HET, 0)

        def EEN(self):
            return self.getToken(RegelSpraakParser.EEN, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_kenmerkPhrase

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterKenmerkPhrase" ):
                listener.enterKenmerkPhrase(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitKenmerkPhrase" ):
                listener.exitKenmerkPhrase(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitKenmerkPhrase" ):
                return visitor.visitKenmerkPhrase(self)
            else:
                return visitor.visitChildren(self)




    def kenmerkPhrase(self):

        localctx = RegelSpraakParser.KenmerkPhraseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 196, self.RULE_kenmerkPhrase)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1311
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 146)) & ~0x3f) == 0 and ((1 << (_la - 146)) & 4611686019501129733) != 0) or ((((_la - 216)) & ~0x3f) == 0 and ((1 << (_la - 216)) & 4597129233) != 0):
                self.state = 1310
                self.voorzetsel()


            self.state = 1314
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 212)) & ~0x3f) == 0 and ((1 << (_la - 212)) & 41) != 0):
                self.state = 1313
                _la = self._input.LA(1)
                if not(((((_la - 212)) & ~0x3f) == 0 and ((1 << (_la - 212)) & 41) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


            self.state = 1317 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 1316
                self.identifierOrKeywordWithNumbers()
                self.state = 1319 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (((((_la - 96)) & ~0x3f) == 0 and ((1 << (_la - 96)) & 68988059649) != 0) or ((((_la - 161)) & ~0x3f) == 0 and ((1 << (_la - 161)) & -3457864013260521471) != 0) or ((((_la - 232)) & ~0x3f) == 0 and ((1 << (_la - 232)) & 103081312261) != 0)):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BezieldeReferentieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def ZIJN(self):
            return self.getToken(RegelSpraakParser.ZIJN, 0)

        def HAAR(self):
            return self.getToken(RegelSpraakParser.HAAR, 0)

        def HUN(self):
            return self.getToken(RegelSpraakParser.HUN, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_bezieldeReferentie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBezieldeReferentie" ):
                listener.enterBezieldeReferentie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBezieldeReferentie" ):
                listener.exitBezieldeReferentie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBezieldeReferentie" ):
                return visitor.visitBezieldeReferentie(self)
            else:
                return visitor.visitChildren(self)




    def bezieldeReferentie(self):

        localctx = RegelSpraakParser.BezieldeReferentieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 198, self.RULE_bezieldeReferentie)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1321
            _la = self._input.LA(1)
            if not(((((_la - 119)) & ~0x3f) == 0 and ((1 << (_la - 119)) & 7) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 1322
            self.naamwoord()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AggregationSubjectContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ALLE(self):
            return self.getToken(RegelSpraakParser.ALLE, 0)

        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def predicaat(self):
            return self.getTypedRuleContext(RegelSpraakParser.PredicaatContext,0)


        def DIE(self):
            return self.getToken(RegelSpraakParser.DIE, 0)

        def DAT(self):
            return self.getToken(RegelSpraakParser.DAT, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_aggregationSubject

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAggregationSubject" ):
                listener.enterAggregationSubject(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAggregationSubject" ):
                listener.exitAggregationSubject(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAggregationSubject" ):
                return visitor.visitAggregationSubject(self)
            else:
                return visitor.visitChildren(self)




    def aggregationSubject(self):

        localctx = RegelSpraakParser.AggregationSubjectContext(self, self._ctx, self.state)
        self.enterRule(localctx, 200, self.RULE_aggregationSubject)
        self._la = 0 # Token type
        try:
            self.state = 1331
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,162,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1324
                self.match(RegelSpraakParser.ALLE)
                self.state = 1325
                self.naamwoord()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1326
                self.naamwoord()
                self.state = 1329
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,161,self._ctx)
                if la_ == 1:
                    self.state = 1327
                    _la = self._input.LA(1)
                    if not(_la==211 or _la==214):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()
                    self.state = 1328
                    self.predicaat()


                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PredicaatContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def elementairPredicaat(self):
            return self.getTypedRuleContext(RegelSpraakParser.ElementairPredicaatContext,0)


        def samengesteldPredicaat(self):
            return self.getTypedRuleContext(RegelSpraakParser.SamengesteldPredicaatContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_predicaat

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPredicaat" ):
                listener.enterPredicaat(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPredicaat" ):
                listener.exitPredicaat(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPredicaat" ):
                return visitor.visitPredicaat(self)
            else:
                return visitor.visitChildren(self)




    def predicaat(self):

        localctx = RegelSpraakParser.PredicaatContext(self, self._ctx, self.state)
        self.enterRule(localctx, 202, self.RULE_predicaat)
        try:
            self.state = 1335
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [45, 54, 55, 56, 57, 58, 59, 64, 65, 66, 67, 96, 110, 113, 119, 124, 132, 140, 146, 148, 161, 176, 190, 201, 202, 205, 206, 208, 209, 210, 212, 215, 216, 217, 220, 221, 223, 224, 229, 231, 232, 233, 234, 241, 244, 248, 253, 267, 268]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1333
                self.elementairPredicaat()
                pass
            elif token in [122]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1334
                self.samengesteldPredicaat()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ElementairPredicaatContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def attribuutVergelijkingsPredicaat(self):
            return self.getTypedRuleContext(RegelSpraakParser.AttribuutVergelijkingsPredicaatContext,0)


        def objectPredicaat(self):
            return self.getTypedRuleContext(RegelSpraakParser.ObjectPredicaatContext,0)


        def getalPredicaat(self):
            return self.getTypedRuleContext(RegelSpraakParser.GetalPredicaatContext,0)


        def tekstPredicaat(self):
            return self.getTypedRuleContext(RegelSpraakParser.TekstPredicaatContext,0)


        def datumPredicaat(self):
            return self.getTypedRuleContext(RegelSpraakParser.DatumPredicaatContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_elementairPredicaat

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterElementairPredicaat" ):
                listener.enterElementairPredicaat(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitElementairPredicaat" ):
                listener.exitElementairPredicaat(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitElementairPredicaat" ):
                return visitor.visitElementairPredicaat(self)
            else:
                return visitor.visitChildren(self)




    def elementairPredicaat(self):

        localctx = RegelSpraakParser.ElementairPredicaatContext(self, self._ctx, self.state)
        self.enterRule(localctx, 204, self.RULE_elementairPredicaat)
        try:
            self.state = 1342
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,164,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1337
                self.attribuutVergelijkingsPredicaat()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1338
                self.objectPredicaat()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1339
                self.getalPredicaat()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 1340
                self.tekstPredicaat()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 1341
                self.datumPredicaat()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ObjectPredicaatContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def eenzijdigeObjectVergelijking(self):
            return self.getTypedRuleContext(RegelSpraakParser.EenzijdigeObjectVergelijkingContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_objectPredicaat

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterObjectPredicaat" ):
                listener.enterObjectPredicaat(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitObjectPredicaat" ):
                listener.exitObjectPredicaat(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitObjectPredicaat" ):
                return visitor.visitObjectPredicaat(self)
            else:
                return visitor.visitChildren(self)




    def objectPredicaat(self):

        localctx = RegelSpraakParser.ObjectPredicaatContext(self, self._ctx, self.state)
        self.enterRule(localctx, 206, self.RULE_objectPredicaat)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1344
            self.eenzijdigeObjectVergelijking()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EenzijdigeObjectVergelijkingContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ZIJN(self):
            return self.getToken(RegelSpraakParser.ZIJN, 0)

        def HEBBEN(self):
            return self.getToken(RegelSpraakParser.HEBBEN, 0)

        def kenmerkNaam(self):
            return self.getTypedRuleContext(RegelSpraakParser.KenmerkNaamContext,0)


        def rolNaam(self):
            return self.getTypedRuleContext(RegelSpraakParser.RolNaamContext,0)


        def EEN(self):
            return self.getToken(RegelSpraakParser.EEN, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_eenzijdigeObjectVergelijking

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEenzijdigeObjectVergelijking" ):
                listener.enterEenzijdigeObjectVergelijking(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEenzijdigeObjectVergelijking" ):
                listener.exitEenzijdigeObjectVergelijking(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEenzijdigeObjectVergelijking" ):
                return visitor.visitEenzijdigeObjectVergelijking(self)
            else:
                return visitor.visitChildren(self)




    def eenzijdigeObjectVergelijking(self):

        localctx = RegelSpraakParser.EenzijdigeObjectVergelijkingContext(self, self._ctx, self.state)
        self.enterRule(localctx, 208, self.RULE_eenzijdigeObjectVergelijking)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1347
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,165,self._ctx)
            if la_ == 1:
                self.state = 1346
                self.match(RegelSpraakParser.EEN)


            self.state = 1351
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,166,self._ctx)
            if la_ == 1:
                self.state = 1349
                self.kenmerkNaam()
                pass

            elif la_ == 2:
                self.state = 1350
                self.rolNaam()
                pass


            self.state = 1353
            _la = self._input.LA(1)
            if not(_la==109 or _la==119):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RolNaamContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_rolNaam

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRolNaam" ):
                listener.enterRolNaam(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRolNaam" ):
                listener.exitRolNaam(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRolNaam" ):
                return visitor.visitRolNaam(self)
            else:
                return visitor.visitChildren(self)




    def rolNaam(self):

        localctx = RegelSpraakParser.RolNaamContext(self, self._ctx, self.state)
        self.enterRule(localctx, 210, self.RULE_rolNaam)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1355
            self.naamwoord()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AttribuutVergelijkingsPredicaatContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.attribuutNaam = None # NaamwoordContext

        def HEBBEN(self):
            return self.getToken(RegelSpraakParser.HEBBEN, 0)

        def comparisonOperator(self):
            return self.getTypedRuleContext(RegelSpraakParser.ComparisonOperatorContext,0)


        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)


        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def EEN(self):
            return self.getToken(RegelSpraakParser.EEN, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_attribuutVergelijkingsPredicaat

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAttribuutVergelijkingsPredicaat" ):
                listener.enterAttribuutVergelijkingsPredicaat(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAttribuutVergelijkingsPredicaat" ):
                listener.exitAttribuutVergelijkingsPredicaat(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAttribuutVergelijkingsPredicaat" ):
                return visitor.visitAttribuutVergelijkingsPredicaat(self)
            else:
                return visitor.visitChildren(self)




    def attribuutVergelijkingsPredicaat(self):

        localctx = RegelSpraakParser.AttribuutVergelijkingsPredicaatContext(self, self._ctx, self.state)
        self.enterRule(localctx, 212, self.RULE_attribuutVergelijkingsPredicaat)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1358
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,167,self._ctx)
            if la_ == 1:
                self.state = 1357
                self.match(RegelSpraakParser.EEN)


            self.state = 1360
            localctx.attribuutNaam = self.naamwoord()
            self.state = 1361
            self.match(RegelSpraakParser.HEBBEN)
            self.state = 1362
            self.comparisonOperator()
            self.state = 1363
            self.expressie()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GetalPredicaatContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def getalVergelijkingsOperatorMeervoud(self):
            return self.getTypedRuleContext(RegelSpraakParser.GetalVergelijkingsOperatorMeervoudContext,0)


        def getalExpressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.GetalExpressieContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_getalPredicaat

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGetalPredicaat" ):
                listener.enterGetalPredicaat(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGetalPredicaat" ):
                listener.exitGetalPredicaat(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGetalPredicaat" ):
                return visitor.visitGetalPredicaat(self)
            else:
                return visitor.visitChildren(self)




    def getalPredicaat(self):

        localctx = RegelSpraakParser.GetalPredicaatContext(self, self._ctx, self.state)
        self.enterRule(localctx, 214, self.RULE_getalPredicaat)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1365
            self.getalVergelijkingsOperatorMeervoud()
            self.state = 1366
            self.getalExpressie()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TekstPredicaatContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def tekstVergelijkingsOperatorMeervoud(self):
            return self.getTypedRuleContext(RegelSpraakParser.TekstVergelijkingsOperatorMeervoudContext,0)


        def tekstExpressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.TekstExpressieContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_tekstPredicaat

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTekstPredicaat" ):
                listener.enterTekstPredicaat(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTekstPredicaat" ):
                listener.exitTekstPredicaat(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTekstPredicaat" ):
                return visitor.visitTekstPredicaat(self)
            else:
                return visitor.visitChildren(self)




    def tekstPredicaat(self):

        localctx = RegelSpraakParser.TekstPredicaatContext(self, self._ctx, self.state)
        self.enterRule(localctx, 216, self.RULE_tekstPredicaat)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1368
            self.tekstVergelijkingsOperatorMeervoud()
            self.state = 1369
            self.tekstExpressie()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DatumPredicaatContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def datumVergelijkingsOperatorMeervoud(self):
            return self.getTypedRuleContext(RegelSpraakParser.DatumVergelijkingsOperatorMeervoudContext,0)


        def datumExpressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.DatumExpressieContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_datumPredicaat

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDatumPredicaat" ):
                listener.enterDatumPredicaat(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDatumPredicaat" ):
                listener.exitDatumPredicaat(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDatumPredicaat" ):
                return visitor.visitDatumPredicaat(self)
            else:
                return visitor.visitChildren(self)




    def datumPredicaat(self):

        localctx = RegelSpraakParser.DatumPredicaatContext(self, self._ctx, self.state)
        self.enterRule(localctx, 218, self.RULE_datumPredicaat)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1371
            self.datumVergelijkingsOperatorMeervoud()
            self.state = 1372
            self.datumExpressie()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SamengesteldPredicaatContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def AAN(self):
            return self.getToken(RegelSpraakParser.AAN, 0)

        def voorwaardeKwantificatie(self):
            return self.getTypedRuleContext(RegelSpraakParser.VoorwaardeKwantificatieContext,0)


        def VOLGENDE(self):
            return self.getToken(RegelSpraakParser.VOLGENDE, 0)

        def COLON(self):
            return self.getToken(RegelSpraakParser.COLON, 0)

        def VOORWAARDE(self):
            return self.getToken(RegelSpraakParser.VOORWAARDE, 0)

        def VOORWAARDEN(self):
            return self.getToken(RegelSpraakParser.VOORWAARDEN, 0)

        def VOLDOET(self):
            return self.getToken(RegelSpraakParser.VOLDOET, 0)

        def VOLDOEN(self):
            return self.getToken(RegelSpraakParser.VOLDOEN, 0)

        def samengesteldeVoorwaardeOnderdeelInPredicaat(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.SamengesteldeVoorwaardeOnderdeelInPredicaatContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.SamengesteldeVoorwaardeOnderdeelInPredicaatContext,i)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_samengesteldPredicaat

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSamengesteldPredicaat" ):
                listener.enterSamengesteldPredicaat(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSamengesteldPredicaat" ):
                listener.exitSamengesteldPredicaat(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSamengesteldPredicaat" ):
                return visitor.visitSamengesteldPredicaat(self)
            else:
                return visitor.visitChildren(self)




    def samengesteldPredicaat(self):

        localctx = RegelSpraakParser.SamengesteldPredicaatContext(self, self._ctx, self.state)
        self.enterRule(localctx, 220, self.RULE_samengesteldPredicaat)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1374
            self.match(RegelSpraakParser.AAN)
            self.state = 1375
            self.voorwaardeKwantificatie()
            self.state = 1376
            self.match(RegelSpraakParser.VOLGENDE)
            self.state = 1377
            _la = self._input.LA(1)
            if not(_la==161 or _la==162):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 1378
            _la = self._input.LA(1)
            if not(_la==153 or _la==154):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 1379
            self.match(RegelSpraakParser.COLON)
            self.state = 1381 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 1380
                    self.samengesteldeVoorwaardeOnderdeelInPredicaat()

                else:
                    raise NoViableAltException(self)
                self.state = 1383 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,168,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SamengesteldeVoorwaardeOnderdeelInPredicaatContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def bulletPrefix(self):
            return self.getTypedRuleContext(RegelSpraakParser.BulletPrefixContext,0)


        def elementaireVoorwaardeInPredicaat(self):
            return self.getTypedRuleContext(RegelSpraakParser.ElementaireVoorwaardeInPredicaatContext,0)


        def genesteSamengesteldeVoorwaardeInPredicaat(self):
            return self.getTypedRuleContext(RegelSpraakParser.GenesteSamengesteldeVoorwaardeInPredicaatContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_samengesteldeVoorwaardeOnderdeelInPredicaat

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSamengesteldeVoorwaardeOnderdeelInPredicaat" ):
                listener.enterSamengesteldeVoorwaardeOnderdeelInPredicaat(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSamengesteldeVoorwaardeOnderdeelInPredicaat" ):
                listener.exitSamengesteldeVoorwaardeOnderdeelInPredicaat(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSamengesteldeVoorwaardeOnderdeelInPredicaat" ):
                return visitor.visitSamengesteldeVoorwaardeOnderdeelInPredicaat(self)
            else:
                return visitor.visitChildren(self)




    def samengesteldeVoorwaardeOnderdeelInPredicaat(self):

        localctx = RegelSpraakParser.SamengesteldeVoorwaardeOnderdeelInPredicaatContext(self, self._ctx, self.state)
        self.enterRule(localctx, 222, self.RULE_samengesteldeVoorwaardeOnderdeelInPredicaat)
        try:
            self.state = 1391
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,169,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1385
                self.bulletPrefix()
                self.state = 1386
                self.elementaireVoorwaardeInPredicaat()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1388
                self.bulletPrefix()
                self.state = 1389
                self.genesteSamengesteldeVoorwaardeInPredicaat()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ElementaireVoorwaardeInPredicaatContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def vergelijkingInPredicaat(self):
            return self.getTypedRuleContext(RegelSpraakParser.VergelijkingInPredicaatContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_elementaireVoorwaardeInPredicaat

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterElementaireVoorwaardeInPredicaat" ):
                listener.enterElementaireVoorwaardeInPredicaat(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitElementaireVoorwaardeInPredicaat" ):
                listener.exitElementaireVoorwaardeInPredicaat(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitElementaireVoorwaardeInPredicaat" ):
                return visitor.visitElementaireVoorwaardeInPredicaat(self)
            else:
                return visitor.visitChildren(self)




    def elementaireVoorwaardeInPredicaat(self):

        localctx = RegelSpraakParser.ElementaireVoorwaardeInPredicaatContext(self, self._ctx, self.state)
        self.enterRule(localctx, 224, self.RULE_elementaireVoorwaardeInPredicaat)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1393
            self.vergelijkingInPredicaat()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VergelijkingInPredicaatContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def attribuutReferentie(self):
            return self.getTypedRuleContext(RegelSpraakParser.AttribuutReferentieContext,0)


        def comparisonOperator(self):
            return self.getTypedRuleContext(RegelSpraakParser.ComparisonOperatorContext,0)


        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)


        def onderwerpReferentie(self):
            return self.getTypedRuleContext(RegelSpraakParser.OnderwerpReferentieContext,0)


        def eenzijdigeObjectVergelijking(self):
            return self.getTypedRuleContext(RegelSpraakParser.EenzijdigeObjectVergelijkingContext,0)


        def kenmerkNaam(self):
            return self.getTypedRuleContext(RegelSpraakParser.KenmerkNaamContext,0)


        def IS(self):
            return self.getToken(RegelSpraakParser.IS, 0)

        def ZIJN(self):
            return self.getToken(RegelSpraakParser.ZIJN, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_vergelijkingInPredicaat

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVergelijkingInPredicaat" ):
                listener.enterVergelijkingInPredicaat(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVergelijkingInPredicaat" ):
                listener.exitVergelijkingInPredicaat(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVergelijkingInPredicaat" ):
                return visitor.visitVergelijkingInPredicaat(self)
            else:
                return visitor.visitChildren(self)




    def vergelijkingInPredicaat(self):

        localctx = RegelSpraakParser.VergelijkingInPredicaatContext(self, self._ctx, self.state)
        self.enterRule(localctx, 226, self.RULE_vergelijkingInPredicaat)
        self._la = 0 # Token type
        try:
            self.state = 1406
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,170,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1395
                self.attribuutReferentie()
                self.state = 1396
                self.comparisonOperator()
                self.state = 1397
                self.expressie()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1399
                self.onderwerpReferentie()
                self.state = 1400
                self.eenzijdigeObjectVergelijking()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1402
                self.attribuutReferentie()
                self.state = 1403
                _la = self._input.LA(1)
                if not(_la==113 or _la==119):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1404
                self.kenmerkNaam()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GenesteSamengesteldeVoorwaardeInPredicaatContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def AAN(self):
            return self.getToken(RegelSpraakParser.AAN, 0)

        def voorwaardeKwantificatie(self):
            return self.getTypedRuleContext(RegelSpraakParser.VoorwaardeKwantificatieContext,0)


        def VOLGENDE(self):
            return self.getToken(RegelSpraakParser.VOLGENDE, 0)

        def COLON(self):
            return self.getToken(RegelSpraakParser.COLON, 0)

        def VOORWAARDE(self):
            return self.getToken(RegelSpraakParser.VOORWAARDE, 0)

        def VOORWAARDEN(self):
            return self.getToken(RegelSpraakParser.VOORWAARDEN, 0)

        def VOLDOET(self):
            return self.getToken(RegelSpraakParser.VOLDOET, 0)

        def VOLDOEN(self):
            return self.getToken(RegelSpraakParser.VOLDOEN, 0)

        def WORDT(self):
            return self.getToken(RegelSpraakParser.WORDT, 0)

        def VOLDAAN(self):
            return self.getToken(RegelSpraakParser.VOLDAAN, 0)

        def samengesteldeVoorwaardeOnderdeelInPredicaat(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.SamengesteldeVoorwaardeOnderdeelInPredicaatContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.SamengesteldeVoorwaardeOnderdeelInPredicaatContext,i)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_genesteSamengesteldeVoorwaardeInPredicaat

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGenesteSamengesteldeVoorwaardeInPredicaat" ):
                listener.enterGenesteSamengesteldeVoorwaardeInPredicaat(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGenesteSamengesteldeVoorwaardeInPredicaat" ):
                listener.exitGenesteSamengesteldeVoorwaardeInPredicaat(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGenesteSamengesteldeVoorwaardeInPredicaat" ):
                return visitor.visitGenesteSamengesteldeVoorwaardeInPredicaat(self)
            else:
                return visitor.visitChildren(self)




    def genesteSamengesteldeVoorwaardeInPredicaat(self):

        localctx = RegelSpraakParser.GenesteSamengesteldeVoorwaardeInPredicaatContext(self, self._ctx, self.state)
        self.enterRule(localctx, 228, self.RULE_genesteSamengesteldeVoorwaardeInPredicaat)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1412
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [154]:
                self.state = 1408
                self.match(RegelSpraakParser.VOLDOET)
                pass
            elif token in [153]:
                self.state = 1409
                self.match(RegelSpraakParser.VOLDOEN)
                pass
            elif token in [117]:
                self.state = 1410
                self.match(RegelSpraakParser.WORDT)
                self.state = 1411
                self.match(RegelSpraakParser.VOLDAAN)
                pass
            else:
                raise NoViableAltException(self)

            self.state = 1414
            self.match(RegelSpraakParser.AAN)
            self.state = 1415
            self.voorwaardeKwantificatie()
            self.state = 1416
            self.match(RegelSpraakParser.VOLGENDE)
            self.state = 1417
            _la = self._input.LA(1)
            if not(_la==161 or _la==162):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 1418
            self.match(RegelSpraakParser.COLON)
            self.state = 1420 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 1419
                    self.samengesteldeVoorwaardeOnderdeelInPredicaat()

                else:
                    raise NoViableAltException(self)
                self.state = 1422 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,172,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GetalVergelijkingsOperatorMeervoudContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ZIJN_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.ZIJN_GELIJK_AAN, 0)

        def ZIJN_ONGELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.ZIJN_ONGELIJK_AAN, 0)

        def ZIJN_GROTER_DAN(self):
            return self.getToken(RegelSpraakParser.ZIJN_GROTER_DAN, 0)

        def ZIJN_GROTER_OF_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.ZIJN_GROTER_OF_GELIJK_AAN, 0)

        def ZIJN_KLEINER_DAN(self):
            return self.getToken(RegelSpraakParser.ZIJN_KLEINER_DAN, 0)

        def ZIJN_KLEINER_OF_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.ZIJN_KLEINER_OF_GELIJK_AAN, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_getalVergelijkingsOperatorMeervoud

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGetalVergelijkingsOperatorMeervoud" ):
                listener.enterGetalVergelijkingsOperatorMeervoud(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGetalVergelijkingsOperatorMeervoud" ):
                listener.exitGetalVergelijkingsOperatorMeervoud(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGetalVergelijkingsOperatorMeervoud" ):
                return visitor.visitGetalVergelijkingsOperatorMeervoud(self)
            else:
                return visitor.visitChildren(self)




    def getalVergelijkingsOperatorMeervoud(self):

        localctx = RegelSpraakParser.GetalVergelijkingsOperatorMeervoudContext(self, self._ctx, self.state)
        self.enterRule(localctx, 230, self.RULE_getalVergelijkingsOperatorMeervoud)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1424
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 1134907106097364992) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TekstVergelijkingsOperatorMeervoudContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ZIJN_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.ZIJN_GELIJK_AAN, 0)

        def ZIJN_ONGELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.ZIJN_ONGELIJK_AAN, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_tekstVergelijkingsOperatorMeervoud

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTekstVergelijkingsOperatorMeervoud" ):
                listener.enterTekstVergelijkingsOperatorMeervoud(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTekstVergelijkingsOperatorMeervoud" ):
                listener.exitTekstVergelijkingsOperatorMeervoud(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTekstVergelijkingsOperatorMeervoud" ):
                return visitor.visitTekstVergelijkingsOperatorMeervoud(self)
            else:
                return visitor.visitChildren(self)




    def tekstVergelijkingsOperatorMeervoud(self):

        localctx = RegelSpraakParser.TekstVergelijkingsOperatorMeervoudContext(self, self._ctx, self.state)
        self.enterRule(localctx, 232, self.RULE_tekstVergelijkingsOperatorMeervoud)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1426
            _la = self._input.LA(1)
            if not(_la==54 or _la==55):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DatumVergelijkingsOperatorMeervoudContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ZIJN_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.ZIJN_GELIJK_AAN, 0)

        def ZIJN_ONGELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.ZIJN_ONGELIJK_AAN, 0)

        def ZIJN_LATER_DAN(self):
            return self.getToken(RegelSpraakParser.ZIJN_LATER_DAN, 0)

        def ZIJN_LATER_OF_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.ZIJN_LATER_OF_GELIJK_AAN, 0)

        def ZIJN_EERDER_DAN(self):
            return self.getToken(RegelSpraakParser.ZIJN_EERDER_DAN, 0)

        def ZIJN_EERDER_OF_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.ZIJN_EERDER_OF_GELIJK_AAN, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_datumVergelijkingsOperatorMeervoud

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDatumVergelijkingsOperatorMeervoud" ):
                listener.enterDatumVergelijkingsOperatorMeervoud(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDatumVergelijkingsOperatorMeervoud" ):
                listener.exitDatumVergelijkingsOperatorMeervoud(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDatumVergelijkingsOperatorMeervoud" ):
                return visitor.visitDatumVergelijkingsOperatorMeervoud(self)
            else:
                return visitor.visitChildren(self)




    def datumVergelijkingsOperatorMeervoud(self):

        localctx = RegelSpraakParser.DatumVergelijkingsOperatorMeervoudContext(self, self._ctx, self.state)
        self.enterRule(localctx, 234, self.RULE_datumVergelijkingsOperatorMeervoud)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1428
            _la = self._input.LA(1)
            if not(((((_la - 54)) & ~0x3f) == 0 and ((1 << (_la - 54)) & 15363) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GetalExpressieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_getalExpressie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGetalExpressie" ):
                listener.enterGetalExpressie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGetalExpressie" ):
                listener.exitGetalExpressie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGetalExpressie" ):
                return visitor.visitGetalExpressie(self)
            else:
                return visitor.visitChildren(self)




    def getalExpressie(self):

        localctx = RegelSpraakParser.GetalExpressieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 236, self.RULE_getalExpressie)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1430
            self.expressie()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TekstExpressieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_tekstExpressie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTekstExpressie" ):
                listener.enterTekstExpressie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTekstExpressie" ):
                listener.exitTekstExpressie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTekstExpressie" ):
                return visitor.visitTekstExpressie(self)
            else:
                return visitor.visitChildren(self)




    def tekstExpressie(self):

        localctx = RegelSpraakParser.TekstExpressieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 238, self.RULE_tekstExpressie)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1432
            self.expressie()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DatumExpressieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def datumLiteral(self):
            return self.getTypedRuleContext(RegelSpraakParser.DatumLiteralContext,0)


        def REKENDATUM(self):
            return self.getToken(RegelSpraakParser.REKENDATUM, 0)

        def REKENJAAR(self):
            return self.getToken(RegelSpraakParser.REKENJAAR, 0)

        def DE_DATUM_MET(self):
            return self.getToken(RegelSpraakParser.DE_DATUM_MET, 0)

        def LPAREN(self):
            return self.getToken(RegelSpraakParser.LPAREN, 0)

        def primaryExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.PrimaryExpressionContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.COMMA)
            else:
                return self.getToken(RegelSpraakParser.COMMA, i)

        def RPAREN(self):
            return self.getToken(RegelSpraakParser.RPAREN, 0)

        def DE_EERSTE_PAASDAG_VAN(self):
            return self.getToken(RegelSpraakParser.DE_EERSTE_PAASDAG_VAN, 0)

        def attribuutReferentie(self):
            return self.getTypedRuleContext(RegelSpraakParser.AttribuutReferentieContext,0)


        def bezieldeReferentie(self):
            return self.getTypedRuleContext(RegelSpraakParser.BezieldeReferentieContext,0)


        def parameterMetLidwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.ParameterMetLidwoordContext,0)


        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_datumExpressie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDatumExpressie" ):
                listener.enterDatumExpressie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDatumExpressie" ):
                listener.exitDatumExpressie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDatumExpressie" ):
                return visitor.visitDatumExpressie(self)
            else:
                return visitor.visitChildren(self)




    def datumExpressie(self):

        localctx = RegelSpraakParser.DatumExpressieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 240, self.RULE_datumExpressie)
        try:
            self.state = 1458
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,173,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1434
                self.datumLiteral()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1435
                self.match(RegelSpraakParser.REKENDATUM)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1436
                self.match(RegelSpraakParser.REKENJAAR)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 1437
                self.match(RegelSpraakParser.DE_DATUM_MET)
                self.state = 1438
                self.match(RegelSpraakParser.LPAREN)
                self.state = 1439
                self.primaryExpression(0)
                self.state = 1440
                self.match(RegelSpraakParser.COMMA)
                self.state = 1441
                self.primaryExpression(0)
                self.state = 1442
                self.match(RegelSpraakParser.COMMA)
                self.state = 1443
                self.primaryExpression(0)
                self.state = 1444
                self.match(RegelSpraakParser.RPAREN)
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 1446
                self.match(RegelSpraakParser.DE_EERSTE_PAASDAG_VAN)
                self.state = 1447
                self.match(RegelSpraakParser.LPAREN)
                self.state = 1448
                self.primaryExpression(0)
                self.state = 1449
                self.match(RegelSpraakParser.RPAREN)
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 1451
                self.attribuutReferentie()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 1452
                self.bezieldeReferentie()
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 1453
                self.parameterMetLidwoord()
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 1454
                self.match(RegelSpraakParser.LPAREN)
                self.state = 1455
                self.expressie()
                self.state = 1456
                self.match(RegelSpraakParser.RPAREN)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VariabeleDeelContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DAARBIJ_GELDT(self):
            return self.getToken(RegelSpraakParser.DAARBIJ_GELDT, 0)

        def DOT(self):
            return self.getToken(RegelSpraakParser.DOT, 0)

        def variabeleToekenning(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.VariabeleToekenningContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.VariabeleToekenningContext,i)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_variabeleDeel

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVariabeleDeel" ):
                listener.enterVariabeleDeel(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVariabeleDeel" ):
                listener.exitVariabeleDeel(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVariabeleDeel" ):
                return visitor.visitVariabeleDeel(self)
            else:
                return visitor.visitChildren(self)




    def variabeleDeel(self):

        localctx = RegelSpraakParser.VariabeleDeelContext(self, self._ctx, self.state)
        self.enterRule(localctx, 242, self.RULE_variabeleDeel)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1460
            self.match(RegelSpraakParser.DAARBIJ_GELDT)
            self.state = 1464
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((((_la - 212)) & ~0x3f) == 0 and ((1 << (_la - 212)) & 36028797018964001) != 0):
                self.state = 1461
                self.variabeleToekenning()
                self.state = 1466
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1467
            self.match(RegelSpraakParser.DOT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VariabeleToekenningContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.article = None # Token
            self.varName = None # Token
            self.varExpr = None # VariabeleExpressieContext

        def IS(self):
            return self.getToken(RegelSpraakParser.IS, 0)

        def IDENTIFIER(self):
            return self.getToken(RegelSpraakParser.IDENTIFIER, 0)

        def variabeleExpressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.VariabeleExpressieContext,0)


        def DE(self):
            return self.getToken(RegelSpraakParser.DE, 0)

        def HET(self):
            return self.getToken(RegelSpraakParser.HET, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_variabeleToekenning

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVariabeleToekenning" ):
                listener.enterVariabeleToekenning(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVariabeleToekenning" ):
                listener.exitVariabeleToekenning(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVariabeleToekenning" ):
                return visitor.visitVariabeleToekenning(self)
            else:
                return visitor.visitChildren(self)




    def variabeleToekenning(self):

        localctx = RegelSpraakParser.VariabeleToekenningContext(self, self._ctx, self.state)
        self.enterRule(localctx, 244, self.RULE_variabeleToekenning)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1470
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==212 or _la==217:
                self.state = 1469
                localctx.article = self._input.LT(1)
                _la = self._input.LA(1)
                if not(_la==212 or _la==217):
                    localctx.article = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


            self.state = 1472
            localctx.varName = self.match(RegelSpraakParser.IDENTIFIER)
            self.state = 1473
            self.match(RegelSpraakParser.IS)
            self.state = 1474
            localctx.varExpr = self.variabeleExpressie()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VariabeleExpressieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def primaryExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.PrimaryExpressionContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,i)


        def additiveOperator(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.AdditiveOperatorContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.AdditiveOperatorContext,i)


        def multiplicativeOperator(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.MultiplicativeOperatorContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.MultiplicativeOperatorContext,i)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_variabeleExpressie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVariabeleExpressie" ):
                listener.enterVariabeleExpressie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVariabeleExpressie" ):
                listener.exitVariabeleExpressie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVariabeleExpressie" ):
                return visitor.visitVariabeleExpressie(self)
            else:
                return visitor.visitChildren(self)




    def variabeleExpressie(self):

        localctx = RegelSpraakParser.VariabeleExpressieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 246, self.RULE_variabeleExpressie)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1476
            self.primaryExpression(0)
            self.state = 1485
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((((_la - 126)) & ~0x3f) == 0 and ((1 << (_la - 126)) & 67243011) != 0):
                self.state = 1479
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [137, 143, 152]:
                    self.state = 1477
                    self.additiveOperator()
                    pass
                elif token in [126, 127, 136]:
                    self.state = 1478
                    self.multiplicativeOperator()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 1481
                self.primaryExpression(0)
                self.state = 1487
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExpressieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_expressie

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class SimpleExprContext(ExpressieContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.ExpressieContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def logicalExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.LogicalExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSimpleExpr" ):
                listener.enterSimpleExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSimpleExpr" ):
                listener.exitSimpleExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSimpleExpr" ):
                return visitor.visitSimpleExpr(self)
            else:
                return visitor.visitChildren(self)


    class ExprBegrenzingAfrondingContext(ExpressieContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.ExpressieContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def logicalExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.LogicalExpressionContext,0)

        def COMMA(self):
            return self.getToken(RegelSpraakParser.COMMA, 0)
        def begrenzing(self):
            return self.getTypedRuleContext(RegelSpraakParser.BegrenzingContext,0)

        def afronding(self):
            return self.getTypedRuleContext(RegelSpraakParser.AfrondingContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExprBegrenzingAfronding" ):
                listener.enterExprBegrenzingAfronding(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExprBegrenzingAfronding" ):
                listener.exitExprBegrenzingAfronding(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExprBegrenzingAfronding" ):
                return visitor.visitExprBegrenzingAfronding(self)
            else:
                return visitor.visitChildren(self)


    class ExprBegrenzingContext(ExpressieContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.ExpressieContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def logicalExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.LogicalExpressionContext,0)

        def COMMA(self):
            return self.getToken(RegelSpraakParser.COMMA, 0)
        def begrenzing(self):
            return self.getTypedRuleContext(RegelSpraakParser.BegrenzingContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExprBegrenzing" ):
                listener.enterExprBegrenzing(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExprBegrenzing" ):
                listener.exitExprBegrenzing(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExprBegrenzing" ):
                return visitor.visitExprBegrenzing(self)
            else:
                return visitor.visitChildren(self)


    class ExprAfrondingContext(ExpressieContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.ExpressieContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def logicalExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.LogicalExpressionContext,0)

        def afronding(self):
            return self.getTypedRuleContext(RegelSpraakParser.AfrondingContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExprAfronding" ):
                listener.enterExprAfronding(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExprAfronding" ):
                listener.exitExprAfronding(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExprAfronding" ):
                return visitor.visitExprAfronding(self)
            else:
                return visitor.visitChildren(self)



    def expressie(self):

        localctx = RegelSpraakParser.ExpressieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 248, self.RULE_expressie)
        try:
            self.state = 1501
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,178,self._ctx)
            if la_ == 1:
                localctx = RegelSpraakParser.ExprBegrenzingAfrondingContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1488
                self.logicalExpression()
                self.state = 1489
                self.match(RegelSpraakParser.COMMA)
                self.state = 1490
                self.begrenzing()
                self.state = 1491
                self.afronding()
                pass

            elif la_ == 2:
                localctx = RegelSpraakParser.ExprBegrenzingContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1493
                self.logicalExpression()
                self.state = 1494
                self.match(RegelSpraakParser.COMMA)
                self.state = 1495
                self.begrenzing()
                pass

            elif la_ == 3:
                localctx = RegelSpraakParser.ExprAfrondingContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 1497
                self.logicalExpression()
                self.state = 1498
                self.afronding()
                pass

            elif la_ == 4:
                localctx = RegelSpraakParser.SimpleExprContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 1500
                self.logicalExpression()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SimpleExpressieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_simpleExpressie

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class SimpleExprBegrenzingContext(SimpleExpressieContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.SimpleExpressieContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def comparisonExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.ComparisonExpressionContext,0)

        def COMMA(self):
            return self.getToken(RegelSpraakParser.COMMA, 0)
        def begrenzing(self):
            return self.getTypedRuleContext(RegelSpraakParser.BegrenzingContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSimpleExprBegrenzing" ):
                listener.enterSimpleExprBegrenzing(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSimpleExprBegrenzing" ):
                listener.exitSimpleExprBegrenzing(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSimpleExprBegrenzing" ):
                return visitor.visitSimpleExprBegrenzing(self)
            else:
                return visitor.visitChildren(self)


    class SimpleExprAfrondingContext(SimpleExpressieContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.SimpleExpressieContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def comparisonExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.ComparisonExpressionContext,0)

        def afronding(self):
            return self.getTypedRuleContext(RegelSpraakParser.AfrondingContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSimpleExprAfronding" ):
                listener.enterSimpleExprAfronding(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSimpleExprAfronding" ):
                listener.exitSimpleExprAfronding(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSimpleExprAfronding" ):
                return visitor.visitSimpleExprAfronding(self)
            else:
                return visitor.visitChildren(self)


    class SimpleExprBegrenzingAfrondingContext(SimpleExpressieContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.SimpleExpressieContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def comparisonExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.ComparisonExpressionContext,0)

        def COMMA(self):
            return self.getToken(RegelSpraakParser.COMMA, 0)
        def begrenzing(self):
            return self.getTypedRuleContext(RegelSpraakParser.BegrenzingContext,0)

        def afronding(self):
            return self.getTypedRuleContext(RegelSpraakParser.AfrondingContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSimpleExprBegrenzingAfronding" ):
                listener.enterSimpleExprBegrenzingAfronding(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSimpleExprBegrenzingAfronding" ):
                listener.exitSimpleExprBegrenzingAfronding(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSimpleExprBegrenzingAfronding" ):
                return visitor.visitSimpleExprBegrenzingAfronding(self)
            else:
                return visitor.visitChildren(self)


    class SimpleExprBaseContext(SimpleExpressieContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.SimpleExpressieContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def comparisonExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.ComparisonExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSimpleExprBase" ):
                listener.enterSimpleExprBase(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSimpleExprBase" ):
                listener.exitSimpleExprBase(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSimpleExprBase" ):
                return visitor.visitSimpleExprBase(self)
            else:
                return visitor.visitChildren(self)



    def simpleExpressie(self):

        localctx = RegelSpraakParser.SimpleExpressieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 250, self.RULE_simpleExpressie)
        try:
            self.state = 1516
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,179,self._ctx)
            if la_ == 1:
                localctx = RegelSpraakParser.SimpleExprBegrenzingAfrondingContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1503
                self.comparisonExpression()
                self.state = 1504
                self.match(RegelSpraakParser.COMMA)
                self.state = 1505
                self.begrenzing()
                self.state = 1506
                self.afronding()
                pass

            elif la_ == 2:
                localctx = RegelSpraakParser.SimpleExprBegrenzingContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1508
                self.comparisonExpression()
                self.state = 1509
                self.match(RegelSpraakParser.COMMA)
                self.state = 1510
                self.begrenzing()
                pass

            elif la_ == 3:
                localctx = RegelSpraakParser.SimpleExprAfrondingContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 1512
                self.comparisonExpression()
                self.state = 1513
                self.afronding()
                pass

            elif la_ == 4:
                localctx = RegelSpraakParser.SimpleExprBaseContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 1515
                self.comparisonExpression()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LogicalExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_logicalExpression

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class LogicalExprContext(LogicalExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.LogicalExpressionContext
            super().__init__(parser)
            self.left = None # ComparisonExpressionContext
            self.op = None # Token
            self.right = None # LogicalExpressionContext
            self.copyFrom(ctx)

        def comparisonExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.ComparisonExpressionContext,0)

        def logicalExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.LogicalExpressionContext,0)

        def EN(self):
            return self.getToken(RegelSpraakParser.EN, 0)
        def OF(self):
            return self.getToken(RegelSpraakParser.OF, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLogicalExpr" ):
                listener.enterLogicalExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLogicalExpr" ):
                listener.exitLogicalExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLogicalExpr" ):
                return visitor.visitLogicalExpr(self)
            else:
                return visitor.visitChildren(self)



    def logicalExpression(self):

        localctx = RegelSpraakParser.LogicalExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 252, self.RULE_logicalExpression)
        self._la = 0 # Token type
        try:
            localctx = RegelSpraakParser.LogicalExprContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 1518
            localctx.left = self.comparisonExpression()
            self.state = 1521
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,180,self._ctx)
            if la_ == 1:
                self.state = 1519
                localctx.op = self._input.LT(1)
                _la = self._input.LA(1)
                if not(_la==216 or _la==229):
                    localctx.op = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1520
                localctx.right = self.logicalExpression()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ComparisonExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_comparisonExpression

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class GelijkIsAanOfExprContext(ComparisonExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.ComparisonExpressionContext
            super().__init__(parser)
            self.left = None # AdditiveExpressionContext
            self.op = None # GelijkIsAanOperatorContext
            self.firstValue = None # LiteralValueContext
            self._literalValue = None # LiteralValueContext
            self.middleValues = list() # of LiteralValueContexts
            self.lastValue = None # LiteralValueContext
            self.copyFrom(ctx)

        def OF(self):
            return self.getToken(RegelSpraakParser.OF, 0)
        def additiveExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.AdditiveExpressionContext,0)

        def gelijkIsAanOperator(self):
            return self.getTypedRuleContext(RegelSpraakParser.GelijkIsAanOperatorContext,0)

        def literalValue(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.LiteralValueContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.LiteralValueContext,i)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.COMMA)
            else:
                return self.getToken(RegelSpraakParser.COMMA, i)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGelijkIsAanOfExpr" ):
                listener.enterGelijkIsAanOfExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGelijkIsAanOfExpr" ):
                listener.exitGelijkIsAanOfExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGelijkIsAanOfExpr" ):
                return visitor.visitGelijkIsAanOfExpr(self)
            else:
                return visitor.visitChildren(self)


    class SubordinateClauseExprContext(ComparisonExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.ComparisonExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def subordinateClauseExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.SubordinateClauseExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSubordinateClauseExpr" ):
                listener.enterSubordinateClauseExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSubordinateClauseExpr" ):
                listener.exitSubordinateClauseExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSubordinateClauseExpr" ):
                return visitor.visitSubordinateClauseExpr(self)
            else:
                return visitor.visitChildren(self)


    class PeriodeCheckExprContext(ComparisonExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.ComparisonExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def periodevergelijkingElementair(self):
            return self.getTypedRuleContext(RegelSpraakParser.PeriodevergelijkingElementairContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPeriodeCheckExpr" ):
                listener.enterPeriodeCheckExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPeriodeCheckExpr" ):
                listener.exitPeriodeCheckExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPeriodeCheckExpr" ):
                return visitor.visitPeriodeCheckExpr(self)
            else:
                return visitor.visitChildren(self)


    class BinaryComparisonExprContext(ComparisonExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.ComparisonExpressionContext
            super().__init__(parser)
            self.left = None # AdditiveExpressionContext
            self.right = None # AdditiveExpressionContext
            self.copyFrom(ctx)

        def additiveExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.AdditiveExpressionContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.AdditiveExpressionContext,i)

        def comparisonOperator(self):
            return self.getTypedRuleContext(RegelSpraakParser.ComparisonOperatorContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBinaryComparisonExpr" ):
                listener.enterBinaryComparisonExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBinaryComparisonExpr" ):
                listener.exitBinaryComparisonExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBinaryComparisonExpr" ):
                return visitor.visitBinaryComparisonExpr(self)
            else:
                return visitor.visitChildren(self)


    class UnaryConditionExprContext(ComparisonExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.ComparisonExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def unaryCondition(self):
            return self.getTypedRuleContext(RegelSpraakParser.UnaryConditionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnaryConditionExpr" ):
                listener.enterUnaryConditionExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnaryConditionExpr" ):
                listener.exitUnaryConditionExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnaryConditionExpr" ):
                return visitor.visitUnaryConditionExpr(self)
            else:
                return visitor.visitChildren(self)


    class HeeftKenmerkExprContext(ComparisonExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.ComparisonExpressionContext
            super().__init__(parser)
            self.left = None # AdditiveExpressionContext
            self.copyFrom(ctx)

        def HEEFT(self):
            return self.getToken(RegelSpraakParser.HEEFT, 0)
        def naamwoordWithNumbers(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordWithNumbersContext,0)

        def additiveExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.AdditiveExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterHeeftKenmerkExpr" ):
                listener.enterHeeftKenmerkExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitHeeftKenmerkExpr" ):
                listener.exitHeeftKenmerkExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitHeeftKenmerkExpr" ):
                return visitor.visitHeeftKenmerkExpr(self)
            else:
                return visitor.visitChildren(self)


    class IsKenmerkExprContext(ComparisonExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.ComparisonExpressionContext
            super().__init__(parser)
            self.left = None # AdditiveExpressionContext
            self.copyFrom(ctx)

        def IS(self):
            return self.getToken(RegelSpraakParser.IS, 0)
        def naamwoordWithNumbers(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordWithNumbersContext,0)

        def additiveExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.AdditiveExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIsKenmerkExpr" ):
                listener.enterIsKenmerkExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIsKenmerkExpr" ):
                listener.exitIsKenmerkExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIsKenmerkExpr" ):
                return visitor.visitIsKenmerkExpr(self)
            else:
                return visitor.visitChildren(self)


    class RegelStatusConditionExprContext(ComparisonExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.ComparisonExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def regelStatusCondition(self):
            return self.getTypedRuleContext(RegelSpraakParser.RegelStatusConditionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRegelStatusConditionExpr" ):
                listener.enterRegelStatusConditionExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRegelStatusConditionExpr" ):
                listener.exitRegelStatusConditionExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRegelStatusConditionExpr" ):
                return visitor.visitRegelStatusConditionExpr(self)
            else:
                return visitor.visitChildren(self)



    def comparisonExpression(self):

        localctx = RegelSpraakParser.ComparisonExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 254, self.RULE_comparisonExpression)
        self._la = 0 # Token type
        try:
            self.state = 1554
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,183,self._ctx)
            if la_ == 1:
                localctx = RegelSpraakParser.SubordinateClauseExprContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1523
                self.subordinateClauseExpression()
                pass

            elif la_ == 2:
                localctx = RegelSpraakParser.PeriodeCheckExprContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1524
                self.periodevergelijkingElementair()
                pass

            elif la_ == 3:
                localctx = RegelSpraakParser.IsKenmerkExprContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 1525
                localctx.left = self.additiveExpression()
                self.state = 1526
                self.match(RegelSpraakParser.IS)
                self.state = 1527
                self.naamwoordWithNumbers()
                pass

            elif la_ == 4:
                localctx = RegelSpraakParser.HeeftKenmerkExprContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 1529
                localctx.left = self.additiveExpression()
                self.state = 1530
                self.match(RegelSpraakParser.HEEFT)
                self.state = 1531
                self.naamwoordWithNumbers()
                pass

            elif la_ == 5:
                localctx = RegelSpraakParser.GelijkIsAanOfExprContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 1533
                localctx.left = self.additiveExpression()
                self.state = 1534
                localctx.op = self.gelijkIsAanOperator()
                self.state = 1535
                localctx.firstValue = self.literalValue()
                self.state = 1540
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==278:
                    self.state = 1536
                    self.match(RegelSpraakParser.COMMA)
                    self.state = 1537
                    localctx._literalValue = self.literalValue()
                    localctx.middleValues.append(localctx._literalValue)
                    self.state = 1542
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 1543
                self.match(RegelSpraakParser.OF)
                self.state = 1544
                localctx.lastValue = self.literalValue()
                pass

            elif la_ == 6:
                localctx = RegelSpraakParser.BinaryComparisonExprContext(self, localctx)
                self.enterOuterAlt(localctx, 6)
                self.state = 1546
                localctx.left = self.additiveExpression()
                self.state = 1550
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,182,self._ctx)
                if la_ == 1:
                    self.state = 1547
                    self.comparisonOperator()
                    self.state = 1548
                    localctx.right = self.additiveExpression()


                pass

            elif la_ == 7:
                localctx = RegelSpraakParser.UnaryConditionExprContext(self, localctx)
                self.enterOuterAlt(localctx, 7)
                self.state = 1552
                self.unaryCondition()
                pass

            elif la_ == 8:
                localctx = RegelSpraakParser.RegelStatusConditionExprContext(self, localctx)
                self.enterOuterAlt(localctx, 8)
                self.state = 1553
                self.regelStatusCondition()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LiteralValueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ENUM_LITERAL(self):
            return self.getToken(RegelSpraakParser.ENUM_LITERAL, 0)

        def STRING_LITERAL(self):
            return self.getToken(RegelSpraakParser.STRING_LITERAL, 0)

        def NUMBER(self):
            return self.getToken(RegelSpraakParser.NUMBER, 0)

        def unitIdentifier(self):
            return self.getTypedRuleContext(RegelSpraakParser.UnitIdentifierContext,0)


        def PERCENTAGE_LITERAL(self):
            return self.getToken(RegelSpraakParser.PERCENTAGE_LITERAL, 0)

        def datumLiteral(self):
            return self.getTypedRuleContext(RegelSpraakParser.DatumLiteralContext,0)


        def identifier(self):
            return self.getTypedRuleContext(RegelSpraakParser.IdentifierContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_literalValue

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLiteralValue" ):
                listener.enterLiteralValue(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLiteralValue" ):
                listener.exitLiteralValue(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLiteralValue" ):
                return visitor.visitLiteralValue(self)
            else:
                return visitor.visitChildren(self)




    def literalValue(self):

        localctx = RegelSpraakParser.LiteralValueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 256, self.RULE_literalValue)
        try:
            self.state = 1565
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [273]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1556
                self.match(RegelSpraakParser.ENUM_LITERAL)
                pass
            elif token in [272]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1557
                self.match(RegelSpraakParser.STRING_LITERAL)
                pass
            elif token in [268]:
                self.enterOuterAlt(localctx, 3)
                self.state = 1558
                self.match(RegelSpraakParser.NUMBER)
                self.state = 1560
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,184,self._ctx)
                if la_ == 1:
                    self.state = 1559
                    self.unitIdentifier()


                pass
            elif token in [271]:
                self.enterOuterAlt(localctx, 4)
                self.state = 1562
                self.match(RegelSpraakParser.PERCENTAGE_LITERAL)
                pass
            elif token in [270]:
                self.enterOuterAlt(localctx, 5)
                self.state = 1563
                self.datumLiteral()
                pass
            elif token in [267]:
                self.enterOuterAlt(localctx, 6)
                self.state = 1564
                self.identifier()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GelijkIsAanOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GELIJK_IS_AAN(self):
            return self.getToken(RegelSpraakParser.GELIJK_IS_AAN, 0)

        def IS_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.IS_GELIJK_AAN, 0)

        def GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.GELIJK_AAN, 0)

        def ZIJN_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.ZIJN_GELIJK_AAN, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_gelijkIsAanOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGelijkIsAanOperator" ):
                listener.enterGelijkIsAanOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGelijkIsAanOperator" ):
                listener.exitGelijkIsAanOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGelijkIsAanOperator" ):
                return visitor.visitGelijkIsAanOperator(self)
            else:
                return visitor.visitChildren(self)




    def gelijkIsAanOperator(self):

        localctx = RegelSpraakParser.GelijkIsAanOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 258, self.RULE_gelijkIsAanOperator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1567
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 18436610974547968) != 0) or _la==128):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ComparisonOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.GELIJK_AAN, 0)

        def ONGELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.ONGELIJK_AAN, 0)

        def GELIJK_IS_AAN(self):
            return self.getToken(RegelSpraakParser.GELIJK_IS_AAN, 0)

        def GROTER_DAN(self):
            return self.getToken(RegelSpraakParser.GROTER_DAN, 0)

        def GROTER_OF_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.GROTER_OF_GELIJK_AAN, 0)

        def KLEINER_DAN(self):
            return self.getToken(RegelSpraakParser.KLEINER_DAN, 0)

        def KLEINER_OF_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.KLEINER_OF_GELIJK_AAN, 0)

        def KLEINER_IS_DAN(self):
            return self.getToken(RegelSpraakParser.KLEINER_IS_DAN, 0)

        def GROTER_IS_DAN(self):
            return self.getToken(RegelSpraakParser.GROTER_IS_DAN, 0)

        def IS(self):
            return self.getToken(RegelSpraakParser.IS, 0)

        def IN(self):
            return self.getToken(RegelSpraakParser.IN, 0)

        def LATER_DAN(self):
            return self.getToken(RegelSpraakParser.LATER_DAN, 0)

        def LATER_OF_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.LATER_OF_GELIJK_AAN, 0)

        def EERDER_DAN(self):
            return self.getToken(RegelSpraakParser.EERDER_DAN, 0)

        def EERDER_OF_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.EERDER_OF_GELIJK_AAN, 0)

        def NIET(self):
            return self.getToken(RegelSpraakParser.NIET, 0)

        def IS_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.IS_GELIJK_AAN, 0)

        def IS_ONGELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.IS_ONGELIJK_AAN, 0)

        def IS_KLEINER_DAN(self):
            return self.getToken(RegelSpraakParser.IS_KLEINER_DAN, 0)

        def IS_KLEINER_OF_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.IS_KLEINER_OF_GELIJK_AAN, 0)

        def IS_GROTER_DAN(self):
            return self.getToken(RegelSpraakParser.IS_GROTER_DAN, 0)

        def IS_GROTER_OF_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.IS_GROTER_OF_GELIJK_AAN, 0)

        def ZIJN_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.ZIJN_GELIJK_AAN, 0)

        def ZIJN_ONGELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.ZIJN_ONGELIJK_AAN, 0)

        def ZIJN_KLEINER_DAN(self):
            return self.getToken(RegelSpraakParser.ZIJN_KLEINER_DAN, 0)

        def ZIJN_KLEINER_OF_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.ZIJN_KLEINER_OF_GELIJK_AAN, 0)

        def ZIJN_GROTER_DAN(self):
            return self.getToken(RegelSpraakParser.ZIJN_GROTER_DAN, 0)

        def ZIJN_GROTER_OF_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.ZIJN_GROTER_OF_GELIJK_AAN, 0)

        def IS_LATER_DAN(self):
            return self.getToken(RegelSpraakParser.IS_LATER_DAN, 0)

        def IS_LATER_OF_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.IS_LATER_OF_GELIJK_AAN, 0)

        def IS_EERDER_DAN(self):
            return self.getToken(RegelSpraakParser.IS_EERDER_DAN, 0)

        def IS_EERDER_OF_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.IS_EERDER_OF_GELIJK_AAN, 0)

        def ZIJN_LATER_DAN(self):
            return self.getToken(RegelSpraakParser.ZIJN_LATER_DAN, 0)

        def ZIJN_LATER_OF_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.ZIJN_LATER_OF_GELIJK_AAN, 0)

        def ZIJN_EERDER_DAN(self):
            return self.getToken(RegelSpraakParser.ZIJN_EERDER_DAN, 0)

        def ZIJN_EERDER_OF_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.ZIJN_EERDER_OF_GELIJK_AAN, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_comparisonOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterComparisonOperator" ):
                listener.enterComparisonOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitComparisonOperator" ):
                listener.exitComparisonOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitComparisonOperator" ):
                return visitor.visitComparisonOperator(self)
            else:
                return visitor.visitChildren(self)




    def comparisonOperator(self):

        localctx = RegelSpraakParser.ComparisonOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 260, self.RULE_comparisonOperator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1569
            _la = self._input.LA(1)
            if not(((((_la - 22)) & ~0x3f) == 0 and ((1 << (_la - 22)) & 70368710819855) != 0) or ((((_la - 113)) & ~0x3f) == 0 and ((1 << (_la - 113)) & 674533377) != 0) or _la==220):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AdditiveExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.left = None # MultiplicativeExpressionContext
            self.right = None # MultiplicativeExpressionContext

        def multiplicativeExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.MultiplicativeExpressionContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.MultiplicativeExpressionContext,i)


        def additiveOperator(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.AdditiveOperatorContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.AdditiveOperatorContext,i)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_additiveExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAdditiveExpression" ):
                listener.enterAdditiveExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAdditiveExpression" ):
                listener.exitAdditiveExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAdditiveExpression" ):
                return visitor.visitAdditiveExpression(self)
            else:
                return visitor.visitChildren(self)




    def additiveExpression(self):

        localctx = RegelSpraakParser.AdditiveExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 262, self.RULE_additiveExpression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1571
            localctx.left = self.multiplicativeExpression()
            self.state = 1577
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,186,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 1572
                    self.additiveOperator()
                    self.state = 1573
                    localctx.right = self.multiplicativeExpression() 
                self.state = 1579
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,186,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AdditiveOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PLUS(self):
            return self.getToken(RegelSpraakParser.PLUS, 0)

        def MIN(self):
            return self.getToken(RegelSpraakParser.MIN, 0)

        def VERMINDERD_MET(self):
            return self.getToken(RegelSpraakParser.VERMINDERD_MET, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_additiveOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAdditiveOperator" ):
                listener.enterAdditiveOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAdditiveOperator" ):
                listener.exitAdditiveOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAdditiveOperator" ):
                return visitor.visitAdditiveOperator(self)
            else:
                return visitor.visitChildren(self)




    def additiveOperator(self):

        localctx = RegelSpraakParser.AdditiveOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 264, self.RULE_additiveOperator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1580
            _la = self._input.LA(1)
            if not(((((_la - 137)) & ~0x3f) == 0 and ((1 << (_la - 137)) & 32833) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MultiplicativeExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.left = None # PowerExpressionContext
            self.right = None # PowerExpressionContext

        def powerExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.PowerExpressionContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.PowerExpressionContext,i)


        def multiplicativeOperator(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.MultiplicativeOperatorContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.MultiplicativeOperatorContext,i)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_multiplicativeExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMultiplicativeExpression" ):
                listener.enterMultiplicativeExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMultiplicativeExpression" ):
                listener.exitMultiplicativeExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMultiplicativeExpression" ):
                return visitor.visitMultiplicativeExpression(self)
            else:
                return visitor.visitChildren(self)




    def multiplicativeExpression(self):

        localctx = RegelSpraakParser.MultiplicativeExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 266, self.RULE_multiplicativeExpression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1582
            localctx.left = self.powerExpression()
            self.state = 1588
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,187,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 1583
                    self.multiplicativeOperator()
                    self.state = 1584
                    localctx.right = self.powerExpression() 
                self.state = 1590
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,187,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MultiplicativeOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MAAL(self):
            return self.getToken(RegelSpraakParser.MAAL, 0)

        def GEDEELD_DOOR(self):
            return self.getToken(RegelSpraakParser.GEDEELD_DOOR, 0)

        def GEDEELD_DOOR_ABS(self):
            return self.getToken(RegelSpraakParser.GEDEELD_DOOR_ABS, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_multiplicativeOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMultiplicativeOperator" ):
                listener.enterMultiplicativeOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMultiplicativeOperator" ):
                listener.exitMultiplicativeOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMultiplicativeOperator" ):
                return visitor.visitMultiplicativeOperator(self)
            else:
                return visitor.visitChildren(self)




    def multiplicativeOperator(self):

        localctx = RegelSpraakParser.MultiplicativeOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 268, self.RULE_multiplicativeOperator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1591
            _la = self._input.LA(1)
            if not(((((_la - 126)) & ~0x3f) == 0 and ((1 << (_la - 126)) & 1027) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PowerExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.left = None # PrimaryExpressionContext
            self.right = None # PrimaryExpressionContext

        def primaryExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.PrimaryExpressionContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,i)


        def powerOperator(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.PowerOperatorContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.PowerOperatorContext,i)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_powerExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPowerExpression" ):
                listener.enterPowerExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPowerExpression" ):
                listener.exitPowerExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPowerExpression" ):
                return visitor.visitPowerExpression(self)
            else:
                return visitor.visitChildren(self)




    def powerExpression(self):

        localctx = RegelSpraakParser.PowerExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 270, self.RULE_powerExpression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1593
            localctx.left = self.primaryExpression(0)
            self.state = 1599
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,188,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 1594
                    self.powerOperator()
                    self.state = 1595
                    localctx.right = self.primaryExpression(0) 
                self.state = 1601
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,188,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PowerOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TOT_DE_MACHT(self):
            return self.getToken(RegelSpraakParser.TOT_DE_MACHT, 0)

        def CARET(self):
            return self.getToken(RegelSpraakParser.CARET, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_powerOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPowerOperator" ):
                listener.enterPowerOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPowerOperator" ):
                listener.exitPowerOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPowerOperator" ):
                return visitor.visitPowerOperator(self)
            else:
                return visitor.visitChildren(self)




    def powerOperator(self):

        localctx = RegelSpraakParser.PowerOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 272, self.RULE_powerOperator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1602
            _la = self._input.LA(1)
            if not(_la==147 or _la==288):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PrimaryExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_primaryExpression

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)


    class WortelFuncExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def DE_WORTEL_VAN(self):
            return self.getToken(RegelSpraakParser.DE_WORTEL_VAN, 0)
        def primaryExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWortelFuncExpr" ):
                listener.enterWortelFuncExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWortelFuncExpr" ):
                listener.exitWortelFuncExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitWortelFuncExpr" ):
                return visitor.visitWortelFuncExpr(self)
            else:
                return visitor.visitChildren(self)


    class BooleanTrueLiteralExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def WAAR(self):
            return self.getToken(RegelSpraakParser.WAAR, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBooleanTrueLiteralExpr" ):
                listener.enterBooleanTrueLiteralExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBooleanTrueLiteralExpr" ):
                listener.exitBooleanTrueLiteralExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBooleanTrueLiteralExpr" ):
                return visitor.visitBooleanTrueLiteralExpr(self)
            else:
                return visitor.visitChildren(self)


    class AbsValFuncExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def DE_ABSOLUTE_WAARDE_VAN(self):
            return self.getToken(RegelSpraakParser.DE_ABSOLUTE_WAARDE_VAN, 0)
        def LPAREN(self):
            return self.getToken(RegelSpraakParser.LPAREN, 0)
        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)

        def RPAREN(self):
            return self.getToken(RegelSpraakParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAbsValFuncExpr" ):
                listener.enterAbsValFuncExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAbsValFuncExpr" ):
                listener.exitAbsValFuncExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAbsValFuncExpr" ):
                return visitor.visitAbsValFuncExpr(self)
            else:
                return visitor.visitChildren(self)


    class MaxValFuncExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def DE_MAXIMALE_WAARDE_VAN(self):
            return self.getToken(RegelSpraakParser.DE_MAXIMALE_WAARDE_VAN, 0)
        def primaryExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.PrimaryExpressionContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,i)

        def EN(self):
            return self.getToken(RegelSpraakParser.EN, 0)
        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.COMMA)
            else:
                return self.getToken(RegelSpraakParser.COMMA, i)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMaxValFuncExpr" ):
                listener.enterMaxValFuncExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMaxValFuncExpr" ):
                listener.exitMaxValFuncExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMaxValFuncExpr" ):
                return visitor.visitMaxValFuncExpr(self)
            else:
                return visitor.visitChildren(self)


    class RekendatumKeywordExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def REKENDATUM(self):
            return self.getToken(RegelSpraakParser.REKENDATUM, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRekendatumKeywordExpr" ):
                listener.enterRekendatumKeywordExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRekendatumKeywordExpr" ):
                listener.exitRekendatumKeywordExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRekendatumKeywordExpr" ):
                return visitor.visitRekendatumKeywordExpr(self)
            else:
                return visitor.visitChildren(self)


    class EnumLiteralExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ENUM_LITERAL(self):
            return self.getToken(RegelSpraakParser.ENUM_LITERAL, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEnumLiteralExpr" ):
                listener.enterEnumLiteralExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEnumLiteralExpr" ):
                listener.exitEnumLiteralExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEnumLiteralExpr" ):
                return visitor.visitEnumLiteralExpr(self)
            else:
                return visitor.visitChildren(self)


    class NumberLiteralExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def NUMBER(self):
            return self.getToken(RegelSpraakParser.NUMBER, 0)
        def unitIdentifier(self):
            return self.getTypedRuleContext(RegelSpraakParser.UnitIdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumberLiteralExpr" ):
                listener.enterNumberLiteralExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumberLiteralExpr" ):
                listener.exitNumberLiteralExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNumberLiteralExpr" ):
                return visitor.visitNumberLiteralExpr(self)
            else:
                return visitor.visitChildren(self)


    class DatumLiteralExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def datumLiteral(self):
            return self.getTypedRuleContext(RegelSpraakParser.DatumLiteralContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDatumLiteralExpr" ):
                listener.enterDatumLiteralExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDatumLiteralExpr" ):
                listener.exitDatumLiteralExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDatumLiteralExpr" ):
                return visitor.visitDatumLiteralExpr(self)
            else:
                return visitor.visitChildren(self)


    class AantalFuncExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def aggregationSubject(self):
            return self.getTypedRuleContext(RegelSpraakParser.AggregationSubjectContext,0)

        def HET(self):
            return self.getToken(RegelSpraakParser.HET, 0)
        def AANTAL(self):
            return self.getToken(RegelSpraakParser.AANTAL, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAantalFuncExpr" ):
                listener.enterAantalFuncExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAantalFuncExpr" ):
                listener.exitAantalFuncExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAantalFuncExpr" ):
                return visitor.visitAantalFuncExpr(self)
            else:
                return visitor.visitChildren(self)


    class UnaryNietExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def NIET(self):
            return self.getToken(RegelSpraakParser.NIET, 0)
        def primaryExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnaryNietExpr" ):
                listener.enterUnaryNietExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnaryNietExpr" ):
                listener.exitUnaryNietExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnaryNietExpr" ):
                return visitor.visitUnaryNietExpr(self)
            else:
                return visitor.visitChildren(self)


    class ConcatenatieExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def CONCATENATIE_VAN(self):
            return self.getToken(RegelSpraakParser.CONCATENATIE_VAN, 0)
        def primaryExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.PrimaryExpressionContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,i)

        def EN(self):
            return self.getToken(RegelSpraakParser.EN, 0)
        def OF(self):
            return self.getToken(RegelSpraakParser.OF, 0)
        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.COMMA)
            else:
                return self.getToken(RegelSpraakParser.COMMA, i)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConcatenatieExpr" ):
                listener.enterConcatenatieExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConcatenatieExpr" ):
                listener.exitConcatenatieExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConcatenatieExpr" ):
                return visitor.visitConcatenatieExpr(self)
            else:
                return visitor.visitChildren(self)


    class SomAlleAttribuutExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def SOM_VAN(self):
            return self.getToken(RegelSpraakParser.SOM_VAN, 0)
        def ALLE(self):
            return self.getToken(RegelSpraakParser.ALLE, 0)
        def attribuutReferentie(self):
            return self.getTypedRuleContext(RegelSpraakParser.AttribuutReferentieContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSomAlleAttribuutExpr" ):
                listener.enterSomAlleAttribuutExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSomAlleAttribuutExpr" ):
                listener.exitSomAlleAttribuutExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSomAlleAttribuutExpr" ):
                return visitor.visitSomAlleAttribuutExpr(self)
            else:
                return visitor.visitChildren(self)


    class AttrRefExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def attribuutReferentie(self):
            return self.getTypedRuleContext(RegelSpraakParser.AttribuutReferentieContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAttrRefExpr" ):
                listener.enterAttrRefExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAttrRefExpr" ):
                listener.exitAttrRefExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAttrRefExpr" ):
                return visitor.visitAttrRefExpr(self)
            else:
                return visitor.visitChildren(self)


    class DagUitFuncExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def DE(self):
            return self.getToken(RegelSpraakParser.DE, 0)
        def DAG(self):
            return self.getToken(RegelSpraakParser.DAG, 0)
        def UIT(self):
            return self.getToken(RegelSpraakParser.UIT, 0)
        def primaryExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDagUitFuncExpr" ):
                listener.enterDagUitFuncExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDagUitFuncExpr" ):
                listener.exitDagUitFuncExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDagUitFuncExpr" ):
                return visitor.visitDagUitFuncExpr(self)
            else:
                return visitor.visitChildren(self)


    class BegrenzingExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def primaryExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,0)

        def COMMA(self):
            return self.getToken(RegelSpraakParser.COMMA, 0)
        def begrenzing(self):
            return self.getTypedRuleContext(RegelSpraakParser.BegrenzingContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBegrenzingExpr" ):
                listener.enterBegrenzingExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBegrenzingExpr" ):
                listener.exitBegrenzingExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBegrenzingExpr" ):
                return visitor.visitBegrenzingExpr(self)
            else:
                return visitor.visitChildren(self)


    class NaamwoordExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNaamwoordExpr" ):
                listener.enterNaamwoordExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNaamwoordExpr" ):
                listener.exitNaamwoordExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNaamwoordExpr" ):
                return visitor.visitNaamwoordExpr(self)
            else:
                return visitor.visitChildren(self)


    class BooleanFalseLiteralExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ONWAAR(self):
            return self.getToken(RegelSpraakParser.ONWAAR, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBooleanFalseLiteralExpr" ):
                listener.enterBooleanFalseLiteralExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBooleanFalseLiteralExpr" ):
                listener.exitBooleanFalseLiteralExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBooleanFalseLiteralExpr" ):
                return visitor.visitBooleanFalseLiteralExpr(self)
            else:
                return visitor.visitChildren(self)


    class JaarUitFuncExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def HET(self):
            return self.getToken(RegelSpraakParser.HET, 0)
        def JAAR(self):
            return self.getToken(RegelSpraakParser.JAAR, 0)
        def UIT(self):
            return self.getToken(RegelSpraakParser.UIT, 0)
        def primaryExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterJaarUitFuncExpr" ):
                listener.enterJaarUitFuncExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitJaarUitFuncExpr" ):
                listener.exitJaarUitFuncExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitJaarUitFuncExpr" ):
                return visitor.visitJaarUitFuncExpr(self)
            else:
                return visitor.visitChildren(self)


    class TotaalVanExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def HET_TOTAAL_VAN(self):
            return self.getToken(RegelSpraakParser.HET_TOTAAL_VAN, 0)
        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)

        def conditieBijExpressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ConditieBijExpressieContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTotaalVanExpr" ):
                listener.enterTotaalVanExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTotaalVanExpr" ):
                listener.exitTotaalVanExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTotaalVanExpr" ):
                return visitor.visitTotaalVanExpr(self)
            else:
                return visitor.visitChildren(self)


    class TijdsevenredigDeelExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def HET_TIJDSEVENREDIG_DEEL_PER(self):
            return self.getToken(RegelSpraakParser.HET_TIJDSEVENREDIG_DEEL_PER, 0)
        def VAN(self):
            return self.getToken(RegelSpraakParser.VAN, 0)
        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)

        def MAAND(self):
            return self.getToken(RegelSpraakParser.MAAND, 0)
        def JAAR(self):
            return self.getToken(RegelSpraakParser.JAAR, 0)
        def conditieBijExpressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ConditieBijExpressieContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTijdsevenredigDeelExpr" ):
                listener.enterTijdsevenredigDeelExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTijdsevenredigDeelExpr" ):
                listener.exitTijdsevenredigDeelExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTijdsevenredigDeelExpr" ):
                return visitor.visitTijdsevenredigDeelExpr(self)
            else:
                return visitor.visitChildren(self)


    class CapitalizedTijdsevenredigDeelExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def HET_TIJDSEVENREDIG_DEEL_PER(self):
            return self.getToken(RegelSpraakParser.HET_TIJDSEVENREDIG_DEEL_PER, 0)
        def VAN(self):
            return self.getToken(RegelSpraakParser.VAN, 0)
        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)

        def MAAND(self):
            return self.getToken(RegelSpraakParser.MAAND, 0)
        def JAAR(self):
            return self.getToken(RegelSpraakParser.JAAR, 0)
        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.IdentifierContext,i)

        def conditieBijExpressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ConditieBijExpressieContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCapitalizedTijdsevenredigDeelExpr" ):
                listener.enterCapitalizedTijdsevenredigDeelExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCapitalizedTijdsevenredigDeelExpr" ):
                listener.exitCapitalizedTijdsevenredigDeelExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCapitalizedTijdsevenredigDeelExpr" ):
                return visitor.visitCapitalizedTijdsevenredigDeelExpr(self)
            else:
                return visitor.visitChildren(self)


    class AantalAttribuutExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def HET(self):
            return self.getToken(RegelSpraakParser.HET, 0)
        def AANTAL(self):
            return self.getToken(RegelSpraakParser.AANTAL, 0)
        def attribuutReferentie(self):
            return self.getTypedRuleContext(RegelSpraakParser.AttribuutReferentieContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAantalAttribuutExpr" ):
                listener.enterAantalAttribuutExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAantalAttribuutExpr" ):
                listener.exitAantalAttribuutExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAantalAttribuutExpr" ):
                return visitor.visitAantalAttribuutExpr(self)
            else:
                return visitor.visitChildren(self)


    class ParenExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(RegelSpraakParser.LPAREN, 0)
        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)

        def RPAREN(self):
            return self.getToken(RegelSpraakParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParenExpr" ):
                listener.enterParenExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParenExpr" ):
                listener.exitParenExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParenExpr" ):
                return visitor.visitParenExpr(self)
            else:
                return visitor.visitChildren(self)


    class DimensieRangeAggExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def VANAF(self):
            return self.getToken(RegelSpraakParser.VANAF, 0)
        def naamwoord(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.NaamwoordContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,i)

        def TM(self):
            return self.getToken(RegelSpraakParser.TM, 0)
        def getalAggregatieFunctie(self):
            return self.getTypedRuleContext(RegelSpraakParser.GetalAggregatieFunctieContext,0)

        def datumAggregatieFunctie(self):
            return self.getTypedRuleContext(RegelSpraakParser.DatumAggregatieFunctieContext,0)

        def bezieldeReferentie(self):
            return self.getTypedRuleContext(RegelSpraakParser.BezieldeReferentieContext,0)

        def attribuutReferentie(self):
            return self.getTypedRuleContext(RegelSpraakParser.AttribuutReferentieContext,0)

        def DOT(self):
            return self.getToken(RegelSpraakParser.DOT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDimensieRangeAggExpr" ):
                listener.enterDimensieRangeAggExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDimensieRangeAggExpr" ):
                listener.exitDimensieRangeAggExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDimensieRangeAggExpr" ):
                return visitor.visitDimensieRangeAggExpr(self)
            else:
                return visitor.visitChildren(self)


    class DatumMetFuncExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def DE_DATUM_MET(self):
            return self.getToken(RegelSpraakParser.DE_DATUM_MET, 0)
        def LPAREN(self):
            return self.getToken(RegelSpraakParser.LPAREN, 0)
        def primaryExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.PrimaryExpressionContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,i)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.COMMA)
            else:
                return self.getToken(RegelSpraakParser.COMMA, i)
        def RPAREN(self):
            return self.getToken(RegelSpraakParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDatumMetFuncExpr" ):
                listener.enterDatumMetFuncExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDatumMetFuncExpr" ):
                listener.exitDatumMetFuncExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDatumMetFuncExpr" ):
                return visitor.visitDatumMetFuncExpr(self)
            else:
                return visitor.visitChildren(self)


    class PercentageLiteralExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def PERCENTAGE_LITERAL(self):
            return self.getToken(RegelSpraakParser.PERCENTAGE_LITERAL, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPercentageLiteralExpr" ):
                listener.enterPercentageLiteralExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPercentageLiteralExpr" ):
                listener.exitPercentageLiteralExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPercentageLiteralExpr" ):
                return visitor.visitPercentageLiteralExpr(self)
            else:
                return visitor.visitChildren(self)


    class StringLiteralExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def STRING_LITERAL(self):
            return self.getToken(RegelSpraakParser.STRING_LITERAL, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStringLiteralExpr" ):
                listener.enterStringLiteralExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStringLiteralExpr" ):
                listener.exitStringLiteralExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStringLiteralExpr" ):
                return visitor.visitStringLiteralExpr(self)
            else:
                return visitor.visitChildren(self)


    class PercentageFuncExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.p = None # Token
            self.copyFrom(ctx)

        def VAN(self):
            return self.getToken(RegelSpraakParser.VAN, 0)
        def primaryExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,0)

        def NUMBER(self):
            return self.getToken(RegelSpraakParser.NUMBER, 0)
        def PERCENTAGE_LITERAL(self):
            return self.getToken(RegelSpraakParser.PERCENTAGE_LITERAL, 0)
        def PERCENT_SIGN(self):
            return self.getToken(RegelSpraakParser.PERCENT_SIGN, 0)
        def IDENTIFIER(self):
            return self.getToken(RegelSpraakParser.IDENTIFIER, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPercentageFuncExpr" ):
                listener.enterPercentageFuncExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPercentageFuncExpr" ):
                listener.exitPercentageFuncExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPercentageFuncExpr" ):
                return visitor.visitPercentageFuncExpr(self)
            else:
                return visitor.visitChildren(self)


    class EersteDatumFuncExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def EERSTE_VAN(self):
            return self.getToken(RegelSpraakParser.EERSTE_VAN, 0)
        def primaryExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.PrimaryExpressionContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,i)

        def EN(self):
            return self.getToken(RegelSpraakParser.EN, 0)
        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.COMMA)
            else:
                return self.getToken(RegelSpraakParser.COMMA, i)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEersteDatumFuncExpr" ):
                listener.enterEersteDatumFuncExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEersteDatumFuncExpr" ):
                listener.exitEersteDatumFuncExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEersteDatumFuncExpr" ):
                return visitor.visitEersteDatumFuncExpr(self)
            else:
                return visitor.visitChildren(self)


    class PasenFuncExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def DE_EERSTE_PAASDAG_VAN(self):
            return self.getToken(RegelSpraakParser.DE_EERSTE_PAASDAG_VAN, 0)
        def LPAREN(self):
            return self.getToken(RegelSpraakParser.LPAREN, 0)
        def primaryExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,0)

        def RPAREN(self):
            return self.getToken(RegelSpraakParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPasenFuncExpr" ):
                listener.enterPasenFuncExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPasenFuncExpr" ):
                listener.exitPasenFuncExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPasenFuncExpr" ):
                return visitor.visitPasenFuncExpr(self)
            else:
                return visitor.visitChildren(self)


    class AbsTijdsduurFuncExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def DE_ABSOLUTE_TIJDSDUUR_VAN(self):
            return self.getToken(RegelSpraakParser.DE_ABSOLUTE_TIJDSDUUR_VAN, 0)
        def primaryExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.PrimaryExpressionContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,i)

        def TOT(self):
            return self.getToken(RegelSpraakParser.TOT, 0)
        def IN_HELE(self):
            return self.getToken(RegelSpraakParser.IN_HELE, 0)
        def unitIdentifier(self):
            return self.getTypedRuleContext(RegelSpraakParser.UnitIdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAbsTijdsduurFuncExpr" ):
                listener.enterAbsTijdsduurFuncExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAbsTijdsduurFuncExpr" ):
                listener.exitAbsTijdsduurFuncExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAbsTijdsduurFuncExpr" ):
                return visitor.visitAbsTijdsduurFuncExpr(self)
            else:
                return visitor.visitChildren(self)


    class MaandUitFuncExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def DE(self):
            return self.getToken(RegelSpraakParser.DE, 0)
        def MAAND(self):
            return self.getToken(RegelSpraakParser.MAAND, 0)
        def UIT(self):
            return self.getToken(RegelSpraakParser.UIT, 0)
        def primaryExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMaandUitFuncExpr" ):
                listener.enterMaandUitFuncExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMaandUitFuncExpr" ):
                listener.exitMaandUitFuncExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMaandUitFuncExpr" ):
                return visitor.visitMaandUitFuncExpr(self)
            else:
                return visitor.visitChildren(self)


    class CapitalizedTotaalVanExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def HET_TOTAAL_VAN(self):
            return self.getToken(RegelSpraakParser.HET_TOTAAL_VAN, 0)
        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)

        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.IdentifierContext,i)

        def conditieBijExpressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ConditieBijExpressieContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCapitalizedTotaalVanExpr" ):
                listener.enterCapitalizedTotaalVanExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCapitalizedTotaalVanExpr" ):
                listener.exitCapitalizedTotaalVanExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCapitalizedTotaalVanExpr" ):
                return visitor.visitCapitalizedTotaalVanExpr(self)
            else:
                return visitor.visitChildren(self)


    class IdentifierExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(RegelSpraakParser.IdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIdentifierExpr" ):
                listener.enterIdentifierExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIdentifierExpr" ):
                listener.exitIdentifierExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIdentifierExpr" ):
                return visitor.visitIdentifierExpr(self)
            else:
                return visitor.visitChildren(self)


    class DimensieAggExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def attribuutMetLidwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.AttribuutMetLidwoordContext,0)

        def dimensieSelectie(self):
            return self.getTypedRuleContext(RegelSpraakParser.DimensieSelectieContext,0)

        def getalAggregatieFunctie(self):
            return self.getTypedRuleContext(RegelSpraakParser.GetalAggregatieFunctieContext,0)

        def datumAggregatieFunctie(self):
            return self.getTypedRuleContext(RegelSpraakParser.DatumAggregatieFunctieContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDimensieAggExpr" ):
                listener.enterDimensieAggExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDimensieAggExpr" ):
                listener.exitDimensieAggExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDimensieAggExpr" ):
                return visitor.visitDimensieAggExpr(self)
            else:
                return visitor.visitChildren(self)


    class TijdsduurFuncExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def TIJDSDUUR_VAN(self):
            return self.getToken(RegelSpraakParser.TIJDSDUUR_VAN, 0)
        def primaryExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.PrimaryExpressionContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,i)

        def TOT(self):
            return self.getToken(RegelSpraakParser.TOT, 0)
        def IN_HELE(self):
            return self.getToken(RegelSpraakParser.IN_HELE, 0)
        def unitIdentifier(self):
            return self.getTypedRuleContext(RegelSpraakParser.UnitIdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTijdsduurFuncExpr" ):
                listener.enterTijdsduurFuncExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTijdsduurFuncExpr" ):
                listener.exitTijdsduurFuncExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTijdsduurFuncExpr" ):
                return visitor.visitTijdsduurFuncExpr(self)
            else:
                return visitor.visitChildren(self)


    class OnderwerpRefExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def onderwerpReferentie(self):
            return self.getTypedRuleContext(RegelSpraakParser.OnderwerpReferentieContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOnderwerpRefExpr" ):
                listener.enterOnderwerpRefExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOnderwerpRefExpr" ):
                listener.exitOnderwerpRefExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOnderwerpRefExpr" ):
                return visitor.visitOnderwerpRefExpr(self)
            else:
                return visitor.visitChildren(self)


    class SomFuncExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def SOM_VAN(self):
            return self.getToken(RegelSpraakParser.SOM_VAN, 0)
        def primaryExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.PrimaryExpressionContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,i)

        def EN(self):
            return self.getToken(RegelSpraakParser.EN, 0)
        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.COMMA)
            else:
                return self.getToken(RegelSpraakParser.COMMA, i)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSomFuncExpr" ):
                listener.enterSomFuncExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSomFuncExpr" ):
                listener.exitSomFuncExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSomFuncExpr" ):
                return visitor.visitSomFuncExpr(self)
            else:
                return visitor.visitChildren(self)


    class SomAlleExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def SOM_VAN(self):
            return self.getToken(RegelSpraakParser.SOM_VAN, 0)
        def ALLE(self):
            return self.getToken(RegelSpraakParser.ALLE, 0)
        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSomAlleExpr" ):
                listener.enterSomAlleExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSomAlleExpr" ):
                listener.exitSomAlleExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSomAlleExpr" ):
                return visitor.visitSomAlleExpr(self)
            else:
                return visitor.visitChildren(self)


    class SimpleConcatenatieExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def primaryExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.PrimaryExpressionContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,i)

        def EN(self):
            return self.getToken(RegelSpraakParser.EN, 0)
        def OF(self):
            return self.getToken(RegelSpraakParser.OF, 0)
        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.COMMA)
            else:
                return self.getToken(RegelSpraakParser.COMMA, i)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSimpleConcatenatieExpr" ):
                listener.enterSimpleConcatenatieExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSimpleConcatenatieExpr" ):
                listener.exitSimpleConcatenatieExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSimpleConcatenatieExpr" ):
                return visitor.visitSimpleConcatenatieExpr(self)
            else:
                return visitor.visitChildren(self)


    class BegrenzingAfrondingExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def primaryExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,0)

        def COMMA(self):
            return self.getToken(RegelSpraakParser.COMMA, 0)
        def begrenzing(self):
            return self.getTypedRuleContext(RegelSpraakParser.BegrenzingContext,0)

        def afronding(self):
            return self.getTypedRuleContext(RegelSpraakParser.AfrondingContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBegrenzingAfrondingExpr" ):
                listener.enterBegrenzingAfrondingExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBegrenzingAfrondingExpr" ):
                listener.exitBegrenzingAfrondingExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBegrenzingAfrondingExpr" ):
                return visitor.visitBegrenzingAfrondingExpr(self)
            else:
                return visitor.visitChildren(self)


    class PercentageOfExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def PERCENTAGE_LITERAL(self):
            return self.getToken(RegelSpraakParser.PERCENTAGE_LITERAL, 0)
        def VAN(self):
            return self.getToken(RegelSpraakParser.VAN, 0)
        def primaryExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPercentageOfExpr" ):
                listener.enterPercentageOfExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPercentageOfExpr" ):
                listener.exitPercentageOfExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPercentageOfExpr" ):
                return visitor.visitPercentageOfExpr(self)
            else:
                return visitor.visitChildren(self)


    class MinValFuncExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def DE_MINIMALE_WAARDE_VAN(self):
            return self.getToken(RegelSpraakParser.DE_MINIMALE_WAARDE_VAN, 0)
        def primaryExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.PrimaryExpressionContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,i)

        def EN(self):
            return self.getToken(RegelSpraakParser.EN, 0)
        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.COMMA)
            else:
                return self.getToken(RegelSpraakParser.COMMA, i)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMinValFuncExpr" ):
                listener.enterMinValFuncExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMinValFuncExpr" ):
                listener.exitMinValFuncExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMinValFuncExpr" ):
                return visitor.visitMinValFuncExpr(self)
            else:
                return visitor.visitChildren(self)


    class MaxAlleAttribuutExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def DE_MAXIMALE_WAARDE_VAN(self):
            return self.getToken(RegelSpraakParser.DE_MAXIMALE_WAARDE_VAN, 0)
        def ALLE(self):
            return self.getToken(RegelSpraakParser.ALLE, 0)
        def attribuutReferentie(self):
            return self.getTypedRuleContext(RegelSpraakParser.AttribuutReferentieContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMaxAlleAttribuutExpr" ):
                listener.enterMaxAlleAttribuutExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMaxAlleAttribuutExpr" ):
                listener.exitMaxAlleAttribuutExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMaxAlleAttribuutExpr" ):
                return visitor.visitMaxAlleAttribuutExpr(self)
            else:
                return visitor.visitChildren(self)


    class DateCalcExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def datumExpressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.DatumExpressieContext,0)

        def primaryExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,0)

        def timeUnit(self):
            return self.getTypedRuleContext(RegelSpraakParser.TimeUnitContext,0)

        def PLUS(self):
            return self.getToken(RegelSpraakParser.PLUS, 0)
        def MIN(self):
            return self.getToken(RegelSpraakParser.MIN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDateCalcExpr" ):
                listener.enterDateCalcExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDateCalcExpr" ):
                listener.exitDateCalcExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDateCalcExpr" ):
                return visitor.visitDateCalcExpr(self)
            else:
                return visitor.visitChildren(self)


    class BezieldeRefExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def bezieldeReferentie(self):
            return self.getTypedRuleContext(RegelSpraakParser.BezieldeReferentieContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBezieldeRefExpr" ):
                listener.enterBezieldeRefExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBezieldeRefExpr" ):
                listener.exitBezieldeRefExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBezieldeRefExpr" ):
                return visitor.visitBezieldeRefExpr(self)
            else:
                return visitor.visitChildren(self)


    class MinAlleAttribuutExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def DE_MINIMALE_WAARDE_VAN(self):
            return self.getToken(RegelSpraakParser.DE_MINIMALE_WAARDE_VAN, 0)
        def ALLE(self):
            return self.getToken(RegelSpraakParser.ALLE, 0)
        def attribuutReferentie(self):
            return self.getTypedRuleContext(RegelSpraakParser.AttribuutReferentieContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMinAlleAttribuutExpr" ):
                listener.enterMinAlleAttribuutExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMinAlleAttribuutExpr" ):
                listener.exitMinAlleAttribuutExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMinAlleAttribuutExpr" ):
                return visitor.visitMinAlleAttribuutExpr(self)
            else:
                return visitor.visitChildren(self)


    class AfrondingExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def primaryExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,0)

        def afronding(self):
            return self.getTypedRuleContext(RegelSpraakParser.AfrondingContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAfrondingExpr" ):
                listener.enterAfrondingExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAfrondingExpr" ):
                listener.exitAfrondingExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAfrondingExpr" ):
                return visitor.visitAfrondingExpr(self)
            else:
                return visitor.visitChildren(self)


    class LaatsteDatumFuncExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LAATSTE_VAN(self):
            return self.getToken(RegelSpraakParser.LAATSTE_VAN, 0)
        def primaryExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.PrimaryExpressionContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,i)

        def EN(self):
            return self.getToken(RegelSpraakParser.EN, 0)
        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.COMMA)
            else:
                return self.getToken(RegelSpraakParser.COMMA, i)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLaatsteDatumFuncExpr" ):
                listener.enterLaatsteDatumFuncExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLaatsteDatumFuncExpr" ):
                listener.exitLaatsteDatumFuncExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLaatsteDatumFuncExpr" ):
                return visitor.visitLaatsteDatumFuncExpr(self)
            else:
                return visitor.visitChildren(self)


    class HetAantalDagenInExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def HET(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.HET)
            else:
                return self.getToken(RegelSpraakParser.HET, i)
        def AANTAL(self):
            return self.getToken(RegelSpraakParser.AANTAL, 0)
        def DAGEN(self):
            return self.getToken(RegelSpraakParser.DAGEN, 0)
        def IN(self):
            return self.getToken(RegelSpraakParser.IN, 0)
        def DAT(self):
            return self.getToken(RegelSpraakParser.DAT, 0)
        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)

        def MAAND(self):
            return self.getToken(RegelSpraakParser.MAAND, 0)
        def JAAR(self):
            return self.getToken(RegelSpraakParser.JAAR, 0)
        def DE(self):
            return self.getToken(RegelSpraakParser.DE, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterHetAantalDagenInExpr" ):
                listener.enterHetAantalDagenInExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitHetAantalDagenInExpr" ):
                listener.exitHetAantalDagenInExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitHetAantalDagenInExpr" ):
                return visitor.visitHetAantalDagenInExpr(self)
            else:
                return visitor.visitChildren(self)


    class UnaryMinusExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def MIN(self):
            return self.getToken(RegelSpraakParser.MIN, 0)
        def primaryExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,0)

        def MINUS(self):
            return self.getToken(RegelSpraakParser.MINUS, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnaryMinusExpr" ):
                listener.enterUnaryMinusExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnaryMinusExpr" ):
                listener.exitUnaryMinusExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnaryMinusExpr" ):
                return visitor.visitUnaryMinusExpr(self)
            else:
                return visitor.visitChildren(self)


    class ParamRefExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def parameterMetLidwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.ParameterMetLidwoordContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParamRefExpr" ):
                listener.enterParamRefExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParamRefExpr" ):
                listener.exitParamRefExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParamRefExpr" ):
                return visitor.visitParamRefExpr(self)
            else:
                return visitor.visitChildren(self)


    class PronounExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def HIJ(self):
            return self.getToken(RegelSpraakParser.HIJ, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPronounExpr" ):
                listener.enterPronounExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPronounExpr" ):
                listener.exitPronounExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPronounExpr" ):
                return visitor.visitPronounExpr(self)
            else:
                return visitor.visitChildren(self)



    def primaryExpression(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = RegelSpraakParser.PrimaryExpressionContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 274
        self.enterRecursionRule(localctx, 274, self.RULE_primaryExpression, _p)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1867
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,214,self._ctx)
            if la_ == 1:
                localctx = RegelSpraakParser.UnaryMinusExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx

                self.state = 1605
                self.match(RegelSpraakParser.MIN)
                self.state = 1606
                self.primaryExpression(55)
                pass

            elif la_ == 2:
                localctx = RegelSpraakParser.UnaryMinusExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1607
                self.match(RegelSpraakParser.MINUS)
                self.state = 1608
                self.primaryExpression(54)
                pass

            elif la_ == 3:
                localctx = RegelSpraakParser.UnaryNietExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1609
                self.match(RegelSpraakParser.NIET)
                self.state = 1610
                self.primaryExpression(53)
                pass

            elif la_ == 4:
                localctx = RegelSpraakParser.AbsTijdsduurFuncExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1611
                self.match(RegelSpraakParser.DE_ABSOLUTE_TIJDSDUUR_VAN)
                self.state = 1612
                self.primaryExpression(0)
                self.state = 1613
                self.match(RegelSpraakParser.TOT)
                self.state = 1614
                self.primaryExpression(0)
                self.state = 1617
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,189,self._ctx)
                if la_ == 1:
                    self.state = 1615
                    self.match(RegelSpraakParser.IN_HELE)
                    self.state = 1616
                    self.unitIdentifier()


                pass

            elif la_ == 5:
                localctx = RegelSpraakParser.TijdsduurFuncExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1619
                self.match(RegelSpraakParser.TIJDSDUUR_VAN)
                self.state = 1620
                self.primaryExpression(0)
                self.state = 1621
                self.match(RegelSpraakParser.TOT)
                self.state = 1622
                self.primaryExpression(0)
                self.state = 1625
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,190,self._ctx)
                if la_ == 1:
                    self.state = 1623
                    self.match(RegelSpraakParser.IN_HELE)
                    self.state = 1624
                    self.unitIdentifier()


                pass

            elif la_ == 6:
                localctx = RegelSpraakParser.SomFuncExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1627
                self.match(RegelSpraakParser.SOM_VAN)
                self.state = 1628
                self.primaryExpression(0)
                self.state = 1633
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==278:
                    self.state = 1629
                    self.match(RegelSpraakParser.COMMA)
                    self.state = 1630
                    self.primaryExpression(0)
                    self.state = 1635
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 1636
                self.match(RegelSpraakParser.EN)
                self.state = 1637
                self.primaryExpression(50)
                pass

            elif la_ == 7:
                localctx = RegelSpraakParser.SomAlleExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1639
                self.match(RegelSpraakParser.SOM_VAN)
                self.state = 1640
                self.match(RegelSpraakParser.ALLE)
                self.state = 1641
                self.naamwoord()
                pass

            elif la_ == 8:
                localctx = RegelSpraakParser.SomAlleAttribuutExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1642
                self.match(RegelSpraakParser.SOM_VAN)
                self.state = 1643
                self.match(RegelSpraakParser.ALLE)
                self.state = 1644
                self.attribuutReferentie()
                pass

            elif la_ == 9:
                localctx = RegelSpraakParser.AantalFuncExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1648
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [217]:
                    self.state = 1645
                    self.match(RegelSpraakParser.HET)
                    self.state = 1646
                    self.match(RegelSpraakParser.AANTAL)
                    pass
                elif token in [190]:
                    self.state = 1647
                    self.match(RegelSpraakParser.AANTAL)
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 1650
                self.aggregationSubject()
                pass

            elif la_ == 10:
                localctx = RegelSpraakParser.AantalAttribuutExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1651
                self.match(RegelSpraakParser.HET)
                self.state = 1652
                self.match(RegelSpraakParser.AANTAL)
                self.state = 1653
                self.attribuutReferentie()
                pass

            elif la_ == 11:
                localctx = RegelSpraakParser.AantalAttribuutExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1654
                self.match(RegelSpraakParser.AANTAL)
                self.state = 1655
                self.attribuutReferentie()
                pass

            elif la_ == 12:
                localctx = RegelSpraakParser.PercentageFuncExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1662
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [268]:
                    self.state = 1656
                    self.match(RegelSpraakParser.NUMBER)
                    self.state = 1659
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [283]:
                        self.state = 1657
                        self.match(RegelSpraakParser.PERCENT_SIGN)
                        pass
                    elif token in [267]:
                        self.state = 1658
                        localctx.p = self.match(RegelSpraakParser.IDENTIFIER)
                        pass
                    else:
                        raise NoViableAltException(self)

                    pass
                elif token in [271]:
                    self.state = 1661
                    self.match(RegelSpraakParser.PERCENTAGE_LITERAL)
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 1664
                self.match(RegelSpraakParser.VAN)
                self.state = 1665
                self.primaryExpression(44)
                pass

            elif la_ == 13:
                localctx = RegelSpraakParser.PercentageOfExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1666
                self.match(RegelSpraakParser.PERCENTAGE_LITERAL)
                self.state = 1667
                self.match(RegelSpraakParser.VAN)
                self.state = 1668
                self.primaryExpression(43)
                pass

            elif la_ == 14:
                localctx = RegelSpraakParser.ConcatenatieExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1669
                self.match(RegelSpraakParser.CONCATENATIE_VAN)
                self.state = 1670
                self.primaryExpression(0)
                self.state = 1675
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==278:
                    self.state = 1671
                    self.match(RegelSpraakParser.COMMA)
                    self.state = 1672
                    self.primaryExpression(0)
                    self.state = 1677
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 1678
                _la = self._input.LA(1)
                if not(_la==216 or _la==229):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1679
                self.primaryExpression(39)
                pass

            elif la_ == 15:
                localctx = RegelSpraakParser.WortelFuncExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1681
                self.match(RegelSpraakParser.DE_WORTEL_VAN)
                self.state = 1682
                self.primaryExpression(37)
                pass

            elif la_ == 16:
                localctx = RegelSpraakParser.AbsValFuncExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1683
                self.match(RegelSpraakParser.DE_ABSOLUTE_WAARDE_VAN)
                self.state = 1684
                self.match(RegelSpraakParser.LPAREN)
                self.state = 1685
                self.expressie()
                self.state = 1686
                self.match(RegelSpraakParser.RPAREN)
                pass

            elif la_ == 17:
                localctx = RegelSpraakParser.MinValFuncExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1688
                self.match(RegelSpraakParser.DE_MINIMALE_WAARDE_VAN)
                self.state = 1689
                self.primaryExpression(0)
                self.state = 1694
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==278:
                    self.state = 1690
                    self.match(RegelSpraakParser.COMMA)
                    self.state = 1691
                    self.primaryExpression(0)
                    self.state = 1696
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 1697
                self.match(RegelSpraakParser.EN)
                self.state = 1698
                self.primaryExpression(35)
                pass

            elif la_ == 18:
                localctx = RegelSpraakParser.MinAlleAttribuutExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1700
                self.match(RegelSpraakParser.DE_MINIMALE_WAARDE_VAN)
                self.state = 1701
                self.match(RegelSpraakParser.ALLE)
                self.state = 1702
                self.attribuutReferentie()
                pass

            elif la_ == 19:
                localctx = RegelSpraakParser.MaxValFuncExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1703
                self.match(RegelSpraakParser.DE_MAXIMALE_WAARDE_VAN)
                self.state = 1704
                self.primaryExpression(0)
                self.state = 1709
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==278:
                    self.state = 1705
                    self.match(RegelSpraakParser.COMMA)
                    self.state = 1706
                    self.primaryExpression(0)
                    self.state = 1711
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 1712
                self.match(RegelSpraakParser.EN)
                self.state = 1713
                self.primaryExpression(33)
                pass

            elif la_ == 20:
                localctx = RegelSpraakParser.MaxAlleAttribuutExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1715
                self.match(RegelSpraakParser.DE_MAXIMALE_WAARDE_VAN)
                self.state = 1716
                self.match(RegelSpraakParser.ALLE)
                self.state = 1717
                self.attribuutReferentie()
                pass

            elif la_ == 21:
                localctx = RegelSpraakParser.JaarUitFuncExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1718
                self.match(RegelSpraakParser.HET)
                self.state = 1719
                self.match(RegelSpraakParser.JAAR)
                self.state = 1720
                self.match(RegelSpraakParser.UIT)
                self.state = 1721
                self.primaryExpression(31)
                pass

            elif la_ == 22:
                localctx = RegelSpraakParser.MaandUitFuncExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1722
                self.match(RegelSpraakParser.DE)
                self.state = 1723
                self.match(RegelSpraakParser.MAAND)
                self.state = 1724
                self.match(RegelSpraakParser.UIT)
                self.state = 1725
                self.primaryExpression(30)
                pass

            elif la_ == 23:
                localctx = RegelSpraakParser.DagUitFuncExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1726
                self.match(RegelSpraakParser.DE)
                self.state = 1727
                self.match(RegelSpraakParser.DAG)
                self.state = 1728
                self.match(RegelSpraakParser.UIT)
                self.state = 1729
                self.primaryExpression(29)
                pass

            elif la_ == 24:
                localctx = RegelSpraakParser.DatumMetFuncExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1730
                self.match(RegelSpraakParser.DE_DATUM_MET)
                self.state = 1731
                self.match(RegelSpraakParser.LPAREN)
                self.state = 1732
                self.primaryExpression(0)
                self.state = 1733
                self.match(RegelSpraakParser.COMMA)
                self.state = 1734
                self.primaryExpression(0)
                self.state = 1735
                self.match(RegelSpraakParser.COMMA)
                self.state = 1736
                self.primaryExpression(0)
                self.state = 1737
                self.match(RegelSpraakParser.RPAREN)
                pass

            elif la_ == 25:
                localctx = RegelSpraakParser.PasenFuncExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1739
                self.match(RegelSpraakParser.DE_EERSTE_PAASDAG_VAN)
                self.state = 1740
                self.match(RegelSpraakParser.LPAREN)
                self.state = 1741
                self.primaryExpression(0)
                self.state = 1742
                self.match(RegelSpraakParser.RPAREN)
                pass

            elif la_ == 26:
                localctx = RegelSpraakParser.DateCalcExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1744
                self.datumExpressie()
                self.state = 1745
                _la = self._input.LA(1)
                if not(_la==137 or _la==143):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1746
                self.primaryExpression(0)
                self.state = 1747
                self.timeUnit()
                pass

            elif la_ == 27:
                localctx = RegelSpraakParser.EersteDatumFuncExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1749
                self.match(RegelSpraakParser.EERSTE_VAN)
                self.state = 1750
                self.primaryExpression(0)
                self.state = 1755
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==278:
                    self.state = 1751
                    self.match(RegelSpraakParser.COMMA)
                    self.state = 1752
                    self.primaryExpression(0)
                    self.state = 1757
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 1758
                self.match(RegelSpraakParser.EN)
                self.state = 1759
                self.primaryExpression(25)
                pass

            elif la_ == 28:
                localctx = RegelSpraakParser.LaatsteDatumFuncExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1761
                self.match(RegelSpraakParser.LAATSTE_VAN)
                self.state = 1762
                self.primaryExpression(0)
                self.state = 1767
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==278:
                    self.state = 1763
                    self.match(RegelSpraakParser.COMMA)
                    self.state = 1764
                    self.primaryExpression(0)
                    self.state = 1769
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 1770
                self.match(RegelSpraakParser.EN)
                self.state = 1771
                self.primaryExpression(24)
                pass

            elif la_ == 29:
                localctx = RegelSpraakParser.TotaalVanExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1773
                self.match(RegelSpraakParser.HET_TOTAAL_VAN)
                self.state = 1774
                self.expressie()
                self.state = 1776
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,200,self._ctx)
                if la_ == 1:
                    self.state = 1775
                    self.conditieBijExpressie()


                pass

            elif la_ == 30:
                localctx = RegelSpraakParser.HetAantalDagenInExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1778
                self.match(RegelSpraakParser.HET)
                self.state = 1779
                self.match(RegelSpraakParser.AANTAL)
                self.state = 1780
                self.match(RegelSpraakParser.DAGEN)
                self.state = 1781
                self.match(RegelSpraakParser.IN)
                self.state = 1790
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [212, 224]:
                    self.state = 1783
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==212:
                        self.state = 1782
                        self.match(RegelSpraakParser.DE)


                    self.state = 1785
                    self.match(RegelSpraakParser.MAAND)
                    pass
                elif token in [217, 221]:
                    self.state = 1787
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==217:
                        self.state = 1786
                        self.match(RegelSpraakParser.HET)


                    self.state = 1789
                    self.match(RegelSpraakParser.JAAR)
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 1792
                self.match(RegelSpraakParser.DAT)
                self.state = 1793
                self.expressie()
                pass

            elif la_ == 31:
                localctx = RegelSpraakParser.CapitalizedTotaalVanExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1795 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 1794
                    self.identifier()
                    self.state = 1797 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==267):
                        break

                self.state = 1799
                self.match(RegelSpraakParser.HET_TOTAAL_VAN)
                self.state = 1800
                self.expressie()
                self.state = 1802
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,205,self._ctx)
                if la_ == 1:
                    self.state = 1801
                    self.conditieBijExpressie()


                pass

            elif la_ == 32:
                localctx = RegelSpraakParser.TijdsevenredigDeelExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1804
                self.match(RegelSpraakParser.HET_TIJDSEVENREDIG_DEEL_PER)
                self.state = 1805
                _la = self._input.LA(1)
                if not(_la==221 or _la==224):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1806
                self.match(RegelSpraakParser.VAN)
                self.state = 1807
                self.expressie()
                self.state = 1809
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,206,self._ctx)
                if la_ == 1:
                    self.state = 1808
                    self.conditieBijExpressie()


                pass

            elif la_ == 33:
                localctx = RegelSpraakParser.CapitalizedTijdsevenredigDeelExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1812 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 1811
                    self.identifier()
                    self.state = 1814 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==267):
                        break

                self.state = 1816
                self.match(RegelSpraakParser.HET_TIJDSEVENREDIG_DEEL_PER)
                self.state = 1817
                _la = self._input.LA(1)
                if not(_la==221 or _la==224):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1818
                self.match(RegelSpraakParser.VAN)
                self.state = 1819
                self.expressie()
                self.state = 1821
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,208,self._ctx)
                if la_ == 1:
                    self.state = 1820
                    self.conditieBijExpressie()


                pass

            elif la_ == 34:
                localctx = RegelSpraakParser.DimensieAggExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1825
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [13, 14, 190, 195, 217]:
                    self.state = 1823
                    self.getalAggregatieFunctie()
                    pass
                elif token in [191, 193]:
                    self.state = 1824
                    self.datumAggregatieFunctie()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 1827
                self.attribuutMetLidwoord()
                self.state = 1828
                self.dimensieSelectie()
                pass

            elif la_ == 35:
                localctx = RegelSpraakParser.DimensieRangeAggExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1832
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [13, 14, 190, 195, 217]:
                    self.state = 1830
                    self.getalAggregatieFunctie()
                    pass
                elif token in [191, 193]:
                    self.state = 1831
                    self.datumAggregatieFunctie()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 1836
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,211,self._ctx)
                if la_ == 1:
                    self.state = 1834
                    self.bezieldeReferentie()
                    pass

                elif la_ == 2:
                    self.state = 1835
                    self.attribuutReferentie()
                    pass


                self.state = 1838
                self.match(RegelSpraakParser.VANAF)
                self.state = 1839
                self.naamwoord()
                self.state = 1840
                self.match(RegelSpraakParser.TM)
                self.state = 1841
                self.naamwoord()
                self.state = 1843
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,212,self._ctx)
                if la_ == 1:
                    self.state = 1842
                    self.match(RegelSpraakParser.DOT)


                pass

            elif la_ == 36:
                localctx = RegelSpraakParser.NumberLiteralExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1845
                self.match(RegelSpraakParser.NUMBER)
                self.state = 1847
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,213,self._ctx)
                if la_ == 1:
                    self.state = 1846
                    self.unitIdentifier()


                pass

            elif la_ == 37:
                localctx = RegelSpraakParser.RekendatumKeywordExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1849
                self.match(RegelSpraakParser.REKENDATUM)
                pass

            elif la_ == 38:
                localctx = RegelSpraakParser.IdentifierExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1850
                self.identifier()
                pass

            elif la_ == 39:
                localctx = RegelSpraakParser.BezieldeRefExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1851
                self.bezieldeReferentie()
                pass

            elif la_ == 40:
                localctx = RegelSpraakParser.AttrRefExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1852
                self.attribuutReferentie()
                pass

            elif la_ == 41:
                localctx = RegelSpraakParser.OnderwerpRefExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1853
                self.onderwerpReferentie()
                pass

            elif la_ == 42:
                localctx = RegelSpraakParser.NaamwoordExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1854
                self.naamwoord()
                pass

            elif la_ == 43:
                localctx = RegelSpraakParser.ParamRefExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1855
                self.parameterMetLidwoord()
                pass

            elif la_ == 44:
                localctx = RegelSpraakParser.PercentageLiteralExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1856
                self.match(RegelSpraakParser.PERCENTAGE_LITERAL)
                pass

            elif la_ == 45:
                localctx = RegelSpraakParser.StringLiteralExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1857
                self.match(RegelSpraakParser.STRING_LITERAL)
                pass

            elif la_ == 46:
                localctx = RegelSpraakParser.EnumLiteralExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1858
                self.match(RegelSpraakParser.ENUM_LITERAL)
                pass

            elif la_ == 47:
                localctx = RegelSpraakParser.DatumLiteralExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1859
                self.datumLiteral()
                pass

            elif la_ == 48:
                localctx = RegelSpraakParser.BooleanTrueLiteralExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1860
                self.match(RegelSpraakParser.WAAR)
                pass

            elif la_ == 49:
                localctx = RegelSpraakParser.BooleanFalseLiteralExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1861
                self.match(RegelSpraakParser.ONWAAR)
                pass

            elif la_ == 50:
                localctx = RegelSpraakParser.PronounExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1862
                self.match(RegelSpraakParser.HIJ)
                pass

            elif la_ == 51:
                localctx = RegelSpraakParser.ParenExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1863
                self.match(RegelSpraakParser.LPAREN)
                self.state = 1864
                self.expressie()
                self.state = 1865
                self.match(RegelSpraakParser.RPAREN)
                pass


            self._ctx.stop = self._input.LT(-1)
            self.state = 1891
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,217,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    self.state = 1889
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,216,self._ctx)
                    if la_ == 1:
                        localctx = RegelSpraakParser.SimpleConcatenatieExprContext(self, RegelSpraakParser.PrimaryExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_primaryExpression)
                        self.state = 1869
                        if not self.precpred(self._ctx, 38):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 38)")
                        self.state = 1872 
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        while True:
                            self.state = 1870
                            self.match(RegelSpraakParser.COMMA)
                            self.state = 1871
                            self.primaryExpression(0)
                            self.state = 1874 
                            self._errHandler.sync(self)
                            _la = self._input.LA(1)
                            if not (_la==278):
                                break

                        self.state = 1876
                        _la = self._input.LA(1)
                        if not(_la==216 or _la==229):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 1877
                        self.primaryExpression(39)
                        pass

                    elif la_ == 2:
                        localctx = RegelSpraakParser.AfrondingExprContext(self, RegelSpraakParser.PrimaryExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_primaryExpression)
                        self.state = 1879
                        if not self.precpred(self._ctx, 42):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 42)")
                        self.state = 1880
                        self.afronding()
                        pass

                    elif la_ == 3:
                        localctx = RegelSpraakParser.BegrenzingAfrondingExprContext(self, RegelSpraakParser.PrimaryExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_primaryExpression)
                        self.state = 1881
                        if not self.precpred(self._ctx, 41):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 41)")
                        self.state = 1882
                        self.match(RegelSpraakParser.COMMA)
                        self.state = 1883
                        self.begrenzing()
                        self.state = 1884
                        self.afronding()
                        pass

                    elif la_ == 4:
                        localctx = RegelSpraakParser.BegrenzingExprContext(self, RegelSpraakParser.PrimaryExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_primaryExpression)
                        self.state = 1886
                        if not self.precpred(self._ctx, 40):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 40)")
                        self.state = 1887
                        self.match(RegelSpraakParser.COMMA)
                        self.state = 1888
                        self.begrenzing()
                        pass

             
                self.state = 1893
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,217,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class AfrondingContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def AFGEROND_OP(self):
            return self.getToken(RegelSpraakParser.AFGEROND_OP, 0)

        def NUMBER(self):
            return self.getToken(RegelSpraakParser.NUMBER, 0)

        def DECIMALEN(self):
            return self.getToken(RegelSpraakParser.DECIMALEN, 0)

        def NAAR_BENEDEN(self):
            return self.getToken(RegelSpraakParser.NAAR_BENEDEN, 0)

        def NAAR_BOVEN(self):
            return self.getToken(RegelSpraakParser.NAAR_BOVEN, 0)

        def REKENKUNDIG(self):
            return self.getToken(RegelSpraakParser.REKENKUNDIG, 0)

        def RICHTING_NUL(self):
            return self.getToken(RegelSpraakParser.RICHTING_NUL, 0)

        def WEG_VAN_NUL(self):
            return self.getToken(RegelSpraakParser.WEG_VAN_NUL, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_afronding

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAfronding" ):
                listener.enterAfronding(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAfronding" ):
                listener.exitAfronding(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAfronding" ):
                return visitor.visitAfronding(self)
            else:
                return visitor.visitChildren(self)




    def afronding(self):

        localctx = RegelSpraakParser.AfrondingContext(self, self._ctx, self.state)
        self.enterRule(localctx, 276, self.RULE_afronding)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1894
            _la = self._input.LA(1)
            if not(((((_la - 138)) & ~0x3f) == 0 and ((1 << (_la - 138)) & 131267) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 1895
            self.match(RegelSpraakParser.AFGEROND_OP)
            self.state = 1896
            self.match(RegelSpraakParser.NUMBER)
            self.state = 1897
            self.match(RegelSpraakParser.DECIMALEN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BegrenzingContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def begrenzingMinimum(self):
            return self.getTypedRuleContext(RegelSpraakParser.BegrenzingMinimumContext,0)


        def begrenzingMaximum(self):
            return self.getTypedRuleContext(RegelSpraakParser.BegrenzingMaximumContext,0)


        def EN(self):
            return self.getToken(RegelSpraakParser.EN, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_begrenzing

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBegrenzing" ):
                listener.enterBegrenzing(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBegrenzing" ):
                listener.exitBegrenzing(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBegrenzing" ):
                return visitor.visitBegrenzing(self)
            else:
                return visitor.visitChildren(self)




    def begrenzing(self):

        localctx = RegelSpraakParser.BegrenzingContext(self, self._ctx, self.state)
        self.enterRule(localctx, 278, self.RULE_begrenzing)
        try:
            self.state = 1905
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,218,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1899
                self.begrenzingMinimum()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1900
                self.begrenzingMaximum()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1901
                self.begrenzingMinimum()
                self.state = 1902
                self.match(RegelSpraakParser.EN)
                self.state = 1903
                self.begrenzingMaximum()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BegrenzingMinimumContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MET_EEN_MINIMUM_VAN(self):
            return self.getToken(RegelSpraakParser.MET_EEN_MINIMUM_VAN, 0)

        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_begrenzingMinimum

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBegrenzingMinimum" ):
                listener.enterBegrenzingMinimum(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBegrenzingMinimum" ):
                listener.exitBegrenzingMinimum(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBegrenzingMinimum" ):
                return visitor.visitBegrenzingMinimum(self)
            else:
                return visitor.visitChildren(self)




    def begrenzingMinimum(self):

        localctx = RegelSpraakParser.BegrenzingMinimumContext(self, self._ctx, self.state)
        self.enterRule(localctx, 280, self.RULE_begrenzingMinimum)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1907
            self.match(RegelSpraakParser.MET_EEN_MINIMUM_VAN)
            self.state = 1908
            self.expressie()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BegrenzingMaximumContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MET_EEN_MAXIMUM_VAN(self):
            return self.getToken(RegelSpraakParser.MET_EEN_MAXIMUM_VAN, 0)

        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_begrenzingMaximum

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBegrenzingMaximum" ):
                listener.enterBegrenzingMaximum(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBegrenzingMaximum" ):
                listener.exitBegrenzingMaximum(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBegrenzingMaximum" ):
                return visitor.visitBegrenzingMaximum(self)
            else:
                return visitor.visitChildren(self)




    def begrenzingMaximum(self):

        localctx = RegelSpraakParser.BegrenzingMaximumContext(self, self._ctx, self.state)
        self.enterRule(localctx, 282, self.RULE_begrenzingMaximum)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1910
            self.match(RegelSpraakParser.MET_EEN_MAXIMUM_VAN)
            self.state = 1911
            self.expressie()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConditieBijExpressieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.condition = None # ExpressieContext

        def GEDURENDE_DE_TIJD_DAT(self):
            return self.getToken(RegelSpraakParser.GEDURENDE_DE_TIJD_DAT, 0)

        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)


        def periodevergelijkingEnkelvoudig(self):
            return self.getTypedRuleContext(RegelSpraakParser.PeriodevergelijkingEnkelvoudigContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_conditieBijExpressie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConditieBijExpressie" ):
                listener.enterConditieBijExpressie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConditieBijExpressie" ):
                listener.exitConditieBijExpressie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConditieBijExpressie" ):
                return visitor.visitConditieBijExpressie(self)
            else:
                return visitor.visitChildren(self)




    def conditieBijExpressie(self):

        localctx = RegelSpraakParser.ConditieBijExpressieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 284, self.RULE_conditieBijExpressie)
        try:
            self.state = 1916
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [4]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1913
                self.match(RegelSpraakParser.GEDURENDE_DE_TIJD_DAT)
                self.state = 1914
                localctx.condition = self.expressie()
                pass
            elif token in [146, 148, 150, 244]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1915
                self.periodevergelijkingEnkelvoudig()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PeriodevergelijkingElementairContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def HET_IS_DE_PERIODE(self):
            return self.getToken(RegelSpraakParser.HET_IS_DE_PERIODE, 0)

        def periodevergelijkingEnkelvoudig(self):
            return self.getTypedRuleContext(RegelSpraakParser.PeriodevergelijkingEnkelvoudigContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_periodevergelijkingElementair

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPeriodevergelijkingElementair" ):
                listener.enterPeriodevergelijkingElementair(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPeriodevergelijkingElementair" ):
                listener.exitPeriodevergelijkingElementair(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPeriodevergelijkingElementair" ):
                return visitor.visitPeriodevergelijkingElementair(self)
            else:
                return visitor.visitChildren(self)




    def periodevergelijkingElementair(self):

        localctx = RegelSpraakParser.PeriodevergelijkingElementairContext(self, self._ctx, self.state)
        self.enterRule(localctx, 286, self.RULE_periodevergelijkingElementair)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1918
            self.match(RegelSpraakParser.HET_IS_DE_PERIODE)
            self.state = 1919
            self.periodevergelijkingEnkelvoudig()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PeriodevergelijkingEnkelvoudigContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def VANAF(self):
            return self.getToken(RegelSpraakParser.VANAF, 0)

        def datumExpressie(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.DatumExpressieContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.DatumExpressieContext,i)


        def VAN(self):
            return self.getToken(RegelSpraakParser.VAN, 0)

        def TOT(self):
            return self.getToken(RegelSpraakParser.TOT, 0)

        def TOT_EN_MET(self):
            return self.getToken(RegelSpraakParser.TOT_EN_MET, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_periodevergelijkingEnkelvoudig

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPeriodevergelijkingEnkelvoudig" ):
                listener.enterPeriodevergelijkingEnkelvoudig(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPeriodevergelijkingEnkelvoudig" ):
                listener.exitPeriodevergelijkingEnkelvoudig(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPeriodevergelijkingEnkelvoudig" ):
                return visitor.visitPeriodevergelijkingEnkelvoudig(self)
            else:
                return visitor.visitChildren(self)




    def periodevergelijkingEnkelvoudig(self):

        localctx = RegelSpraakParser.PeriodevergelijkingEnkelvoudigContext(self, self._ctx, self.state)
        self.enterRule(localctx, 288, self.RULE_periodevergelijkingEnkelvoudig)
        try:
            self.state = 1937
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,220,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1921
                self.match(RegelSpraakParser.VANAF)
                self.state = 1922
                self.datumExpressie()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1923
                self.match(RegelSpraakParser.VAN)
                self.state = 1924
                self.datumExpressie()
                self.state = 1925
                self.match(RegelSpraakParser.TOT)
                self.state = 1926
                self.datumExpressie()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1928
                self.match(RegelSpraakParser.VAN)
                self.state = 1929
                self.datumExpressie()
                self.state = 1930
                self.match(RegelSpraakParser.TOT_EN_MET)
                self.state = 1931
                self.datumExpressie()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 1933
                self.match(RegelSpraakParser.TOT)
                self.state = 1934
                self.datumExpressie()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 1935
                self.match(RegelSpraakParser.TOT_EN_MET)
                self.state = 1936
                self.datumExpressie()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PeriodeDefinitieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_periodeDefinitie

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class VanafPeriodeContext(PeriodeDefinitieContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PeriodeDefinitieContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def VANAF(self):
            return self.getToken(RegelSpraakParser.VANAF, 0)
        def dateExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.DateExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVanafPeriode" ):
                listener.enterVanafPeriode(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVanafPeriode" ):
                listener.exitVanafPeriode(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVanafPeriode" ):
                return visitor.visitVanafPeriode(self)
            else:
                return visitor.visitChildren(self)


    class VanTotPeriodeContext(PeriodeDefinitieContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PeriodeDefinitieContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def VAN(self):
            return self.getToken(RegelSpraakParser.VAN, 0)
        def dateExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.DateExpressionContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.DateExpressionContext,i)

        def TOT(self):
            return self.getToken(RegelSpraakParser.TOT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVanTotPeriode" ):
                listener.enterVanTotPeriode(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVanTotPeriode" ):
                listener.exitVanTotPeriode(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVanTotPeriode" ):
                return visitor.visitVanTotPeriode(self)
            else:
                return visitor.visitChildren(self)


    class VanTotEnMetPeriodeContext(PeriodeDefinitieContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PeriodeDefinitieContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def VAN(self):
            return self.getToken(RegelSpraakParser.VAN, 0)
        def dateExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.DateExpressionContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.DateExpressionContext,i)

        def TOT_EN_MET(self):
            return self.getToken(RegelSpraakParser.TOT_EN_MET, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVanTotEnMetPeriode" ):
                listener.enterVanTotEnMetPeriode(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVanTotEnMetPeriode" ):
                listener.exitVanTotEnMetPeriode(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVanTotEnMetPeriode" ):
                return visitor.visitVanTotEnMetPeriode(self)
            else:
                return visitor.visitChildren(self)


    class TotPeriodeContext(PeriodeDefinitieContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PeriodeDefinitieContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def TOT(self):
            return self.getToken(RegelSpraakParser.TOT, 0)
        def dateExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.DateExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTotPeriode" ):
                listener.enterTotPeriode(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTotPeriode" ):
                listener.exitTotPeriode(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTotPeriode" ):
                return visitor.visitTotPeriode(self)
            else:
                return visitor.visitChildren(self)


    class TotEnMetPeriodeContext(PeriodeDefinitieContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PeriodeDefinitieContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def TOT_EN_MET(self):
            return self.getToken(RegelSpraakParser.TOT_EN_MET, 0)
        def dateExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.DateExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTotEnMetPeriode" ):
                listener.enterTotEnMetPeriode(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTotEnMetPeriode" ):
                listener.exitTotEnMetPeriode(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTotEnMetPeriode" ):
                return visitor.visitTotEnMetPeriode(self)
            else:
                return visitor.visitChildren(self)



    def periodeDefinitie(self):

        localctx = RegelSpraakParser.PeriodeDefinitieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 290, self.RULE_periodeDefinitie)
        try:
            self.state = 1955
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,221,self._ctx)
            if la_ == 1:
                localctx = RegelSpraakParser.VanafPeriodeContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1939
                self.match(RegelSpraakParser.VANAF)
                self.state = 1940
                self.dateExpression()
                pass

            elif la_ == 2:
                localctx = RegelSpraakParser.TotPeriodeContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1941
                self.match(RegelSpraakParser.TOT)
                self.state = 1942
                self.dateExpression()
                pass

            elif la_ == 3:
                localctx = RegelSpraakParser.TotEnMetPeriodeContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 1943
                self.match(RegelSpraakParser.TOT_EN_MET)
                self.state = 1944
                self.dateExpression()
                pass

            elif la_ == 4:
                localctx = RegelSpraakParser.VanTotPeriodeContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 1945
                self.match(RegelSpraakParser.VAN)
                self.state = 1946
                self.dateExpression()
                self.state = 1947
                self.match(RegelSpraakParser.TOT)
                self.state = 1948
                self.dateExpression()
                pass

            elif la_ == 5:
                localctx = RegelSpraakParser.VanTotEnMetPeriodeContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 1950
                self.match(RegelSpraakParser.VAN)
                self.state = 1951
                self.dateExpression()
                self.state = 1952
                self.match(RegelSpraakParser.TOT_EN_MET)
                self.state = 1953
                self.dateExpression()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DateExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def datumLiteral(self):
            return self.getTypedRuleContext(RegelSpraakParser.DatumLiteralContext,0)


        def REKENDATUM(self):
            return self.getToken(RegelSpraakParser.REKENDATUM, 0)

        def REKENJAAR(self):
            return self.getToken(RegelSpraakParser.REKENJAAR, 0)

        def attribuutReferentie(self):
            return self.getTypedRuleContext(RegelSpraakParser.AttribuutReferentieContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_dateExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDateExpression" ):
                listener.enterDateExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDateExpression" ):
                listener.exitDateExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDateExpression" ):
                return visitor.visitDateExpression(self)
            else:
                return visitor.visitChildren(self)




    def dateExpression(self):

        localctx = RegelSpraakParser.DateExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 292, self.RULE_dateExpression)
        try:
            self.state = 1961
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [270]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1957
                self.datumLiteral()
                pass
            elif token in [235]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1958
                self.match(RegelSpraakParser.REKENDATUM)
                pass
            elif token in [236]:
                self.enterOuterAlt(localctx, 3)
                self.state = 1959
                self.match(RegelSpraakParser.REKENJAAR)
                pass
            elif token in [45, 96, 110, 119, 124, 132, 140, 161, 190, 201, 202, 205, 206, 209, 210, 212, 215, 217, 221, 223, 224, 232, 234, 253, 267]:
                self.enterOuterAlt(localctx, 4)
                self.state = 1960
                self.attribuutReferentie()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GetalAggregatieFunctieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def HET(self):
            return self.getToken(RegelSpraakParser.HET, 0)

        def AANTAL(self):
            return self.getToken(RegelSpraakParser.AANTAL, 0)

        def DE_MAXIMALE_WAARDE_VAN(self):
            return self.getToken(RegelSpraakParser.DE_MAXIMALE_WAARDE_VAN, 0)

        def DE_MINIMALE_WAARDE_VAN(self):
            return self.getToken(RegelSpraakParser.DE_MINIMALE_WAARDE_VAN, 0)

        def SOM_VAN(self):
            return self.getToken(RegelSpraakParser.SOM_VAN, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_getalAggregatieFunctie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGetalAggregatieFunctie" ):
                listener.enterGetalAggregatieFunctie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGetalAggregatieFunctie" ):
                listener.exitGetalAggregatieFunctie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGetalAggregatieFunctie" ):
                return visitor.visitGetalAggregatieFunctie(self)
            else:
                return visitor.visitChildren(self)




    def getalAggregatieFunctie(self):

        localctx = RegelSpraakParser.GetalAggregatieFunctieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 294, self.RULE_getalAggregatieFunctie)
        try:
            self.state = 1969
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [217]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1963
                self.match(RegelSpraakParser.HET)
                self.state = 1964
                self.match(RegelSpraakParser.AANTAL)
                pass
            elif token in [190]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1965
                self.match(RegelSpraakParser.AANTAL)
                pass
            elif token in [13]:
                self.enterOuterAlt(localctx, 3)
                self.state = 1966
                self.match(RegelSpraakParser.DE_MAXIMALE_WAARDE_VAN)
                pass
            elif token in [14]:
                self.enterOuterAlt(localctx, 4)
                self.state = 1967
                self.match(RegelSpraakParser.DE_MINIMALE_WAARDE_VAN)
                pass
            elif token in [195]:
                self.enterOuterAlt(localctx, 5)
                self.state = 1968
                self.match(RegelSpraakParser.SOM_VAN)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DatumAggregatieFunctieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EERSTE_VAN(self):
            return self.getToken(RegelSpraakParser.EERSTE_VAN, 0)

        def LAATSTE_VAN(self):
            return self.getToken(RegelSpraakParser.LAATSTE_VAN, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_datumAggregatieFunctie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDatumAggregatieFunctie" ):
                listener.enterDatumAggregatieFunctie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDatumAggregatieFunctie" ):
                listener.exitDatumAggregatieFunctie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDatumAggregatieFunctie" ):
                return visitor.visitDatumAggregatieFunctie(self)
            else:
                return visitor.visitChildren(self)




    def datumAggregatieFunctie(self):

        localctx = RegelSpraakParser.DatumAggregatieFunctieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 296, self.RULE_datumAggregatieFunctie)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1971
            _la = self._input.LA(1)
            if not(_la==191 or _la==193):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DimensieSelectieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OVER(self):
            return self.getToken(RegelSpraakParser.OVER, 0)

        def DOT(self):
            return self.getToken(RegelSpraakParser.DOT, 0)

        def aggregerenOverAlleDimensies(self):
            return self.getTypedRuleContext(RegelSpraakParser.AggregerenOverAlleDimensiesContext,0)


        def aggregerenOverVerzameling(self):
            return self.getTypedRuleContext(RegelSpraakParser.AggregerenOverVerzamelingContext,0)


        def aggregerenOverBereik(self):
            return self.getTypedRuleContext(RegelSpraakParser.AggregerenOverBereikContext,0)


        def VAN(self):
            return self.getToken(RegelSpraakParser.VAN, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_dimensieSelectie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDimensieSelectie" ):
                listener.enterDimensieSelectie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDimensieSelectie" ):
                listener.exitDimensieSelectie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDimensieSelectie" ):
                return visitor.visitDimensieSelectie(self)
            else:
                return visitor.visitChildren(self)




    def dimensieSelectie(self):

        localctx = RegelSpraakParser.DimensieSelectieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 298, self.RULE_dimensieSelectie)
        try:
            self.state = 1983
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [233]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1973
                self.match(RegelSpraakParser.OVER)
                self.state = 1977
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,224,self._ctx)
                if la_ == 1:
                    self.state = 1974
                    self.aggregerenOverAlleDimensies()
                    pass

                elif la_ == 2:
                    self.state = 1975
                    self.aggregerenOverVerzameling()
                    pass

                elif la_ == 3:
                    self.state = 1976
                    self.aggregerenOverBereik()
                    pass


                self.state = 1979
                self.match(RegelSpraakParser.DOT)
                pass
            elif token in [244]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1981
                self.match(RegelSpraakParser.VAN)
                self.state = 1982
                self.aggregerenOverAlleDimensies()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AggregerenOverAlleDimensiesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ALLE(self):
            return self.getToken(RegelSpraakParser.ALLE, 0)

        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def predicaat(self):
            return self.getTypedRuleContext(RegelSpraakParser.PredicaatContext,0)


        def DIE(self):
            return self.getToken(RegelSpraakParser.DIE, 0)

        def DAT(self):
            return self.getToken(RegelSpraakParser.DAT, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_aggregerenOverAlleDimensies

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAggregerenOverAlleDimensies" ):
                listener.enterAggregerenOverAlleDimensies(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAggregerenOverAlleDimensies" ):
                listener.exitAggregerenOverAlleDimensies(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAggregerenOverAlleDimensies" ):
                return visitor.visitAggregerenOverAlleDimensies(self)
            else:
                return visitor.visitChildren(self)




    def aggregerenOverAlleDimensies(self):

        localctx = RegelSpraakParser.AggregerenOverAlleDimensiesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 300, self.RULE_aggregerenOverAlleDimensies)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1985
            self.match(RegelSpraakParser.ALLE)
            self.state = 1986
            self.naamwoord()
            self.state = 1989
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,226,self._ctx)
            if la_ == 1:
                self.state = 1987
                _la = self._input.LA(1)
                if not(_la==211 or _la==214):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1988
                self.predicaat()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AggregerenOverVerzamelingContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DE(self):
            return self.getToken(RegelSpraakParser.DE, 0)

        def naamwoord(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.NaamwoordContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,i)


        def VANAF(self):
            return self.getToken(RegelSpraakParser.VANAF, 0)

        def TM(self):
            return self.getToken(RegelSpraakParser.TM, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_aggregerenOverVerzameling

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAggregerenOverVerzameling" ):
                listener.enterAggregerenOverVerzameling(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAggregerenOverVerzameling" ):
                listener.exitAggregerenOverVerzameling(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAggregerenOverVerzameling" ):
                return visitor.visitAggregerenOverVerzameling(self)
            else:
                return visitor.visitChildren(self)




    def aggregerenOverVerzameling(self):

        localctx = RegelSpraakParser.AggregerenOverVerzamelingContext(self, self._ctx, self.state)
        self.enterRule(localctx, 302, self.RULE_aggregerenOverVerzameling)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1991
            self.match(RegelSpraakParser.DE)
            self.state = 1992
            self.naamwoord()
            self.state = 1993
            self.match(RegelSpraakParser.VANAF)
            self.state = 1994
            self.naamwoord()
            self.state = 1995
            self.match(RegelSpraakParser.TM)
            self.state = 1996
            self.naamwoord()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AggregerenOverBereikContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DE(self):
            return self.getToken(RegelSpraakParser.DE, 0)

        def naamwoord(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.NaamwoordContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,i)


        def IN(self):
            return self.getToken(RegelSpraakParser.IN, 0)

        def LBRACE(self):
            return self.getToken(RegelSpraakParser.LBRACE, 0)

        def EN(self):
            return self.getToken(RegelSpraakParser.EN, 0)

        def RBRACE(self):
            return self.getToken(RegelSpraakParser.RBRACE, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.COMMA)
            else:
                return self.getToken(RegelSpraakParser.COMMA, i)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_aggregerenOverBereik

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAggregerenOverBereik" ):
                listener.enterAggregerenOverBereik(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAggregerenOverBereik" ):
                listener.exitAggregerenOverBereik(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAggregerenOverBereik" ):
                return visitor.visitAggregerenOverBereik(self)
            else:
                return visitor.visitChildren(self)




    def aggregerenOverBereik(self):

        localctx = RegelSpraakParser.AggregerenOverBereikContext(self, self._ctx, self.state)
        self.enterRule(localctx, 304, self.RULE_aggregerenOverBereik)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1998
            self.match(RegelSpraakParser.DE)
            self.state = 1999
            self.naamwoord()
            self.state = 2000
            self.match(RegelSpraakParser.IN)
            self.state = 2001
            self.match(RegelSpraakParser.LBRACE)
            self.state = 2002
            self.naamwoord()
            self.state = 2007
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==278:
                self.state = 2003
                self.match(RegelSpraakParser.COMMA)
                self.state = 2004
                self.naamwoord()
                self.state = 2009
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 2010
            self.match(RegelSpraakParser.EN)
            self.state = 2011
            self.naamwoord()
            self.state = 2012
            self.match(RegelSpraakParser.RBRACE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UnaryConditionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_unaryCondition

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class UnaryCheckConditionContext(UnaryConditionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.UnaryConditionContext
            super().__init__(parser)
            self.expr = None # PrimaryExpressionContext
            self.op = None # Token
            self.copyFrom(ctx)

        def primaryExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,0)

        def IS_LEEG(self):
            return self.getToken(RegelSpraakParser.IS_LEEG, 0)
        def IS_GEVULD(self):
            return self.getToken(RegelSpraakParser.IS_GEVULD, 0)
        def VOLDOET_AAN_DE_ELFPROEF(self):
            return self.getToken(RegelSpraakParser.VOLDOET_AAN_DE_ELFPROEF, 0)
        def VOLDOET_NIET_AAN_DE_ELFPROEF(self):
            return self.getToken(RegelSpraakParser.VOLDOET_NIET_AAN_DE_ELFPROEF, 0)
        def ZIJN_LEEG(self):
            return self.getToken(RegelSpraakParser.ZIJN_LEEG, 0)
        def ZIJN_GEVULD(self):
            return self.getToken(RegelSpraakParser.ZIJN_GEVULD, 0)
        def VOLDOEN_AAN_DE_ELFPROEF(self):
            return self.getToken(RegelSpraakParser.VOLDOEN_AAN_DE_ELFPROEF, 0)
        def VOLDOEN_NIET_AAN_DE_ELFPROEF(self):
            return self.getToken(RegelSpraakParser.VOLDOEN_NIET_AAN_DE_ELFPROEF, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnaryCheckCondition" ):
                listener.enterUnaryCheckCondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnaryCheckCondition" ):
                listener.exitUnaryCheckCondition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnaryCheckCondition" ):
                return visitor.visitUnaryCheckCondition(self)
            else:
                return visitor.visitChildren(self)


    class UnaryKenmerkConditionContext(UnaryConditionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.UnaryConditionContext
            super().__init__(parser)
            self.expr = None # PrimaryExpressionContext
            self.op = None # Token
            self.kenmerk = None # IdentifierContext
            self.copyFrom(ctx)

        def primaryExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,0)

        def identifier(self):
            return self.getTypedRuleContext(RegelSpraakParser.IdentifierContext,0)

        def IS_KENMERK(self):
            return self.getToken(RegelSpraakParser.IS_KENMERK, 0)
        def ZIJN_KENMERK(self):
            return self.getToken(RegelSpraakParser.ZIJN_KENMERK, 0)
        def IS_NIET_KENMERK(self):
            return self.getToken(RegelSpraakParser.IS_NIET_KENMERK, 0)
        def ZIJN_NIET_KENMERK(self):
            return self.getToken(RegelSpraakParser.ZIJN_NIET_KENMERK, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnaryKenmerkCondition" ):
                listener.enterUnaryKenmerkCondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnaryKenmerkCondition" ):
                listener.exitUnaryKenmerkCondition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnaryKenmerkCondition" ):
                return visitor.visitUnaryKenmerkCondition(self)
            else:
                return visitor.visitChildren(self)


    class UnaryNumeriekExactConditionContext(UnaryConditionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.UnaryConditionContext
            super().__init__(parser)
            self.expr = None # PrimaryExpressionContext
            self.op = None # Token
            self.copyFrom(ctx)

        def NUMBER(self):
            return self.getToken(RegelSpraakParser.NUMBER, 0)
        def CIJFERS(self):
            return self.getToken(RegelSpraakParser.CIJFERS, 0)
        def primaryExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,0)

        def IS_NUMERIEK_MET_EXACT(self):
            return self.getToken(RegelSpraakParser.IS_NUMERIEK_MET_EXACT, 0)
        def IS_NIET_NUMERIEK_MET_EXACT(self):
            return self.getToken(RegelSpraakParser.IS_NIET_NUMERIEK_MET_EXACT, 0)
        def ZIJN_NUMERIEK_MET_EXACT(self):
            return self.getToken(RegelSpraakParser.ZIJN_NUMERIEK_MET_EXACT, 0)
        def ZIJN_NIET_NUMERIEK_MET_EXACT(self):
            return self.getToken(RegelSpraakParser.ZIJN_NIET_NUMERIEK_MET_EXACT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnaryNumeriekExactCondition" ):
                listener.enterUnaryNumeriekExactCondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnaryNumeriekExactCondition" ):
                listener.exitUnaryNumeriekExactCondition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnaryNumeriekExactCondition" ):
                return visitor.visitUnaryNumeriekExactCondition(self)
            else:
                return visitor.visitChildren(self)


    class UnaryRolConditionContext(UnaryConditionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.UnaryConditionContext
            super().__init__(parser)
            self.expr = None # PrimaryExpressionContext
            self.op = None # Token
            self.rol = None # IdentifierContext
            self.copyFrom(ctx)

        def primaryExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,0)

        def identifier(self):
            return self.getTypedRuleContext(RegelSpraakParser.IdentifierContext,0)

        def IS_ROL(self):
            return self.getToken(RegelSpraakParser.IS_ROL, 0)
        def ZIJN_ROL(self):
            return self.getToken(RegelSpraakParser.ZIJN_ROL, 0)
        def IS_NIET_ROL(self):
            return self.getToken(RegelSpraakParser.IS_NIET_ROL, 0)
        def ZIJN_NIET_ROL(self):
            return self.getToken(RegelSpraakParser.ZIJN_NIET_ROL, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnaryRolCondition" ):
                listener.enterUnaryRolCondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnaryRolCondition" ):
                listener.exitUnaryRolCondition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnaryRolCondition" ):
                return visitor.visitUnaryRolCondition(self)
            else:
                return visitor.visitChildren(self)


    class UnaryDagsoortConditionContext(UnaryConditionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.UnaryConditionContext
            super().__init__(parser)
            self.expr = None # PrimaryExpressionContext
            self.op = None # Token
            self.dagsoort = None # IdentifierContext
            self.copyFrom(ctx)

        def primaryExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,0)

        def identifier(self):
            return self.getTypedRuleContext(RegelSpraakParser.IdentifierContext,0)

        def IS_EEN_DAGSOORT(self):
            return self.getToken(RegelSpraakParser.IS_EEN_DAGSOORT, 0)
        def ZIJN_EEN_DAGSOORT(self):
            return self.getToken(RegelSpraakParser.ZIJN_EEN_DAGSOORT, 0)
        def IS_GEEN_DAGSOORT(self):
            return self.getToken(RegelSpraakParser.IS_GEEN_DAGSOORT, 0)
        def ZIJN_GEEN_DAGSOORT(self):
            return self.getToken(RegelSpraakParser.ZIJN_GEEN_DAGSOORT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnaryDagsoortCondition" ):
                listener.enterUnaryDagsoortCondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnaryDagsoortCondition" ):
                listener.exitUnaryDagsoortCondition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnaryDagsoortCondition" ):
                return visitor.visitUnaryDagsoortCondition(self)
            else:
                return visitor.visitChildren(self)


    class UnaryInconsistentDataConditionContext(UnaryConditionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.UnaryConditionContext
            super().__init__(parser)
            self.expr = None # PrimaryExpressionContext
            self.copyFrom(ctx)

        def IS_INCONSISTENT(self):
            return self.getToken(RegelSpraakParser.IS_INCONSISTENT, 0)
        def primaryExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnaryInconsistentDataCondition" ):
                listener.enterUnaryInconsistentDataCondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnaryInconsistentDataCondition" ):
                listener.exitUnaryInconsistentDataCondition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnaryInconsistentDataCondition" ):
                return visitor.visitUnaryInconsistentDataCondition(self)
            else:
                return visitor.visitChildren(self)


    class UnaryUniekConditionContext(UnaryConditionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.UnaryConditionContext
            super().__init__(parser)
            self.ref = None # OnderwerpReferentieContext
            self.copyFrom(ctx)

        def MOETEN_UNIEK_ZIJN(self):
            return self.getToken(RegelSpraakParser.MOETEN_UNIEK_ZIJN, 0)
        def onderwerpReferentie(self):
            return self.getTypedRuleContext(RegelSpraakParser.OnderwerpReferentieContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnaryUniekCondition" ):
                listener.enterUnaryUniekCondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnaryUniekCondition" ):
                listener.exitUnaryUniekCondition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnaryUniekCondition" ):
                return visitor.visitUnaryUniekCondition(self)
            else:
                return visitor.visitChildren(self)



    def unaryCondition(self):

        localctx = RegelSpraakParser.UnaryConditionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 306, self.RULE_unaryCondition)
        self._la = 0 # Token type
        try:
            self.state = 2040
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,228,self._ctx)
            if la_ == 1:
                localctx = RegelSpraakParser.UnaryCheckConditionContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 2014
                localctx.expr = self.primaryExpression(0)
                self.state = 2015
                localctx.op = self._input.LT(1)
                _la = self._input.LA(1)
                if not(((((_la - 68)) & ~0x3f) == 0 and ((1 << (_la - 68)) & 61455) != 0)):
                    localctx.op = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass

            elif la_ == 2:
                localctx = RegelSpraakParser.UnaryNumeriekExactConditionContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 2017
                localctx.expr = self.primaryExpression(0)
                self.state = 2018
                localctx.op = self._input.LT(1)
                _la = self._input.LA(1)
                if not(((((_la - 84)) & ~0x3f) == 0 and ((1 << (_la - 84)) & 15) != 0)):
                    localctx.op = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 2019
                self.match(RegelSpraakParser.NUMBER)
                self.state = 2020
                self.match(RegelSpraakParser.CIJFERS)
                pass

            elif la_ == 3:
                localctx = RegelSpraakParser.UnaryDagsoortConditionContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 2022
                localctx.expr = self.primaryExpression(0)
                self.state = 2023
                localctx.op = self._input.LT(1)
                _la = self._input.LA(1)
                if not(((((_la - 88)) & ~0x3f) == 0 and ((1 << (_la - 88)) & 15) != 0)):
                    localctx.op = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 2024
                localctx.dagsoort = self.identifier()
                pass

            elif la_ == 4:
                localctx = RegelSpraakParser.UnaryKenmerkConditionContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 2026
                localctx.expr = self.primaryExpression(0)
                self.state = 2027
                localctx.op = self._input.LT(1)
                _la = self._input.LA(1)
                if not(((((_la - 72)) & ~0x3f) == 0 and ((1 << (_la - 72)) & 85) != 0)):
                    localctx.op = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 2028
                localctx.kenmerk = self.identifier()
                pass

            elif la_ == 5:
                localctx = RegelSpraakParser.UnaryRolConditionContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 2030
                localctx.expr = self.primaryExpression(0)
                self.state = 2031
                localctx.op = self._input.LT(1)
                _la = self._input.LA(1)
                if not(((((_la - 73)) & ~0x3f) == 0 and ((1 << (_la - 73)) & 85) != 0)):
                    localctx.op = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 2032
                localctx.rol = self.identifier()
                pass

            elif la_ == 6:
                localctx = RegelSpraakParser.UnaryUniekConditionContext(self, localctx)
                self.enterOuterAlt(localctx, 6)
                self.state = 2034
                localctx.ref = self.onderwerpReferentie()
                self.state = 2035
                self.match(RegelSpraakParser.MOETEN_UNIEK_ZIJN)
                pass

            elif la_ == 7:
                localctx = RegelSpraakParser.UnaryInconsistentDataConditionContext(self, localctx)
                self.enterOuterAlt(localctx, 7)
                self.state = 2037
                localctx.expr = self.primaryExpression(0)
                self.state = 2038
                self.match(RegelSpraakParser.IS_INCONSISTENT)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RegelStatusConditionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_regelStatusCondition

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class RegelStatusInconsistentCheckContext(RegelStatusConditionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.RegelStatusConditionContext
            super().__init__(parser)
            self.name = None # NaamwoordContext
            self.copyFrom(ctx)

        def REGELVERSIE(self):
            return self.getToken(RegelSpraakParser.REGELVERSIE, 0)
        def IS_INCONSISTENT(self):
            return self.getToken(RegelSpraakParser.IS_INCONSISTENT, 0)
        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRegelStatusInconsistentCheck" ):
                listener.enterRegelStatusInconsistentCheck(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRegelStatusInconsistentCheck" ):
                listener.exitRegelStatusInconsistentCheck(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRegelStatusInconsistentCheck" ):
                return visitor.visitRegelStatusInconsistentCheck(self)
            else:
                return visitor.visitChildren(self)


    class RegelStatusGevuurdCheckContext(RegelStatusConditionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.RegelStatusConditionContext
            super().__init__(parser)
            self.name = None # NaamwoordContext
            self.copyFrom(ctx)

        def REGELVERSIE(self):
            return self.getToken(RegelSpraakParser.REGELVERSIE, 0)
        def IS_GEVUURD(self):
            return self.getToken(RegelSpraakParser.IS_GEVUURD, 0)
        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRegelStatusGevuurdCheck" ):
                listener.enterRegelStatusGevuurdCheck(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRegelStatusGevuurdCheck" ):
                listener.exitRegelStatusGevuurdCheck(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRegelStatusGevuurdCheck" ):
                return visitor.visitRegelStatusGevuurdCheck(self)
            else:
                return visitor.visitChildren(self)



    def regelStatusCondition(self):

        localctx = RegelSpraakParser.RegelStatusConditionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 308, self.RULE_regelStatusCondition)
        try:
            self.state = 2050
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,229,self._ctx)
            if la_ == 1:
                localctx = RegelSpraakParser.RegelStatusGevuurdCheckContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 2042
                self.match(RegelSpraakParser.REGELVERSIE)
                self.state = 2043
                localctx.name = self.naamwoord()
                self.state = 2044
                self.match(RegelSpraakParser.IS_GEVUURD)
                pass

            elif la_ == 2:
                localctx = RegelSpraakParser.RegelStatusInconsistentCheckContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 2046
                self.match(RegelSpraakParser.REGELVERSIE)
                self.state = 2047
                localctx.name = self.naamwoord()
                self.state = 2048
                self.match(RegelSpraakParser.IS_INCONSISTENT)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SubordinateClauseExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_subordinateClauseExpression

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class SubordinateIsWithExprContext(SubordinateClauseExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.SubordinateClauseExpressionContext
            super().__init__(parser)
            self.subject = None # OnderwerpReferentieContext
            self.prepPhrase = None # NaamwoordWithNumbersContext
            self.verb = None # Token
            self.copyFrom(ctx)

        def onderwerpReferentie(self):
            return self.getTypedRuleContext(RegelSpraakParser.OnderwerpReferentieContext,0)

        def naamwoordWithNumbers(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordWithNumbersContext,0)

        def IS(self):
            return self.getToken(RegelSpraakParser.IS, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSubordinateIsWithExpr" ):
                listener.enterSubordinateIsWithExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSubordinateIsWithExpr" ):
                listener.exitSubordinateIsWithExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSubordinateIsWithExpr" ):
                return visitor.visitSubordinateIsWithExpr(self)
            else:
                return visitor.visitChildren(self)


    class SubordinateHasExprContext(SubordinateClauseExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.SubordinateClauseExpressionContext
            super().__init__(parser)
            self.subject = None # OnderwerpReferentieContext
            self.object_ = None # NaamwoordWithNumbersContext
            self.verb = None # Token
            self.copyFrom(ctx)

        def onderwerpReferentie(self):
            return self.getTypedRuleContext(RegelSpraakParser.OnderwerpReferentieContext,0)

        def naamwoordWithNumbers(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordWithNumbersContext,0)

        def HEEFT(self):
            return self.getToken(RegelSpraakParser.HEEFT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSubordinateHasExpr" ):
                listener.enterSubordinateHasExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSubordinateHasExpr" ):
                listener.exitSubordinateHasExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSubordinateHasExpr" ):
                return visitor.visitSubordinateHasExpr(self)
            else:
                return visitor.visitChildren(self)


    class SubordinateIsKenmerkExprContext(SubordinateClauseExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.SubordinateClauseExpressionContext
            super().__init__(parser)
            self.subject = None # OnderwerpReferentieContext
            self.verb = None # Token
            self.kenmerk = None # NaamwoordWithNumbersContext
            self.copyFrom(ctx)

        def onderwerpReferentie(self):
            return self.getTypedRuleContext(RegelSpraakParser.OnderwerpReferentieContext,0)

        def IS(self):
            return self.getToken(RegelSpraakParser.IS, 0)
        def naamwoordWithNumbers(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordWithNumbersContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSubordinateIsKenmerkExpr" ):
                listener.enterSubordinateIsKenmerkExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSubordinateIsKenmerkExpr" ):
                listener.exitSubordinateIsKenmerkExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSubordinateIsKenmerkExpr" ):
                return visitor.visitSubordinateIsKenmerkExpr(self)
            else:
                return visitor.visitChildren(self)



    def subordinateClauseExpression(self):

        localctx = RegelSpraakParser.SubordinateClauseExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 310, self.RULE_subordinateClauseExpression)
        try:
            self.state = 2064
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,230,self._ctx)
            if la_ == 1:
                localctx = RegelSpraakParser.SubordinateHasExprContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 2052
                localctx.subject = self.onderwerpReferentie()
                self.state = 2053
                localctx.object_ = self.naamwoordWithNumbers()
                self.state = 2054
                localctx.verb = self.match(RegelSpraakParser.HEEFT)
                pass

            elif la_ == 2:
                localctx = RegelSpraakParser.SubordinateIsWithExprContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 2056
                localctx.subject = self.onderwerpReferentie()
                self.state = 2057
                localctx.prepPhrase = self.naamwoordWithNumbers()
                self.state = 2058
                localctx.verb = self.match(RegelSpraakParser.IS)
                pass

            elif la_ == 3:
                localctx = RegelSpraakParser.SubordinateIsKenmerkExprContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 2060
                localctx.subject = self.onderwerpReferentie()
                self.state = 2061
                localctx.verb = self.match(RegelSpraakParser.IS)
                self.state = 2062
                localctx.kenmerk = self.naamwoordWithNumbers()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DagsoortDefinitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self._IDENTIFIER = None # Token
            self.plural = list() # of Tokens

        def DAGSOORT(self):
            return self.getToken(RegelSpraakParser.DAGSOORT, 0)

        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def MV_START(self):
            return self.getToken(RegelSpraakParser.MV_START, 0)

        def RPAREN(self):
            return self.getToken(RegelSpraakParser.RPAREN, 0)

        def SEMICOLON(self):
            return self.getToken(RegelSpraakParser.SEMICOLON, 0)

        def IDENTIFIER(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.IDENTIFIER)
            else:
                return self.getToken(RegelSpraakParser.IDENTIFIER, i)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_dagsoortDefinition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDagsoortDefinition" ):
                listener.enterDagsoortDefinition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDagsoortDefinition" ):
                listener.exitDagsoortDefinition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDagsoortDefinition" ):
                return visitor.visitDagsoortDefinition(self)
            else:
                return visitor.visitChildren(self)




    def dagsoortDefinition(self):

        localctx = RegelSpraakParser.DagsoortDefinitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 312, self.RULE_dagsoortDefinition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2066
            self.match(RegelSpraakParser.DAGSOORT)
            self.state = 2067
            self.naamwoord()
            self.state = 2075
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==178:
                self.state = 2068
                self.match(RegelSpraakParser.MV_START)
                self.state = 2070 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 2069
                    localctx._IDENTIFIER = self.match(RegelSpraakParser.IDENTIFIER)
                    localctx.plural.append(localctx._IDENTIFIER)
                    self.state = 2072 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==267):
                        break

                self.state = 2074
                self.match(RegelSpraakParser.RPAREN)


            self.state = 2078
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==281:
                self.state = 2077
                self.match(RegelSpraakParser.SEMICOLON)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TekstreeksExprContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STRING_LITERAL(self):
            return self.getToken(RegelSpraakParser.STRING_LITERAL, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_tekstreeksExpr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTekstreeksExpr" ):
                listener.enterTekstreeksExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTekstreeksExpr" ):
                listener.exitTekstreeksExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTekstreeksExpr" ):
                return visitor.visitTekstreeksExpr(self)
            else:
                return visitor.visitChildren(self)




    def tekstreeksExpr(self):

        localctx = RegelSpraakParser.TekstreeksExprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 314, self.RULE_tekstreeksExpr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2080
            self.match(RegelSpraakParser.STRING_LITERAL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VerdelingResultaatContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.sourceAmount = None # ExpressieContext
            self.targetCollection = None # ExpressieContext

        def WORDT_VERDEELD_OVER(self):
            return self.getToken(RegelSpraakParser.WORDT_VERDEELD_OVER, 0)

        def COMMA(self):
            return self.getToken(RegelSpraakParser.COMMA, 0)

        def WAARBIJ_WORDT_VERDEELD(self):
            return self.getToken(RegelSpraakParser.WAARBIJ_WORDT_VERDEELD, 0)

        def expressie(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.ExpressieContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,i)


        def verdelingMethodeSimple(self):
            return self.getTypedRuleContext(RegelSpraakParser.VerdelingMethodeSimpleContext,0)


        def verdelingMethodeMultiLine(self):
            return self.getTypedRuleContext(RegelSpraakParser.VerdelingMethodeMultiLineContext,0)


        def verdelingRest(self):
            return self.getTypedRuleContext(RegelSpraakParser.VerdelingRestContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_verdelingResultaat

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVerdelingResultaat" ):
                listener.enterVerdelingResultaat(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVerdelingResultaat" ):
                listener.exitVerdelingResultaat(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVerdelingResultaat" ):
                return visitor.visitVerdelingResultaat(self)
            else:
                return visitor.visitChildren(self)




    def verdelingResultaat(self):

        localctx = RegelSpraakParser.VerdelingResultaatContext(self, self._ctx, self.state)
        self.enterRule(localctx, 316, self.RULE_verdelingResultaat)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2082
            localctx.sourceAmount = self.expressie()
            self.state = 2083
            self.match(RegelSpraakParser.WORDT_VERDEELD_OVER)
            self.state = 2084
            localctx.targetCollection = self.expressie()
            self.state = 2085
            self.match(RegelSpraakParser.COMMA)
            self.state = 2086
            self.match(RegelSpraakParser.WAARBIJ_WORDT_VERDEELD)
            self.state = 2089
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [21, 33, 34, 35, 123, 198]:
                self.state = 2087
                self.verdelingMethodeSimple()
                pass
            elif token in [280]:
                self.state = 2088
                self.verdelingMethodeMultiLine()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 2092
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==19:
                self.state = 2091
                self.verdelingRest()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VerdelingMethodeSimpleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def verdelingMethode(self):
            return self.getTypedRuleContext(RegelSpraakParser.VerdelingMethodeContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_verdelingMethodeSimple

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVerdelingMethodeSimple" ):
                listener.enterVerdelingMethodeSimple(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVerdelingMethodeSimple" ):
                listener.exitVerdelingMethodeSimple(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVerdelingMethodeSimple" ):
                return visitor.visitVerdelingMethodeSimple(self)
            else:
                return visitor.visitChildren(self)




    def verdelingMethodeSimple(self):

        localctx = RegelSpraakParser.VerdelingMethodeSimpleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 318, self.RULE_verdelingMethodeSimple)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2094
            self.verdelingMethode()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VerdelingMethodeMultiLineContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def COLON(self):
            return self.getToken(RegelSpraakParser.COLON, 0)

        def verdelingMethodeBulletList(self):
            return self.getTypedRuleContext(RegelSpraakParser.VerdelingMethodeBulletListContext,0)


        def DOT(self):
            return self.getToken(RegelSpraakParser.DOT, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_verdelingMethodeMultiLine

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVerdelingMethodeMultiLine" ):
                listener.enterVerdelingMethodeMultiLine(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVerdelingMethodeMultiLine" ):
                listener.exitVerdelingMethodeMultiLine(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVerdelingMethodeMultiLine" ):
                return visitor.visitVerdelingMethodeMultiLine(self)
            else:
                return visitor.visitChildren(self)




    def verdelingMethodeMultiLine(self):

        localctx = RegelSpraakParser.VerdelingMethodeMultiLineContext(self, self._ctx, self.state)
        self.enterRule(localctx, 320, self.RULE_verdelingMethodeMultiLine)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2096
            self.match(RegelSpraakParser.COLON)
            self.state = 2097
            self.verdelingMethodeBulletList()
            self.state = 2099
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,236,self._ctx)
            if la_ == 1:
                self.state = 2098
                self.match(RegelSpraakParser.DOT)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VerdelingMethodeBulletListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def verdelingMethodeBullet(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.VerdelingMethodeBulletContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.VerdelingMethodeBulletContext,i)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_verdelingMethodeBulletList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVerdelingMethodeBulletList" ):
                listener.enterVerdelingMethodeBulletList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVerdelingMethodeBulletList" ):
                listener.exitVerdelingMethodeBulletList(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVerdelingMethodeBulletList" ):
                return visitor.visitVerdelingMethodeBulletList(self)
            else:
                return visitor.visitChildren(self)




    def verdelingMethodeBulletList(self):

        localctx = RegelSpraakParser.VerdelingMethodeBulletListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 322, self.RULE_verdelingMethodeBulletList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2101
            self.verdelingMethodeBullet()
            self.state = 2105
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==292:
                self.state = 2102
                self.verdelingMethodeBullet()
                self.state = 2107
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VerdelingMethodeBulletContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MINUS(self):
            return self.getToken(RegelSpraakParser.MINUS, 0)

        def verdelingMethode(self):
            return self.getTypedRuleContext(RegelSpraakParser.VerdelingMethodeContext,0)


        def COMMA(self):
            return self.getToken(RegelSpraakParser.COMMA, 0)

        def DOT(self):
            return self.getToken(RegelSpraakParser.DOT, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_verdelingMethodeBullet

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVerdelingMethodeBullet" ):
                listener.enterVerdelingMethodeBullet(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVerdelingMethodeBullet" ):
                listener.exitVerdelingMethodeBullet(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVerdelingMethodeBullet" ):
                return visitor.visitVerdelingMethodeBullet(self)
            else:
                return visitor.visitChildren(self)




    def verdelingMethodeBullet(self):

        localctx = RegelSpraakParser.VerdelingMethodeBulletContext(self, self._ctx, self.state)
        self.enterRule(localctx, 324, self.RULE_verdelingMethodeBullet)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2108
            self.match(RegelSpraakParser.MINUS)
            self.state = 2109
            self.verdelingMethode()
            self.state = 2111
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,238,self._ctx)
            if la_ == 1:
                self.state = 2110
                _la = self._input.LA(1)
                if not(_la==278 or _la==279):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VerdelingMethodeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_verdelingMethode

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class VerdelingNaarRatoContext(VerdelingMethodeContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.VerdelingMethodeContext
            super().__init__(parser)
            self.ratioExpression = None # ExpressieContext
            self.copyFrom(ctx)

        def NAAR_RATO_VAN(self):
            return self.getToken(RegelSpraakParser.NAAR_RATO_VAN, 0)
        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVerdelingNaarRato" ):
                listener.enterVerdelingNaarRato(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVerdelingNaarRato" ):
                listener.exitVerdelingNaarRato(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVerdelingNaarRato" ):
                return visitor.visitVerdelingNaarRato(self)
            else:
                return visitor.visitChildren(self)


    class VerdelingGelijkeDelenContext(VerdelingMethodeContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.VerdelingMethodeContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def IN_GELIJKE_DELEN(self):
            return self.getToken(RegelSpraakParser.IN_GELIJKE_DELEN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVerdelingGelijkeDelen" ):
                listener.enterVerdelingGelijkeDelen(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVerdelingGelijkeDelen" ):
                listener.exitVerdelingGelijkeDelen(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVerdelingGelijkeDelen" ):
                return visitor.visitVerdelingGelijkeDelen(self)
            else:
                return visitor.visitChildren(self)


    class VerdelingMaximumContext(VerdelingMethodeContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.VerdelingMethodeContext
            super().__init__(parser)
            self.maxExpression = None # ExpressieContext
            self.copyFrom(ctx)

        def MET_EEN_MAXIMUM_VAN(self):
            return self.getToken(RegelSpraakParser.MET_EEN_MAXIMUM_VAN, 0)
        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVerdelingMaximum" ):
                listener.enterVerdelingMaximum(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVerdelingMaximum" ):
                listener.exitVerdelingMaximum(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVerdelingMaximum" ):
                return visitor.visitVerdelingMaximum(self)
            else:
                return visitor.visitChildren(self)


    class VerdelingOpVolgordeContext(VerdelingMethodeContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.VerdelingMethodeContext
            super().__init__(parser)
            self.orderDirection = None # Token
            self.orderExpression = None # ExpressieContext
            self.copyFrom(ctx)

        def OP_VOLGORDE_VAN(self):
            return self.getToken(RegelSpraakParser.OP_VOLGORDE_VAN, 0)
        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)

        def TOENEMENDE(self):
            return self.getToken(RegelSpraakParser.TOENEMENDE, 0)
        def AFNEMENDE(self):
            return self.getToken(RegelSpraakParser.AFNEMENDE, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVerdelingOpVolgorde" ):
                listener.enterVerdelingOpVolgorde(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVerdelingOpVolgorde" ):
                listener.exitVerdelingOpVolgorde(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVerdelingOpVolgorde" ):
                return visitor.visitVerdelingOpVolgorde(self)
            else:
                return visitor.visitChildren(self)


    class VerdelingTieBreakContext(VerdelingMethodeContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.VerdelingMethodeContext
            super().__init__(parser)
            self.tieBreakMethod = None # VerdelingMethodeContext
            self.copyFrom(ctx)

        def BIJ_EVEN_GROOT_CRITERIUM(self):
            return self.getToken(RegelSpraakParser.BIJ_EVEN_GROOT_CRITERIUM, 0)
        def verdelingMethode(self):
            return self.getTypedRuleContext(RegelSpraakParser.VerdelingMethodeContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVerdelingTieBreak" ):
                listener.enterVerdelingTieBreak(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVerdelingTieBreak" ):
                listener.exitVerdelingTieBreak(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVerdelingTieBreak" ):
                return visitor.visitVerdelingTieBreak(self)
            else:
                return visitor.visitChildren(self)


    class VerdelingAfrondingContext(VerdelingMethodeContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.VerdelingMethodeContext
            super().__init__(parser)
            self.decimals = None # Token
            self.roundDirection = None # Token
            self.copyFrom(ctx)

        def AFGEROND_OP(self):
            return self.getToken(RegelSpraakParser.AFGEROND_OP, 0)
        def DECIMALEN(self):
            return self.getToken(RegelSpraakParser.DECIMALEN, 0)
        def NUMBER(self):
            return self.getToken(RegelSpraakParser.NUMBER, 0)
        def NAAR_BENEDEN(self):
            return self.getToken(RegelSpraakParser.NAAR_BENEDEN, 0)
        def NAAR_BOVEN(self):
            return self.getToken(RegelSpraakParser.NAAR_BOVEN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVerdelingAfronding" ):
                listener.enterVerdelingAfronding(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVerdelingAfronding" ):
                listener.exitVerdelingAfronding(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVerdelingAfronding" ):
                return visitor.visitVerdelingAfronding(self)
            else:
                return visitor.visitChildren(self)



    def verdelingMethode(self):

        localctx = RegelSpraakParser.VerdelingMethodeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 326, self.RULE_verdelingMethode)
        self._la = 0 # Token type
        try:
            self.state = 2127
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [198]:
                localctx = RegelSpraakParser.VerdelingGelijkeDelenContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 2113
                self.match(RegelSpraakParser.IN_GELIJKE_DELEN)
                pass
            elif token in [35]:
                localctx = RegelSpraakParser.VerdelingNaarRatoContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 2114
                self.match(RegelSpraakParser.NAAR_RATO_VAN)
                self.state = 2115
                localctx.ratioExpression = self.expressie()
                pass
            elif token in [34]:
                localctx = RegelSpraakParser.VerdelingOpVolgordeContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 2116
                self.match(RegelSpraakParser.OP_VOLGORDE_VAN)
                self.state = 2117
                localctx.orderDirection = self._input.LT(1)
                _la = self._input.LA(1)
                if not(_la==197 or _la==200):
                    localctx.orderDirection = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 2118
                localctx.orderExpression = self.expressie()
                pass
            elif token in [33]:
                localctx = RegelSpraakParser.VerdelingTieBreakContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 2119
                self.match(RegelSpraakParser.BIJ_EVEN_GROOT_CRITERIUM)
                self.state = 2120
                localctx.tieBreakMethod = self.verdelingMethode()
                pass
            elif token in [21]:
                localctx = RegelSpraakParser.VerdelingMaximumContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 2121
                self.match(RegelSpraakParser.MET_EEN_MAXIMUM_VAN)
                self.state = 2122
                localctx.maxExpression = self.expressie()
                pass
            elif token in [123]:
                localctx = RegelSpraakParser.VerdelingAfrondingContext(self, localctx)
                self.enterOuterAlt(localctx, 6)
                self.state = 2123
                self.match(RegelSpraakParser.AFGEROND_OP)
                self.state = 2124
                localctx.decimals = self.match(RegelSpraakParser.NUMBER)
                self.state = 2125
                self.match(RegelSpraakParser.DECIMALEN)
                self.state = 2126
                localctx.roundDirection = self._input.LT(1)
                _la = self._input.LA(1)
                if not(_la==138 or _la==139):
                    localctx.roundDirection = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VerdelingRestContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.remainderTarget = None # ExpressieContext

        def ALS_ONVERDEELDE_REST_BLIJFT(self):
            return self.getToken(RegelSpraakParser.ALS_ONVERDEELDE_REST_BLIJFT, 0)

        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)


        def OVER_VERDELING(self):
            return self.getToken(RegelSpraakParser.OVER_VERDELING, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_verdelingRest

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVerdelingRest" ):
                listener.enterVerdelingRest(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVerdelingRest" ):
                listener.exitVerdelingRest(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVerdelingRest" ):
                return visitor.visitVerdelingRest(self)
            else:
                return visitor.visitChildren(self)




    def verdelingRest(self):

        localctx = RegelSpraakParser.VerdelingRestContext(self, self._ctx, self.state)
        self.enterRule(localctx, 328, self.RULE_verdelingRest)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2129
            self.match(RegelSpraakParser.ALS_ONVERDEELDE_REST_BLIJFT)
            self.state = 2130
            localctx.remainderTarget = self.expressie()
            self.state = 2132
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==199:
                self.state = 2131
                self.match(RegelSpraakParser.OVER_VERDELING)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx



    def sempred(self, localctx:RuleContext, ruleIndex:int, predIndex:int):
        if self._predicates == None:
            self._predicates = dict()
        self._predicates[137] = self.primaryExpression_sempred
        pred = self._predicates.get(ruleIndex, None)
        if pred is None:
            raise Exception("No predicate with index:" + str(ruleIndex))
        else:
            return pred(localctx, predIndex)

    def primaryExpression_sempred(self, localctx:PrimaryExpressionContext, predIndex:int):
            if predIndex == 0:
                return self.precpred(self._ctx, 38)
         

            if predIndex == 1:
                return self.precpred(self._ctx, 42)
         

            if predIndex == 2:
                return self.precpred(self._ctx, 41)
         

            if predIndex == 3:
                return self.precpred(self._ctx, 40)
         




