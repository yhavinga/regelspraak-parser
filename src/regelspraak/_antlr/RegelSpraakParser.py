# Generated from RegelSpraak.g4 by ANTLR 4.13.1
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO

def serializedATN():
    return [
        4,1,271,1218,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,
        7,6,2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,
        13,2,14,7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,
        20,7,20,2,21,7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,
        26,2,27,7,27,2,28,7,28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,
        33,7,33,2,34,7,34,2,35,7,35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,
        39,2,40,7,40,2,41,7,41,2,42,7,42,2,43,7,43,2,44,7,44,2,45,7,45,2,
        46,7,46,2,47,7,47,2,48,7,48,2,49,7,49,2,50,7,50,2,51,7,51,2,52,7,
        52,2,53,7,53,2,54,7,54,2,55,7,55,2,56,7,56,2,57,7,57,2,58,7,58,2,
        59,7,59,2,60,7,60,2,61,7,61,2,62,7,62,2,63,7,63,2,64,7,64,2,65,7,
        65,2,66,7,66,2,67,7,67,2,68,7,68,2,69,7,69,2,70,7,70,2,71,7,71,2,
        72,7,72,2,73,7,73,2,74,7,74,2,75,7,75,2,76,7,76,2,77,7,77,2,78,7,
        78,2,79,7,79,2,80,7,80,2,81,7,81,2,82,7,82,2,83,7,83,2,84,7,84,2,
        85,7,85,2,86,7,86,1,0,1,0,1,0,1,0,1,0,5,0,180,8,0,10,0,12,0,183,
        9,0,1,0,1,0,1,1,1,1,1,1,1,1,1,1,1,1,3,1,193,8,1,1,2,1,2,1,2,3,2,
        198,8,2,1,3,1,3,1,4,3,4,203,8,4,1,4,4,4,206,8,4,11,4,12,4,207,1,
        4,4,4,211,8,4,11,4,12,4,212,1,4,1,4,4,4,217,8,4,11,4,12,4,218,1,
        4,1,4,4,4,223,8,4,11,4,12,4,224,1,4,1,4,4,4,229,8,4,11,4,12,4,230,
        1,4,4,4,234,8,4,11,4,12,4,235,1,4,1,4,4,4,240,8,4,11,4,12,4,241,
        1,4,1,4,4,4,246,8,4,11,4,12,4,247,3,4,250,8,4,1,5,1,5,1,5,1,5,5,
        5,256,8,5,10,5,12,5,259,9,5,1,6,1,6,1,7,1,7,1,8,1,8,1,9,1,9,1,9,
        1,9,4,9,271,8,9,11,9,12,9,272,1,9,3,9,276,8,9,1,9,3,9,279,8,9,1,
        9,5,9,282,8,9,10,9,12,9,285,9,9,1,10,1,10,3,10,289,8,10,1,10,1,10,
        1,11,3,11,294,8,11,1,11,1,11,3,11,298,8,11,1,11,1,11,3,11,302,8,
        11,1,12,1,12,1,12,3,12,307,8,12,1,12,1,12,1,12,1,12,1,12,3,12,314,
        8,12,3,12,316,8,12,1,12,1,12,1,12,1,12,5,12,322,8,12,10,12,12,12,
        325,9,12,3,12,327,8,12,1,12,3,12,330,8,12,1,13,1,13,1,13,1,13,3,
        13,336,8,13,1,14,1,14,1,14,1,14,1,14,3,14,343,8,14,1,15,1,15,1,16,
        1,16,1,17,1,17,1,18,3,18,352,8,18,1,18,1,18,1,18,1,18,1,18,1,18,
        3,18,360,8,18,1,19,1,19,4,19,364,8,19,11,19,12,19,365,1,19,1,19,
        1,19,1,19,3,19,372,8,19,1,19,3,19,375,8,19,1,20,1,20,1,20,1,20,1,
        20,3,20,382,8,20,1,21,1,21,4,21,386,8,21,11,21,12,21,387,1,22,1,
        22,1,22,1,23,1,23,1,23,5,23,396,8,23,10,23,12,23,399,9,23,1,24,1,
        24,1,24,1,24,1,24,1,24,3,24,407,8,24,1,25,1,25,1,26,1,26,1,26,3,
        26,414,8,26,1,26,1,26,1,26,1,26,3,26,420,8,26,1,27,1,27,1,27,3,27,
        425,8,27,1,28,1,28,1,28,3,28,430,8,28,1,28,1,28,1,28,1,28,4,28,436,
        8,28,11,28,12,28,437,1,29,1,29,1,29,1,29,3,29,444,8,29,1,29,3,29,
        447,8,29,1,30,1,30,1,30,1,30,1,31,1,31,1,32,1,32,1,33,1,33,1,33,
        1,33,1,33,3,33,462,8,33,1,33,1,33,3,33,466,8,33,1,33,3,33,469,8,
        33,1,33,1,33,1,34,3,34,474,8,34,1,34,4,34,477,8,34,11,34,12,34,478,
        1,35,1,35,1,36,1,36,1,36,1,36,1,36,1,36,3,36,489,8,36,1,36,1,36,
        4,36,493,8,36,11,36,12,36,494,1,37,1,37,1,37,1,38,1,38,1,38,3,38,
        503,8,38,1,38,1,38,1,38,1,38,3,38,509,8,38,1,38,3,38,512,8,38,1,
        38,3,38,515,8,38,1,39,4,39,518,8,39,11,39,12,39,519,1,39,1,39,4,
        39,524,8,39,11,39,12,39,525,1,39,1,39,4,39,530,8,39,11,39,12,39,
        531,1,39,1,39,4,39,536,8,39,11,39,12,39,537,1,39,1,39,1,39,4,39,
        543,8,39,11,39,12,39,544,1,39,1,39,1,39,4,39,550,8,39,11,39,12,39,
        551,1,39,1,39,4,39,556,8,39,11,39,12,39,557,1,39,4,39,561,8,39,11,
        39,12,39,562,1,39,1,39,4,39,567,8,39,11,39,12,39,568,3,39,571,8,
        39,1,40,1,40,1,40,1,41,1,41,1,41,1,41,1,41,3,41,581,8,41,3,41,583,
        8,41,1,42,1,42,3,42,587,8,42,1,42,1,42,1,42,1,42,1,42,1,42,3,42,
        595,8,42,1,42,1,42,1,42,1,42,1,42,1,42,1,42,1,42,1,42,1,42,1,42,
        4,42,608,8,42,11,42,12,42,609,1,42,1,42,1,42,1,42,1,42,1,42,3,42,
        618,8,42,1,42,1,42,5,42,622,8,42,10,42,12,42,625,9,42,1,42,1,42,
        1,42,1,42,1,42,1,42,3,42,633,8,42,1,42,1,42,1,42,1,42,1,42,3,42,
        640,8,42,1,42,3,42,643,8,42,1,42,1,42,1,42,1,42,1,42,1,42,1,42,1,
        42,3,42,653,8,42,1,42,3,42,656,8,42,1,43,1,43,1,43,1,43,3,43,662,
        8,43,1,43,3,43,665,8,43,1,43,1,43,1,43,1,43,1,43,3,43,672,8,43,1,
        43,3,43,675,8,43,3,43,677,8,43,1,44,1,44,1,44,1,44,5,44,683,8,44,
        10,44,12,44,686,9,44,1,45,1,45,1,45,1,45,1,46,1,46,1,46,1,46,1,46,
        1,46,3,46,698,8,46,1,46,3,46,701,8,46,3,46,703,8,46,1,47,1,47,1,
        47,3,47,708,8,47,1,48,3,48,711,8,48,1,48,1,48,1,48,1,49,1,49,1,49,
        3,49,719,8,49,1,50,1,50,1,50,1,50,5,50,725,8,50,10,50,12,50,728,
        9,50,1,51,3,51,731,8,51,1,51,4,51,734,8,51,11,51,12,51,735,1,51,
        3,51,739,8,51,1,52,1,52,1,52,1,52,1,53,1,53,1,54,1,54,1,54,1,55,
        1,55,1,55,3,55,753,8,55,1,55,1,55,1,55,1,55,1,55,1,55,1,55,1,55,
        1,55,1,55,1,55,1,55,1,55,1,55,3,55,769,8,55,1,56,1,56,1,56,1,56,
        1,56,3,56,776,8,56,1,57,1,57,1,57,1,57,5,57,782,8,57,10,57,12,57,
        785,9,57,1,58,1,58,1,59,1,59,5,59,791,8,59,10,59,12,59,794,9,59,
        1,59,1,59,1,60,1,60,1,60,1,60,3,60,802,8,60,1,61,1,61,1,62,1,62,
        1,63,1,63,1,63,1,63,1,63,1,63,1,63,1,63,1,63,1,63,1,63,1,63,3,63,
        820,8,63,1,63,1,63,3,63,824,8,63,1,64,1,64,1,65,1,65,1,65,1,65,5,
        65,832,8,65,10,65,12,65,835,9,65,1,66,1,66,1,67,1,67,1,67,1,67,5,
        67,843,8,67,10,67,12,67,846,9,67,1,68,1,68,1,69,1,69,1,69,1,69,5,
        69,854,8,69,10,69,12,69,857,9,69,1,70,1,70,1,71,1,71,1,71,1,71,1,
        71,1,71,1,71,1,71,1,71,1,71,1,71,3,71,872,8,71,1,71,1,71,1,71,1,
        71,1,71,1,71,3,71,880,8,71,1,71,1,71,3,71,884,8,71,1,71,1,71,3,71,
        888,8,71,1,71,1,71,3,71,892,8,71,1,71,1,71,1,71,1,71,3,71,898,8,
        71,1,71,1,71,1,71,1,71,1,71,1,71,5,71,906,8,71,10,71,12,71,909,9,
        71,1,71,1,71,1,71,1,71,1,71,1,71,1,71,1,71,1,71,1,71,1,71,1,71,1,
        71,1,71,5,71,925,8,71,10,71,12,71,928,9,71,1,71,1,71,1,71,1,71,1,
        71,1,71,1,71,5,71,937,8,71,10,71,12,71,940,9,71,1,71,1,71,1,71,1,
        71,1,71,1,71,1,71,1,71,1,71,1,71,1,71,1,71,1,71,1,71,1,71,1,71,1,
        71,1,71,1,71,1,71,1,71,1,71,1,71,1,71,1,71,1,71,1,71,1,71,1,71,1,
        71,1,71,1,71,1,71,5,71,975,8,71,10,71,12,71,978,9,71,1,71,1,71,1,
        71,1,71,1,71,1,71,1,71,5,71,987,8,71,10,71,12,71,990,9,71,1,71,1,
        71,1,71,1,71,1,71,1,71,1,71,3,71,999,8,71,1,71,1,71,1,71,1,71,1,
        71,3,71,1006,8,71,1,71,1,71,1,71,4,71,1011,8,71,11,71,12,71,1012,
        1,71,1,71,1,71,1,71,3,71,1019,8,71,1,71,1,71,1,71,1,71,1,71,1,71,
        3,71,1027,8,71,1,71,4,71,1030,8,71,11,71,12,71,1031,1,71,1,71,1,
        71,1,71,1,71,1,71,3,71,1040,8,71,1,71,1,71,3,71,1044,8,71,1,71,1,
        71,1,71,1,71,1,71,1,71,1,71,1,71,1,71,1,71,1,71,1,71,1,71,1,71,1,
        71,1,71,1,71,1,71,1,71,1,71,1,71,3,71,1067,8,71,1,71,1,71,1,71,4,
        71,1072,8,71,11,71,12,71,1073,1,71,1,71,1,71,1,71,1,71,1,71,1,71,
        1,71,1,71,1,71,1,71,1,71,1,71,5,71,1089,8,71,10,71,12,71,1092,9,
        71,1,72,1,72,1,72,1,72,1,72,1,73,1,73,1,73,1,73,1,73,1,73,3,73,1105,
        8,73,1,74,1,74,1,74,1,75,1,75,1,75,1,76,1,76,1,76,3,76,1116,8,76,
        1,77,1,77,1,77,1,77,1,77,1,77,1,77,1,77,1,77,1,77,1,77,1,77,1,77,
        1,77,1,77,1,77,3,77,1134,8,77,1,78,3,78,1137,8,78,1,78,1,78,1,78,
        1,78,3,78,1143,8,78,1,79,1,79,1,80,1,80,1,80,1,80,3,80,1151,8,80,
        1,80,1,80,1,81,1,81,1,81,1,82,1,82,1,82,1,82,1,82,1,82,1,82,1,83,
        1,83,1,83,1,83,1,83,1,83,1,83,5,83,1172,8,83,10,83,12,83,1175,9,
        83,1,83,1,83,1,83,1,83,1,84,1,84,1,84,1,84,1,84,1,84,1,84,1,84,1,
        84,1,84,1,84,1,84,1,84,1,84,1,84,1,84,1,84,1,84,1,84,1,84,1,84,1,
        84,1,84,1,84,1,84,1,84,3,84,1207,8,84,1,85,1,85,1,85,1,85,1,86,1,
        86,1,86,3,86,1216,8,86,1,86,0,1,142,87,0,2,4,6,8,10,12,14,16,18,
        20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,62,
        64,66,68,70,72,74,76,78,80,82,84,86,88,90,92,94,96,98,100,102,104,
        106,108,110,112,114,116,118,120,122,124,126,128,130,132,134,136,
        138,140,142,144,146,148,150,152,154,156,158,160,162,164,166,168,
        170,172,0,34,3,0,116,116,202,202,207,207,7,0,140,140,199,199,209,
        209,217,218,225,225,227,227,230,230,1,0,154,155,2,0,7,7,158,158,
        2,0,169,170,173,173,5,0,132,132,214,214,223,223,226,226,234,247,
        1,0,177,179,2,0,202,202,207,207,2,0,180,180,247,247,2,0,31,31,105,
        105,2,0,142,142,224,224,2,0,110,110,112,112,2,0,140,140,166,166,
        1,0,2,4,2,0,144,144,227,227,2,0,140,140,142,142,2,0,210,210,212,
        212,3,0,202,202,207,207,233,233,4,0,116,116,202,202,205,205,207,
        207,3,0,191,192,196,197,248,248,2,0,264,265,271,271,9,0,25,28,41,
        42,50,69,112,112,120,120,123,123,126,126,128,129,135,136,3,0,132,
        132,137,137,146,146,2,0,121,122,131,131,2,0,206,206,215,215,2,0,
        132,132,137,137,3,0,133,134,138,139,149,149,2,0,181,181,183,183,
        2,0,70,73,82,85,1,0,86,89,1,0,90,93,4,0,74,74,76,76,78,78,80,80,
        4,0,75,75,77,77,79,79,81,81,1,0,95,96,1364,0,181,1,0,0,0,2,192,1,
        0,0,0,4,194,1,0,0,0,6,199,1,0,0,0,8,249,1,0,0,0,10,251,1,0,0,0,12,
        260,1,0,0,0,14,262,1,0,0,0,16,264,1,0,0,0,18,266,1,0,0,0,20,288,
        1,0,0,0,22,297,1,0,0,0,24,303,1,0,0,0,26,335,1,0,0,0,28,337,1,0,
        0,0,30,344,1,0,0,0,32,346,1,0,0,0,34,348,1,0,0,0,36,351,1,0,0,0,
        38,361,1,0,0,0,40,381,1,0,0,0,42,383,1,0,0,0,44,389,1,0,0,0,46,392,
        1,0,0,0,48,400,1,0,0,0,50,408,1,0,0,0,52,419,1,0,0,0,54,421,1,0,
        0,0,56,426,1,0,0,0,58,446,1,0,0,0,60,448,1,0,0,0,62,452,1,0,0,0,
        64,454,1,0,0,0,66,456,1,0,0,0,68,473,1,0,0,0,70,480,1,0,0,0,72,482,
        1,0,0,0,74,496,1,0,0,0,76,499,1,0,0,0,78,570,1,0,0,0,80,572,1,0,
        0,0,82,582,1,0,0,0,84,655,1,0,0,0,86,676,1,0,0,0,88,678,1,0,0,0,
        90,687,1,0,0,0,92,691,1,0,0,0,94,704,1,0,0,0,96,710,1,0,0,0,98,715,
        1,0,0,0,100,720,1,0,0,0,102,738,1,0,0,0,104,740,1,0,0,0,106,744,
        1,0,0,0,108,746,1,0,0,0,110,768,1,0,0,0,112,775,1,0,0,0,114,777,
        1,0,0,0,116,786,1,0,0,0,118,788,1,0,0,0,120,797,1,0,0,0,122,803,
        1,0,0,0,124,805,1,0,0,0,126,823,1,0,0,0,128,825,1,0,0,0,130,827,
        1,0,0,0,132,836,1,0,0,0,134,838,1,0,0,0,136,847,1,0,0,0,138,849,
        1,0,0,0,140,858,1,0,0,0,142,1066,1,0,0,0,144,1093,1,0,0,0,146,1104,
        1,0,0,0,148,1106,1,0,0,0,150,1109,1,0,0,0,152,1115,1,0,0,0,154,1133,
        1,0,0,0,156,1142,1,0,0,0,158,1144,1,0,0,0,160,1146,1,0,0,0,162,1154,
        1,0,0,0,164,1157,1,0,0,0,166,1164,1,0,0,0,168,1206,1,0,0,0,170,1208,
        1,0,0,0,172,1212,1,0,0,0,174,180,3,2,1,0,175,180,3,76,38,0,176,180,
        3,4,2,0,177,180,3,92,46,0,178,180,3,46,23,0,179,174,1,0,0,0,179,
        175,1,0,0,0,179,176,1,0,0,0,179,177,1,0,0,0,179,178,1,0,0,0,180,
        183,1,0,0,0,181,179,1,0,0,0,181,182,1,0,0,0,182,184,1,0,0,0,183,
        181,1,0,0,0,184,185,5,0,0,1,185,1,1,0,0,0,186,193,3,18,9,0,187,193,
        3,38,19,0,188,193,3,66,33,0,189,193,3,56,28,0,190,193,3,72,36,0,
        191,193,3,172,86,0,192,186,1,0,0,0,192,187,1,0,0,0,192,188,1,0,0,
        0,192,189,1,0,0,0,192,190,1,0,0,0,192,191,1,0,0,0,193,3,1,0,0,0,
        194,195,5,99,0,0,195,197,3,10,5,0,196,198,3,80,40,0,197,196,1,0,
        0,0,197,198,1,0,0,0,198,5,1,0,0,0,199,200,5,247,0,0,200,7,1,0,0,
        0,201,203,7,0,0,0,202,201,1,0,0,0,202,203,1,0,0,0,203,205,1,0,0,
        0,204,206,5,247,0,0,205,204,1,0,0,0,206,207,1,0,0,0,207,205,1,0,
        0,0,207,208,1,0,0,0,208,250,1,0,0,0,209,211,3,6,3,0,210,209,1,0,
        0,0,211,212,1,0,0,0,212,210,1,0,0,0,212,213,1,0,0,0,213,250,1,0,
        0,0,214,216,5,48,0,0,215,217,5,247,0,0,216,215,1,0,0,0,217,218,1,
        0,0,0,218,216,1,0,0,0,218,219,1,0,0,0,219,250,1,0,0,0,220,222,5,
        48,0,0,221,223,5,247,0,0,222,221,1,0,0,0,223,224,1,0,0,0,224,222,
        1,0,0,0,224,225,1,0,0,0,225,226,1,0,0,0,226,228,5,166,0,0,227,229,
        5,247,0,0,228,227,1,0,0,0,229,230,1,0,0,0,230,228,1,0,0,0,230,231,
        1,0,0,0,231,250,1,0,0,0,232,234,3,6,3,0,233,232,1,0,0,0,234,235,
        1,0,0,0,235,233,1,0,0,0,235,236,1,0,0,0,236,237,1,0,0,0,237,239,
        5,166,0,0,238,240,3,6,3,0,239,238,1,0,0,0,240,241,1,0,0,0,241,239,
        1,0,0,0,241,242,1,0,0,0,242,250,1,0,0,0,243,245,5,135,0,0,244,246,
        5,247,0,0,245,244,1,0,0,0,246,247,1,0,0,0,247,245,1,0,0,0,247,248,
        1,0,0,0,248,250,1,0,0,0,249,202,1,0,0,0,249,210,1,0,0,0,249,214,
        1,0,0,0,249,220,1,0,0,0,249,233,1,0,0,0,249,243,1,0,0,0,250,9,1,
        0,0,0,251,257,3,8,4,0,252,253,3,12,6,0,253,254,3,8,4,0,254,256,1,
        0,0,0,255,252,1,0,0,0,256,259,1,0,0,0,257,255,1,0,0,0,257,258,1,
        0,0,0,258,11,1,0,0,0,259,257,1,0,0,0,260,261,7,1,0,0,261,13,1,0,
        0,0,262,263,5,250,0,0,263,15,1,0,0,0,264,265,5,247,0,0,265,17,1,
        0,0,0,266,267,5,100,0,0,267,275,3,10,5,0,268,270,5,168,0,0,269,271,
        5,247,0,0,270,269,1,0,0,0,271,272,1,0,0,0,272,270,1,0,0,0,272,273,
        1,0,0,0,273,274,1,0,0,0,274,276,5,255,0,0,275,268,1,0,0,0,275,276,
        1,0,0,0,276,278,1,0,0,0,277,279,5,153,0,0,278,277,1,0,0,0,278,279,
        1,0,0,0,279,283,1,0,0,0,280,282,3,20,10,0,281,280,1,0,0,0,282,285,
        1,0,0,0,283,281,1,0,0,0,283,284,1,0,0,0,284,19,1,0,0,0,285,283,1,
        0,0,0,286,289,3,22,11,0,287,289,3,24,12,0,288,286,1,0,0,0,288,287,
        1,0,0,0,289,290,1,0,0,0,290,291,5,261,0,0,291,21,1,0,0,0,292,294,
        5,112,0,0,293,292,1,0,0,0,293,294,1,0,0,0,294,295,1,0,0,0,295,298,
        3,6,3,0,296,298,3,10,5,0,297,293,1,0,0,0,297,296,1,0,0,0,298,299,
        1,0,0,0,299,301,5,164,0,0,300,302,7,2,0,0,301,300,1,0,0,0,301,302,
        1,0,0,0,302,23,1,0,0,0,303,306,3,10,5,0,304,307,3,26,13,0,305,307,
        3,44,22,0,306,304,1,0,0,0,306,305,1,0,0,0,307,315,1,0,0,0,308,313,
        5,167,0,0,309,314,5,247,0,0,310,314,5,263,0,0,311,314,5,245,0,0,
        312,314,5,246,0,0,313,309,1,0,0,0,313,310,1,0,0,0,313,311,1,0,0,
        0,313,312,1,0,0,0,314,316,1,0,0,0,315,308,1,0,0,0,315,316,1,0,0,
        0,316,326,1,0,0,0,317,318,5,161,0,0,318,323,3,64,32,0,319,320,5,
        206,0,0,320,322,3,64,32,0,321,319,1,0,0,0,322,325,1,0,0,0,323,321,
        1,0,0,0,323,324,1,0,0,0,324,327,1,0,0,0,325,323,1,0,0,0,326,317,
        1,0,0,0,326,327,1,0,0,0,327,329,1,0,0,0,328,330,3,62,31,0,329,328,
        1,0,0,0,329,330,1,0,0,0,330,25,1,0,0,0,331,336,3,28,14,0,332,336,
        3,30,15,0,333,336,3,32,16,0,334,336,3,34,17,0,335,331,1,0,0,0,335,
        332,1,0,0,0,335,333,1,0,0,0,335,334,1,0,0,0,336,27,1,0,0,0,337,342,
        5,171,0,0,338,339,5,254,0,0,339,340,3,36,18,0,340,341,5,255,0,0,
        341,343,1,0,0,0,342,338,1,0,0,0,342,343,1,0,0,0,343,29,1,0,0,0,344,
        345,5,176,0,0,345,31,1,0,0,0,346,347,5,156,0,0,347,33,1,0,0,0,348,
        349,7,3,0,0,349,35,1,0,0,0,350,352,7,4,0,0,351,350,1,0,0,0,351,352,
        1,0,0,0,352,359,1,0,0,0,353,360,5,162,0,0,354,355,5,163,0,0,355,
        356,5,166,0,0,356,357,5,248,0,0,357,360,5,159,0,0,358,360,5,163,
        0,0,359,353,1,0,0,0,359,354,1,0,0,0,359,358,1,0,0,0,360,37,1,0,0,
        0,361,363,5,101,0,0,362,364,5,247,0,0,363,362,1,0,0,0,364,365,1,
        0,0,0,365,363,1,0,0,0,365,366,1,0,0,0,366,367,1,0,0,0,367,368,5,
        32,0,0,368,371,3,40,20,0,369,370,5,167,0,0,370,372,3,52,26,0,371,
        369,1,0,0,0,371,372,1,0,0,0,372,374,1,0,0,0,373,375,5,261,0,0,374,
        373,1,0,0,0,374,375,1,0,0,0,375,39,1,0,0,0,376,382,3,42,21,0,377,
        382,3,28,14,0,378,382,3,30,15,0,379,382,3,32,16,0,380,382,3,34,17,
        0,381,376,1,0,0,0,381,377,1,0,0,0,381,378,1,0,0,0,381,379,1,0,0,
        0,381,380,1,0,0,0,382,41,1,0,0,0,383,385,5,160,0,0,384,386,5,253,
        0,0,385,384,1,0,0,0,386,387,1,0,0,0,387,385,1,0,0,0,387,388,1,0,
        0,0,388,43,1,0,0,0,389,390,5,101,0,0,390,391,5,247,0,0,391,45,1,
        0,0,0,392,393,5,103,0,0,393,397,3,6,3,0,394,396,3,48,24,0,395,394,
        1,0,0,0,396,399,1,0,0,0,397,395,1,0,0,0,397,398,1,0,0,0,398,47,1,
        0,0,0,399,397,1,0,0,0,400,401,5,202,0,0,401,402,3,50,25,0,402,406,
        3,50,25,0,403,404,5,249,0,0,404,405,5,248,0,0,405,407,3,50,25,0,
        406,403,1,0,0,0,406,407,1,0,0,0,407,49,1,0,0,0,408,409,7,5,0,0,409,
        51,1,0,0,0,410,413,3,54,27,0,411,412,5,262,0,0,412,414,3,54,27,0,
        413,411,1,0,0,0,413,414,1,0,0,0,414,420,1,0,0,0,415,420,5,248,0,
        0,416,420,5,263,0,0,417,420,5,245,0,0,418,420,5,246,0,0,419,410,
        1,0,0,0,419,415,1,0,0,0,419,416,1,0,0,0,419,417,1,0,0,0,419,418,
        1,0,0,0,420,53,1,0,0,0,421,424,3,50,25,0,422,423,5,268,0,0,423,425,
        5,248,0,0,424,422,1,0,0,0,424,425,1,0,0,0,425,55,1,0,0,0,426,427,
        5,102,0,0,427,429,3,10,5,0,428,430,5,258,0,0,429,428,1,0,0,0,429,
        430,1,0,0,0,430,431,1,0,0,0,431,432,5,30,0,0,432,433,3,10,5,0,433,
        435,3,58,29,0,434,436,3,60,30,0,435,434,1,0,0,0,436,437,1,0,0,0,
        437,435,1,0,0,0,437,438,1,0,0,0,438,57,1,0,0,0,439,440,5,6,0,0,440,
        441,3,12,6,0,441,443,5,255,0,0,442,444,5,260,0,0,443,442,1,0,0,0,
        443,444,1,0,0,0,444,447,1,0,0,0,445,447,5,5,0,0,446,439,1,0,0,0,
        446,445,1,0,0,0,447,59,1,0,0,0,448,449,5,248,0,0,449,450,5,259,0,
        0,450,451,3,6,3,0,451,61,1,0,0,0,452,453,7,6,0,0,453,63,1,0,0,0,
        454,455,5,247,0,0,455,65,1,0,0,0,456,457,5,104,0,0,457,458,3,68,
        34,0,458,461,5,260,0,0,459,462,3,26,13,0,460,462,3,44,22,0,461,459,
        1,0,0,0,461,460,1,0,0,0,462,465,1,0,0,0,463,464,5,167,0,0,464,466,
        3,52,26,0,465,463,1,0,0,0,465,466,1,0,0,0,466,468,1,0,0,0,467,469,
        3,62,31,0,468,467,1,0,0,0,468,469,1,0,0,0,469,470,1,0,0,0,470,471,
        5,261,0,0,471,67,1,0,0,0,472,474,7,7,0,0,473,472,1,0,0,0,473,474,
        1,0,0,0,474,476,1,0,0,0,475,477,7,8,0,0,476,475,1,0,0,0,477,478,
        1,0,0,0,478,476,1,0,0,0,478,479,1,0,0,0,479,69,1,0,0,0,480,481,3,
        10,5,0,481,71,1,0,0,0,482,483,7,9,0,0,483,488,3,10,5,0,484,485,5,
        110,0,0,485,489,3,10,5,0,486,487,5,112,0,0,487,489,3,10,5,0,488,
        484,1,0,0,0,488,486,1,0,0,0,489,490,1,0,0,0,490,492,3,74,37,0,491,
        493,3,74,37,0,492,491,1,0,0,0,493,494,1,0,0,0,494,492,1,0,0,0,494,
        495,1,0,0,0,495,73,1,0,0,0,496,497,3,58,29,0,497,498,3,6,3,0,498,
        75,1,0,0,0,499,500,5,98,0,0,500,502,3,78,39,0,501,503,5,248,0,0,
        502,501,1,0,0,0,502,503,1,0,0,0,503,504,1,0,0,0,504,505,3,80,40,
        0,505,511,3,84,42,0,506,508,3,98,49,0,507,509,5,259,0,0,508,507,
        1,0,0,0,508,509,1,0,0,0,509,512,1,0,0,0,510,512,5,259,0,0,511,506,
        1,0,0,0,511,510,1,0,0,0,511,512,1,0,0,0,512,514,1,0,0,0,513,515,
        3,118,59,0,514,513,1,0,0,0,514,515,1,0,0,0,515,77,1,0,0,0,516,518,
        5,247,0,0,517,516,1,0,0,0,518,519,1,0,0,0,519,517,1,0,0,0,519,520,
        1,0,0,0,520,571,1,0,0,0,521,571,3,10,5,0,522,524,5,247,0,0,523,522,
        1,0,0,0,524,525,1,0,0,0,525,523,1,0,0,0,525,526,1,0,0,0,526,527,
        1,0,0,0,527,571,5,164,0,0,528,530,5,247,0,0,529,528,1,0,0,0,530,
        531,1,0,0,0,531,529,1,0,0,0,531,532,1,0,0,0,532,533,1,0,0,0,533,
        571,5,174,0,0,534,536,5,247,0,0,535,534,1,0,0,0,536,537,1,0,0,0,
        537,535,1,0,0,0,537,538,1,0,0,0,538,539,1,0,0,0,539,540,5,135,0,
        0,540,571,5,164,0,0,541,543,5,247,0,0,542,541,1,0,0,0,543,544,1,
        0,0,0,544,542,1,0,0,0,544,545,1,0,0,0,545,546,1,0,0,0,546,547,5,
        135,0,0,547,571,5,174,0,0,548,550,5,247,0,0,549,548,1,0,0,0,550,
        551,1,0,0,0,551,549,1,0,0,0,551,552,1,0,0,0,552,553,1,0,0,0,553,
        555,5,165,0,0,554,556,5,247,0,0,555,554,1,0,0,0,556,557,1,0,0,0,
        557,555,1,0,0,0,557,558,1,0,0,0,558,571,1,0,0,0,559,561,5,247,0,
        0,560,559,1,0,0,0,561,562,1,0,0,0,562,560,1,0,0,0,562,563,1,0,0,
        0,563,564,1,0,0,0,564,566,5,175,0,0,565,567,5,247,0,0,566,565,1,
        0,0,0,567,568,1,0,0,0,568,566,1,0,0,0,568,569,1,0,0,0,569,571,1,
        0,0,0,570,517,1,0,0,0,570,521,1,0,0,0,570,523,1,0,0,0,570,529,1,
        0,0,0,570,535,1,0,0,0,570,542,1,0,0,0,570,549,1,0,0,0,570,560,1,
        0,0,0,571,79,1,0,0,0,572,573,5,108,0,0,573,574,3,82,41,0,574,81,
        1,0,0,0,575,583,5,198,0,0,576,577,5,144,0,0,577,580,3,14,7,0,578,
        579,7,10,0,0,579,581,3,14,7,0,580,578,1,0,0,0,580,581,1,0,0,0,581,
        583,1,0,0,0,582,575,1,0,0,0,582,576,1,0,0,0,583,83,1,0,0,0,584,587,
        3,10,5,0,585,587,3,104,52,0,586,584,1,0,0,0,586,585,1,0,0,0,587,
        594,1,0,0,0,588,589,5,11,0,0,589,595,3,122,61,0,590,591,5,12,0,0,
        591,595,3,122,61,0,592,593,5,13,0,0,593,595,3,122,61,0,594,588,1,
        0,0,0,594,590,1,0,0,0,594,592,1,0,0,0,595,656,1,0,0,0,596,597,3,
        100,50,0,597,598,7,11,0,0,598,599,3,106,53,0,599,656,1,0,0,0,600,
        601,3,100,50,0,601,602,5,110,0,0,602,603,3,10,5,0,603,604,7,12,0,
        0,604,605,3,100,50,0,605,656,1,0,0,0,606,608,3,6,3,0,607,606,1,0,
        0,0,608,609,1,0,0,0,609,607,1,0,0,0,609,610,1,0,0,0,610,617,1,0,
        0,0,611,612,5,11,0,0,612,618,3,122,61,0,613,614,5,12,0,0,614,618,
        3,122,61,0,615,616,5,13,0,0,616,618,3,122,61,0,617,611,1,0,0,0,617,
        613,1,0,0,0,617,615,1,0,0,0,618,656,1,0,0,0,619,623,7,13,0,0,620,
        622,3,6,3,0,621,620,1,0,0,0,622,625,1,0,0,0,623,621,1,0,0,0,623,
        624,1,0,0,0,624,632,1,0,0,0,625,623,1,0,0,0,626,627,5,11,0,0,627,
        633,3,122,61,0,628,629,5,12,0,0,629,633,3,122,61,0,630,631,5,13,
        0,0,631,633,3,122,61,0,632,626,1,0,0,0,632,628,1,0,0,0,632,630,1,
        0,0,0,633,639,1,0,0,0,634,635,7,14,0,0,635,636,3,14,7,0,636,637,
        7,15,0,0,637,638,3,14,7,0,638,640,1,0,0,0,639,634,1,0,0,0,639,640,
        1,0,0,0,640,642,1,0,0,0,641,643,5,259,0,0,642,641,1,0,0,0,642,643,
        1,0,0,0,643,656,1,0,0,0,644,645,5,1,0,0,645,652,7,16,0,0,646,647,
        5,11,0,0,647,653,3,122,61,0,648,649,5,12,0,0,649,653,3,122,61,0,
        650,651,5,13,0,0,651,653,3,122,61,0,652,646,1,0,0,0,652,648,1,0,
        0,0,652,650,1,0,0,0,653,656,1,0,0,0,654,656,3,86,43,0,655,586,1,
        0,0,0,655,596,1,0,0,0,655,600,1,0,0,0,655,607,1,0,0,0,655,619,1,
        0,0,0,655,644,1,0,0,0,655,654,1,0,0,0,656,85,1,0,0,0,657,658,5,44,
        0,0,658,659,3,10,5,0,659,661,5,46,0,0,660,662,3,88,44,0,661,660,
        1,0,0,0,661,662,1,0,0,0,662,664,1,0,0,0,663,665,5,259,0,0,664,663,
        1,0,0,0,664,665,1,0,0,0,665,677,1,0,0,0,666,667,5,47,0,0,667,668,
        5,205,0,0,668,669,5,48,0,0,669,671,3,10,5,0,670,672,3,88,44,0,671,
        670,1,0,0,0,671,672,1,0,0,0,672,674,1,0,0,0,673,675,5,259,0,0,674,
        673,1,0,0,0,674,675,1,0,0,0,675,677,1,0,0,0,676,657,1,0,0,0,676,
        666,1,0,0,0,677,87,1,0,0,0,678,679,5,166,0,0,679,680,3,10,5,0,680,
        684,3,122,61,0,681,683,3,90,45,0,682,681,1,0,0,0,683,686,1,0,0,0,
        684,682,1,0,0,0,684,685,1,0,0,0,685,89,1,0,0,0,686,684,1,0,0,0,687,
        688,5,206,0,0,688,689,3,10,5,0,689,690,3,122,61,0,690,91,1,0,0,0,
        691,692,5,97,0,0,692,702,3,10,5,0,693,703,3,94,47,0,694,700,3,96,
        48,0,695,697,3,98,49,0,696,698,5,259,0,0,697,696,1,0,0,0,697,698,
        1,0,0,0,698,701,1,0,0,0,699,701,5,259,0,0,700,695,1,0,0,0,700,699,
        1,0,0,0,700,701,1,0,0,0,701,703,1,0,0,0,702,693,1,0,0,0,702,694,
        1,0,0,0,703,93,1,0,0,0,704,705,3,100,50,0,705,707,5,94,0,0,706,708,
        5,259,0,0,707,706,1,0,0,0,707,708,1,0,0,0,708,95,1,0,0,0,709,711,
        7,17,0,0,710,709,1,0,0,0,710,711,1,0,0,0,711,712,1,0,0,0,712,713,
        3,10,5,0,713,714,5,96,0,0,714,97,1,0,0,0,715,718,5,111,0,0,716,719,
        3,122,61,0,717,719,3,110,55,0,718,716,1,0,0,0,718,717,1,0,0,0,719,
        99,1,0,0,0,720,726,3,102,51,0,721,722,3,12,6,0,722,723,3,102,51,
        0,723,725,1,0,0,0,724,721,1,0,0,0,725,728,1,0,0,0,726,724,1,0,0,
        0,726,727,1,0,0,0,727,101,1,0,0,0,728,726,1,0,0,0,729,731,7,18,0,
        0,730,729,1,0,0,0,730,731,1,0,0,0,731,733,1,0,0,0,732,734,5,247,
        0,0,733,732,1,0,0,0,734,735,1,0,0,0,735,733,1,0,0,0,735,736,1,0,
        0,0,736,739,1,0,0,0,737,739,5,208,0,0,738,730,1,0,0,0,738,737,1,
        0,0,0,739,103,1,0,0,0,740,741,3,10,5,0,741,742,5,227,0,0,742,743,
        3,100,50,0,743,105,1,0,0,0,744,745,3,100,50,0,745,107,1,0,0,0,746,
        747,5,116,0,0,747,748,3,6,3,0,748,109,1,0,0,0,749,753,5,208,0,0,
        750,753,5,207,0,0,751,753,3,100,50,0,752,749,1,0,0,0,752,750,1,0,
        0,0,752,751,1,0,0,0,753,754,1,0,0,0,754,755,5,117,0,0,755,756,3,
        112,56,0,756,757,5,229,0,0,757,758,5,148,0,0,758,759,5,260,0,0,759,
        760,3,114,57,0,760,769,1,0,0,0,761,762,5,49,0,0,762,763,3,112,56,
        0,763,764,5,229,0,0,764,765,5,43,0,0,765,766,5,260,0,0,766,767,3,
        114,57,0,767,769,1,0,0,0,768,752,1,0,0,0,768,761,1,0,0,0,769,111,
        1,0,0,0,770,776,5,119,0,0,771,772,5,151,0,0,772,773,7,19,0,0,773,
        774,5,227,0,0,774,776,5,202,0,0,775,770,1,0,0,0,775,771,1,0,0,0,
        776,113,1,0,0,0,777,778,7,20,0,0,778,783,3,116,58,0,779,780,7,20,
        0,0,780,782,3,116,58,0,781,779,1,0,0,0,782,785,1,0,0,0,783,781,1,
        0,0,0,783,784,1,0,0,0,784,115,1,0,0,0,785,783,1,0,0,0,786,787,3,
        122,61,0,787,117,1,0,0,0,788,792,5,107,0,0,789,791,3,120,60,0,790,
        789,1,0,0,0,791,794,1,0,0,0,792,790,1,0,0,0,792,793,1,0,0,0,793,
        795,1,0,0,0,794,792,1,0,0,0,795,796,5,259,0,0,796,119,1,0,0,0,797,
        798,3,10,5,0,798,799,5,112,0,0,799,801,3,122,61,0,800,802,5,261,
        0,0,801,800,1,0,0,0,801,802,1,0,0,0,802,121,1,0,0,0,803,804,3,124,
        62,0,804,123,1,0,0,0,805,806,3,126,63,0,806,125,1,0,0,0,807,808,
        3,130,65,0,808,809,5,112,0,0,809,810,3,6,3,0,810,824,1,0,0,0,811,
        812,3,130,65,0,812,813,5,110,0,0,813,814,3,6,3,0,814,824,1,0,0,0,
        815,819,3,130,65,0,816,817,3,128,64,0,817,818,3,130,65,0,818,820,
        1,0,0,0,819,816,1,0,0,0,819,820,1,0,0,0,820,824,1,0,0,0,821,824,
        3,168,84,0,822,824,3,170,85,0,823,807,1,0,0,0,823,811,1,0,0,0,823,
        815,1,0,0,0,823,821,1,0,0,0,823,822,1,0,0,0,824,127,1,0,0,0,825,
        826,7,21,0,0,826,129,1,0,0,0,827,833,3,134,67,0,828,829,3,132,66,
        0,829,830,3,134,67,0,830,832,1,0,0,0,831,828,1,0,0,0,832,835,1,0,
        0,0,833,831,1,0,0,0,833,834,1,0,0,0,834,131,1,0,0,0,835,833,1,0,
        0,0,836,837,7,22,0,0,837,133,1,0,0,0,838,844,3,138,69,0,839,840,
        3,136,68,0,840,841,3,138,69,0,841,843,1,0,0,0,842,839,1,0,0,0,843,
        846,1,0,0,0,844,842,1,0,0,0,844,845,1,0,0,0,845,135,1,0,0,0,846,
        844,1,0,0,0,847,848,7,23,0,0,848,137,1,0,0,0,849,855,3,142,71,0,
        850,851,3,140,70,0,851,852,3,142,71,0,852,854,1,0,0,0,853,850,1,
        0,0,0,854,857,1,0,0,0,855,853,1,0,0,0,855,856,1,0,0,0,856,139,1,
        0,0,0,857,855,1,0,0,0,858,859,5,141,0,0,859,141,1,0,0,0,860,861,
        6,71,-1,0,861,862,5,132,0,0,862,1067,3,142,71,44,863,864,5,135,0,
        0,864,1067,3,142,71,43,865,866,5,14,0,0,866,867,3,142,71,0,867,868,
        5,140,0,0,868,871,3,142,71,0,869,870,5,182,0,0,870,872,5,247,0,0,
        871,869,1,0,0,0,871,872,1,0,0,0,872,1067,1,0,0,0,873,874,5,186,0,
        0,874,875,3,142,71,0,875,876,5,140,0,0,876,879,3,142,71,0,877,878,
        5,182,0,0,878,880,5,247,0,0,879,877,1,0,0,0,879,880,1,0,0,0,880,
        1067,1,0,0,0,881,883,5,185,0,0,882,884,5,119,0,0,883,882,1,0,0,0,
        883,884,1,0,0,0,884,885,1,0,0,0,885,1067,3,100,50,0,886,888,5,207,
        0,0,887,886,1,0,0,0,887,888,1,0,0,0,888,889,1,0,0,0,889,891,5,180,
        0,0,890,892,5,119,0,0,891,890,1,0,0,0,891,892,1,0,0,0,892,893,1,
        0,0,0,893,1067,3,100,50,0,894,897,5,248,0,0,895,898,5,263,0,0,896,
        898,5,247,0,0,897,895,1,0,0,0,897,896,1,0,0,0,898,899,1,0,0,0,899,
        900,5,227,0,0,900,1067,3,142,71,38,901,902,5,33,0,0,902,907,3,142,
        71,0,903,904,5,258,0,0,904,906,3,142,71,0,905,903,1,0,0,0,906,909,
        1,0,0,0,907,905,1,0,0,0,907,908,1,0,0,0,908,910,1,0,0,0,909,907,
        1,0,0,0,910,911,7,24,0,0,911,912,3,142,71,35,912,1067,1,0,0,0,913,
        914,5,150,0,0,914,1067,3,142,71,33,915,916,5,15,0,0,916,917,5,254,
        0,0,917,918,3,142,71,0,918,919,5,255,0,0,919,1067,1,0,0,0,920,921,
        5,17,0,0,921,926,3,142,71,0,922,923,5,258,0,0,923,925,3,142,71,0,
        924,922,1,0,0,0,925,928,1,0,0,0,926,924,1,0,0,0,926,927,1,0,0,0,
        927,929,1,0,0,0,928,926,1,0,0,0,929,930,5,206,0,0,930,931,3,142,
        71,31,931,1067,1,0,0,0,932,933,5,16,0,0,933,938,3,142,71,0,934,935,
        5,258,0,0,935,937,3,142,71,0,936,934,1,0,0,0,937,940,1,0,0,0,938,
        936,1,0,0,0,938,939,1,0,0,0,939,941,1,0,0,0,940,938,1,0,0,0,941,
        942,5,206,0,0,942,943,3,142,71,30,943,1067,1,0,0,0,944,945,5,207,
        0,0,945,946,5,210,0,0,946,947,5,225,0,0,947,1067,3,142,71,29,948,
        949,5,202,0,0,949,950,5,212,0,0,950,951,5,225,0,0,951,1067,3,142,
        71,28,952,953,5,202,0,0,953,954,5,200,0,0,954,955,5,225,0,0,955,
        1067,3,142,71,27,956,957,5,20,0,0,957,958,5,254,0,0,958,959,3,142,
        71,0,959,960,5,258,0,0,960,961,3,142,71,0,961,962,5,258,0,0,962,
        963,3,142,71,0,963,964,5,255,0,0,964,1067,1,0,0,0,965,966,5,21,0,
        0,966,967,5,254,0,0,967,968,3,142,71,0,968,969,5,255,0,0,969,1067,
        1,0,0,0,970,971,5,181,0,0,971,976,3,142,71,0,972,973,5,258,0,0,973,
        975,3,142,71,0,974,972,1,0,0,0,975,978,1,0,0,0,976,974,1,0,0,0,976,
        977,1,0,0,0,977,979,1,0,0,0,978,976,1,0,0,0,979,980,5,206,0,0,980,
        981,3,142,71,23,981,1067,1,0,0,0,982,983,5,183,0,0,983,988,3,142,
        71,0,984,985,5,258,0,0,985,987,3,142,71,0,986,984,1,0,0,0,987,990,
        1,0,0,0,988,986,1,0,0,0,988,989,1,0,0,0,989,991,1,0,0,0,990,988,
        1,0,0,0,991,992,5,206,0,0,992,993,3,142,71,22,993,1067,1,0,0,0,994,
        995,5,18,0,0,995,998,3,122,61,0,996,997,5,8,0,0,997,999,3,122,61,
        0,998,996,1,0,0,0,998,999,1,0,0,0,999,1067,1,0,0,0,1000,1005,5,1,
        0,0,1001,1002,5,202,0,0,1002,1006,5,212,0,0,1003,1004,5,207,0,0,
        1004,1006,5,210,0,0,1005,1001,1,0,0,0,1005,1003,1,0,0,0,1006,1007,
        1,0,0,0,1007,1008,5,201,0,0,1008,1067,3,122,61,0,1009,1011,3,6,3,
        0,1010,1009,1,0,0,0,1011,1012,1,0,0,0,1012,1010,1,0,0,0,1012,1013,
        1,0,0,0,1013,1014,1,0,0,0,1014,1015,5,18,0,0,1015,1018,3,122,61,
        0,1016,1017,5,8,0,0,1017,1019,3,122,61,0,1018,1016,1,0,0,0,1018,
        1019,1,0,0,0,1019,1067,1,0,0,0,1020,1021,5,19,0,0,1021,1022,7,16,
        0,0,1022,1023,5,227,0,0,1023,1026,3,122,61,0,1024,1025,5,8,0,0,1025,
        1027,3,122,61,0,1026,1024,1,0,0,0,1026,1027,1,0,0,0,1027,1067,1,
        0,0,0,1028,1030,3,6,3,0,1029,1028,1,0,0,0,1030,1031,1,0,0,0,1031,
        1029,1,0,0,0,1031,1032,1,0,0,0,1032,1033,1,0,0,0,1033,1034,5,19,
        0,0,1034,1035,7,16,0,0,1035,1036,5,227,0,0,1036,1039,3,122,61,0,
        1037,1038,5,8,0,0,1038,1040,3,122,61,0,1039,1037,1,0,0,0,1039,1040,
        1,0,0,0,1040,1067,1,0,0,0,1041,1044,3,156,78,0,1042,1044,3,158,79,
        0,1043,1041,1,0,0,0,1043,1042,1,0,0,0,1044,1045,1,0,0,0,1045,1046,
        3,104,52,0,1046,1047,3,160,80,0,1047,1067,1,0,0,0,1048,1067,3,104,
        52,0,1049,1067,3,108,54,0,1050,1067,3,100,50,0,1051,1067,3,10,5,
        0,1052,1067,3,70,35,0,1053,1067,5,220,0,0,1054,1067,3,6,3,0,1055,
        1067,5,248,0,0,1056,1067,5,252,0,0,1057,1067,5,253,0,0,1058,1067,
        3,14,7,0,1059,1067,5,231,0,0,1060,1067,5,216,0,0,1061,1067,5,208,
        0,0,1062,1063,5,254,0,0,1063,1064,3,122,61,0,1064,1065,5,255,0,0,
        1065,1067,1,0,0,0,1066,860,1,0,0,0,1066,863,1,0,0,0,1066,865,1,0,
        0,0,1066,873,1,0,0,0,1066,881,1,0,0,0,1066,887,1,0,0,0,1066,894,
        1,0,0,0,1066,901,1,0,0,0,1066,913,1,0,0,0,1066,915,1,0,0,0,1066,
        920,1,0,0,0,1066,932,1,0,0,0,1066,944,1,0,0,0,1066,948,1,0,0,0,1066,
        952,1,0,0,0,1066,956,1,0,0,0,1066,965,1,0,0,0,1066,970,1,0,0,0,1066,
        982,1,0,0,0,1066,994,1,0,0,0,1066,1000,1,0,0,0,1066,1010,1,0,0,0,
        1066,1020,1,0,0,0,1066,1029,1,0,0,0,1066,1043,1,0,0,0,1066,1048,
        1,0,0,0,1066,1049,1,0,0,0,1066,1050,1,0,0,0,1066,1051,1,0,0,0,1066,
        1052,1,0,0,0,1066,1053,1,0,0,0,1066,1054,1,0,0,0,1066,1055,1,0,0,
        0,1066,1056,1,0,0,0,1066,1057,1,0,0,0,1066,1058,1,0,0,0,1066,1059,
        1,0,0,0,1066,1060,1,0,0,0,1066,1061,1,0,0,0,1066,1062,1,0,0,0,1067,
        1090,1,0,0,0,1068,1071,10,34,0,0,1069,1070,5,258,0,0,1070,1072,3,
        142,71,0,1071,1069,1,0,0,0,1072,1073,1,0,0,0,1073,1071,1,0,0,0,1073,
        1074,1,0,0,0,1074,1075,1,0,0,0,1075,1076,7,24,0,0,1076,1077,3,142,
        71,35,1077,1089,1,0,0,0,1078,1079,10,37,0,0,1079,1089,3,144,72,0,
        1080,1081,10,36,0,0,1081,1082,5,258,0,0,1082,1089,3,146,73,0,1083,
        1084,10,24,0,0,1084,1085,7,25,0,0,1085,1086,3,142,71,0,1086,1087,
        3,6,3,0,1087,1089,1,0,0,0,1088,1068,1,0,0,0,1088,1078,1,0,0,0,1088,
        1080,1,0,0,0,1088,1083,1,0,0,0,1089,1092,1,0,0,0,1090,1088,1,0,0,
        0,1090,1091,1,0,0,0,1091,143,1,0,0,0,1092,1090,1,0,0,0,1093,1094,
        7,26,0,0,1094,1095,5,118,0,0,1095,1096,5,248,0,0,1096,1097,5,159,
        0,0,1097,145,1,0,0,0,1098,1105,3,148,74,0,1099,1105,3,150,75,0,1100,
        1101,3,148,74,0,1101,1102,5,206,0,0,1102,1103,3,150,75,0,1103,1105,
        1,0,0,0,1104,1098,1,0,0,0,1104,1099,1,0,0,0,1104,1100,1,0,0,0,1105,
        147,1,0,0,0,1106,1107,5,23,0,0,1107,1108,3,122,61,0,1108,149,1,0,
        0,0,1109,1110,5,24,0,0,1110,1111,3,122,61,0,1111,151,1,0,0,0,1112,
        1113,5,8,0,0,1113,1116,3,122,61,0,1114,1116,3,154,77,0,1115,1112,
        1,0,0,0,1115,1114,1,0,0,0,1116,153,1,0,0,0,1117,1118,5,144,0,0,1118,
        1134,3,14,7,0,1119,1120,5,227,0,0,1120,1121,3,14,7,0,1121,1122,5,
        140,0,0,1122,1123,3,14,7,0,1123,1134,1,0,0,0,1124,1125,5,227,0,0,
        1125,1126,3,14,7,0,1126,1127,5,142,0,0,1127,1128,3,14,7,0,1128,1134,
        1,0,0,0,1129,1130,5,140,0,0,1130,1134,3,14,7,0,1131,1132,5,142,0,
        0,1132,1134,3,14,7,0,1133,1117,1,0,0,0,1133,1119,1,0,0,0,1133,1124,
        1,0,0,0,1133,1129,1,0,0,0,1133,1131,1,0,0,0,1134,155,1,0,0,0,1135,
        1137,5,207,0,0,1136,1135,1,0,0,0,1136,1137,1,0,0,0,1137,1138,1,0,
        0,0,1138,1143,5,180,0,0,1139,1143,5,16,0,0,1140,1143,5,17,0,0,1141,
        1143,5,185,0,0,1142,1136,1,0,0,0,1142,1139,1,0,0,0,1142,1140,1,0,
        0,0,1142,1141,1,0,0,0,1143,157,1,0,0,0,1144,1145,7,27,0,0,1145,159,
        1,0,0,0,1146,1150,5,218,0,0,1147,1151,3,162,81,0,1148,1151,3,164,
        82,0,1149,1151,3,166,83,0,1150,1147,1,0,0,0,1150,1148,1,0,0,0,1150,
        1149,1,0,0,0,1151,1152,1,0,0,0,1152,1153,5,259,0,0,1153,161,1,0,
        0,0,1154,1155,5,119,0,0,1155,1156,3,10,5,0,1156,163,1,0,0,0,1157,
        1158,5,202,0,0,1158,1159,3,10,5,0,1159,1160,5,144,0,0,1160,1161,
        3,6,3,0,1161,1162,5,224,0,0,1162,1163,3,6,3,0,1163,165,1,0,0,0,1164,
        1165,5,202,0,0,1165,1166,3,10,5,0,1166,1167,5,209,0,0,1167,1168,
        5,256,0,0,1168,1173,3,6,3,0,1169,1170,5,258,0,0,1170,1172,3,6,3,
        0,1171,1169,1,0,0,0,1172,1175,1,0,0,0,1173,1171,1,0,0,0,1173,1174,
        1,0,0,0,1174,1176,1,0,0,0,1175,1173,1,0,0,0,1176,1177,5,206,0,0,
        1177,1178,3,6,3,0,1178,1179,5,257,0,0,1179,167,1,0,0,0,1180,1181,
        3,142,71,0,1181,1182,7,28,0,0,1182,1207,1,0,0,0,1183,1184,3,142,
        71,0,1184,1185,7,29,0,0,1185,1186,5,248,0,0,1186,1187,5,157,0,0,
        1187,1207,1,0,0,0,1188,1189,3,142,71,0,1189,1190,7,30,0,0,1190,1191,
        3,6,3,0,1191,1207,1,0,0,0,1192,1193,3,142,71,0,1193,1194,7,31,0,
        0,1194,1195,3,6,3,0,1195,1207,1,0,0,0,1196,1197,3,142,71,0,1197,
        1198,7,32,0,0,1198,1199,3,6,3,0,1199,1207,1,0,0,0,1200,1201,3,100,
        50,0,1201,1202,5,94,0,0,1202,1207,1,0,0,0,1203,1204,3,142,71,0,1204,
        1205,5,96,0,0,1205,1207,1,0,0,0,1206,1180,1,0,0,0,1206,1183,1,0,
        0,0,1206,1188,1,0,0,0,1206,1192,1,0,0,0,1206,1196,1,0,0,0,1206,1200,
        1,0,0,0,1206,1203,1,0,0,0,1207,169,1,0,0,0,1208,1209,5,98,0,0,1209,
        1210,3,10,5,0,1210,1211,7,33,0,0,1211,171,1,0,0,0,1212,1213,5,106,
        0,0,1213,1215,3,10,5,0,1214,1216,5,261,0,0,1215,1214,1,0,0,0,1215,
        1216,1,0,0,0,1216,173,1,0,0,0,139,179,181,192,197,202,207,212,218,
        224,230,235,241,247,249,257,272,275,278,283,288,293,297,301,306,
        313,315,323,326,329,335,342,351,359,365,371,374,381,387,397,406,
        413,419,424,429,437,443,446,461,465,468,473,478,488,494,502,508,
        511,514,519,525,531,537,544,551,557,562,568,570,580,582,586,594,
        609,617,623,632,639,642,652,655,661,664,671,674,676,684,697,700,
        702,707,710,718,726,730,735,738,752,768,775,783,792,801,819,823,
        833,844,855,871,879,883,887,891,897,907,926,938,976,988,998,1005,
        1012,1018,1026,1031,1039,1043,1066,1073,1088,1090,1104,1115,1133,
        1136,1142,1150,1173,1206,1215
    ]

class RegelSpraakParser ( Parser ):

    grammarFileName = "RegelSpraak.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'het aantal dagen in'", "'het kwartaal'", 
                     "'het deel per maand'", "'het deel per jaar'", "'(voor het attribuut zonder voorzetsel):'", 
                     "'(na het attribuut met voorzetsel'", "'Datum en tijd in millisecondes'", 
                     "'gedurende de tijd dat'", "'gedurende het gehele'", 
                     "'gedurende de gehele'", "'moet berekend worden als'", 
                     "'moet gesteld worden op'", "'moet ge\\u00EFnitialiseerd worden op'", 
                     "'de absolute tijdsduur van'", "'de absolute waarde van'", 
                     "'de maximale waarde van'", "'de minimale waarde van'", 
                     "'het totaal van'", "'het tijdsevenredig deel per'", 
                     "'de datum met jaar, maand en dag'", "'de eerste paasdag van'", 
                     "'Als onverdeelde rest blijft'", "'met een minimum van'", 
                     "'met een maximum van'", "'groter of gelijk aan'", 
                     "'kleiner of gelijk aan'", "'later of gelijk aan'", 
                     "'eerder of gelijk aan'", "', waarbij wordt verdeeld'", 
                     "', bestaande uit de'", "'Wederkerig feittype'", "'is van het type'", 
                     "'de concatenatie van'", "'het volgende criterium:'", 
                     "'volgende criteria:'", "'bij even groot criterium'", 
                     "'op volgorde van'", "'naar rato van'", "'numeriek met exact'", 
                     "'aan de elfproef'", "'groter is dan'", "'kleiner is dan'", 
                     "'wordt voldaan'", "<INVALID>", "'wordt een nieuw'", 
                     "'aangemaakt'", "'Cre\\u00EBer'", "'nieuwe'", "<INVALID>", 
                     "'is gelijk aan'", "'is ongelijk aan'", "'is kleiner dan'", 
                     "'is kleiner of gelijk aan'", "'is groter dan'", "'is groter of gelijk aan'", 
                     "'zijn gelijk aan'", "'zijn ongelijk aan'", "'zijn groter dan'", 
                     "'zijn groter of gelijk aan'", "'zijn kleiner dan'", 
                     "'zijn kleiner of gelijk aan'", "'is later dan'", "'is later of gelijk aan'", 
                     "'is eerder dan'", "'is eerder of gelijk aan'", "'zijn later dan'", 
                     "'zijn later of gelijk aan'", "'zijn eerder dan'", 
                     "'zijn eerder of gelijk aan'", "'is leeg'", "'is gevuld'", 
                     "'zijn leeg'", "'zijn gevuld'", "'is kenmerk'", "'is rol'", 
                     "'zijn kenmerk'", "'zijn rol'", "'is niet kenmerk'", 
                     "'is niet rol'", "'zijn niet kenmerk'", "'zijn niet rol'", 
                     "'voldoet aan de elfproef'", "'voldoen aan de elfproef'", 
                     "'voldoet niet aan de elfproef'", "'voldoen niet aan de elfproef'", 
                     "'is numeriek met exact'", "'is niet numeriek met exact'", 
                     "'zijn numeriek met exact'", "'zijn niet numeriek met exact'", 
                     "'is een dagsoort'", "'zijn een dagsoort'", "'is geen dagsoort'", 
                     "'zijn geen dagsoort'", "'moeten uniek zijn'", "'is gevuurd'", 
                     "'is inconsistent'", "'Consistentieregel'", "'Regel'", 
                     "'Beslistabel'", "'Objecttype'", "'Domein'", "'Dimensie'", 
                     "'Eenheidsysteem'", "'Parameter'", "'FeitType'", "'Dagsoort'", 
                     "'Daarbij geldt:'", "'geldig'", "'hebben'", "'heeft'", 
                     "'indien'", "'is'", "'moet'", "'moeten'", "'wordt verdeeld over'", 
                     "'zijn'", "'aan'", "'afgerond op'", "'alle'", "'eerder dan'", 
                     "'gedeeld door'", "'gedeeld door (ABS)'", "'gelijk aan'", 
                     "'gevuld'", "'gevuurd'", "'groter dan'", "'inconsistent'", 
                     "'kleiner dan'", "'later dan'", "'leeg'", "'maal'", 
                     "'min'", "'naar beneden'", "'naar boven'", "'niet'", 
                     "'ongelijk aan'", "'plus'", "'rekenkundig'", "'richting nul'", 
                     "'tot'", "'tot de macht'", "'tot en met'", "'uniek'", 
                     "'vanaf'", "'verenigd met'", "'verminderd met'", "'voldoen'", 
                     "'voldoet'", "'weg van nul'", "'de wortel van'", "'tenminste'", 
                     "'ten minste'", "'(bezield)'", "'(bezittelijk)'", "'(bijvoeglijk)'", 
                     "'Boolean'", "'cijfers'", "'Datum in dagen'", "'decimalen'", 
                     "'Enumeratie'", "'gedimensioneerd met'", "'geheel getal'", 
                     "'getal'", "'kenmerk'", "'kenmerken'", "'met'", "'met eenheid'", 
                     "'(mv:'", "'negatief'", "'niet-negatief'", "'Numeriek'", 
                     "'Percentage'", "'positief'", "'rol'", "'rollen'", 
                     "'Tekst'", "'voor elk jaar'", "'voor elke dag'", "'voor elke maand'", 
                     "'aantal'", "'de eerste van'", "'in hele'", "'de laatste van'", 
                     "'reeks van teksten en waarden'", "'de som van'", "'de tijdsduur van'", 
                     "'afnemende'", "'in gelijke delen'", "'over.'", "'toenemende'", 
                     "'drie'", "'\\u00E9\\u00E9n'", "'geen van de'", "'precies'", 
                     "'ten hoogste'", "'twee'", "'vier'", "'altijd'", "'bij'", 
                     "'dag'", "'dat'", "'de'", "'dd.'", "'die'", "'een'", 
                     "'en'", "'het'", "'hij'", "'in'", "'jaar'", "'kwartaal'", 
                     "'maand'", "'milliseconde'", "'minuut'", "'of'", "'onwaar'", 
                     "'op'", "'over'", "'periode'", "'Rekendatum'", "'Rekenjaar'", 
                     "'regelversie'", "'seconde'", "'t/m'", "'uit'", "'uur'", 
                     "'van'", "'volgende voorwaarde'", "'volgende voorwaarden'", 
                     "'voor'", "'waar'", "'week'", "'er'", "'meter'", "'kilogram'", 
                     "'voet'", "'pond'", "'mijl'", "'m'", "'kg'", "'s'", 
                     "'ft'", "'lb'", "'mi'", "'\\u20AC'", "'$'", "<INVALID>", 
                     "<INVALID>", "'='", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "'('", "')'", "'{'", "'}'", "','", "'.'", 
                     "':'", "';'", "'/'", "'%'", "'\\u2022'", "'*'", "'\\u00AB'", 
                     "'\\u00BB'", "'^'", "<INVALID>", "<INVALID>", "'-'" ]

    symbolicNames = [ "<INVALID>", "HET_AANTAL_DAGEN_IN", "HET_KWARTAAL", 
                      "HET_DEEL_PER_MAAND", "HET_DEEL_PER_JAAR", "VOOR_HET_ATTRIBUUT_ZONDER_VOORZETSEL", 
                      "NA_HET_ATTRIBUUT_MET_VOORZETSEL", "DATUM_TIJD_MILLIS", 
                      "GEDURENDE_DE_TIJD_DAT", "GEDURENDE_HET_GEHELE", "GEDURENDE_DE_GEHELE", 
                      "WORDT_BEREKEND_ALS", "WORDT_GESTELD_OP", "WORDT_GEINITIALISEERD_OP", 
                      "DE_ABSOLUTE_TIJDSDUUR_VAN", "DE_ABSOLUTE_WAARDE_VAN", 
                      "DE_MAXIMALE_WAARDE_VAN", "DE_MINIMALE_WAARDE_VAN", 
                      "HET_TOTAAL_VAN", "HET_TIJDSEVENREDIG_DEEL_PER", "DE_DATUM_MET", 
                      "DE_EERSTE_PAASDAG_VAN", "ALS_ONVERDEELDE_REST_BLIJFT", 
                      "MET_EEN_MINIMUM_VAN", "MET_EEN_MAXIMUM_VAN", "GROTER_OF_GELIJK_AAN", 
                      "KLEINER_OF_GELIJK_AAN", "LATER_OF_GELIJK_AAN", "EERDER_OF_GELIJK_AAN", 
                      "WAARBIJ_WORDT_VERDEELD", "BESTAANDE_UIT", "WEDERKERIG_FEITTYPE", 
                      "IS_VAN_HET_TYPE", "CONCATENATIE_VAN", "VOLGEND_CRITERIUM", 
                      "VOLGENDE_CRITERIA", "BIJ_EVEN_GROOT_CRITERIUM", "OP_VOLGORDE_VAN", 
                      "NAAR_RATO_VAN", "NUMERIEK_MET_EXACT", "AAN_DE_ELFPROEF", 
                      "GROTER_IS_DAN", "KLEINER_IS_DAN", "WORDT_VOLDAAN", 
                      "ER_WORDT_EEN_NIEUW", "WORDT_EEN_NIEUW", "AANGEMAAKT", 
                      "CREEER", "NIEUWE", "ER_AAN", "IS_GELIJK_AAN", "IS_ONGELIJK_AAN", 
                      "IS_KLEINER_DAN", "IS_KLEINER_OF_GELIJK_AAN", "IS_GROTER_DAN", 
                      "IS_GROTER_OF_GELIJK_AAN", "ZIJN_GELIJK_AAN", "ZIJN_ONGELIJK_AAN", 
                      "ZIJN_GROTER_DAN", "ZIJN_GROTER_OF_GELIJK_AAN", "ZIJN_KLEINER_DAN", 
                      "ZIJN_KLEINER_OF_GELIJK_AAN", "IS_LATER_DAN", "IS_LATER_OF_GELIJK_AAN", 
                      "IS_EERDER_DAN", "IS_EERDER_OF_GELIJK_AAN", "ZIJN_LATER_DAN", 
                      "ZIJN_LATER_OF_GELIJK_AAN", "ZIJN_EERDER_DAN", "ZIJN_EERDER_OF_GELIJK_AAN", 
                      "IS_LEEG", "IS_GEVULD", "ZIJN_LEEG", "ZIJN_GEVULD", 
                      "IS_KENMERK", "IS_ROL", "ZIJN_KENMERK", "ZIJN_ROL", 
                      "IS_NIET_KENMERK", "IS_NIET_ROL", "ZIJN_NIET_KENMERK", 
                      "ZIJN_NIET_ROL", "VOLDOET_AAN_DE_ELFPROEF", "VOLDOEN_AAN_DE_ELFPROEF", 
                      "VOLDOET_NIET_AAN_DE_ELFPROEF", "VOLDOEN_NIET_AAN_DE_ELFPROEF", 
                      "IS_NUMERIEK_MET_EXACT", "IS_NIET_NUMERIEK_MET_EXACT", 
                      "ZIJN_NUMERIEK_MET_EXACT", "ZIJN_NIET_NUMERIEK_MET_EXACT", 
                      "IS_EEN_DAGSOORT", "ZIJN_EEN_DAGSOORT", "IS_GEEN_DAGSOORT", 
                      "ZIJN_GEEN_DAGSOORT", "MOETEN_UNIEK_ZIJN", "IS_GEVUURD", 
                      "IS_INCONSISTENT", "CONSISTENTIEREGEL", "REGEL", "BESLISTABEL", 
                      "OBJECTTYPE", "DOMEIN", "DIMENSIE", "EENHEIDSYSTEEM", 
                      "PARAMETER", "FEITTYPE", "DAGSOORT", "DAARBIJ_GELDT", 
                      "GELDIG", "HEBBEN", "HEEFT", "INDIEN", "IS", "MOET", 
                      "MOETEN", "WORDT_VERDEELD_OVER", "ZIJN", "AAN", "AFGEROND_OP", 
                      "ALLE", "EERDER_DAN", "GEDEELD_DOOR", "GEDEELD_DOOR_ABS", 
                      "GELIJK_AAN", "GEVULD", "GEVUURD", "GROTER_DAN", "INCONSISTENT", 
                      "KLEINER_DAN", "LATER_DAN", "LEEG", "MAAL", "MIN", 
                      "NAAR_BENEDEN", "NAAR_BOVEN", "NIET", "ONGELIJK_AAN", 
                      "PLUS", "REKENKUNDIG", "RICHTING_NUL", "TOT", "TOT_DE_MACHT", 
                      "TOT_EN_MET", "UNIEK", "VANAF", "VERENIGD_MET", "VERMINDERD_MET", 
                      "VOLDOEN", "VOLDOET", "WEG_VAN_NUL", "DE_WORTEL_VAN", 
                      "TENMINSTE", "TEN_MINSTE", "BEZIELD", "BEZITTELIJK", 
                      "BIJVOEGLIJK", "BOOLEAN", "CIJFERS", "DATUM_IN_DAGEN", 
                      "DECIMALEN", "ENUMERATIE", "GEDIMENSIONEERD_MET", 
                      "GEHEEL_GETAL", "GETAL", "KENMERK", "KENMERKEN", "MET", 
                      "MET_EENHEID", "MV_START", "NEGATIEF", "NIET_NEGATIEF", 
                      "NUMERIEK", "PERCENTAGE", "POSITIEF", "ROL", "ROLLEN", 
                      "TEKST", "VOOR_ELK_JAAR", "VOOR_ELKE_DAG", "VOOR_ELKE_MAAND", 
                      "AANTAL", "EERSTE_VAN", "IN_HELE", "LAATSTE_VAN", 
                      "REEKS_VAN_TEKSTEN_EN_WAARDEN", "SOM_VAN", "TIJDSDUUR_VAN", 
                      "AFNEMENDE", "IN_GELIJKE_DELEN", "OVER_VERDELING", 
                      "TOENEMENDE", "DRIE_TELWOORD", "EEN_TELWOORD", "GEEN_VAN_DE", 
                      "PRECIES", "TEN_HOOGSTE", "TWEE_TELWOORD", "VIER_TELWOORD", 
                      "ALTIJD", "BIJ", "DAG", "DAT", "DE", "DD_PUNT", "DIE", 
                      "EEN", "EN", "HET", "HIJ", "IN", "JAAR", "KWARTAAL", 
                      "MAAND", "MILLISECONDE", "MINUUT", "OF", "ONWAAR", 
                      "OP", "OVER", "PERIODE", "REKENDATUM", "REKENJAAR", 
                      "REGELVERSIE", "SECONDE", "TM", "UIT", "UUR", "VAN", 
                      "VOLGENDE_VOORWAARDE", "VOLGENDE_VOORWAARDEN", "VOOR", 
                      "WAAR", "WEEK", "ER", "METER", "KILOGRAM", "VOET", 
                      "POND", "MIJL", "M", "KG", "S", "FT", "LB", "MI", 
                      "EURO_SYMBOL", "DOLLAR_SYMBOL", "IDENTIFIER", "NUMBER", 
                      "EQUALS", "DATE_TIME_LITERAL", "PERCENTAGE_LITERAL", 
                      "STRING_LITERAL", "ENUM_LITERAL", "LPAREN", "RPAREN", 
                      "LBRACE", "RBRACE", "COMMA", "DOT", "COLON", "SEMICOLON", 
                      "SLASH", "PERCENT_SIGN", "BULLET", "ASTERISK", "L_ANGLE_QUOTE", 
                      "R_ANGLE_QUOTE", "CARET", "WS", "LINE_COMMENT", "MINUS" ]

    RULE_regelSpraakDocument = 0
    RULE_definitie = 1
    RULE_beslistabel = 2
    RULE_identifier = 3
    RULE_naamPhrase = 4
    RULE_naamwoord = 5
    RULE_voorzetsel = 6
    RULE_datumLiteral = 7
    RULE_unit = 8
    RULE_objectTypeDefinition = 9
    RULE_objectTypeMember = 10
    RULE_kenmerkSpecificatie = 11
    RULE_attribuutSpecificatie = 12
    RULE_datatype = 13
    RULE_numeriekDatatype = 14
    RULE_tekstDatatype = 15
    RULE_booleanDatatype = 16
    RULE_datumTijdDatatype = 17
    RULE_getalSpecificatie = 18
    RULE_domeinDefinition = 19
    RULE_domeinType = 20
    RULE_enumeratieSpecificatie = 21
    RULE_domeinRef = 22
    RULE_eenheidsysteemDefinition = 23
    RULE_eenheidEntry = 24
    RULE_unitIdentifier = 25
    RULE_eenheidExpressie = 26
    RULE_eenheidMacht = 27
    RULE_dimensieDefinition = 28
    RULE_voorzetselSpecificatie = 29
    RULE_labelWaardeSpecificatie = 30
    RULE_tijdlijn = 31
    RULE_dimensieRef = 32
    RULE_parameterDefinition = 33
    RULE_parameterNamePhrase = 34
    RULE_parameterMetLidwoord = 35
    RULE_feitTypeDefinition = 36
    RULE_rolSpecificatie = 37
    RULE_regel = 38
    RULE_regelName = 39
    RULE_regelVersie = 40
    RULE_versieGeldigheid = 41
    RULE_resultaatDeel = 42
    RULE_objectCreatie = 43
    RULE_objectAttributeInit = 44
    RULE_attributeInitVervolg = 45
    RULE_consistentieregel = 46
    RULE_uniekzijnResultaat = 47
    RULE_inconsistentResultaat = 48
    RULE_voorwaardeDeel = 49
    RULE_onderwerpReferentie = 50
    RULE_basisOnderwerp = 51
    RULE_attribuutReferentie = 52
    RULE_kenmerkNaam = 53
    RULE_bezieldeReferentie = 54
    RULE_toplevelSamengesteldeVoorwaarde = 55
    RULE_voorwaardeKwantificatie = 56
    RULE_samengesteldeVoorwaardeOnderdeel = 57
    RULE_genesteVoorwaarde = 58
    RULE_variabeleDeel = 59
    RULE_variabeleToekenning = 60
    RULE_expressie = 61
    RULE_logicalExpression = 62
    RULE_comparisonExpression = 63
    RULE_comparisonOperator = 64
    RULE_additiveExpression = 65
    RULE_additiveOperator = 66
    RULE_multiplicativeExpression = 67
    RULE_multiplicativeOperator = 68
    RULE_powerExpression = 69
    RULE_powerOperator = 70
    RULE_primaryExpression = 71
    RULE_afronding = 72
    RULE_begrenzing = 73
    RULE_begrenzingMinimum = 74
    RULE_begrenzingMaximum = 75
    RULE_conditieBijExpressie = 76
    RULE_periodevergelijkingEnkelvoudig = 77
    RULE_getalAggregatieFunctie = 78
    RULE_datumAggregatieFunctie = 79
    RULE_dimensieSelectie = 80
    RULE_aggregerenOverAlleDimensies = 81
    RULE_aggregerenOverVerzameling = 82
    RULE_aggregerenOverBereik = 83
    RULE_unaryCondition = 84
    RULE_regelStatusCondition = 85
    RULE_dagsoortDefinition = 86

    ruleNames =  [ "regelSpraakDocument", "definitie", "beslistabel", "identifier", 
                   "naamPhrase", "naamwoord", "voorzetsel", "datumLiteral", 
                   "unit", "objectTypeDefinition", "objectTypeMember", "kenmerkSpecificatie", 
                   "attribuutSpecificatie", "datatype", "numeriekDatatype", 
                   "tekstDatatype", "booleanDatatype", "datumTijdDatatype", 
                   "getalSpecificatie", "domeinDefinition", "domeinType", 
                   "enumeratieSpecificatie", "domeinRef", "eenheidsysteemDefinition", 
                   "eenheidEntry", "unitIdentifier", "eenheidExpressie", 
                   "eenheidMacht", "dimensieDefinition", "voorzetselSpecificatie", 
                   "labelWaardeSpecificatie", "tijdlijn", "dimensieRef", 
                   "parameterDefinition", "parameterNamePhrase", "parameterMetLidwoord", 
                   "feitTypeDefinition", "rolSpecificatie", "regel", "regelName", 
                   "regelVersie", "versieGeldigheid", "resultaatDeel", "objectCreatie", 
                   "objectAttributeInit", "attributeInitVervolg", "consistentieregel", 
                   "uniekzijnResultaat", "inconsistentResultaat", "voorwaardeDeel", 
                   "onderwerpReferentie", "basisOnderwerp", "attribuutReferentie", 
                   "kenmerkNaam", "bezieldeReferentie", "toplevelSamengesteldeVoorwaarde", 
                   "voorwaardeKwantificatie", "samengesteldeVoorwaardeOnderdeel", 
                   "genesteVoorwaarde", "variabeleDeel", "variabeleToekenning", 
                   "expressie", "logicalExpression", "comparisonExpression", 
                   "comparisonOperator", "additiveExpression", "additiveOperator", 
                   "multiplicativeExpression", "multiplicativeOperator", 
                   "powerExpression", "powerOperator", "primaryExpression", 
                   "afronding", "begrenzing", "begrenzingMinimum", "begrenzingMaximum", 
                   "conditieBijExpressie", "periodevergelijkingEnkelvoudig", 
                   "getalAggregatieFunctie", "datumAggregatieFunctie", "dimensieSelectie", 
                   "aggregerenOverAlleDimensies", "aggregerenOverVerzameling", 
                   "aggregerenOverBereik", "unaryCondition", "regelStatusCondition", 
                   "dagsoortDefinition" ]

    EOF = Token.EOF
    HET_AANTAL_DAGEN_IN=1
    HET_KWARTAAL=2
    HET_DEEL_PER_MAAND=3
    HET_DEEL_PER_JAAR=4
    VOOR_HET_ATTRIBUUT_ZONDER_VOORZETSEL=5
    NA_HET_ATTRIBUUT_MET_VOORZETSEL=6
    DATUM_TIJD_MILLIS=7
    GEDURENDE_DE_TIJD_DAT=8
    GEDURENDE_HET_GEHELE=9
    GEDURENDE_DE_GEHELE=10
    WORDT_BEREKEND_ALS=11
    WORDT_GESTELD_OP=12
    WORDT_GEINITIALISEERD_OP=13
    DE_ABSOLUTE_TIJDSDUUR_VAN=14
    DE_ABSOLUTE_WAARDE_VAN=15
    DE_MAXIMALE_WAARDE_VAN=16
    DE_MINIMALE_WAARDE_VAN=17
    HET_TOTAAL_VAN=18
    HET_TIJDSEVENREDIG_DEEL_PER=19
    DE_DATUM_MET=20
    DE_EERSTE_PAASDAG_VAN=21
    ALS_ONVERDEELDE_REST_BLIJFT=22
    MET_EEN_MINIMUM_VAN=23
    MET_EEN_MAXIMUM_VAN=24
    GROTER_OF_GELIJK_AAN=25
    KLEINER_OF_GELIJK_AAN=26
    LATER_OF_GELIJK_AAN=27
    EERDER_OF_GELIJK_AAN=28
    WAARBIJ_WORDT_VERDEELD=29
    BESTAANDE_UIT=30
    WEDERKERIG_FEITTYPE=31
    IS_VAN_HET_TYPE=32
    CONCATENATIE_VAN=33
    VOLGEND_CRITERIUM=34
    VOLGENDE_CRITERIA=35
    BIJ_EVEN_GROOT_CRITERIUM=36
    OP_VOLGORDE_VAN=37
    NAAR_RATO_VAN=38
    NUMERIEK_MET_EXACT=39
    AAN_DE_ELFPROEF=40
    GROTER_IS_DAN=41
    KLEINER_IS_DAN=42
    WORDT_VOLDAAN=43
    ER_WORDT_EEN_NIEUW=44
    WORDT_EEN_NIEUW=45
    AANGEMAAKT=46
    CREEER=47
    NIEUWE=48
    ER_AAN=49
    IS_GELIJK_AAN=50
    IS_ONGELIJK_AAN=51
    IS_KLEINER_DAN=52
    IS_KLEINER_OF_GELIJK_AAN=53
    IS_GROTER_DAN=54
    IS_GROTER_OF_GELIJK_AAN=55
    ZIJN_GELIJK_AAN=56
    ZIJN_ONGELIJK_AAN=57
    ZIJN_GROTER_DAN=58
    ZIJN_GROTER_OF_GELIJK_AAN=59
    ZIJN_KLEINER_DAN=60
    ZIJN_KLEINER_OF_GELIJK_AAN=61
    IS_LATER_DAN=62
    IS_LATER_OF_GELIJK_AAN=63
    IS_EERDER_DAN=64
    IS_EERDER_OF_GELIJK_AAN=65
    ZIJN_LATER_DAN=66
    ZIJN_LATER_OF_GELIJK_AAN=67
    ZIJN_EERDER_DAN=68
    ZIJN_EERDER_OF_GELIJK_AAN=69
    IS_LEEG=70
    IS_GEVULD=71
    ZIJN_LEEG=72
    ZIJN_GEVULD=73
    IS_KENMERK=74
    IS_ROL=75
    ZIJN_KENMERK=76
    ZIJN_ROL=77
    IS_NIET_KENMERK=78
    IS_NIET_ROL=79
    ZIJN_NIET_KENMERK=80
    ZIJN_NIET_ROL=81
    VOLDOET_AAN_DE_ELFPROEF=82
    VOLDOEN_AAN_DE_ELFPROEF=83
    VOLDOET_NIET_AAN_DE_ELFPROEF=84
    VOLDOEN_NIET_AAN_DE_ELFPROEF=85
    IS_NUMERIEK_MET_EXACT=86
    IS_NIET_NUMERIEK_MET_EXACT=87
    ZIJN_NUMERIEK_MET_EXACT=88
    ZIJN_NIET_NUMERIEK_MET_EXACT=89
    IS_EEN_DAGSOORT=90
    ZIJN_EEN_DAGSOORT=91
    IS_GEEN_DAGSOORT=92
    ZIJN_GEEN_DAGSOORT=93
    MOETEN_UNIEK_ZIJN=94
    IS_GEVUURD=95
    IS_INCONSISTENT=96
    CONSISTENTIEREGEL=97
    REGEL=98
    BESLISTABEL=99
    OBJECTTYPE=100
    DOMEIN=101
    DIMENSIE=102
    EENHEIDSYSTEEM=103
    PARAMETER=104
    FEITTYPE=105
    DAGSOORT=106
    DAARBIJ_GELDT=107
    GELDIG=108
    HEBBEN=109
    HEEFT=110
    INDIEN=111
    IS=112
    MOET=113
    MOETEN=114
    WORDT_VERDEELD_OVER=115
    ZIJN=116
    AAN=117
    AFGEROND_OP=118
    ALLE=119
    EERDER_DAN=120
    GEDEELD_DOOR=121
    GEDEELD_DOOR_ABS=122
    GELIJK_AAN=123
    GEVULD=124
    GEVUURD=125
    GROTER_DAN=126
    INCONSISTENT=127
    KLEINER_DAN=128
    LATER_DAN=129
    LEEG=130
    MAAL=131
    MIN=132
    NAAR_BENEDEN=133
    NAAR_BOVEN=134
    NIET=135
    ONGELIJK_AAN=136
    PLUS=137
    REKENKUNDIG=138
    RICHTING_NUL=139
    TOT=140
    TOT_DE_MACHT=141
    TOT_EN_MET=142
    UNIEK=143
    VANAF=144
    VERENIGD_MET=145
    VERMINDERD_MET=146
    VOLDOEN=147
    VOLDOET=148
    WEG_VAN_NUL=149
    DE_WORTEL_VAN=150
    TENMINSTE=151
    TEN_MINSTE=152
    BEZIELD=153
    BEZITTELIJK=154
    BIJVOEGLIJK=155
    BOOLEAN=156
    CIJFERS=157
    DATUM_IN_DAGEN=158
    DECIMALEN=159
    ENUMERATIE=160
    GEDIMENSIONEERD_MET=161
    GEHEEL_GETAL=162
    GETAL=163
    KENMERK=164
    KENMERKEN=165
    MET=166
    MET_EENHEID=167
    MV_START=168
    NEGATIEF=169
    NIET_NEGATIEF=170
    NUMERIEK=171
    PERCENTAGE=172
    POSITIEF=173
    ROL=174
    ROLLEN=175
    TEKST=176
    VOOR_ELK_JAAR=177
    VOOR_ELKE_DAG=178
    VOOR_ELKE_MAAND=179
    AANTAL=180
    EERSTE_VAN=181
    IN_HELE=182
    LAATSTE_VAN=183
    REEKS_VAN_TEKSTEN_EN_WAARDEN=184
    SOM_VAN=185
    TIJDSDUUR_VAN=186
    AFNEMENDE=187
    IN_GELIJKE_DELEN=188
    OVER_VERDELING=189
    TOENEMENDE=190
    DRIE_TELWOORD=191
    EEN_TELWOORD=192
    GEEN_VAN_DE=193
    PRECIES=194
    TEN_HOOGSTE=195
    TWEE_TELWOORD=196
    VIER_TELWOORD=197
    ALTIJD=198
    BIJ=199
    DAG=200
    DAT=201
    DE=202
    DD_PUNT=203
    DIE=204
    EEN=205
    EN=206
    HET=207
    HIJ=208
    IN=209
    JAAR=210
    KWARTAAL=211
    MAAND=212
    MILLISECONDE=213
    MINUUT=214
    OF=215
    ONWAAR=216
    OP=217
    OVER=218
    PERIODE=219
    REKENDATUM=220
    REKENJAAR=221
    REGELVERSIE=222
    SECONDE=223
    TM=224
    UIT=225
    UUR=226
    VAN=227
    VOLGENDE_VOORWAARDE=228
    VOLGENDE_VOORWAARDEN=229
    VOOR=230
    WAAR=231
    WEEK=232
    ER=233
    METER=234
    KILOGRAM=235
    VOET=236
    POND=237
    MIJL=238
    M=239
    KG=240
    S=241
    FT=242
    LB=243
    MI=244
    EURO_SYMBOL=245
    DOLLAR_SYMBOL=246
    IDENTIFIER=247
    NUMBER=248
    EQUALS=249
    DATE_TIME_LITERAL=250
    PERCENTAGE_LITERAL=251
    STRING_LITERAL=252
    ENUM_LITERAL=253
    LPAREN=254
    RPAREN=255
    LBRACE=256
    RBRACE=257
    COMMA=258
    DOT=259
    COLON=260
    SEMICOLON=261
    SLASH=262
    PERCENT_SIGN=263
    BULLET=264
    ASTERISK=265
    L_ANGLE_QUOTE=266
    R_ANGLE_QUOTE=267
    CARET=268
    WS=269
    LINE_COMMENT=270
    MINUS=271

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.13.1")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class RegelSpraakDocumentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOF(self):
            return self.getToken(RegelSpraakParser.EOF, 0)

        def definitie(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.DefinitieContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.DefinitieContext,i)


        def regel(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.RegelContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.RegelContext,i)


        def beslistabel(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.BeslistabelContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.BeslistabelContext,i)


        def consistentieregel(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.ConsistentieregelContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.ConsistentieregelContext,i)


        def eenheidsysteemDefinition(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.EenheidsysteemDefinitionContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.EenheidsysteemDefinitionContext,i)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_regelSpraakDocument

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRegelSpraakDocument" ):
                listener.enterRegelSpraakDocument(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRegelSpraakDocument" ):
                listener.exitRegelSpraakDocument(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRegelSpraakDocument" ):
                return visitor.visitRegelSpraakDocument(self)
            else:
                return visitor.visitChildren(self)




    def regelSpraakDocument(self):

        localctx = RegelSpraakParser.RegelSpraakDocumentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_regelSpraakDocument)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 181
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==31 or ((((_la - 97)) & ~0x3f) == 0 and ((1 << (_la - 97)) & 1023) != 0):
                self.state = 179
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [31, 100, 101, 102, 104, 105, 106]:
                    self.state = 174
                    self.definitie()
                    pass
                elif token in [98]:
                    self.state = 175
                    self.regel()
                    pass
                elif token in [99]:
                    self.state = 176
                    self.beslistabel()
                    pass
                elif token in [97]:
                    self.state = 177
                    self.consistentieregel()
                    pass
                elif token in [103]:
                    self.state = 178
                    self.eenheidsysteemDefinition()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 183
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 184
            self.match(RegelSpraakParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DefinitieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def objectTypeDefinition(self):
            return self.getTypedRuleContext(RegelSpraakParser.ObjectTypeDefinitionContext,0)


        def domeinDefinition(self):
            return self.getTypedRuleContext(RegelSpraakParser.DomeinDefinitionContext,0)


        def parameterDefinition(self):
            return self.getTypedRuleContext(RegelSpraakParser.ParameterDefinitionContext,0)


        def dimensieDefinition(self):
            return self.getTypedRuleContext(RegelSpraakParser.DimensieDefinitionContext,0)


        def feitTypeDefinition(self):
            return self.getTypedRuleContext(RegelSpraakParser.FeitTypeDefinitionContext,0)


        def dagsoortDefinition(self):
            return self.getTypedRuleContext(RegelSpraakParser.DagsoortDefinitionContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_definitie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDefinitie" ):
                listener.enterDefinitie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDefinitie" ):
                listener.exitDefinitie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDefinitie" ):
                return visitor.visitDefinitie(self)
            else:
                return visitor.visitChildren(self)




    def definitie(self):

        localctx = RegelSpraakParser.DefinitieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_definitie)
        try:
            self.state = 192
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [100]:
                self.enterOuterAlt(localctx, 1)
                self.state = 186
                self.objectTypeDefinition()
                pass
            elif token in [101]:
                self.enterOuterAlt(localctx, 2)
                self.state = 187
                self.domeinDefinition()
                pass
            elif token in [104]:
                self.enterOuterAlt(localctx, 3)
                self.state = 188
                self.parameterDefinition()
                pass
            elif token in [102]:
                self.enterOuterAlt(localctx, 4)
                self.state = 189
                self.dimensieDefinition()
                pass
            elif token in [31, 105]:
                self.enterOuterAlt(localctx, 5)
                self.state = 190
                self.feitTypeDefinition()
                pass
            elif token in [106]:
                self.enterOuterAlt(localctx, 6)
                self.state = 191
                self.dagsoortDefinition()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BeslistabelContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BESLISTABEL(self):
            return self.getToken(RegelSpraakParser.BESLISTABEL, 0)

        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def regelVersie(self):
            return self.getTypedRuleContext(RegelSpraakParser.RegelVersieContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_beslistabel

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBeslistabel" ):
                listener.enterBeslistabel(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBeslistabel" ):
                listener.exitBeslistabel(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBeslistabel" ):
                return visitor.visitBeslistabel(self)
            else:
                return visitor.visitChildren(self)




    def beslistabel(self):

        localctx = RegelSpraakParser.BeslistabelContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_beslistabel)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 194
            self.match(RegelSpraakParser.BESLISTABEL)
            self.state = 195
            self.naamwoord()
            self.state = 197
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==108:
                self.state = 196
                self.regelVersie()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IdentifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(RegelSpraakParser.IDENTIFIER, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_identifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIdentifier" ):
                listener.enterIdentifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIdentifier" ):
                listener.exitIdentifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIdentifier" ):
                return visitor.visitIdentifier(self)
            else:
                return visitor.visitChildren(self)




    def identifier(self):

        localctx = RegelSpraakParser.IdentifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_identifier)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 199
            self.match(RegelSpraakParser.IDENTIFIER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NaamPhraseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.IDENTIFIER)
            else:
                return self.getToken(RegelSpraakParser.IDENTIFIER, i)

        def DE(self):
            return self.getToken(RegelSpraakParser.DE, 0)

        def HET(self):
            return self.getToken(RegelSpraakParser.HET, 0)

        def ZIJN(self):
            return self.getToken(RegelSpraakParser.ZIJN, 0)

        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.IdentifierContext,i)


        def NIEUWE(self):
            return self.getToken(RegelSpraakParser.NIEUWE, 0)

        def MET(self):
            return self.getToken(RegelSpraakParser.MET, 0)

        def NIET(self):
            return self.getToken(RegelSpraakParser.NIET, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_naamPhrase

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNaamPhrase" ):
                listener.enterNaamPhrase(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNaamPhrase" ):
                listener.exitNaamPhrase(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNaamPhrase" ):
                return visitor.visitNaamPhrase(self)
            else:
                return visitor.visitChildren(self)




    def naamPhrase(self):

        localctx = RegelSpraakParser.NaamPhraseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_naamPhrase)
        self._la = 0 # Token type
        try:
            self.state = 249
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,13,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 202
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==116 or _la==202 or _la==207:
                    self.state = 201
                    _la = self._input.LA(1)
                    if not(_la==116 or _la==202 or _la==207):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                self.state = 205 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 204
                        self.match(RegelSpraakParser.IDENTIFIER)

                    else:
                        raise NoViableAltException(self)
                    self.state = 207 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,5,self._ctx)

                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 210 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 209
                        self.identifier()

                    else:
                        raise NoViableAltException(self)
                    self.state = 212 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,6,self._ctx)

                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 214
                self.match(RegelSpraakParser.NIEUWE)
                self.state = 216 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 215
                        self.match(RegelSpraakParser.IDENTIFIER)

                    else:
                        raise NoViableAltException(self)
                    self.state = 218 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,7,self._ctx)

                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 220
                self.match(RegelSpraakParser.NIEUWE)
                self.state = 222 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 221
                    self.match(RegelSpraakParser.IDENTIFIER)
                    self.state = 224 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==247):
                        break

                self.state = 226
                self.match(RegelSpraakParser.MET)
                self.state = 228 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 227
                        self.match(RegelSpraakParser.IDENTIFIER)

                    else:
                        raise NoViableAltException(self)
                    self.state = 230 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,9,self._ctx)

                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 233 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 232
                    self.identifier()
                    self.state = 235 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==247):
                        break

                self.state = 237
                self.match(RegelSpraakParser.MET)
                self.state = 239 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 238
                        self.identifier()

                    else:
                        raise NoViableAltException(self)
                    self.state = 241 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,11,self._ctx)

                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 243
                self.match(RegelSpraakParser.NIET)
                self.state = 245 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 244
                        self.match(RegelSpraakParser.IDENTIFIER)

                    else:
                        raise NoViableAltException(self)
                    self.state = 247 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,12,self._ctx)

                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NaamwoordContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def naamPhrase(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.NaamPhraseContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.NaamPhraseContext,i)


        def voorzetsel(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.VoorzetselContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.VoorzetselContext,i)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_naamwoord

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNaamwoord" ):
                listener.enterNaamwoord(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNaamwoord" ):
                listener.exitNaamwoord(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNaamwoord" ):
                return visitor.visitNaamwoord(self)
            else:
                return visitor.visitChildren(self)




    def naamwoord(self):

        localctx = RegelSpraakParser.NaamwoordContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_naamwoord)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 251
            self.naamPhrase()
            self.state = 257
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,14,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 252
                    self.voorzetsel()
                    self.state = 253
                    self.naamPhrase() 
                self.state = 259
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,14,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VoorzetselContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def VAN(self):
            return self.getToken(RegelSpraakParser.VAN, 0)

        def IN(self):
            return self.getToken(RegelSpraakParser.IN, 0)

        def VOOR(self):
            return self.getToken(RegelSpraakParser.VOOR, 0)

        def OVER(self):
            return self.getToken(RegelSpraakParser.OVER, 0)

        def OP(self):
            return self.getToken(RegelSpraakParser.OP, 0)

        def BIJ(self):
            return self.getToken(RegelSpraakParser.BIJ, 0)

        def UIT(self):
            return self.getToken(RegelSpraakParser.UIT, 0)

        def TOT(self):
            return self.getToken(RegelSpraakParser.TOT, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_voorzetsel

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVoorzetsel" ):
                listener.enterVoorzetsel(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVoorzetsel" ):
                listener.exitVoorzetsel(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVoorzetsel" ):
                return visitor.visitVoorzetsel(self)
            else:
                return visitor.visitChildren(self)




    def voorzetsel(self):

        localctx = RegelSpraakParser.VoorzetselContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_voorzetsel)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 260
            _la = self._input.LA(1)
            if not(_la==140 or _la==199 or ((((_la - 209)) & ~0x3f) == 0 and ((1 << (_la - 209)) & 2425601) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DatumLiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DATE_TIME_LITERAL(self):
            return self.getToken(RegelSpraakParser.DATE_TIME_LITERAL, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_datumLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDatumLiteral" ):
                listener.enterDatumLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDatumLiteral" ):
                listener.exitDatumLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDatumLiteral" ):
                return visitor.visitDatumLiteral(self)
            else:
                return visitor.visitChildren(self)




    def datumLiteral(self):

        localctx = RegelSpraakParser.DatumLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_datumLiteral)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 262
            self.match(RegelSpraakParser.DATE_TIME_LITERAL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UnitContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(RegelSpraakParser.IDENTIFIER, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_unit

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnit" ):
                listener.enterUnit(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnit" ):
                listener.exitUnit(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnit" ):
                return visitor.visitUnit(self)
            else:
                return visitor.visitChildren(self)




    def unit(self):

        localctx = RegelSpraakParser.UnitContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_unit)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 264
            self.match(RegelSpraakParser.IDENTIFIER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ObjectTypeDefinitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self._IDENTIFIER = None # Token
            self.plural = list() # of Tokens

        def OBJECTTYPE(self):
            return self.getToken(RegelSpraakParser.OBJECTTYPE, 0)

        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def MV_START(self):
            return self.getToken(RegelSpraakParser.MV_START, 0)

        def RPAREN(self):
            return self.getToken(RegelSpraakParser.RPAREN, 0)

        def BEZIELD(self):
            return self.getToken(RegelSpraakParser.BEZIELD, 0)

        def objectTypeMember(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.ObjectTypeMemberContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.ObjectTypeMemberContext,i)


        def IDENTIFIER(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.IDENTIFIER)
            else:
                return self.getToken(RegelSpraakParser.IDENTIFIER, i)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_objectTypeDefinition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterObjectTypeDefinition" ):
                listener.enterObjectTypeDefinition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitObjectTypeDefinition" ):
                listener.exitObjectTypeDefinition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitObjectTypeDefinition" ):
                return visitor.visitObjectTypeDefinition(self)
            else:
                return visitor.visitChildren(self)




    def objectTypeDefinition(self):

        localctx = RegelSpraakParser.ObjectTypeDefinitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_objectTypeDefinition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 266
            self.match(RegelSpraakParser.OBJECTTYPE)
            self.state = 267
            self.naamwoord()
            self.state = 275
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==168:
                self.state = 268
                self.match(RegelSpraakParser.MV_START)
                self.state = 270 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 269
                    localctx._IDENTIFIER = self.match(RegelSpraakParser.IDENTIFIER)
                    localctx.plural.append(localctx._IDENTIFIER)
                    self.state = 272 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==247):
                        break

                self.state = 274
                self.match(RegelSpraakParser.RPAREN)


            self.state = 278
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==153:
                self.state = 277
                self.match(RegelSpraakParser.BEZIELD)


            self.state = 283
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==48 or ((((_la - 112)) & ~0x3f) == 0 and ((1 << (_la - 112)) & 8388625) != 0) or ((((_la - 202)) & ~0x3f) == 0 and ((1 << (_la - 202)) & 35184372088865) != 0):
                self.state = 280
                self.objectTypeMember()
                self.state = 285
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ObjectTypeMemberContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SEMICOLON(self):
            return self.getToken(RegelSpraakParser.SEMICOLON, 0)

        def kenmerkSpecificatie(self):
            return self.getTypedRuleContext(RegelSpraakParser.KenmerkSpecificatieContext,0)


        def attribuutSpecificatie(self):
            return self.getTypedRuleContext(RegelSpraakParser.AttribuutSpecificatieContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_objectTypeMember

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterObjectTypeMember" ):
                listener.enterObjectTypeMember(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitObjectTypeMember" ):
                listener.exitObjectTypeMember(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitObjectTypeMember" ):
                return visitor.visitObjectTypeMember(self)
            else:
                return visitor.visitChildren(self)




    def objectTypeMember(self):

        localctx = RegelSpraakParser.ObjectTypeMemberContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_objectTypeMember)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 288
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,19,self._ctx)
            if la_ == 1:
                self.state = 286
                self.kenmerkSpecificatie()
                pass

            elif la_ == 2:
                self.state = 287
                self.attribuutSpecificatie()
                pass


            self.state = 290
            self.match(RegelSpraakParser.SEMICOLON)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class KenmerkSpecificatieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KENMERK(self):
            return self.getToken(RegelSpraakParser.KENMERK, 0)

        def identifier(self):
            return self.getTypedRuleContext(RegelSpraakParser.IdentifierContext,0)


        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def BIJVOEGLIJK(self):
            return self.getToken(RegelSpraakParser.BIJVOEGLIJK, 0)

        def BEZITTELIJK(self):
            return self.getToken(RegelSpraakParser.BEZITTELIJK, 0)

        def IS(self):
            return self.getToken(RegelSpraakParser.IS, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_kenmerkSpecificatie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterKenmerkSpecificatie" ):
                listener.enterKenmerkSpecificatie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitKenmerkSpecificatie" ):
                listener.exitKenmerkSpecificatie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitKenmerkSpecificatie" ):
                return visitor.visitKenmerkSpecificatie(self)
            else:
                return visitor.visitChildren(self)




    def kenmerkSpecificatie(self):

        localctx = RegelSpraakParser.KenmerkSpecificatieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_kenmerkSpecificatie)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 297
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,21,self._ctx)
            if la_ == 1:
                self.state = 293
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==112:
                    self.state = 292
                    self.match(RegelSpraakParser.IS)


                self.state = 295
                self.identifier()
                pass

            elif la_ == 2:
                self.state = 296
                self.naamwoord()
                pass


            self.state = 299
            self.match(RegelSpraakParser.KENMERK)
            self.state = 301
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==154 or _la==155:
                self.state = 300
                _la = self._input.LA(1)
                if not(_la==154 or _la==155):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AttribuutSpecificatieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.unitName = None # Token

        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def datatype(self):
            return self.getTypedRuleContext(RegelSpraakParser.DatatypeContext,0)


        def domeinRef(self):
            return self.getTypedRuleContext(RegelSpraakParser.DomeinRefContext,0)


        def MET_EENHEID(self):
            return self.getToken(RegelSpraakParser.MET_EENHEID, 0)

        def GEDIMENSIONEERD_MET(self):
            return self.getToken(RegelSpraakParser.GEDIMENSIONEERD_MET, 0)

        def dimensieRef(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.DimensieRefContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.DimensieRefContext,i)


        def tijdlijn(self):
            return self.getTypedRuleContext(RegelSpraakParser.TijdlijnContext,0)


        def PERCENT_SIGN(self):
            return self.getToken(RegelSpraakParser.PERCENT_SIGN, 0)

        def EURO_SYMBOL(self):
            return self.getToken(RegelSpraakParser.EURO_SYMBOL, 0)

        def DOLLAR_SYMBOL(self):
            return self.getToken(RegelSpraakParser.DOLLAR_SYMBOL, 0)

        def IDENTIFIER(self):
            return self.getToken(RegelSpraakParser.IDENTIFIER, 0)

        def EN(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.EN)
            else:
                return self.getToken(RegelSpraakParser.EN, i)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_attribuutSpecificatie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAttribuutSpecificatie" ):
                listener.enterAttribuutSpecificatie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAttribuutSpecificatie" ):
                listener.exitAttribuutSpecificatie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAttribuutSpecificatie" ):
                return visitor.visitAttribuutSpecificatie(self)
            else:
                return visitor.visitChildren(self)




    def attribuutSpecificatie(self):

        localctx = RegelSpraakParser.AttribuutSpecificatieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_attribuutSpecificatie)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 303
            self.naamwoord()
            self.state = 306
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [7, 156, 158, 171, 176]:
                self.state = 304
                self.datatype()
                pass
            elif token in [101]:
                self.state = 305
                self.domeinRef()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 315
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==167:
                self.state = 308
                self.match(RegelSpraakParser.MET_EENHEID)
                self.state = 313
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [247]:
                    self.state = 309
                    localctx.unitName = self.match(RegelSpraakParser.IDENTIFIER)
                    pass
                elif token in [263]:
                    self.state = 310
                    self.match(RegelSpraakParser.PERCENT_SIGN)
                    pass
                elif token in [245]:
                    self.state = 311
                    self.match(RegelSpraakParser.EURO_SYMBOL)
                    pass
                elif token in [246]:
                    self.state = 312
                    self.match(RegelSpraakParser.DOLLAR_SYMBOL)
                    pass
                else:
                    raise NoViableAltException(self)



            self.state = 326
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==161:
                self.state = 317
                self.match(RegelSpraakParser.GEDIMENSIONEERD_MET)
                self.state = 318
                self.dimensieRef()
                self.state = 323
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==206:
                    self.state = 319
                    self.match(RegelSpraakParser.EN)
                    self.state = 320
                    self.dimensieRef()
                    self.state = 325
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)



            self.state = 329
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 177)) & ~0x3f) == 0 and ((1 << (_la - 177)) & 7) != 0):
                self.state = 328
                self.tijdlijn()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DatatypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def numeriekDatatype(self):
            return self.getTypedRuleContext(RegelSpraakParser.NumeriekDatatypeContext,0)


        def tekstDatatype(self):
            return self.getTypedRuleContext(RegelSpraakParser.TekstDatatypeContext,0)


        def booleanDatatype(self):
            return self.getTypedRuleContext(RegelSpraakParser.BooleanDatatypeContext,0)


        def datumTijdDatatype(self):
            return self.getTypedRuleContext(RegelSpraakParser.DatumTijdDatatypeContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_datatype

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDatatype" ):
                listener.enterDatatype(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDatatype" ):
                listener.exitDatatype(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDatatype" ):
                return visitor.visitDatatype(self)
            else:
                return visitor.visitChildren(self)




    def datatype(self):

        localctx = RegelSpraakParser.DatatypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_datatype)
        try:
            self.state = 335
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [171]:
                self.enterOuterAlt(localctx, 1)
                self.state = 331
                self.numeriekDatatype()
                pass
            elif token in [176]:
                self.enterOuterAlt(localctx, 2)
                self.state = 332
                self.tekstDatatype()
                pass
            elif token in [156]:
                self.enterOuterAlt(localctx, 3)
                self.state = 333
                self.booleanDatatype()
                pass
            elif token in [7, 158]:
                self.enterOuterAlt(localctx, 4)
                self.state = 334
                self.datumTijdDatatype()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NumeriekDatatypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NUMERIEK(self):
            return self.getToken(RegelSpraakParser.NUMERIEK, 0)

        def LPAREN(self):
            return self.getToken(RegelSpraakParser.LPAREN, 0)

        def getalSpecificatie(self):
            return self.getTypedRuleContext(RegelSpraakParser.GetalSpecificatieContext,0)


        def RPAREN(self):
            return self.getToken(RegelSpraakParser.RPAREN, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_numeriekDatatype

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumeriekDatatype" ):
                listener.enterNumeriekDatatype(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumeriekDatatype" ):
                listener.exitNumeriekDatatype(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNumeriekDatatype" ):
                return visitor.visitNumeriekDatatype(self)
            else:
                return visitor.visitChildren(self)




    def numeriekDatatype(self):

        localctx = RegelSpraakParser.NumeriekDatatypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_numeriekDatatype)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 337
            self.match(RegelSpraakParser.NUMERIEK)
            self.state = 342
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==254:
                self.state = 338
                self.match(RegelSpraakParser.LPAREN)
                self.state = 339
                self.getalSpecificatie()
                self.state = 340
                self.match(RegelSpraakParser.RPAREN)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TekstDatatypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TEKST(self):
            return self.getToken(RegelSpraakParser.TEKST, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_tekstDatatype

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTekstDatatype" ):
                listener.enterTekstDatatype(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTekstDatatype" ):
                listener.exitTekstDatatype(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTekstDatatype" ):
                return visitor.visitTekstDatatype(self)
            else:
                return visitor.visitChildren(self)




    def tekstDatatype(self):

        localctx = RegelSpraakParser.TekstDatatypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_tekstDatatype)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 344
            self.match(RegelSpraakParser.TEKST)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BooleanDatatypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BOOLEAN(self):
            return self.getToken(RegelSpraakParser.BOOLEAN, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_booleanDatatype

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBooleanDatatype" ):
                listener.enterBooleanDatatype(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBooleanDatatype" ):
                listener.exitBooleanDatatype(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBooleanDatatype" ):
                return visitor.visitBooleanDatatype(self)
            else:
                return visitor.visitChildren(self)




    def booleanDatatype(self):

        localctx = RegelSpraakParser.BooleanDatatypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_booleanDatatype)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 346
            self.match(RegelSpraakParser.BOOLEAN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DatumTijdDatatypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DATUM_IN_DAGEN(self):
            return self.getToken(RegelSpraakParser.DATUM_IN_DAGEN, 0)

        def DATUM_TIJD_MILLIS(self):
            return self.getToken(RegelSpraakParser.DATUM_TIJD_MILLIS, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_datumTijdDatatype

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDatumTijdDatatype" ):
                listener.enterDatumTijdDatatype(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDatumTijdDatatype" ):
                listener.exitDatumTijdDatatype(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDatumTijdDatatype" ):
                return visitor.visitDatumTijdDatatype(self)
            else:
                return visitor.visitChildren(self)




    def datumTijdDatatype(self):

        localctx = RegelSpraakParser.DatumTijdDatatypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_datumTijdDatatype)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 348
            _la = self._input.LA(1)
            if not(_la==7 or _la==158):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GetalSpecificatieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GEHEEL_GETAL(self):
            return self.getToken(RegelSpraakParser.GEHEEL_GETAL, 0)

        def GETAL(self):
            return self.getToken(RegelSpraakParser.GETAL, 0)

        def NEGATIEF(self):
            return self.getToken(RegelSpraakParser.NEGATIEF, 0)

        def NIET_NEGATIEF(self):
            return self.getToken(RegelSpraakParser.NIET_NEGATIEF, 0)

        def POSITIEF(self):
            return self.getToken(RegelSpraakParser.POSITIEF, 0)

        def MET(self):
            return self.getToken(RegelSpraakParser.MET, 0)

        def NUMBER(self):
            return self.getToken(RegelSpraakParser.NUMBER, 0)

        def DECIMALEN(self):
            return self.getToken(RegelSpraakParser.DECIMALEN, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_getalSpecificatie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGetalSpecificatie" ):
                listener.enterGetalSpecificatie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGetalSpecificatie" ):
                listener.exitGetalSpecificatie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGetalSpecificatie" ):
                return visitor.visitGetalSpecificatie(self)
            else:
                return visitor.visitChildren(self)




    def getalSpecificatie(self):

        localctx = RegelSpraakParser.GetalSpecificatieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_getalSpecificatie)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 351
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 169)) & ~0x3f) == 0 and ((1 << (_la - 169)) & 19) != 0):
                self.state = 350
                _la = self._input.LA(1)
                if not(((((_la - 169)) & ~0x3f) == 0 and ((1 << (_la - 169)) & 19) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


            self.state = 359
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,32,self._ctx)
            if la_ == 1:
                self.state = 353
                self.match(RegelSpraakParser.GEHEEL_GETAL)
                pass

            elif la_ == 2:
                self.state = 354
                self.match(RegelSpraakParser.GETAL)
                self.state = 355
                self.match(RegelSpraakParser.MET)
                self.state = 356
                self.match(RegelSpraakParser.NUMBER)
                self.state = 357
                self.match(RegelSpraakParser.DECIMALEN)
                pass

            elif la_ == 3:
                self.state = 358
                self.match(RegelSpraakParser.GETAL)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DomeinDefinitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self._IDENTIFIER = None # Token
            self.name = list() # of Tokens

        def DOMEIN(self):
            return self.getToken(RegelSpraakParser.DOMEIN, 0)

        def IS_VAN_HET_TYPE(self):
            return self.getToken(RegelSpraakParser.IS_VAN_HET_TYPE, 0)

        def domeinType(self):
            return self.getTypedRuleContext(RegelSpraakParser.DomeinTypeContext,0)


        def MET_EENHEID(self):
            return self.getToken(RegelSpraakParser.MET_EENHEID, 0)

        def eenheidExpressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.EenheidExpressieContext,0)


        def SEMICOLON(self):
            return self.getToken(RegelSpraakParser.SEMICOLON, 0)

        def IDENTIFIER(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.IDENTIFIER)
            else:
                return self.getToken(RegelSpraakParser.IDENTIFIER, i)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_domeinDefinition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDomeinDefinition" ):
                listener.enterDomeinDefinition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDomeinDefinition" ):
                listener.exitDomeinDefinition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDomeinDefinition" ):
                return visitor.visitDomeinDefinition(self)
            else:
                return visitor.visitChildren(self)




    def domeinDefinition(self):

        localctx = RegelSpraakParser.DomeinDefinitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_domeinDefinition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 361
            self.match(RegelSpraakParser.DOMEIN)
            self.state = 363 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 362
                localctx._IDENTIFIER = self.match(RegelSpraakParser.IDENTIFIER)
                localctx.name.append(localctx._IDENTIFIER)
                self.state = 365 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==247):
                    break

            self.state = 367
            self.match(RegelSpraakParser.IS_VAN_HET_TYPE)
            self.state = 368
            self.domeinType()
            self.state = 371
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==167:
                self.state = 369
                self.match(RegelSpraakParser.MET_EENHEID)
                self.state = 370
                self.eenheidExpressie()


            self.state = 374
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==261:
                self.state = 373
                self.match(RegelSpraakParser.SEMICOLON)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DomeinTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def enumeratieSpecificatie(self):
            return self.getTypedRuleContext(RegelSpraakParser.EnumeratieSpecificatieContext,0)


        def numeriekDatatype(self):
            return self.getTypedRuleContext(RegelSpraakParser.NumeriekDatatypeContext,0)


        def tekstDatatype(self):
            return self.getTypedRuleContext(RegelSpraakParser.TekstDatatypeContext,0)


        def booleanDatatype(self):
            return self.getTypedRuleContext(RegelSpraakParser.BooleanDatatypeContext,0)


        def datumTijdDatatype(self):
            return self.getTypedRuleContext(RegelSpraakParser.DatumTijdDatatypeContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_domeinType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDomeinType" ):
                listener.enterDomeinType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDomeinType" ):
                listener.exitDomeinType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDomeinType" ):
                return visitor.visitDomeinType(self)
            else:
                return visitor.visitChildren(self)




    def domeinType(self):

        localctx = RegelSpraakParser.DomeinTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_domeinType)
        try:
            self.state = 381
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [160]:
                self.enterOuterAlt(localctx, 1)
                self.state = 376
                self.enumeratieSpecificatie()
                pass
            elif token in [171]:
                self.enterOuterAlt(localctx, 2)
                self.state = 377
                self.numeriekDatatype()
                pass
            elif token in [176]:
                self.enterOuterAlt(localctx, 3)
                self.state = 378
                self.tekstDatatype()
                pass
            elif token in [156]:
                self.enterOuterAlt(localctx, 4)
                self.state = 379
                self.booleanDatatype()
                pass
            elif token in [7, 158]:
                self.enterOuterAlt(localctx, 5)
                self.state = 380
                self.datumTijdDatatype()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EnumeratieSpecificatieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ENUMERATIE(self):
            return self.getToken(RegelSpraakParser.ENUMERATIE, 0)

        def ENUM_LITERAL(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.ENUM_LITERAL)
            else:
                return self.getToken(RegelSpraakParser.ENUM_LITERAL, i)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_enumeratieSpecificatie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEnumeratieSpecificatie" ):
                listener.enterEnumeratieSpecificatie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEnumeratieSpecificatie" ):
                listener.exitEnumeratieSpecificatie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEnumeratieSpecificatie" ):
                return visitor.visitEnumeratieSpecificatie(self)
            else:
                return visitor.visitChildren(self)




    def enumeratieSpecificatie(self):

        localctx = RegelSpraakParser.EnumeratieSpecificatieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_enumeratieSpecificatie)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 383
            self.match(RegelSpraakParser.ENUMERATIE)
            self.state = 385 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 384
                self.match(RegelSpraakParser.ENUM_LITERAL)
                self.state = 387 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==253):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DomeinRefContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.name = None # Token

        def DOMEIN(self):
            return self.getToken(RegelSpraakParser.DOMEIN, 0)

        def IDENTIFIER(self):
            return self.getToken(RegelSpraakParser.IDENTIFIER, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_domeinRef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDomeinRef" ):
                listener.enterDomeinRef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDomeinRef" ):
                listener.exitDomeinRef(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDomeinRef" ):
                return visitor.visitDomeinRef(self)
            else:
                return visitor.visitChildren(self)




    def domeinRef(self):

        localctx = RegelSpraakParser.DomeinRefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_domeinRef)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 389
            self.match(RegelSpraakParser.DOMEIN)
            self.state = 390
            localctx.name = self.match(RegelSpraakParser.IDENTIFIER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EenheidsysteemDefinitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.name = None # IdentifierContext

        def EENHEIDSYSTEEM(self):
            return self.getToken(RegelSpraakParser.EENHEIDSYSTEEM, 0)

        def identifier(self):
            return self.getTypedRuleContext(RegelSpraakParser.IdentifierContext,0)


        def eenheidEntry(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.EenheidEntryContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.EenheidEntryContext,i)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_eenheidsysteemDefinition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEenheidsysteemDefinition" ):
                listener.enterEenheidsysteemDefinition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEenheidsysteemDefinition" ):
                listener.exitEenheidsysteemDefinition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEenheidsysteemDefinition" ):
                return visitor.visitEenheidsysteemDefinition(self)
            else:
                return visitor.visitChildren(self)




    def eenheidsysteemDefinition(self):

        localctx = RegelSpraakParser.EenheidsysteemDefinitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_eenheidsysteemDefinition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 392
            self.match(RegelSpraakParser.EENHEIDSYSTEEM)
            self.state = 393
            localctx.name = self.identifier()
            self.state = 397
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==202:
                self.state = 394
                self.eenheidEntry()
                self.state = 399
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EenheidEntryContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.unitName = None # UnitIdentifierContext
            self.abbrev = None # UnitIdentifierContext
            self.value = None # Token
            self.targetUnit = None # UnitIdentifierContext

        def DE(self):
            return self.getToken(RegelSpraakParser.DE, 0)

        def unitIdentifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.UnitIdentifierContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.UnitIdentifierContext,i)


        def EQUALS(self):
            return self.getToken(RegelSpraakParser.EQUALS, 0)

        def NUMBER(self):
            return self.getToken(RegelSpraakParser.NUMBER, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_eenheidEntry

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEenheidEntry" ):
                listener.enterEenheidEntry(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEenheidEntry" ):
                listener.exitEenheidEntry(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEenheidEntry" ):
                return visitor.visitEenheidEntry(self)
            else:
                return visitor.visitChildren(self)




    def eenheidEntry(self):

        localctx = RegelSpraakParser.EenheidEntryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_eenheidEntry)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 400
            self.match(RegelSpraakParser.DE)
            self.state = 401
            localctx.unitName = self.unitIdentifier()
            self.state = 402
            localctx.abbrev = self.unitIdentifier()
            self.state = 406
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==249:
                self.state = 403
                self.match(RegelSpraakParser.EQUALS)
                self.state = 404
                localctx.value = self.match(RegelSpraakParser.NUMBER)
                self.state = 405
                localctx.targetUnit = self.unitIdentifier()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UnitIdentifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(RegelSpraakParser.IDENTIFIER, 0)

        def METER(self):
            return self.getToken(RegelSpraakParser.METER, 0)

        def KILOGRAM(self):
            return self.getToken(RegelSpraakParser.KILOGRAM, 0)

        def SECONDE(self):
            return self.getToken(RegelSpraakParser.SECONDE, 0)

        def MINUUT(self):
            return self.getToken(RegelSpraakParser.MINUUT, 0)

        def UUR(self):
            return self.getToken(RegelSpraakParser.UUR, 0)

        def VOET(self):
            return self.getToken(RegelSpraakParser.VOET, 0)

        def POND(self):
            return self.getToken(RegelSpraakParser.POND, 0)

        def MIJL(self):
            return self.getToken(RegelSpraakParser.MIJL, 0)

        def M(self):
            return self.getToken(RegelSpraakParser.M, 0)

        def KG(self):
            return self.getToken(RegelSpraakParser.KG, 0)

        def S(self):
            return self.getToken(RegelSpraakParser.S, 0)

        def FT(self):
            return self.getToken(RegelSpraakParser.FT, 0)

        def LB(self):
            return self.getToken(RegelSpraakParser.LB, 0)

        def MIN(self):
            return self.getToken(RegelSpraakParser.MIN, 0)

        def MI(self):
            return self.getToken(RegelSpraakParser.MI, 0)

        def EURO_SYMBOL(self):
            return self.getToken(RegelSpraakParser.EURO_SYMBOL, 0)

        def DOLLAR_SYMBOL(self):
            return self.getToken(RegelSpraakParser.DOLLAR_SYMBOL, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_unitIdentifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnitIdentifier" ):
                listener.enterUnitIdentifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnitIdentifier" ):
                listener.exitUnitIdentifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnitIdentifier" ):
                return visitor.visitUnitIdentifier(self)
            else:
                return visitor.visitChildren(self)




    def unitIdentifier(self):

        localctx = RegelSpraakParser.UnitIdentifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_unitIdentifier)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 408
            _la = self._input.LA(1)
            if not(_la==132 or ((((_la - 214)) & ~0x3f) == 0 and ((1 << (_la - 214)) & 17178825217) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EenheidExpressieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def eenheidMacht(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.EenheidMachtContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.EenheidMachtContext,i)


        def SLASH(self):
            return self.getToken(RegelSpraakParser.SLASH, 0)

        def NUMBER(self):
            return self.getToken(RegelSpraakParser.NUMBER, 0)

        def PERCENT_SIGN(self):
            return self.getToken(RegelSpraakParser.PERCENT_SIGN, 0)

        def EURO_SYMBOL(self):
            return self.getToken(RegelSpraakParser.EURO_SYMBOL, 0)

        def DOLLAR_SYMBOL(self):
            return self.getToken(RegelSpraakParser.DOLLAR_SYMBOL, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_eenheidExpressie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEenheidExpressie" ):
                listener.enterEenheidExpressie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEenheidExpressie" ):
                listener.exitEenheidExpressie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEenheidExpressie" ):
                return visitor.visitEenheidExpressie(self)
            else:
                return visitor.visitChildren(self)




    def eenheidExpressie(self):

        localctx = RegelSpraakParser.EenheidExpressieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_eenheidExpressie)
        self._la = 0 # Token type
        try:
            self.state = 419
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,41,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 410
                self.eenheidMacht()
                self.state = 413
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==262:
                    self.state = 411
                    self.match(RegelSpraakParser.SLASH)
                    self.state = 412
                    self.eenheidMacht()


                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 415
                self.match(RegelSpraakParser.NUMBER)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 416
                self.match(RegelSpraakParser.PERCENT_SIGN)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 417
                self.match(RegelSpraakParser.EURO_SYMBOL)
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 418
                self.match(RegelSpraakParser.DOLLAR_SYMBOL)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EenheidMachtContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def unitIdentifier(self):
            return self.getTypedRuleContext(RegelSpraakParser.UnitIdentifierContext,0)


        def CARET(self):
            return self.getToken(RegelSpraakParser.CARET, 0)

        def NUMBER(self):
            return self.getToken(RegelSpraakParser.NUMBER, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_eenheidMacht

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEenheidMacht" ):
                listener.enterEenheidMacht(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEenheidMacht" ):
                listener.exitEenheidMacht(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEenheidMacht" ):
                return visitor.visitEenheidMacht(self)
            else:
                return visitor.visitChildren(self)




    def eenheidMacht(self):

        localctx = RegelSpraakParser.EenheidMachtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_eenheidMacht)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 421
            self.unitIdentifier()
            self.state = 424
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==268:
                self.state = 422
                self.match(RegelSpraakParser.CARET)
                self.state = 423
                self.match(RegelSpraakParser.NUMBER)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DimensieDefinitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.dimensieNaamMeervoud = None # NaamwoordContext

        def DIMENSIE(self):
            return self.getToken(RegelSpraakParser.DIMENSIE, 0)

        def naamwoord(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.NaamwoordContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,i)


        def BESTAANDE_UIT(self):
            return self.getToken(RegelSpraakParser.BESTAANDE_UIT, 0)

        def voorzetselSpecificatie(self):
            return self.getTypedRuleContext(RegelSpraakParser.VoorzetselSpecificatieContext,0)


        def COMMA(self):
            return self.getToken(RegelSpraakParser.COMMA, 0)

        def labelWaardeSpecificatie(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.LabelWaardeSpecificatieContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.LabelWaardeSpecificatieContext,i)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_dimensieDefinition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDimensieDefinition" ):
                listener.enterDimensieDefinition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDimensieDefinition" ):
                listener.exitDimensieDefinition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDimensieDefinition" ):
                return visitor.visitDimensieDefinition(self)
            else:
                return visitor.visitChildren(self)




    def dimensieDefinition(self):

        localctx = RegelSpraakParser.DimensieDefinitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_dimensieDefinition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 426
            self.match(RegelSpraakParser.DIMENSIE)
            self.state = 427
            self.naamwoord()
            self.state = 429
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==258:
                self.state = 428
                self.match(RegelSpraakParser.COMMA)


            self.state = 431
            self.match(RegelSpraakParser.BESTAANDE_UIT)
            self.state = 432
            localctx.dimensieNaamMeervoud = self.naamwoord()
            self.state = 433
            self.voorzetselSpecificatie()
            self.state = 435 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 434
                self.labelWaardeSpecificatie()
                self.state = 437 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==248):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VoorzetselSpecificatieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.vz = None # VoorzetselContext

        def NA_HET_ATTRIBUUT_MET_VOORZETSEL(self):
            return self.getToken(RegelSpraakParser.NA_HET_ATTRIBUUT_MET_VOORZETSEL, 0)

        def RPAREN(self):
            return self.getToken(RegelSpraakParser.RPAREN, 0)

        def voorzetsel(self):
            return self.getTypedRuleContext(RegelSpraakParser.VoorzetselContext,0)


        def COLON(self):
            return self.getToken(RegelSpraakParser.COLON, 0)

        def VOOR_HET_ATTRIBUUT_ZONDER_VOORZETSEL(self):
            return self.getToken(RegelSpraakParser.VOOR_HET_ATTRIBUUT_ZONDER_VOORZETSEL, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_voorzetselSpecificatie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVoorzetselSpecificatie" ):
                listener.enterVoorzetselSpecificatie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVoorzetselSpecificatie" ):
                listener.exitVoorzetselSpecificatie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVoorzetselSpecificatie" ):
                return visitor.visitVoorzetselSpecificatie(self)
            else:
                return visitor.visitChildren(self)




    def voorzetselSpecificatie(self):

        localctx = RegelSpraakParser.VoorzetselSpecificatieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_voorzetselSpecificatie)
        self._la = 0 # Token type
        try:
            self.state = 446
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [6]:
                self.enterOuterAlt(localctx, 1)
                self.state = 439
                self.match(RegelSpraakParser.NA_HET_ATTRIBUUT_MET_VOORZETSEL)
                self.state = 440
                localctx.vz = self.voorzetsel()
                self.state = 441
                self.match(RegelSpraakParser.RPAREN)
                self.state = 443
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==260:
                    self.state = 442
                    self.match(RegelSpraakParser.COLON)


                pass
            elif token in [5]:
                self.enterOuterAlt(localctx, 2)
                self.state = 445
                self.match(RegelSpraakParser.VOOR_HET_ATTRIBUUT_ZONDER_VOORZETSEL)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LabelWaardeSpecificatieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.dimWaarde = None # IdentifierContext

        def NUMBER(self):
            return self.getToken(RegelSpraakParser.NUMBER, 0)

        def DOT(self):
            return self.getToken(RegelSpraakParser.DOT, 0)

        def identifier(self):
            return self.getTypedRuleContext(RegelSpraakParser.IdentifierContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_labelWaardeSpecificatie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLabelWaardeSpecificatie" ):
                listener.enterLabelWaardeSpecificatie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLabelWaardeSpecificatie" ):
                listener.exitLabelWaardeSpecificatie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLabelWaardeSpecificatie" ):
                return visitor.visitLabelWaardeSpecificatie(self)
            else:
                return visitor.visitChildren(self)




    def labelWaardeSpecificatie(self):

        localctx = RegelSpraakParser.LabelWaardeSpecificatieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_labelWaardeSpecificatie)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 448
            self.match(RegelSpraakParser.NUMBER)
            self.state = 449
            self.match(RegelSpraakParser.DOT)
            self.state = 450
            localctx.dimWaarde = self.identifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TijdlijnContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def VOOR_ELKE_DAG(self):
            return self.getToken(RegelSpraakParser.VOOR_ELKE_DAG, 0)

        def VOOR_ELKE_MAAND(self):
            return self.getToken(RegelSpraakParser.VOOR_ELKE_MAAND, 0)

        def VOOR_ELK_JAAR(self):
            return self.getToken(RegelSpraakParser.VOOR_ELK_JAAR, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_tijdlijn

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTijdlijn" ):
                listener.enterTijdlijn(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTijdlijn" ):
                listener.exitTijdlijn(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTijdlijn" ):
                return visitor.visitTijdlijn(self)
            else:
                return visitor.visitChildren(self)




    def tijdlijn(self):

        localctx = RegelSpraakParser.TijdlijnContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_tijdlijn)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 452
            _la = self._input.LA(1)
            if not(((((_la - 177)) & ~0x3f) == 0 and ((1 << (_la - 177)) & 7) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DimensieRefContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.name = None # Token

        def IDENTIFIER(self):
            return self.getToken(RegelSpraakParser.IDENTIFIER, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_dimensieRef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDimensieRef" ):
                listener.enterDimensieRef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDimensieRef" ):
                listener.exitDimensieRef(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDimensieRef" ):
                return visitor.visitDimensieRef(self)
            else:
                return visitor.visitChildren(self)




    def dimensieRef(self):

        localctx = RegelSpraakParser.DimensieRefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_dimensieRef)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 454
            localctx.name = self.match(RegelSpraakParser.IDENTIFIER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParameterDefinitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PARAMETER(self):
            return self.getToken(RegelSpraakParser.PARAMETER, 0)

        def parameterNamePhrase(self):
            return self.getTypedRuleContext(RegelSpraakParser.ParameterNamePhraseContext,0)


        def COLON(self):
            return self.getToken(RegelSpraakParser.COLON, 0)

        def SEMICOLON(self):
            return self.getToken(RegelSpraakParser.SEMICOLON, 0)

        def datatype(self):
            return self.getTypedRuleContext(RegelSpraakParser.DatatypeContext,0)


        def domeinRef(self):
            return self.getTypedRuleContext(RegelSpraakParser.DomeinRefContext,0)


        def MET_EENHEID(self):
            return self.getToken(RegelSpraakParser.MET_EENHEID, 0)

        def eenheidExpressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.EenheidExpressieContext,0)


        def tijdlijn(self):
            return self.getTypedRuleContext(RegelSpraakParser.TijdlijnContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_parameterDefinition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParameterDefinition" ):
                listener.enterParameterDefinition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParameterDefinition" ):
                listener.exitParameterDefinition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParameterDefinition" ):
                return visitor.visitParameterDefinition(self)
            else:
                return visitor.visitChildren(self)




    def parameterDefinition(self):

        localctx = RegelSpraakParser.ParameterDefinitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_parameterDefinition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 456
            self.match(RegelSpraakParser.PARAMETER)
            self.state = 457
            self.parameterNamePhrase()
            self.state = 458
            self.match(RegelSpraakParser.COLON)
            self.state = 461
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [7, 156, 158, 171, 176]:
                self.state = 459
                self.datatype()
                pass
            elif token in [101]:
                self.state = 460
                self.domeinRef()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 465
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==167:
                self.state = 463
                self.match(RegelSpraakParser.MET_EENHEID)
                self.state = 464
                self.eenheidExpressie()


            self.state = 468
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 177)) & ~0x3f) == 0 and ((1 << (_la - 177)) & 7) != 0):
                self.state = 467
                self.tijdlijn()


            self.state = 470
            self.match(RegelSpraakParser.SEMICOLON)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParameterNamePhraseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DE(self):
            return self.getToken(RegelSpraakParser.DE, 0)

        def HET(self):
            return self.getToken(RegelSpraakParser.HET, 0)

        def IDENTIFIER(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.IDENTIFIER)
            else:
                return self.getToken(RegelSpraakParser.IDENTIFIER, i)

        def AANTAL(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.AANTAL)
            else:
                return self.getToken(RegelSpraakParser.AANTAL, i)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_parameterNamePhrase

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParameterNamePhrase" ):
                listener.enterParameterNamePhrase(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParameterNamePhrase" ):
                listener.exitParameterNamePhrase(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParameterNamePhrase" ):
                return visitor.visitParameterNamePhrase(self)
            else:
                return visitor.visitChildren(self)




    def parameterNamePhrase(self):

        localctx = RegelSpraakParser.ParameterNamePhraseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_parameterNamePhrase)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 473
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==202 or _la==207:
                self.state = 472
                _la = self._input.LA(1)
                if not(_la==202 or _la==207):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


            self.state = 476 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 475
                _la = self._input.LA(1)
                if not(_la==180 or _la==247):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 478 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==180 or _la==247):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParameterMetLidwoordContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_parameterMetLidwoord

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParameterMetLidwoord" ):
                listener.enterParameterMetLidwoord(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParameterMetLidwoord" ):
                listener.exitParameterMetLidwoord(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParameterMetLidwoord" ):
                return visitor.visitParameterMetLidwoord(self)
            else:
                return visitor.visitChildren(self)




    def parameterMetLidwoord(self):

        localctx = RegelSpraakParser.ParameterMetLidwoordContext(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_parameterMetLidwoord)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 480
            self.naamwoord()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FeitTypeDefinitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.subject = None # NaamwoordContext
            self.object_ = None # NaamwoordContext
            self.description = None # NaamwoordContext

        def rolSpecificatie(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.RolSpecificatieContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.RolSpecificatieContext,i)


        def WEDERKERIG_FEITTYPE(self):
            return self.getToken(RegelSpraakParser.WEDERKERIG_FEITTYPE, 0)

        def FEITTYPE(self):
            return self.getToken(RegelSpraakParser.FEITTYPE, 0)

        def naamwoord(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.NaamwoordContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,i)


        def HEEFT(self):
            return self.getToken(RegelSpraakParser.HEEFT, 0)

        def IS(self):
            return self.getToken(RegelSpraakParser.IS, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_feitTypeDefinition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFeitTypeDefinition" ):
                listener.enterFeitTypeDefinition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFeitTypeDefinition" ):
                listener.exitFeitTypeDefinition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFeitTypeDefinition" ):
                return visitor.visitFeitTypeDefinition(self)
            else:
                return visitor.visitChildren(self)




    def feitTypeDefinition(self):

        localctx = RegelSpraakParser.FeitTypeDefinitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_feitTypeDefinition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 482
            _la = self._input.LA(1)
            if not(_la==31 or _la==105):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 483
            localctx.subject = self.naamwoord()
            self.state = 488
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [110]:
                self.state = 484
                self.match(RegelSpraakParser.HEEFT)
                self.state = 485
                localctx.object_ = self.naamwoord()
                pass
            elif token in [112]:
                self.state = 486
                self.match(RegelSpraakParser.IS)
                self.state = 487
                localctx.description = self.naamwoord()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 490
            self.rolSpecificatie()
            self.state = 492 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 491
                self.rolSpecificatie()
                self.state = 494 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==5 or _la==6):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RolSpecificatieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def voorzetselSpecificatie(self):
            return self.getTypedRuleContext(RegelSpraakParser.VoorzetselSpecificatieContext,0)


        def identifier(self):
            return self.getTypedRuleContext(RegelSpraakParser.IdentifierContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_rolSpecificatie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRolSpecificatie" ):
                listener.enterRolSpecificatie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRolSpecificatie" ):
                listener.exitRolSpecificatie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRolSpecificatie" ):
                return visitor.visitRolSpecificatie(self)
            else:
                return visitor.visitChildren(self)




    def rolSpecificatie(self):

        localctx = RegelSpraakParser.RolSpecificatieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 74, self.RULE_rolSpecificatie)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 496
            self.voorzetselSpecificatie()
            self.state = 497
            self.identifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RegelContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def REGEL(self):
            return self.getToken(RegelSpraakParser.REGEL, 0)

        def regelName(self):
            return self.getTypedRuleContext(RegelSpraakParser.RegelNameContext,0)


        def regelVersie(self):
            return self.getTypedRuleContext(RegelSpraakParser.RegelVersieContext,0)


        def resultaatDeel(self):
            return self.getTypedRuleContext(RegelSpraakParser.ResultaatDeelContext,0)


        def NUMBER(self):
            return self.getToken(RegelSpraakParser.NUMBER, 0)

        def voorwaardeDeel(self):
            return self.getTypedRuleContext(RegelSpraakParser.VoorwaardeDeelContext,0)


        def DOT(self):
            return self.getToken(RegelSpraakParser.DOT, 0)

        def variabeleDeel(self):
            return self.getTypedRuleContext(RegelSpraakParser.VariabeleDeelContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_regel

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRegel" ):
                listener.enterRegel(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRegel" ):
                listener.exitRegel(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRegel" ):
                return visitor.visitRegel(self)
            else:
                return visitor.visitChildren(self)




    def regel(self):

        localctx = RegelSpraakParser.RegelContext(self, self._ctx, self.state)
        self.enterRule(localctx, 76, self.RULE_regel)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 499
            self.match(RegelSpraakParser.REGEL)
            self.state = 500
            self.regelName()
            self.state = 502
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==248:
                self.state = 501
                self.match(RegelSpraakParser.NUMBER)


            self.state = 504
            self.regelVersie()
            self.state = 505
            self.resultaatDeel()
            self.state = 511
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [111]:
                self.state = 506
                self.voorwaardeDeel()
                self.state = 508
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==259:
                    self.state = 507
                    self.match(RegelSpraakParser.DOT)


                pass
            elif token in [259]:
                self.state = 510
                self.match(RegelSpraakParser.DOT)
                pass
            elif token in [-1, 31, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107]:
                pass
            else:
                pass
            self.state = 514
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==107:
                self.state = 513
                self.variabeleDeel()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RegelNameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.IDENTIFIER)
            else:
                return self.getToken(RegelSpraakParser.IDENTIFIER, i)

        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def KENMERK(self):
            return self.getToken(RegelSpraakParser.KENMERK, 0)

        def ROL(self):
            return self.getToken(RegelSpraakParser.ROL, 0)

        def NIET(self):
            return self.getToken(RegelSpraakParser.NIET, 0)

        def KENMERKEN(self):
            return self.getToken(RegelSpraakParser.KENMERKEN, 0)

        def ROLLEN(self):
            return self.getToken(RegelSpraakParser.ROLLEN, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_regelName

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRegelName" ):
                listener.enterRegelName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRegelName" ):
                listener.exitRegelName(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRegelName" ):
                return visitor.visitRegelName(self)
            else:
                return visitor.visitChildren(self)




    def regelName(self):

        localctx = RegelSpraakParser.RegelNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 78, self.RULE_regelName)
        self._la = 0 # Token type
        try:
            self.state = 570
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,67,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 517 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 516
                    self.match(RegelSpraakParser.IDENTIFIER)
                    self.state = 519 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==247):
                        break

                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 521
                self.naamwoord()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 523 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 522
                    self.match(RegelSpraakParser.IDENTIFIER)
                    self.state = 525 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==247):
                        break

                self.state = 527
                self.match(RegelSpraakParser.KENMERK)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 529 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 528
                    self.match(RegelSpraakParser.IDENTIFIER)
                    self.state = 531 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==247):
                        break

                self.state = 533
                self.match(RegelSpraakParser.ROL)
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 535 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 534
                    self.match(RegelSpraakParser.IDENTIFIER)
                    self.state = 537 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==247):
                        break

                self.state = 539
                self.match(RegelSpraakParser.NIET)
                self.state = 540
                self.match(RegelSpraakParser.KENMERK)
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 542 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 541
                    self.match(RegelSpraakParser.IDENTIFIER)
                    self.state = 544 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==247):
                        break

                self.state = 546
                self.match(RegelSpraakParser.NIET)
                self.state = 547
                self.match(RegelSpraakParser.ROL)
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 549 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 548
                    self.match(RegelSpraakParser.IDENTIFIER)
                    self.state = 551 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==247):
                        break

                self.state = 553
                self.match(RegelSpraakParser.KENMERKEN)
                self.state = 555 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 554
                    self.match(RegelSpraakParser.IDENTIFIER)
                    self.state = 557 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==247):
                        break

                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 560 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 559
                    self.match(RegelSpraakParser.IDENTIFIER)
                    self.state = 562 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==247):
                        break

                self.state = 564
                self.match(RegelSpraakParser.ROLLEN)
                self.state = 566 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 565
                    self.match(RegelSpraakParser.IDENTIFIER)
                    self.state = 568 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==247):
                        break

                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RegelVersieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GELDIG(self):
            return self.getToken(RegelSpraakParser.GELDIG, 0)

        def versieGeldigheid(self):
            return self.getTypedRuleContext(RegelSpraakParser.VersieGeldigheidContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_regelVersie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRegelVersie" ):
                listener.enterRegelVersie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRegelVersie" ):
                listener.exitRegelVersie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRegelVersie" ):
                return visitor.visitRegelVersie(self)
            else:
                return visitor.visitChildren(self)




    def regelVersie(self):

        localctx = RegelSpraakParser.RegelVersieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 80, self.RULE_regelVersie)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 572
            self.match(RegelSpraakParser.GELDIG)
            self.state = 573
            self.versieGeldigheid()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VersieGeldigheidContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ALTIJD(self):
            return self.getToken(RegelSpraakParser.ALTIJD, 0)

        def VANAF(self):
            return self.getToken(RegelSpraakParser.VANAF, 0)

        def datumLiteral(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.DatumLiteralContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.DatumLiteralContext,i)


        def TM(self):
            return self.getToken(RegelSpraakParser.TM, 0)

        def TOT_EN_MET(self):
            return self.getToken(RegelSpraakParser.TOT_EN_MET, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_versieGeldigheid

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVersieGeldigheid" ):
                listener.enterVersieGeldigheid(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVersieGeldigheid" ):
                listener.exitVersieGeldigheid(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVersieGeldigheid" ):
                return visitor.visitVersieGeldigheid(self)
            else:
                return visitor.visitChildren(self)




    def versieGeldigheid(self):

        localctx = RegelSpraakParser.VersieGeldigheidContext(self, self._ctx, self.state)
        self.enterRule(localctx, 82, self.RULE_versieGeldigheid)
        self._la = 0 # Token type
        try:
            self.state = 582
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [198]:
                self.enterOuterAlt(localctx, 1)
                self.state = 575
                self.match(RegelSpraakParser.ALTIJD)
                pass
            elif token in [144]:
                self.enterOuterAlt(localctx, 2)
                self.state = 576
                self.match(RegelSpraakParser.VANAF)
                self.state = 577
                self.datumLiteral()
                self.state = 580
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==142 or _la==224:
                    self.state = 578
                    _la = self._input.LA(1)
                    if not(_la==142 or _la==224):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()
                    self.state = 579
                    self.datumLiteral()


                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ResultaatDeelContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_resultaatDeel

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class AantalDagenInResultaatContext(ResultaatDeelContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.ResultaatDeelContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def HET_AANTAL_DAGEN_IN(self):
            return self.getToken(RegelSpraakParser.HET_AANTAL_DAGEN_IN, 0)
        def MAAND(self):
            return self.getToken(RegelSpraakParser.MAAND, 0)
        def JAAR(self):
            return self.getToken(RegelSpraakParser.JAAR, 0)
        def WORDT_BEREKEND_ALS(self):
            return self.getToken(RegelSpraakParser.WORDT_BEREKEND_ALS, 0)
        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)

        def WORDT_GESTELD_OP(self):
            return self.getToken(RegelSpraakParser.WORDT_GESTELD_OP, 0)
        def WORDT_GEINITIALISEERD_OP(self):
            return self.getToken(RegelSpraakParser.WORDT_GEINITIALISEERD_OP, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAantalDagenInResultaat" ):
                listener.enterAantalDagenInResultaat(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAantalDagenInResultaat" ):
                listener.exitAantalDagenInResultaat(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAantalDagenInResultaat" ):
                return visitor.visitAantalDagenInResultaat(self)
            else:
                return visitor.visitChildren(self)


    class GelijkstellingResultaatContext(ResultaatDeelContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.ResultaatDeelContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)

        def attribuutReferentie(self):
            return self.getTypedRuleContext(RegelSpraakParser.AttribuutReferentieContext,0)

        def WORDT_BEREKEND_ALS(self):
            return self.getToken(RegelSpraakParser.WORDT_BEREKEND_ALS, 0)
        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)

        def WORDT_GESTELD_OP(self):
            return self.getToken(RegelSpraakParser.WORDT_GESTELD_OP, 0)
        def WORDT_GEINITIALISEERD_OP(self):
            return self.getToken(RegelSpraakParser.WORDT_GEINITIALISEERD_OP, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGelijkstellingResultaat" ):
                listener.enterGelijkstellingResultaat(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGelijkstellingResultaat" ):
                listener.exitGelijkstellingResultaat(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGelijkstellingResultaat" ):
                return visitor.visitGelijkstellingResultaat(self)
            else:
                return visitor.visitChildren(self)


    class CapitalizedGelijkstellingResultaatContext(ResultaatDeelContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.ResultaatDeelContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def WORDT_BEREKEND_ALS(self):
            return self.getToken(RegelSpraakParser.WORDT_BEREKEND_ALS, 0)
        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)

        def WORDT_GESTELD_OP(self):
            return self.getToken(RegelSpraakParser.WORDT_GESTELD_OP, 0)
        def WORDT_GEINITIALISEERD_OP(self):
            return self.getToken(RegelSpraakParser.WORDT_GEINITIALISEERD_OP, 0)
        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.IdentifierContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCapitalizedGelijkstellingResultaat" ):
                listener.enterCapitalizedGelijkstellingResultaat(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCapitalizedGelijkstellingResultaat" ):
                listener.exitCapitalizedGelijkstellingResultaat(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCapitalizedGelijkstellingResultaat" ):
                return visitor.visitCapitalizedGelijkstellingResultaat(self)
            else:
                return visitor.visitChildren(self)


    class SpecialPhraseResultaatContext(ResultaatDeelContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.ResultaatDeelContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def HET_KWARTAAL(self):
            return self.getToken(RegelSpraakParser.HET_KWARTAAL, 0)
        def HET_DEEL_PER_MAAND(self):
            return self.getToken(RegelSpraakParser.HET_DEEL_PER_MAAND, 0)
        def HET_DEEL_PER_JAAR(self):
            return self.getToken(RegelSpraakParser.HET_DEEL_PER_JAAR, 0)
        def WORDT_BEREKEND_ALS(self):
            return self.getToken(RegelSpraakParser.WORDT_BEREKEND_ALS, 0)
        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)

        def WORDT_GESTELD_OP(self):
            return self.getToken(RegelSpraakParser.WORDT_GESTELD_OP, 0)
        def WORDT_GEINITIALISEERD_OP(self):
            return self.getToken(RegelSpraakParser.WORDT_GEINITIALISEERD_OP, 0)
        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.IdentifierContext,i)

        def datumLiteral(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.DatumLiteralContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.DatumLiteralContext,i)

        def DOT(self):
            return self.getToken(RegelSpraakParser.DOT, 0)
        def VANAF(self):
            return self.getToken(RegelSpraakParser.VANAF, 0)
        def VAN(self):
            return self.getToken(RegelSpraakParser.VAN, 0)
        def TOT(self):
            return self.getToken(RegelSpraakParser.TOT, 0)
        def TOT_EN_MET(self):
            return self.getToken(RegelSpraakParser.TOT_EN_MET, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSpecialPhraseResultaat" ):
                listener.enterSpecialPhraseResultaat(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSpecialPhraseResultaat" ):
                listener.exitSpecialPhraseResultaat(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSpecialPhraseResultaat" ):
                return visitor.visitSpecialPhraseResultaat(self)
            else:
                return visitor.visitChildren(self)


    class KenmerkFeitResultaatContext(ResultaatDeelContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.ResultaatDeelContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def onderwerpReferentie(self):
            return self.getTypedRuleContext(RegelSpraakParser.OnderwerpReferentieContext,0)

        def kenmerkNaam(self):
            return self.getTypedRuleContext(RegelSpraakParser.KenmerkNaamContext,0)

        def IS(self):
            return self.getToken(RegelSpraakParser.IS, 0)
        def HEEFT(self):
            return self.getToken(RegelSpraakParser.HEEFT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterKenmerkFeitResultaat" ):
                listener.enterKenmerkFeitResultaat(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitKenmerkFeitResultaat" ):
                listener.exitKenmerkFeitResultaat(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitKenmerkFeitResultaat" ):
                return visitor.visitKenmerkFeitResultaat(self)
            else:
                return visitor.visitChildren(self)


    class ObjectCreatieActieContext(ResultaatDeelContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.ResultaatDeelContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def objectCreatie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ObjectCreatieContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterObjectCreatieActie" ):
                listener.enterObjectCreatieActie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitObjectCreatieActie" ):
                listener.exitObjectCreatieActie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitObjectCreatieActie" ):
                return visitor.visitObjectCreatieActie(self)
            else:
                return visitor.visitChildren(self)


    class FeitCreatieResultaatContext(ResultaatDeelContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.ResultaatDeelContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def onderwerpReferentie(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.OnderwerpReferentieContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.OnderwerpReferentieContext,i)

        def HEEFT(self):
            return self.getToken(RegelSpraakParser.HEEFT, 0)
        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)

        def MET(self):
            return self.getToken(RegelSpraakParser.MET, 0)
        def TOT(self):
            return self.getToken(RegelSpraakParser.TOT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFeitCreatieResultaat" ):
                listener.enterFeitCreatieResultaat(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFeitCreatieResultaat" ):
                listener.exitFeitCreatieResultaat(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFeitCreatieResultaat" ):
                return visitor.visitFeitCreatieResultaat(self)
            else:
                return visitor.visitChildren(self)



    def resultaatDeel(self):

        localctx = RegelSpraakParser.ResultaatDeelContext(self, self._ctx, self.state)
        self.enterRule(localctx, 84, self.RULE_resultaatDeel)
        self._la = 0 # Token type
        try:
            self.state = 655
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,79,self._ctx)
            if la_ == 1:
                localctx = RegelSpraakParser.GelijkstellingResultaatContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 586
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,70,self._ctx)
                if la_ == 1:
                    self.state = 584
                    self.naamwoord()
                    pass

                elif la_ == 2:
                    self.state = 585
                    self.attribuutReferentie()
                    pass


                self.state = 594
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [11]:
                    self.state = 588
                    self.match(RegelSpraakParser.WORDT_BEREKEND_ALS)
                    self.state = 589
                    self.expressie()
                    pass
                elif token in [12]:
                    self.state = 590
                    self.match(RegelSpraakParser.WORDT_GESTELD_OP)
                    self.state = 591
                    self.expressie()
                    pass
                elif token in [13]:
                    self.state = 592
                    self.match(RegelSpraakParser.WORDT_GEINITIALISEERD_OP)
                    self.state = 593
                    self.expressie()
                    pass
                else:
                    raise NoViableAltException(self)

                pass

            elif la_ == 2:
                localctx = RegelSpraakParser.KenmerkFeitResultaatContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 596
                self.onderwerpReferentie()
                self.state = 597
                _la = self._input.LA(1)
                if not(_la==110 or _la==112):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 598
                self.kenmerkNaam()
                pass

            elif la_ == 3:
                localctx = RegelSpraakParser.FeitCreatieResultaatContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 600
                self.onderwerpReferentie()
                self.state = 601
                self.match(RegelSpraakParser.HEEFT)
                self.state = 602
                self.naamwoord()
                self.state = 603
                _la = self._input.LA(1)
                if not(_la==140 or _la==166):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 604
                self.onderwerpReferentie()
                pass

            elif la_ == 4:
                localctx = RegelSpraakParser.CapitalizedGelijkstellingResultaatContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 607 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 606
                    self.identifier()
                    self.state = 609 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==247):
                        break

                self.state = 617
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [11]:
                    self.state = 611
                    self.match(RegelSpraakParser.WORDT_BEREKEND_ALS)
                    self.state = 612
                    self.expressie()
                    pass
                elif token in [12]:
                    self.state = 613
                    self.match(RegelSpraakParser.WORDT_GESTELD_OP)
                    self.state = 614
                    self.expressie()
                    pass
                elif token in [13]:
                    self.state = 615
                    self.match(RegelSpraakParser.WORDT_GEINITIALISEERD_OP)
                    self.state = 616
                    self.expressie()
                    pass
                else:
                    raise NoViableAltException(self)

                pass

            elif la_ == 5:
                localctx = RegelSpraakParser.SpecialPhraseResultaatContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 619
                _la = self._input.LA(1)
                if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 28) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 623
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==247:
                    self.state = 620
                    self.identifier()
                    self.state = 625
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 632
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [11]:
                    self.state = 626
                    self.match(RegelSpraakParser.WORDT_BEREKEND_ALS)
                    self.state = 627
                    self.expressie()
                    pass
                elif token in [12]:
                    self.state = 628
                    self.match(RegelSpraakParser.WORDT_GESTELD_OP)
                    self.state = 629
                    self.expressie()
                    pass
                elif token in [13]:
                    self.state = 630
                    self.match(RegelSpraakParser.WORDT_GEINITIALISEERD_OP)
                    self.state = 631
                    self.expressie()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 639
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==144 or _la==227:
                    self.state = 634
                    _la = self._input.LA(1)
                    if not(_la==144 or _la==227):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()
                    self.state = 635
                    self.datumLiteral()
                    self.state = 636
                    _la = self._input.LA(1)
                    if not(_la==140 or _la==142):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()
                    self.state = 637
                    self.datumLiteral()


                self.state = 642
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,77,self._ctx)
                if la_ == 1:
                    self.state = 641
                    self.match(RegelSpraakParser.DOT)


                pass

            elif la_ == 6:
                localctx = RegelSpraakParser.AantalDagenInResultaatContext(self, localctx)
                self.enterOuterAlt(localctx, 6)
                self.state = 644
                self.match(RegelSpraakParser.HET_AANTAL_DAGEN_IN)
                self.state = 645
                _la = self._input.LA(1)
                if not(_la==210 or _la==212):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 652
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [11]:
                    self.state = 646
                    self.match(RegelSpraakParser.WORDT_BEREKEND_ALS)
                    self.state = 647
                    self.expressie()
                    pass
                elif token in [12]:
                    self.state = 648
                    self.match(RegelSpraakParser.WORDT_GESTELD_OP)
                    self.state = 649
                    self.expressie()
                    pass
                elif token in [13]:
                    self.state = 650
                    self.match(RegelSpraakParser.WORDT_GEINITIALISEERD_OP)
                    self.state = 651
                    self.expressie()
                    pass
                else:
                    raise NoViableAltException(self)

                pass

            elif la_ == 7:
                localctx = RegelSpraakParser.ObjectCreatieActieContext(self, localctx)
                self.enterOuterAlt(localctx, 7)
                self.state = 654
                self.objectCreatie()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ObjectCreatieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.objectType = None # NaamwoordContext

        def ER_WORDT_EEN_NIEUW(self):
            return self.getToken(RegelSpraakParser.ER_WORDT_EEN_NIEUW, 0)

        def AANGEMAAKT(self):
            return self.getToken(RegelSpraakParser.AANGEMAAKT, 0)

        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def objectAttributeInit(self):
            return self.getTypedRuleContext(RegelSpraakParser.ObjectAttributeInitContext,0)


        def DOT(self):
            return self.getToken(RegelSpraakParser.DOT, 0)

        def CREEER(self):
            return self.getToken(RegelSpraakParser.CREEER, 0)

        def EEN(self):
            return self.getToken(RegelSpraakParser.EEN, 0)

        def NIEUWE(self):
            return self.getToken(RegelSpraakParser.NIEUWE, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_objectCreatie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterObjectCreatie" ):
                listener.enterObjectCreatie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitObjectCreatie" ):
                listener.exitObjectCreatie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitObjectCreatie" ):
                return visitor.visitObjectCreatie(self)
            else:
                return visitor.visitChildren(self)




    def objectCreatie(self):

        localctx = RegelSpraakParser.ObjectCreatieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 86, self.RULE_objectCreatie)
        self._la = 0 # Token type
        try:
            self.state = 676
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [44]:
                self.enterOuterAlt(localctx, 1)
                self.state = 657
                self.match(RegelSpraakParser.ER_WORDT_EEN_NIEUW)
                self.state = 658
                localctx.objectType = self.naamwoord()
                self.state = 659
                self.match(RegelSpraakParser.AANGEMAAKT)
                self.state = 661
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==166:
                    self.state = 660
                    self.objectAttributeInit()


                self.state = 664
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,81,self._ctx)
                if la_ == 1:
                    self.state = 663
                    self.match(RegelSpraakParser.DOT)


                pass
            elif token in [47]:
                self.enterOuterAlt(localctx, 2)
                self.state = 666
                self.match(RegelSpraakParser.CREEER)
                self.state = 667
                self.match(RegelSpraakParser.EEN)
                self.state = 668
                self.match(RegelSpraakParser.NIEUWE)
                self.state = 669
                localctx.objectType = self.naamwoord()
                self.state = 671
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==166:
                    self.state = 670
                    self.objectAttributeInit()


                self.state = 674
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,83,self._ctx)
                if la_ == 1:
                    self.state = 673
                    self.match(RegelSpraakParser.DOT)


                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ObjectAttributeInitContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.attribuut = None # NaamwoordContext
            self.waarde = None # ExpressieContext

        def MET(self):
            return self.getToken(RegelSpraakParser.MET, 0)

        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)


        def attributeInitVervolg(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.AttributeInitVervolgContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.AttributeInitVervolgContext,i)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_objectAttributeInit

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterObjectAttributeInit" ):
                listener.enterObjectAttributeInit(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitObjectAttributeInit" ):
                listener.exitObjectAttributeInit(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitObjectAttributeInit" ):
                return visitor.visitObjectAttributeInit(self)
            else:
                return visitor.visitChildren(self)




    def objectAttributeInit(self):

        localctx = RegelSpraakParser.ObjectAttributeInitContext(self, self._ctx, self.state)
        self.enterRule(localctx, 88, self.RULE_objectAttributeInit)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 678
            self.match(RegelSpraakParser.MET)
            self.state = 679
            localctx.attribuut = self.naamwoord()
            self.state = 680
            localctx.waarde = self.expressie()
            self.state = 684
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==206:
                self.state = 681
                self.attributeInitVervolg()
                self.state = 686
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AttributeInitVervolgContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.attribuut = None # NaamwoordContext
            self.waarde = None # ExpressieContext

        def EN(self):
            return self.getToken(RegelSpraakParser.EN, 0)

        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_attributeInitVervolg

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAttributeInitVervolg" ):
                listener.enterAttributeInitVervolg(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAttributeInitVervolg" ):
                listener.exitAttributeInitVervolg(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAttributeInitVervolg" ):
                return visitor.visitAttributeInitVervolg(self)
            else:
                return visitor.visitChildren(self)




    def attributeInitVervolg(self):

        localctx = RegelSpraakParser.AttributeInitVervolgContext(self, self._ctx, self.state)
        self.enterRule(localctx, 90, self.RULE_attributeInitVervolg)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 687
            self.match(RegelSpraakParser.EN)
            self.state = 688
            localctx.attribuut = self.naamwoord()
            self.state = 689
            localctx.waarde = self.expressie()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConsistentieregelContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CONSISTENTIEREGEL(self):
            return self.getToken(RegelSpraakParser.CONSISTENTIEREGEL, 0)

        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def uniekzijnResultaat(self):
            return self.getTypedRuleContext(RegelSpraakParser.UniekzijnResultaatContext,0)


        def inconsistentResultaat(self):
            return self.getTypedRuleContext(RegelSpraakParser.InconsistentResultaatContext,0)


        def voorwaardeDeel(self):
            return self.getTypedRuleContext(RegelSpraakParser.VoorwaardeDeelContext,0)


        def DOT(self):
            return self.getToken(RegelSpraakParser.DOT, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_consistentieregel

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConsistentieregel" ):
                listener.enterConsistentieregel(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConsistentieregel" ):
                listener.exitConsistentieregel(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConsistentieregel" ):
                return visitor.visitConsistentieregel(self)
            else:
                return visitor.visitChildren(self)




    def consistentieregel(self):

        localctx = RegelSpraakParser.ConsistentieregelContext(self, self._ctx, self.state)
        self.enterRule(localctx, 92, self.RULE_consistentieregel)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 691
            self.match(RegelSpraakParser.CONSISTENTIEREGEL)
            self.state = 692
            self.naamwoord()
            self.state = 702
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,88,self._ctx)
            if la_ == 1:
                self.state = 693
                self.uniekzijnResultaat()
                pass

            elif la_ == 2:
                self.state = 694
                self.inconsistentResultaat()
                self.state = 700
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [111]:
                    self.state = 695
                    self.voorwaardeDeel()
                    self.state = 697
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==259:
                        self.state = 696
                        self.match(RegelSpraakParser.DOT)


                    pass
                elif token in [259]:
                    self.state = 699
                    self.match(RegelSpraakParser.DOT)
                    pass
                elif token in [-1, 31, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106]:
                    pass
                else:
                    pass
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UniekzijnResultaatContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def onderwerpReferentie(self):
            return self.getTypedRuleContext(RegelSpraakParser.OnderwerpReferentieContext,0)


        def MOETEN_UNIEK_ZIJN(self):
            return self.getToken(RegelSpraakParser.MOETEN_UNIEK_ZIJN, 0)

        def DOT(self):
            return self.getToken(RegelSpraakParser.DOT, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_uniekzijnResultaat

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUniekzijnResultaat" ):
                listener.enterUniekzijnResultaat(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUniekzijnResultaat" ):
                listener.exitUniekzijnResultaat(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUniekzijnResultaat" ):
                return visitor.visitUniekzijnResultaat(self)
            else:
                return visitor.visitChildren(self)




    def uniekzijnResultaat(self):

        localctx = RegelSpraakParser.UniekzijnResultaatContext(self, self._ctx, self.state)
        self.enterRule(localctx, 94, self.RULE_uniekzijnResultaat)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 704
            self.onderwerpReferentie()
            self.state = 705
            self.match(RegelSpraakParser.MOETEN_UNIEK_ZIJN)
            self.state = 707
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==259:
                self.state = 706
                self.match(RegelSpraakParser.DOT)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InconsistentResultaatContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def IS_INCONSISTENT(self):
            return self.getToken(RegelSpraakParser.IS_INCONSISTENT, 0)

        def DE(self):
            return self.getToken(RegelSpraakParser.DE, 0)

        def HET(self):
            return self.getToken(RegelSpraakParser.HET, 0)

        def ER(self):
            return self.getToken(RegelSpraakParser.ER, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_inconsistentResultaat

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInconsistentResultaat" ):
                listener.enterInconsistentResultaat(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInconsistentResultaat" ):
                listener.exitInconsistentResultaat(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInconsistentResultaat" ):
                return visitor.visitInconsistentResultaat(self)
            else:
                return visitor.visitChildren(self)




    def inconsistentResultaat(self):

        localctx = RegelSpraakParser.InconsistentResultaatContext(self, self._ctx, self.state)
        self.enterRule(localctx, 96, self.RULE_inconsistentResultaat)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 710
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,90,self._ctx)
            if la_ == 1:
                self.state = 709
                _la = self._input.LA(1)
                if not(((((_la - 202)) & ~0x3f) == 0 and ((1 << (_la - 202)) & 2147483681) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


            self.state = 712
            self.naamwoord()
            self.state = 713
            self.match(RegelSpraakParser.IS_INCONSISTENT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VoorwaardeDeelContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INDIEN(self):
            return self.getToken(RegelSpraakParser.INDIEN, 0)

        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)


        def toplevelSamengesteldeVoorwaarde(self):
            return self.getTypedRuleContext(RegelSpraakParser.ToplevelSamengesteldeVoorwaardeContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_voorwaardeDeel

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVoorwaardeDeel" ):
                listener.enterVoorwaardeDeel(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVoorwaardeDeel" ):
                listener.exitVoorwaardeDeel(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVoorwaardeDeel" ):
                return visitor.visitVoorwaardeDeel(self)
            else:
                return visitor.visitChildren(self)




    def voorwaardeDeel(self):

        localctx = RegelSpraakParser.VoorwaardeDeelContext(self, self._ctx, self.state)
        self.enterRule(localctx, 98, self.RULE_voorwaardeDeel)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 715
            self.match(RegelSpraakParser.INDIEN)
            self.state = 718
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,91,self._ctx)
            if la_ == 1:
                self.state = 716
                self.expressie()
                pass

            elif la_ == 2:
                self.state = 717
                self.toplevelSamengesteldeVoorwaarde()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OnderwerpReferentieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def basisOnderwerp(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.BasisOnderwerpContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.BasisOnderwerpContext,i)


        def voorzetsel(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.VoorzetselContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.VoorzetselContext,i)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_onderwerpReferentie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOnderwerpReferentie" ):
                listener.enterOnderwerpReferentie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOnderwerpReferentie" ):
                listener.exitOnderwerpReferentie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOnderwerpReferentie" ):
                return visitor.visitOnderwerpReferentie(self)
            else:
                return visitor.visitChildren(self)




    def onderwerpReferentie(self):

        localctx = RegelSpraakParser.OnderwerpReferentieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 100, self.RULE_onderwerpReferentie)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 720
            self.basisOnderwerp()
            self.state = 726
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,92,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 721
                    self.voorzetsel()
                    self.state = 722
                    self.basisOnderwerp() 
                self.state = 728
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,92,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BasisOnderwerpContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.IDENTIFIER)
            else:
                return self.getToken(RegelSpraakParser.IDENTIFIER, i)

        def DE(self):
            return self.getToken(RegelSpraakParser.DE, 0)

        def HET(self):
            return self.getToken(RegelSpraakParser.HET, 0)

        def EEN(self):
            return self.getToken(RegelSpraakParser.EEN, 0)

        def ZIJN(self):
            return self.getToken(RegelSpraakParser.ZIJN, 0)

        def HIJ(self):
            return self.getToken(RegelSpraakParser.HIJ, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_basisOnderwerp

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBasisOnderwerp" ):
                listener.enterBasisOnderwerp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBasisOnderwerp" ):
                listener.exitBasisOnderwerp(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBasisOnderwerp" ):
                return visitor.visitBasisOnderwerp(self)
            else:
                return visitor.visitChildren(self)




    def basisOnderwerp(self):

        localctx = RegelSpraakParser.BasisOnderwerpContext(self, self._ctx, self.state)
        self.enterRule(localctx, 102, self.RULE_basisOnderwerp)
        self._la = 0 # Token type
        try:
            self.state = 738
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [116, 202, 205, 207, 247]:
                self.enterOuterAlt(localctx, 1)
                self.state = 730
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==116 or ((((_la - 202)) & ~0x3f) == 0 and ((1 << (_la - 202)) & 41) != 0):
                    self.state = 729
                    _la = self._input.LA(1)
                    if not(_la==116 or ((((_la - 202)) & ~0x3f) == 0 and ((1 << (_la - 202)) & 41) != 0)):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                self.state = 733 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 732
                        self.match(RegelSpraakParser.IDENTIFIER)

                    else:
                        raise NoViableAltException(self)
                    self.state = 735 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,94,self._ctx)

                pass
            elif token in [208]:
                self.enterOuterAlt(localctx, 2)
                self.state = 737
                self.match(RegelSpraakParser.HIJ)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AttribuutReferentieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def VAN(self):
            return self.getToken(RegelSpraakParser.VAN, 0)

        def onderwerpReferentie(self):
            return self.getTypedRuleContext(RegelSpraakParser.OnderwerpReferentieContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_attribuutReferentie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAttribuutReferentie" ):
                listener.enterAttribuutReferentie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAttribuutReferentie" ):
                listener.exitAttribuutReferentie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAttribuutReferentie" ):
                return visitor.visitAttribuutReferentie(self)
            else:
                return visitor.visitChildren(self)




    def attribuutReferentie(self):

        localctx = RegelSpraakParser.AttribuutReferentieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 104, self.RULE_attribuutReferentie)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 740
            self.naamwoord()
            self.state = 741
            self.match(RegelSpraakParser.VAN)
            self.state = 742
            self.onderwerpReferentie()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class KenmerkNaamContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def onderwerpReferentie(self):
            return self.getTypedRuleContext(RegelSpraakParser.OnderwerpReferentieContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_kenmerkNaam

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterKenmerkNaam" ):
                listener.enterKenmerkNaam(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitKenmerkNaam" ):
                listener.exitKenmerkNaam(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitKenmerkNaam" ):
                return visitor.visitKenmerkNaam(self)
            else:
                return visitor.visitChildren(self)




    def kenmerkNaam(self):

        localctx = RegelSpraakParser.KenmerkNaamContext(self, self._ctx, self.state)
        self.enterRule(localctx, 106, self.RULE_kenmerkNaam)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 744
            self.onderwerpReferentie()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BezieldeReferentieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ZIJN(self):
            return self.getToken(RegelSpraakParser.ZIJN, 0)

        def identifier(self):
            return self.getTypedRuleContext(RegelSpraakParser.IdentifierContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_bezieldeReferentie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBezieldeReferentie" ):
                listener.enterBezieldeReferentie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBezieldeReferentie" ):
                listener.exitBezieldeReferentie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBezieldeReferentie" ):
                return visitor.visitBezieldeReferentie(self)
            else:
                return visitor.visitChildren(self)




    def bezieldeReferentie(self):

        localctx = RegelSpraakParser.BezieldeReferentieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 108, self.RULE_bezieldeReferentie)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 746
            self.match(RegelSpraakParser.ZIJN)
            self.state = 747
            self.identifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ToplevelSamengesteldeVoorwaardeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def AAN(self):
            return self.getToken(RegelSpraakParser.AAN, 0)

        def voorwaardeKwantificatie(self):
            return self.getTypedRuleContext(RegelSpraakParser.VoorwaardeKwantificatieContext,0)


        def VOLGENDE_VOORWAARDEN(self):
            return self.getToken(RegelSpraakParser.VOLGENDE_VOORWAARDEN, 0)

        def VOLDOET(self):
            return self.getToken(RegelSpraakParser.VOLDOET, 0)

        def COLON(self):
            return self.getToken(RegelSpraakParser.COLON, 0)

        def samengesteldeVoorwaardeOnderdeel(self):
            return self.getTypedRuleContext(RegelSpraakParser.SamengesteldeVoorwaardeOnderdeelContext,0)


        def HIJ(self):
            return self.getToken(RegelSpraakParser.HIJ, 0)

        def HET(self):
            return self.getToken(RegelSpraakParser.HET, 0)

        def onderwerpReferentie(self):
            return self.getTypedRuleContext(RegelSpraakParser.OnderwerpReferentieContext,0)


        def ER_AAN(self):
            return self.getToken(RegelSpraakParser.ER_AAN, 0)

        def WORDT_VOLDAAN(self):
            return self.getToken(RegelSpraakParser.WORDT_VOLDAAN, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_toplevelSamengesteldeVoorwaarde

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterToplevelSamengesteldeVoorwaarde" ):
                listener.enterToplevelSamengesteldeVoorwaarde(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitToplevelSamengesteldeVoorwaarde" ):
                listener.exitToplevelSamengesteldeVoorwaarde(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitToplevelSamengesteldeVoorwaarde" ):
                return visitor.visitToplevelSamengesteldeVoorwaarde(self)
            else:
                return visitor.visitChildren(self)




    def toplevelSamengesteldeVoorwaarde(self):

        localctx = RegelSpraakParser.ToplevelSamengesteldeVoorwaardeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 110, self.RULE_toplevelSamengesteldeVoorwaarde)
        try:
            self.state = 768
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [116, 202, 205, 207, 208, 247]:
                self.enterOuterAlt(localctx, 1)
                self.state = 752
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,96,self._ctx)
                if la_ == 1:
                    self.state = 749
                    self.match(RegelSpraakParser.HIJ)
                    pass

                elif la_ == 2:
                    self.state = 750
                    self.match(RegelSpraakParser.HET)
                    pass

                elif la_ == 3:
                    self.state = 751
                    self.onderwerpReferentie()
                    pass


                self.state = 754
                self.match(RegelSpraakParser.AAN)
                self.state = 755
                self.voorwaardeKwantificatie()
                self.state = 756
                self.match(RegelSpraakParser.VOLGENDE_VOORWAARDEN)
                self.state = 757
                self.match(RegelSpraakParser.VOLDOET)
                self.state = 758
                self.match(RegelSpraakParser.COLON)
                self.state = 759
                self.samengesteldeVoorwaardeOnderdeel()
                pass
            elif token in [49]:
                self.enterOuterAlt(localctx, 2)
                self.state = 761
                self.match(RegelSpraakParser.ER_AAN)
                self.state = 762
                self.voorwaardeKwantificatie()
                self.state = 763
                self.match(RegelSpraakParser.VOLGENDE_VOORWAARDEN)
                self.state = 764
                self.match(RegelSpraakParser.WORDT_VOLDAAN)
                self.state = 765
                self.match(RegelSpraakParser.COLON)
                self.state = 766
                self.samengesteldeVoorwaardeOnderdeel()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VoorwaardeKwantificatieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ALLE(self):
            return self.getToken(RegelSpraakParser.ALLE, 0)

        def TENMINSTE(self):
            return self.getToken(RegelSpraakParser.TENMINSTE, 0)

        def VAN(self):
            return self.getToken(RegelSpraakParser.VAN, 0)

        def DE(self):
            return self.getToken(RegelSpraakParser.DE, 0)

        def EEN_TELWOORD(self):
            return self.getToken(RegelSpraakParser.EEN_TELWOORD, 0)

        def TWEE_TELWOORD(self):
            return self.getToken(RegelSpraakParser.TWEE_TELWOORD, 0)

        def DRIE_TELWOORD(self):
            return self.getToken(RegelSpraakParser.DRIE_TELWOORD, 0)

        def VIER_TELWOORD(self):
            return self.getToken(RegelSpraakParser.VIER_TELWOORD, 0)

        def NUMBER(self):
            return self.getToken(RegelSpraakParser.NUMBER, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_voorwaardeKwantificatie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVoorwaardeKwantificatie" ):
                listener.enterVoorwaardeKwantificatie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVoorwaardeKwantificatie" ):
                listener.exitVoorwaardeKwantificatie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVoorwaardeKwantificatie" ):
                return visitor.visitVoorwaardeKwantificatie(self)
            else:
                return visitor.visitChildren(self)




    def voorwaardeKwantificatie(self):

        localctx = RegelSpraakParser.VoorwaardeKwantificatieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 112, self.RULE_voorwaardeKwantificatie)
        self._la = 0 # Token type
        try:
            self.state = 775
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [119]:
                self.enterOuterAlt(localctx, 1)
                self.state = 770
                self.match(RegelSpraakParser.ALLE)
                pass
            elif token in [151]:
                self.enterOuterAlt(localctx, 2)
                self.state = 771
                self.match(RegelSpraakParser.TENMINSTE)
                self.state = 772
                _la = self._input.LA(1)
                if not(((((_la - 191)) & ~0x3f) == 0 and ((1 << (_la - 191)) & 144115188075855971) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 773
                self.match(RegelSpraakParser.VAN)
                self.state = 774
                self.match(RegelSpraakParser.DE)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SamengesteldeVoorwaardeOnderdeelContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def genesteVoorwaarde(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.GenesteVoorwaardeContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.GenesteVoorwaardeContext,i)


        def BULLET(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.BULLET)
            else:
                return self.getToken(RegelSpraakParser.BULLET, i)

        def MINUS(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.MINUS)
            else:
                return self.getToken(RegelSpraakParser.MINUS, i)

        def ASTERISK(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.ASTERISK)
            else:
                return self.getToken(RegelSpraakParser.ASTERISK, i)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_samengesteldeVoorwaardeOnderdeel

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSamengesteldeVoorwaardeOnderdeel" ):
                listener.enterSamengesteldeVoorwaardeOnderdeel(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSamengesteldeVoorwaardeOnderdeel" ):
                listener.exitSamengesteldeVoorwaardeOnderdeel(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSamengesteldeVoorwaardeOnderdeel" ):
                return visitor.visitSamengesteldeVoorwaardeOnderdeel(self)
            else:
                return visitor.visitChildren(self)




    def samengesteldeVoorwaardeOnderdeel(self):

        localctx = RegelSpraakParser.SamengesteldeVoorwaardeOnderdeelContext(self, self._ctx, self.state)
        self.enterRule(localctx, 114, self.RULE_samengesteldeVoorwaardeOnderdeel)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 777
            _la = self._input.LA(1)
            if not(((((_la - 264)) & ~0x3f) == 0 and ((1 << (_la - 264)) & 131) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 778
            self.genesteVoorwaarde()
            self.state = 783
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((((_la - 264)) & ~0x3f) == 0 and ((1 << (_la - 264)) & 131) != 0):
                self.state = 779
                _la = self._input.LA(1)
                if not(((((_la - 264)) & ~0x3f) == 0 and ((1 << (_la - 264)) & 131) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 780
                self.genesteVoorwaarde()
                self.state = 785
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GenesteVoorwaardeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_genesteVoorwaarde

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGenesteVoorwaarde" ):
                listener.enterGenesteVoorwaarde(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGenesteVoorwaarde" ):
                listener.exitGenesteVoorwaarde(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGenesteVoorwaarde" ):
                return visitor.visitGenesteVoorwaarde(self)
            else:
                return visitor.visitChildren(self)




    def genesteVoorwaarde(self):

        localctx = RegelSpraakParser.GenesteVoorwaardeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 116, self.RULE_genesteVoorwaarde)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 786
            self.expressie()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VariabeleDeelContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DAARBIJ_GELDT(self):
            return self.getToken(RegelSpraakParser.DAARBIJ_GELDT, 0)

        def DOT(self):
            return self.getToken(RegelSpraakParser.DOT, 0)

        def variabeleToekenning(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.VariabeleToekenningContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.VariabeleToekenningContext,i)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_variabeleDeel

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVariabeleDeel" ):
                listener.enterVariabeleDeel(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVariabeleDeel" ):
                listener.exitVariabeleDeel(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVariabeleDeel" ):
                return visitor.visitVariabeleDeel(self)
            else:
                return visitor.visitChildren(self)




    def variabeleDeel(self):

        localctx = RegelSpraakParser.VariabeleDeelContext(self, self._ctx, self.state)
        self.enterRule(localctx, 118, self.RULE_variabeleDeel)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 788
            self.match(RegelSpraakParser.DAARBIJ_GELDT)
            self.state = 792
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==48 or _la==116 or _la==135 or ((((_la - 202)) & ~0x3f) == 0 and ((1 << (_la - 202)) & 35184372088865) != 0):
                self.state = 789
                self.variabeleToekenning()
                self.state = 794
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 795
            self.match(RegelSpraakParser.DOT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VariabeleToekenningContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def IS(self):
            return self.getToken(RegelSpraakParser.IS, 0)

        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)


        def SEMICOLON(self):
            return self.getToken(RegelSpraakParser.SEMICOLON, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_variabeleToekenning

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVariabeleToekenning" ):
                listener.enterVariabeleToekenning(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVariabeleToekenning" ):
                listener.exitVariabeleToekenning(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVariabeleToekenning" ):
                return visitor.visitVariabeleToekenning(self)
            else:
                return visitor.visitChildren(self)




    def variabeleToekenning(self):

        localctx = RegelSpraakParser.VariabeleToekenningContext(self, self._ctx, self.state)
        self.enterRule(localctx, 120, self.RULE_variabeleToekenning)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 797
            self.naamwoord()
            self.state = 798
            self.match(RegelSpraakParser.IS)
            self.state = 799
            self.expressie()
            self.state = 801
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==261:
                self.state = 800
                self.match(RegelSpraakParser.SEMICOLON)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExpressieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def logicalExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.LogicalExpressionContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_expressie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpressie" ):
                listener.enterExpressie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpressie" ):
                listener.exitExpressie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExpressie" ):
                return visitor.visitExpressie(self)
            else:
                return visitor.visitChildren(self)




    def expressie(self):

        localctx = RegelSpraakParser.ExpressieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 122, self.RULE_expressie)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 803
            self.logicalExpression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LogicalExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def comparisonExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.ComparisonExpressionContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_logicalExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLogicalExpression" ):
                listener.enterLogicalExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLogicalExpression" ):
                listener.exitLogicalExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLogicalExpression" ):
                return visitor.visitLogicalExpression(self)
            else:
                return visitor.visitChildren(self)




    def logicalExpression(self):

        localctx = RegelSpraakParser.LogicalExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 124, self.RULE_logicalExpression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 805
            self.comparisonExpression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ComparisonExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_comparisonExpression

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class BinaryComparisonExprContext(ComparisonExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.ComparisonExpressionContext
            super().__init__(parser)
            self.left = None # AdditiveExpressionContext
            self.right = None # AdditiveExpressionContext
            self.copyFrom(ctx)

        def additiveExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.AdditiveExpressionContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.AdditiveExpressionContext,i)

        def comparisonOperator(self):
            return self.getTypedRuleContext(RegelSpraakParser.ComparisonOperatorContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBinaryComparisonExpr" ):
                listener.enterBinaryComparisonExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBinaryComparisonExpr" ):
                listener.exitBinaryComparisonExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBinaryComparisonExpr" ):
                return visitor.visitBinaryComparisonExpr(self)
            else:
                return visitor.visitChildren(self)


    class UnaryConditionExprContext(ComparisonExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.ComparisonExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def unaryCondition(self):
            return self.getTypedRuleContext(RegelSpraakParser.UnaryConditionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnaryConditionExpr" ):
                listener.enterUnaryConditionExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnaryConditionExpr" ):
                listener.exitUnaryConditionExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnaryConditionExpr" ):
                return visitor.visitUnaryConditionExpr(self)
            else:
                return visitor.visitChildren(self)


    class HeeftKenmerkExprContext(ComparisonExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.ComparisonExpressionContext
            super().__init__(parser)
            self.left = None # AdditiveExpressionContext
            self.copyFrom(ctx)

        def HEEFT(self):
            return self.getToken(RegelSpraakParser.HEEFT, 0)
        def identifier(self):
            return self.getTypedRuleContext(RegelSpraakParser.IdentifierContext,0)

        def additiveExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.AdditiveExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterHeeftKenmerkExpr" ):
                listener.enterHeeftKenmerkExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitHeeftKenmerkExpr" ):
                listener.exitHeeftKenmerkExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitHeeftKenmerkExpr" ):
                return visitor.visitHeeftKenmerkExpr(self)
            else:
                return visitor.visitChildren(self)


    class IsKenmerkExprContext(ComparisonExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.ComparisonExpressionContext
            super().__init__(parser)
            self.left = None # AdditiveExpressionContext
            self.copyFrom(ctx)

        def IS(self):
            return self.getToken(RegelSpraakParser.IS, 0)
        def identifier(self):
            return self.getTypedRuleContext(RegelSpraakParser.IdentifierContext,0)

        def additiveExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.AdditiveExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIsKenmerkExpr" ):
                listener.enterIsKenmerkExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIsKenmerkExpr" ):
                listener.exitIsKenmerkExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIsKenmerkExpr" ):
                return visitor.visitIsKenmerkExpr(self)
            else:
                return visitor.visitChildren(self)


    class RegelStatusConditionExprContext(ComparisonExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.ComparisonExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def regelStatusCondition(self):
            return self.getTypedRuleContext(RegelSpraakParser.RegelStatusConditionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRegelStatusConditionExpr" ):
                listener.enterRegelStatusConditionExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRegelStatusConditionExpr" ):
                listener.exitRegelStatusConditionExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRegelStatusConditionExpr" ):
                return visitor.visitRegelStatusConditionExpr(self)
            else:
                return visitor.visitChildren(self)



    def comparisonExpression(self):

        localctx = RegelSpraakParser.ComparisonExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 126, self.RULE_comparisonExpression)
        try:
            self.state = 823
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,103,self._ctx)
            if la_ == 1:
                localctx = RegelSpraakParser.IsKenmerkExprContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 807
                localctx.left = self.additiveExpression()
                self.state = 808
                self.match(RegelSpraakParser.IS)
                self.state = 809
                self.identifier()
                pass

            elif la_ == 2:
                localctx = RegelSpraakParser.HeeftKenmerkExprContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 811
                localctx.left = self.additiveExpression()
                self.state = 812
                self.match(RegelSpraakParser.HEEFT)
                self.state = 813
                self.identifier()
                pass

            elif la_ == 3:
                localctx = RegelSpraakParser.BinaryComparisonExprContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 815
                localctx.left = self.additiveExpression()
                self.state = 819
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,102,self._ctx)
                if la_ == 1:
                    self.state = 816
                    self.comparisonOperator()
                    self.state = 817
                    localctx.right = self.additiveExpression()


                pass

            elif la_ == 4:
                localctx = RegelSpraakParser.UnaryConditionExprContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 821
                self.unaryCondition()
                pass

            elif la_ == 5:
                localctx = RegelSpraakParser.RegelStatusConditionExprContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 822
                self.regelStatusCondition()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ComparisonOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.GELIJK_AAN, 0)

        def ONGELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.ONGELIJK_AAN, 0)

        def GROTER_DAN(self):
            return self.getToken(RegelSpraakParser.GROTER_DAN, 0)

        def GROTER_OF_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.GROTER_OF_GELIJK_AAN, 0)

        def KLEINER_DAN(self):
            return self.getToken(RegelSpraakParser.KLEINER_DAN, 0)

        def KLEINER_OF_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.KLEINER_OF_GELIJK_AAN, 0)

        def KLEINER_IS_DAN(self):
            return self.getToken(RegelSpraakParser.KLEINER_IS_DAN, 0)

        def GROTER_IS_DAN(self):
            return self.getToken(RegelSpraakParser.GROTER_IS_DAN, 0)

        def IS(self):
            return self.getToken(RegelSpraakParser.IS, 0)

        def LATER_DAN(self):
            return self.getToken(RegelSpraakParser.LATER_DAN, 0)

        def LATER_OF_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.LATER_OF_GELIJK_AAN, 0)

        def EERDER_DAN(self):
            return self.getToken(RegelSpraakParser.EERDER_DAN, 0)

        def EERDER_OF_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.EERDER_OF_GELIJK_AAN, 0)

        def NIET(self):
            return self.getToken(RegelSpraakParser.NIET, 0)

        def IS_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.IS_GELIJK_AAN, 0)

        def IS_ONGELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.IS_ONGELIJK_AAN, 0)

        def IS_KLEINER_DAN(self):
            return self.getToken(RegelSpraakParser.IS_KLEINER_DAN, 0)

        def IS_KLEINER_OF_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.IS_KLEINER_OF_GELIJK_AAN, 0)

        def IS_GROTER_DAN(self):
            return self.getToken(RegelSpraakParser.IS_GROTER_DAN, 0)

        def IS_GROTER_OF_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.IS_GROTER_OF_GELIJK_AAN, 0)

        def ZIJN_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.ZIJN_GELIJK_AAN, 0)

        def ZIJN_ONGELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.ZIJN_ONGELIJK_AAN, 0)

        def ZIJN_KLEINER_DAN(self):
            return self.getToken(RegelSpraakParser.ZIJN_KLEINER_DAN, 0)

        def ZIJN_KLEINER_OF_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.ZIJN_KLEINER_OF_GELIJK_AAN, 0)

        def ZIJN_GROTER_DAN(self):
            return self.getToken(RegelSpraakParser.ZIJN_GROTER_DAN, 0)

        def ZIJN_GROTER_OF_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.ZIJN_GROTER_OF_GELIJK_AAN, 0)

        def IS_LATER_DAN(self):
            return self.getToken(RegelSpraakParser.IS_LATER_DAN, 0)

        def IS_LATER_OF_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.IS_LATER_OF_GELIJK_AAN, 0)

        def IS_EERDER_DAN(self):
            return self.getToken(RegelSpraakParser.IS_EERDER_DAN, 0)

        def IS_EERDER_OF_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.IS_EERDER_OF_GELIJK_AAN, 0)

        def ZIJN_LATER_DAN(self):
            return self.getToken(RegelSpraakParser.ZIJN_LATER_DAN, 0)

        def ZIJN_LATER_OF_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.ZIJN_LATER_OF_GELIJK_AAN, 0)

        def ZIJN_EERDER_DAN(self):
            return self.getToken(RegelSpraakParser.ZIJN_EERDER_DAN, 0)

        def ZIJN_EERDER_OF_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.ZIJN_EERDER_OF_GELIJK_AAN, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_comparisonOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterComparisonOperator" ):
                listener.enterComparisonOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitComparisonOperator" ):
                listener.exitComparisonOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitComparisonOperator" ):
                return visitor.visitComparisonOperator(self)
            else:
                return visitor.visitChildren(self)




    def comparisonOperator(self):

        localctx = RegelSpraakParser.ComparisonOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 128, self.RULE_comparisonOperator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 825
            _la = self._input.LA(1)
            if not(((((_la - 25)) & ~0x3f) == 0 and ((1 << (_la - 25)) & 35184338731023) != 0) or ((((_la - 112)) & ~0x3f) == 0 and ((1 << (_la - 112)) & 25381121) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AdditiveExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.left = None # MultiplicativeExpressionContext
            self.right = None # MultiplicativeExpressionContext

        def multiplicativeExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.MultiplicativeExpressionContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.MultiplicativeExpressionContext,i)


        def additiveOperator(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.AdditiveOperatorContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.AdditiveOperatorContext,i)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_additiveExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAdditiveExpression" ):
                listener.enterAdditiveExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAdditiveExpression" ):
                listener.exitAdditiveExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAdditiveExpression" ):
                return visitor.visitAdditiveExpression(self)
            else:
                return visitor.visitChildren(self)




    def additiveExpression(self):

        localctx = RegelSpraakParser.AdditiveExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 130, self.RULE_additiveExpression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 827
            localctx.left = self.multiplicativeExpression()
            self.state = 833
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,104,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 828
                    self.additiveOperator()
                    self.state = 829
                    localctx.right = self.multiplicativeExpression() 
                self.state = 835
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,104,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AdditiveOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PLUS(self):
            return self.getToken(RegelSpraakParser.PLUS, 0)

        def MIN(self):
            return self.getToken(RegelSpraakParser.MIN, 0)

        def VERMINDERD_MET(self):
            return self.getToken(RegelSpraakParser.VERMINDERD_MET, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_additiveOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAdditiveOperator" ):
                listener.enterAdditiveOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAdditiveOperator" ):
                listener.exitAdditiveOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAdditiveOperator" ):
                return visitor.visitAdditiveOperator(self)
            else:
                return visitor.visitChildren(self)




    def additiveOperator(self):

        localctx = RegelSpraakParser.AdditiveOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 132, self.RULE_additiveOperator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 836
            _la = self._input.LA(1)
            if not(((((_la - 132)) & ~0x3f) == 0 and ((1 << (_la - 132)) & 16417) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MultiplicativeExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.left = None # PowerExpressionContext
            self.right = None # PowerExpressionContext

        def powerExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.PowerExpressionContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.PowerExpressionContext,i)


        def multiplicativeOperator(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.MultiplicativeOperatorContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.MultiplicativeOperatorContext,i)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_multiplicativeExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMultiplicativeExpression" ):
                listener.enterMultiplicativeExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMultiplicativeExpression" ):
                listener.exitMultiplicativeExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMultiplicativeExpression" ):
                return visitor.visitMultiplicativeExpression(self)
            else:
                return visitor.visitChildren(self)




    def multiplicativeExpression(self):

        localctx = RegelSpraakParser.MultiplicativeExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 134, self.RULE_multiplicativeExpression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 838
            localctx.left = self.powerExpression()
            self.state = 844
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,105,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 839
                    self.multiplicativeOperator()
                    self.state = 840
                    localctx.right = self.powerExpression() 
                self.state = 846
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,105,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MultiplicativeOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MAAL(self):
            return self.getToken(RegelSpraakParser.MAAL, 0)

        def GEDEELD_DOOR(self):
            return self.getToken(RegelSpraakParser.GEDEELD_DOOR, 0)

        def GEDEELD_DOOR_ABS(self):
            return self.getToken(RegelSpraakParser.GEDEELD_DOOR_ABS, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_multiplicativeOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMultiplicativeOperator" ):
                listener.enterMultiplicativeOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMultiplicativeOperator" ):
                listener.exitMultiplicativeOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMultiplicativeOperator" ):
                return visitor.visitMultiplicativeOperator(self)
            else:
                return visitor.visitChildren(self)




    def multiplicativeOperator(self):

        localctx = RegelSpraakParser.MultiplicativeOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 136, self.RULE_multiplicativeOperator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 847
            _la = self._input.LA(1)
            if not(((((_la - 121)) & ~0x3f) == 0 and ((1 << (_la - 121)) & 1027) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PowerExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.left = None # PrimaryExpressionContext
            self.right = None # PrimaryExpressionContext

        def primaryExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.PrimaryExpressionContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,i)


        def powerOperator(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.PowerOperatorContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.PowerOperatorContext,i)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_powerExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPowerExpression" ):
                listener.enterPowerExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPowerExpression" ):
                listener.exitPowerExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPowerExpression" ):
                return visitor.visitPowerExpression(self)
            else:
                return visitor.visitChildren(self)




    def powerExpression(self):

        localctx = RegelSpraakParser.PowerExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 138, self.RULE_powerExpression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 849
            localctx.left = self.primaryExpression(0)
            self.state = 855
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,106,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 850
                    self.powerOperator()
                    self.state = 851
                    localctx.right = self.primaryExpression(0) 
                self.state = 857
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,106,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PowerOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TOT_DE_MACHT(self):
            return self.getToken(RegelSpraakParser.TOT_DE_MACHT, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_powerOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPowerOperator" ):
                listener.enterPowerOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPowerOperator" ):
                listener.exitPowerOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPowerOperator" ):
                return visitor.visitPowerOperator(self)
            else:
                return visitor.visitChildren(self)




    def powerOperator(self):

        localctx = RegelSpraakParser.PowerOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 140, self.RULE_powerOperator)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 858
            self.match(RegelSpraakParser.TOT_DE_MACHT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PrimaryExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_primaryExpression

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)


    class WortelFuncExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def DE_WORTEL_VAN(self):
            return self.getToken(RegelSpraakParser.DE_WORTEL_VAN, 0)
        def primaryExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWortelFuncExpr" ):
                listener.enterWortelFuncExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWortelFuncExpr" ):
                listener.exitWortelFuncExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitWortelFuncExpr" ):
                return visitor.visitWortelFuncExpr(self)
            else:
                return visitor.visitChildren(self)


    class BooleanTrueLiteralExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def WAAR(self):
            return self.getToken(RegelSpraakParser.WAAR, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBooleanTrueLiteralExpr" ):
                listener.enterBooleanTrueLiteralExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBooleanTrueLiteralExpr" ):
                listener.exitBooleanTrueLiteralExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBooleanTrueLiteralExpr" ):
                return visitor.visitBooleanTrueLiteralExpr(self)
            else:
                return visitor.visitChildren(self)


    class DatumMetFuncExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def DE_DATUM_MET(self):
            return self.getToken(RegelSpraakParser.DE_DATUM_MET, 0)
        def LPAREN(self):
            return self.getToken(RegelSpraakParser.LPAREN, 0)
        def primaryExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.PrimaryExpressionContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,i)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.COMMA)
            else:
                return self.getToken(RegelSpraakParser.COMMA, i)
        def RPAREN(self):
            return self.getToken(RegelSpraakParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDatumMetFuncExpr" ):
                listener.enterDatumMetFuncExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDatumMetFuncExpr" ):
                listener.exitDatumMetFuncExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDatumMetFuncExpr" ):
                return visitor.visitDatumMetFuncExpr(self)
            else:
                return visitor.visitChildren(self)


    class StringLiteralExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def STRING_LITERAL(self):
            return self.getToken(RegelSpraakParser.STRING_LITERAL, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStringLiteralExpr" ):
                listener.enterStringLiteralExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStringLiteralExpr" ):
                listener.exitStringLiteralExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStringLiteralExpr" ):
                return visitor.visitStringLiteralExpr(self)
            else:
                return visitor.visitChildren(self)


    class AbsValFuncExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def DE_ABSOLUTE_WAARDE_VAN(self):
            return self.getToken(RegelSpraakParser.DE_ABSOLUTE_WAARDE_VAN, 0)
        def LPAREN(self):
            return self.getToken(RegelSpraakParser.LPAREN, 0)
        def primaryExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,0)

        def RPAREN(self):
            return self.getToken(RegelSpraakParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAbsValFuncExpr" ):
                listener.enterAbsValFuncExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAbsValFuncExpr" ):
                listener.exitAbsValFuncExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAbsValFuncExpr" ):
                return visitor.visitAbsValFuncExpr(self)
            else:
                return visitor.visitChildren(self)


    class MaxValFuncExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def DE_MAXIMALE_WAARDE_VAN(self):
            return self.getToken(RegelSpraakParser.DE_MAXIMALE_WAARDE_VAN, 0)
        def primaryExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.PrimaryExpressionContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,i)

        def EN(self):
            return self.getToken(RegelSpraakParser.EN, 0)
        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.COMMA)
            else:
                return self.getToken(RegelSpraakParser.COMMA, i)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMaxValFuncExpr" ):
                listener.enterMaxValFuncExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMaxValFuncExpr" ):
                listener.exitMaxValFuncExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMaxValFuncExpr" ):
                return visitor.visitMaxValFuncExpr(self)
            else:
                return visitor.visitChildren(self)


    class RekendatumKeywordExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def REKENDATUM(self):
            return self.getToken(RegelSpraakParser.REKENDATUM, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRekendatumKeywordExpr" ):
                listener.enterRekendatumKeywordExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRekendatumKeywordExpr" ):
                listener.exitRekendatumKeywordExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRekendatumKeywordExpr" ):
                return visitor.visitRekendatumKeywordExpr(self)
            else:
                return visitor.visitChildren(self)


    class PercentageFuncExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.p = None # Token
            self.copyFrom(ctx)

        def NUMBER(self):
            return self.getToken(RegelSpraakParser.NUMBER, 0)
        def VAN(self):
            return self.getToken(RegelSpraakParser.VAN, 0)
        def primaryExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,0)

        def PERCENT_SIGN(self):
            return self.getToken(RegelSpraakParser.PERCENT_SIGN, 0)
        def IDENTIFIER(self):
            return self.getToken(RegelSpraakParser.IDENTIFIER, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPercentageFuncExpr" ):
                listener.enterPercentageFuncExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPercentageFuncExpr" ):
                listener.exitPercentageFuncExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPercentageFuncExpr" ):
                return visitor.visitPercentageFuncExpr(self)
            else:
                return visitor.visitChildren(self)


    class EersteDatumFuncExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def EERSTE_VAN(self):
            return self.getToken(RegelSpraakParser.EERSTE_VAN, 0)
        def primaryExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.PrimaryExpressionContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,i)

        def EN(self):
            return self.getToken(RegelSpraakParser.EN, 0)
        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.COMMA)
            else:
                return self.getToken(RegelSpraakParser.COMMA, i)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEersteDatumFuncExpr" ):
                listener.enterEersteDatumFuncExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEersteDatumFuncExpr" ):
                listener.exitEersteDatumFuncExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEersteDatumFuncExpr" ):
                return visitor.visitEersteDatumFuncExpr(self)
            else:
                return visitor.visitChildren(self)


    class PasenFuncExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def DE_EERSTE_PAASDAG_VAN(self):
            return self.getToken(RegelSpraakParser.DE_EERSTE_PAASDAG_VAN, 0)
        def LPAREN(self):
            return self.getToken(RegelSpraakParser.LPAREN, 0)
        def primaryExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,0)

        def RPAREN(self):
            return self.getToken(RegelSpraakParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPasenFuncExpr" ):
                listener.enterPasenFuncExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPasenFuncExpr" ):
                listener.exitPasenFuncExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPasenFuncExpr" ):
                return visitor.visitPasenFuncExpr(self)
            else:
                return visitor.visitChildren(self)


    class EnumLiteralExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ENUM_LITERAL(self):
            return self.getToken(RegelSpraakParser.ENUM_LITERAL, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEnumLiteralExpr" ):
                listener.enterEnumLiteralExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEnumLiteralExpr" ):
                listener.exitEnumLiteralExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEnumLiteralExpr" ):
                return visitor.visitEnumLiteralExpr(self)
            else:
                return visitor.visitChildren(self)


    class NumberLiteralExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def NUMBER(self):
            return self.getToken(RegelSpraakParser.NUMBER, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumberLiteralExpr" ):
                listener.enterNumberLiteralExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumberLiteralExpr" ):
                listener.exitNumberLiteralExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNumberLiteralExpr" ):
                return visitor.visitNumberLiteralExpr(self)
            else:
                return visitor.visitChildren(self)


    class AbsTijdsduurFuncExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.unitName = None # Token
            self.copyFrom(ctx)

        def DE_ABSOLUTE_TIJDSDUUR_VAN(self):
            return self.getToken(RegelSpraakParser.DE_ABSOLUTE_TIJDSDUUR_VAN, 0)
        def primaryExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.PrimaryExpressionContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,i)

        def TOT(self):
            return self.getToken(RegelSpraakParser.TOT, 0)
        def IN_HELE(self):
            return self.getToken(RegelSpraakParser.IN_HELE, 0)
        def IDENTIFIER(self):
            return self.getToken(RegelSpraakParser.IDENTIFIER, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAbsTijdsduurFuncExpr" ):
                listener.enterAbsTijdsduurFuncExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAbsTijdsduurFuncExpr" ):
                listener.exitAbsTijdsduurFuncExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAbsTijdsduurFuncExpr" ):
                return visitor.visitAbsTijdsduurFuncExpr(self)
            else:
                return visitor.visitChildren(self)


    class MaandUitFuncExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def DE(self):
            return self.getToken(RegelSpraakParser.DE, 0)
        def MAAND(self):
            return self.getToken(RegelSpraakParser.MAAND, 0)
        def UIT(self):
            return self.getToken(RegelSpraakParser.UIT, 0)
        def primaryExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMaandUitFuncExpr" ):
                listener.enterMaandUitFuncExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMaandUitFuncExpr" ):
                listener.exitMaandUitFuncExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMaandUitFuncExpr" ):
                return visitor.visitMaandUitFuncExpr(self)
            else:
                return visitor.visitChildren(self)


    class CapitalizedTotaalVanExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.condition = None # ExpressieContext
            self.copyFrom(ctx)

        def HET_TOTAAL_VAN(self):
            return self.getToken(RegelSpraakParser.HET_TOTAAL_VAN, 0)
        def expressie(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.ExpressieContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,i)

        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.IdentifierContext,i)

        def GEDURENDE_DE_TIJD_DAT(self):
            return self.getToken(RegelSpraakParser.GEDURENDE_DE_TIJD_DAT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCapitalizedTotaalVanExpr" ):
                listener.enterCapitalizedTotaalVanExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCapitalizedTotaalVanExpr" ):
                listener.exitCapitalizedTotaalVanExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCapitalizedTotaalVanExpr" ):
                return visitor.visitCapitalizedTotaalVanExpr(self)
            else:
                return visitor.visitChildren(self)


    class IdentifierExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(RegelSpraakParser.IdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIdentifierExpr" ):
                listener.enterIdentifierExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIdentifierExpr" ):
                listener.exitIdentifierExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIdentifierExpr" ):
                return visitor.visitIdentifierExpr(self)
            else:
                return visitor.visitChildren(self)


    class DatumLiteralExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def datumLiteral(self):
            return self.getTypedRuleContext(RegelSpraakParser.DatumLiteralContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDatumLiteralExpr" ):
                listener.enterDatumLiteralExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDatumLiteralExpr" ):
                listener.exitDatumLiteralExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDatumLiteralExpr" ):
                return visitor.visitDatumLiteralExpr(self)
            else:
                return visitor.visitChildren(self)


    class DimensieAggExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def attribuutReferentie(self):
            return self.getTypedRuleContext(RegelSpraakParser.AttribuutReferentieContext,0)

        def dimensieSelectie(self):
            return self.getTypedRuleContext(RegelSpraakParser.DimensieSelectieContext,0)

        def getalAggregatieFunctie(self):
            return self.getTypedRuleContext(RegelSpraakParser.GetalAggregatieFunctieContext,0)

        def datumAggregatieFunctie(self):
            return self.getTypedRuleContext(RegelSpraakParser.DatumAggregatieFunctieContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDimensieAggExpr" ):
                listener.enterDimensieAggExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDimensieAggExpr" ):
                listener.exitDimensieAggExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDimensieAggExpr" ):
                return visitor.visitDimensieAggExpr(self)
            else:
                return visitor.visitChildren(self)


    class TijdsduurFuncExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.unitName = None # Token
            self.copyFrom(ctx)

        def TIJDSDUUR_VAN(self):
            return self.getToken(RegelSpraakParser.TIJDSDUUR_VAN, 0)
        def primaryExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.PrimaryExpressionContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,i)

        def TOT(self):
            return self.getToken(RegelSpraakParser.TOT, 0)
        def IN_HELE(self):
            return self.getToken(RegelSpraakParser.IN_HELE, 0)
        def IDENTIFIER(self):
            return self.getToken(RegelSpraakParser.IDENTIFIER, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTijdsduurFuncExpr" ):
                listener.enterTijdsduurFuncExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTijdsduurFuncExpr" ):
                listener.exitTijdsduurFuncExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTijdsduurFuncExpr" ):
                return visitor.visitTijdsduurFuncExpr(self)
            else:
                return visitor.visitChildren(self)


    class AantalFuncExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def AANTAL(self):
            return self.getToken(RegelSpraakParser.AANTAL, 0)
        def onderwerpReferentie(self):
            return self.getTypedRuleContext(RegelSpraakParser.OnderwerpReferentieContext,0)

        def HET(self):
            return self.getToken(RegelSpraakParser.HET, 0)
        def ALLE(self):
            return self.getToken(RegelSpraakParser.ALLE, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAantalFuncExpr" ):
                listener.enterAantalFuncExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAantalFuncExpr" ):
                listener.exitAantalFuncExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAantalFuncExpr" ):
                return visitor.visitAantalFuncExpr(self)
            else:
                return visitor.visitChildren(self)


    class UnaryNietExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def NIET(self):
            return self.getToken(RegelSpraakParser.NIET, 0)
        def primaryExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnaryNietExpr" ):
                listener.enterUnaryNietExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnaryNietExpr" ):
                listener.exitUnaryNietExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnaryNietExpr" ):
                return visitor.visitUnaryNietExpr(self)
            else:
                return visitor.visitChildren(self)


    class ConcatenatieExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def CONCATENATIE_VAN(self):
            return self.getToken(RegelSpraakParser.CONCATENATIE_VAN, 0)
        def primaryExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.PrimaryExpressionContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,i)

        def EN(self):
            return self.getToken(RegelSpraakParser.EN, 0)
        def OF(self):
            return self.getToken(RegelSpraakParser.OF, 0)
        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.COMMA)
            else:
                return self.getToken(RegelSpraakParser.COMMA, i)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConcatenatieExpr" ):
                listener.enterConcatenatieExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConcatenatieExpr" ):
                listener.exitConcatenatieExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConcatenatieExpr" ):
                return visitor.visitConcatenatieExpr(self)
            else:
                return visitor.visitChildren(self)


    class OnderwerpRefExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def onderwerpReferentie(self):
            return self.getTypedRuleContext(RegelSpraakParser.OnderwerpReferentieContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOnderwerpRefExpr" ):
                listener.enterOnderwerpRefExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOnderwerpRefExpr" ):
                listener.exitOnderwerpRefExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOnderwerpRefExpr" ):
                return visitor.visitOnderwerpRefExpr(self)
            else:
                return visitor.visitChildren(self)


    class SomFuncExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def SOM_VAN(self):
            return self.getToken(RegelSpraakParser.SOM_VAN, 0)
        def onderwerpReferentie(self):
            return self.getTypedRuleContext(RegelSpraakParser.OnderwerpReferentieContext,0)

        def ALLE(self):
            return self.getToken(RegelSpraakParser.ALLE, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSomFuncExpr" ):
                listener.enterSomFuncExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSomFuncExpr" ):
                listener.exitSomFuncExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSomFuncExpr" ):
                return visitor.visitSomFuncExpr(self)
            else:
                return visitor.visitChildren(self)


    class AttrRefExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def attribuutReferentie(self):
            return self.getTypedRuleContext(RegelSpraakParser.AttribuutReferentieContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAttrRefExpr" ):
                listener.enterAttrRefExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAttrRefExpr" ):
                listener.exitAttrRefExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAttrRefExpr" ):
                return visitor.visitAttrRefExpr(self)
            else:
                return visitor.visitChildren(self)


    class DagUitFuncExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def DE(self):
            return self.getToken(RegelSpraakParser.DE, 0)
        def DAG(self):
            return self.getToken(RegelSpraakParser.DAG, 0)
        def UIT(self):
            return self.getToken(RegelSpraakParser.UIT, 0)
        def primaryExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDagUitFuncExpr" ):
                listener.enterDagUitFuncExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDagUitFuncExpr" ):
                listener.exitDagUitFuncExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDagUitFuncExpr" ):
                return visitor.visitDagUitFuncExpr(self)
            else:
                return visitor.visitChildren(self)


    class SimpleConcatenatieExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def primaryExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.PrimaryExpressionContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,i)

        def EN(self):
            return self.getToken(RegelSpraakParser.EN, 0)
        def OF(self):
            return self.getToken(RegelSpraakParser.OF, 0)
        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.COMMA)
            else:
                return self.getToken(RegelSpraakParser.COMMA, i)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSimpleConcatenatieExpr" ):
                listener.enterSimpleConcatenatieExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSimpleConcatenatieExpr" ):
                listener.exitSimpleConcatenatieExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSimpleConcatenatieExpr" ):
                return visitor.visitSimpleConcatenatieExpr(self)
            else:
                return visitor.visitChildren(self)


    class BegrenzingExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def primaryExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,0)

        def COMMA(self):
            return self.getToken(RegelSpraakParser.COMMA, 0)
        def begrenzing(self):
            return self.getTypedRuleContext(RegelSpraakParser.BegrenzingContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBegrenzingExpr" ):
                listener.enterBegrenzingExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBegrenzingExpr" ):
                listener.exitBegrenzingExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBegrenzingExpr" ):
                return visitor.visitBegrenzingExpr(self)
            else:
                return visitor.visitChildren(self)


    class NaamwoordExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNaamwoordExpr" ):
                listener.enterNaamwoordExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNaamwoordExpr" ):
                listener.exitNaamwoordExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNaamwoordExpr" ):
                return visitor.visitNaamwoordExpr(self)
            else:
                return visitor.visitChildren(self)


    class BooleanFalseLiteralExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ONWAAR(self):
            return self.getToken(RegelSpraakParser.ONWAAR, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBooleanFalseLiteralExpr" ):
                listener.enterBooleanFalseLiteralExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBooleanFalseLiteralExpr" ):
                listener.exitBooleanFalseLiteralExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBooleanFalseLiteralExpr" ):
                return visitor.visitBooleanFalseLiteralExpr(self)
            else:
                return visitor.visitChildren(self)


    class MinValFuncExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def DE_MINIMALE_WAARDE_VAN(self):
            return self.getToken(RegelSpraakParser.DE_MINIMALE_WAARDE_VAN, 0)
        def primaryExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.PrimaryExpressionContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,i)

        def EN(self):
            return self.getToken(RegelSpraakParser.EN, 0)
        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.COMMA)
            else:
                return self.getToken(RegelSpraakParser.COMMA, i)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMinValFuncExpr" ):
                listener.enterMinValFuncExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMinValFuncExpr" ):
                listener.exitMinValFuncExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMinValFuncExpr" ):
                return visitor.visitMinValFuncExpr(self)
            else:
                return visitor.visitChildren(self)


    class JaarUitFuncExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def HET(self):
            return self.getToken(RegelSpraakParser.HET, 0)
        def JAAR(self):
            return self.getToken(RegelSpraakParser.JAAR, 0)
        def UIT(self):
            return self.getToken(RegelSpraakParser.UIT, 0)
        def primaryExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterJaarUitFuncExpr" ):
                listener.enterJaarUitFuncExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitJaarUitFuncExpr" ):
                listener.exitJaarUitFuncExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitJaarUitFuncExpr" ):
                return visitor.visitJaarUitFuncExpr(self)
            else:
                return visitor.visitChildren(self)


    class BezieldeRefExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def bezieldeReferentie(self):
            return self.getTypedRuleContext(RegelSpraakParser.BezieldeReferentieContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBezieldeRefExpr" ):
                listener.enterBezieldeRefExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBezieldeRefExpr" ):
                listener.exitBezieldeRefExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBezieldeRefExpr" ):
                return visitor.visitBezieldeRefExpr(self)
            else:
                return visitor.visitChildren(self)


    class DateCalcExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def primaryExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.PrimaryExpressionContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,i)

        def identifier(self):
            return self.getTypedRuleContext(RegelSpraakParser.IdentifierContext,0)

        def PLUS(self):
            return self.getToken(RegelSpraakParser.PLUS, 0)
        def MIN(self):
            return self.getToken(RegelSpraakParser.MIN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDateCalcExpr" ):
                listener.enterDateCalcExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDateCalcExpr" ):
                listener.exitDateCalcExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDateCalcExpr" ):
                return visitor.visitDateCalcExpr(self)
            else:
                return visitor.visitChildren(self)


    class TotaalVanExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.condition = None # ExpressieContext
            self.copyFrom(ctx)

        def HET_TOTAAL_VAN(self):
            return self.getToken(RegelSpraakParser.HET_TOTAAL_VAN, 0)
        def expressie(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.ExpressieContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,i)

        def GEDURENDE_DE_TIJD_DAT(self):
            return self.getToken(RegelSpraakParser.GEDURENDE_DE_TIJD_DAT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTotaalVanExpr" ):
                listener.enterTotaalVanExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTotaalVanExpr" ):
                listener.exitTotaalVanExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTotaalVanExpr" ):
                return visitor.visitTotaalVanExpr(self)
            else:
                return visitor.visitChildren(self)


    class AfrondingExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def primaryExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,0)

        def afronding(self):
            return self.getTypedRuleContext(RegelSpraakParser.AfrondingContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAfrondingExpr" ):
                listener.enterAfrondingExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAfrondingExpr" ):
                listener.exitAfrondingExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAfrondingExpr" ):
                return visitor.visitAfrondingExpr(self)
            else:
                return visitor.visitChildren(self)


    class LaatsteDatumFuncExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LAATSTE_VAN(self):
            return self.getToken(RegelSpraakParser.LAATSTE_VAN, 0)
        def primaryExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.PrimaryExpressionContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,i)

        def EN(self):
            return self.getToken(RegelSpraakParser.EN, 0)
        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.COMMA)
            else:
                return self.getToken(RegelSpraakParser.COMMA, i)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLaatsteDatumFuncExpr" ):
                listener.enterLaatsteDatumFuncExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLaatsteDatumFuncExpr" ):
                listener.exitLaatsteDatumFuncExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLaatsteDatumFuncExpr" ):
                return visitor.visitLaatsteDatumFuncExpr(self)
            else:
                return visitor.visitChildren(self)


    class HetAantalDagenInExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def HET_AANTAL_DAGEN_IN(self):
            return self.getToken(RegelSpraakParser.HET_AANTAL_DAGEN_IN, 0)
        def DAT(self):
            return self.getToken(RegelSpraakParser.DAT, 0)
        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)

        def DE(self):
            return self.getToken(RegelSpraakParser.DE, 0)
        def MAAND(self):
            return self.getToken(RegelSpraakParser.MAAND, 0)
        def HET(self):
            return self.getToken(RegelSpraakParser.HET, 0)
        def JAAR(self):
            return self.getToken(RegelSpraakParser.JAAR, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterHetAantalDagenInExpr" ):
                listener.enterHetAantalDagenInExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitHetAantalDagenInExpr" ):
                listener.exitHetAantalDagenInExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitHetAantalDagenInExpr" ):
                return visitor.visitHetAantalDagenInExpr(self)
            else:
                return visitor.visitChildren(self)


    class TijdsevenredigDeelExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.condition = None # ExpressieContext
            self.copyFrom(ctx)

        def HET_TIJDSEVENREDIG_DEEL_PER(self):
            return self.getToken(RegelSpraakParser.HET_TIJDSEVENREDIG_DEEL_PER, 0)
        def VAN(self):
            return self.getToken(RegelSpraakParser.VAN, 0)
        def expressie(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.ExpressieContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,i)

        def MAAND(self):
            return self.getToken(RegelSpraakParser.MAAND, 0)
        def JAAR(self):
            return self.getToken(RegelSpraakParser.JAAR, 0)
        def GEDURENDE_DE_TIJD_DAT(self):
            return self.getToken(RegelSpraakParser.GEDURENDE_DE_TIJD_DAT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTijdsevenredigDeelExpr" ):
                listener.enterTijdsevenredigDeelExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTijdsevenredigDeelExpr" ):
                listener.exitTijdsevenredigDeelExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTijdsevenredigDeelExpr" ):
                return visitor.visitTijdsevenredigDeelExpr(self)
            else:
                return visitor.visitChildren(self)


    class CapitalizedTijdsevenredigDeelExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.condition = None # ExpressieContext
            self.copyFrom(ctx)

        def HET_TIJDSEVENREDIG_DEEL_PER(self):
            return self.getToken(RegelSpraakParser.HET_TIJDSEVENREDIG_DEEL_PER, 0)
        def VAN(self):
            return self.getToken(RegelSpraakParser.VAN, 0)
        def expressie(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.ExpressieContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,i)

        def MAAND(self):
            return self.getToken(RegelSpraakParser.MAAND, 0)
        def JAAR(self):
            return self.getToken(RegelSpraakParser.JAAR, 0)
        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.IdentifierContext,i)

        def GEDURENDE_DE_TIJD_DAT(self):
            return self.getToken(RegelSpraakParser.GEDURENDE_DE_TIJD_DAT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCapitalizedTijdsevenredigDeelExpr" ):
                listener.enterCapitalizedTijdsevenredigDeelExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCapitalizedTijdsevenredigDeelExpr" ):
                listener.exitCapitalizedTijdsevenredigDeelExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCapitalizedTijdsevenredigDeelExpr" ):
                return visitor.visitCapitalizedTijdsevenredigDeelExpr(self)
            else:
                return visitor.visitChildren(self)


    class ParenExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(RegelSpraakParser.LPAREN, 0)
        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)

        def RPAREN(self):
            return self.getToken(RegelSpraakParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParenExpr" ):
                listener.enterParenExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParenExpr" ):
                listener.exitParenExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParenExpr" ):
                return visitor.visitParenExpr(self)
            else:
                return visitor.visitChildren(self)


    class UnaryMinusExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def MIN(self):
            return self.getToken(RegelSpraakParser.MIN, 0)
        def primaryExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnaryMinusExpr" ):
                listener.enterUnaryMinusExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnaryMinusExpr" ):
                listener.exitUnaryMinusExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnaryMinusExpr" ):
                return visitor.visitUnaryMinusExpr(self)
            else:
                return visitor.visitChildren(self)


    class ParamRefExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def parameterMetLidwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.ParameterMetLidwoordContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParamRefExpr" ):
                listener.enterParamRefExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParamRefExpr" ):
                listener.exitParamRefExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParamRefExpr" ):
                return visitor.visitParamRefExpr(self)
            else:
                return visitor.visitChildren(self)


    class PronounExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def HIJ(self):
            return self.getToken(RegelSpraakParser.HIJ, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPronounExpr" ):
                listener.enterPronounExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPronounExpr" ):
                listener.exitPronounExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPronounExpr" ):
                return visitor.visitPronounExpr(self)
            else:
                return visitor.visitChildren(self)



    def primaryExpression(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = RegelSpraakParser.PrimaryExpressionContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 142
        self.enterRecursionRule(localctx, 142, self.RULE_primaryExpression, _p)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1066
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,126,self._ctx)
            if la_ == 1:
                localctx = RegelSpraakParser.UnaryMinusExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx

                self.state = 861
                self.match(RegelSpraakParser.MIN)
                self.state = 862
                self.primaryExpression(44)
                pass

            elif la_ == 2:
                localctx = RegelSpraakParser.UnaryNietExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 863
                self.match(RegelSpraakParser.NIET)
                self.state = 864
                self.primaryExpression(43)
                pass

            elif la_ == 3:
                localctx = RegelSpraakParser.AbsTijdsduurFuncExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 865
                self.match(RegelSpraakParser.DE_ABSOLUTE_TIJDSDUUR_VAN)
                self.state = 866
                self.primaryExpression(0)
                self.state = 867
                self.match(RegelSpraakParser.TOT)
                self.state = 868
                self.primaryExpression(0)
                self.state = 871
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,107,self._ctx)
                if la_ == 1:
                    self.state = 869
                    self.match(RegelSpraakParser.IN_HELE)
                    self.state = 870
                    localctx.unitName = self.match(RegelSpraakParser.IDENTIFIER)


                pass

            elif la_ == 4:
                localctx = RegelSpraakParser.TijdsduurFuncExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 873
                self.match(RegelSpraakParser.TIJDSDUUR_VAN)
                self.state = 874
                self.primaryExpression(0)
                self.state = 875
                self.match(RegelSpraakParser.TOT)
                self.state = 876
                self.primaryExpression(0)
                self.state = 879
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,108,self._ctx)
                if la_ == 1:
                    self.state = 877
                    self.match(RegelSpraakParser.IN_HELE)
                    self.state = 878
                    localctx.unitName = self.match(RegelSpraakParser.IDENTIFIER)


                pass

            elif la_ == 5:
                localctx = RegelSpraakParser.SomFuncExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 881
                self.match(RegelSpraakParser.SOM_VAN)

                self.state = 883
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==119:
                    self.state = 882
                    self.match(RegelSpraakParser.ALLE)


                self.state = 885
                self.onderwerpReferentie()
                pass

            elif la_ == 6:
                localctx = RegelSpraakParser.AantalFuncExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 887
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==207:
                    self.state = 886
                    self.match(RegelSpraakParser.HET)


                self.state = 889
                self.match(RegelSpraakParser.AANTAL)

                self.state = 891
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==119:
                    self.state = 890
                    self.match(RegelSpraakParser.ALLE)


                self.state = 893
                self.onderwerpReferentie()
                pass

            elif la_ == 7:
                localctx = RegelSpraakParser.PercentageFuncExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 894
                self.match(RegelSpraakParser.NUMBER)
                self.state = 897
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [263]:
                    self.state = 895
                    self.match(RegelSpraakParser.PERCENT_SIGN)
                    pass
                elif token in [247]:
                    self.state = 896
                    localctx.p = self.match(RegelSpraakParser.IDENTIFIER)
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 899
                self.match(RegelSpraakParser.VAN)
                self.state = 900
                self.primaryExpression(38)
                pass

            elif la_ == 8:
                localctx = RegelSpraakParser.ConcatenatieExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 901
                self.match(RegelSpraakParser.CONCATENATIE_VAN)
                self.state = 902
                self.primaryExpression(0)
                self.state = 907
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==258:
                    self.state = 903
                    self.match(RegelSpraakParser.COMMA)
                    self.state = 904
                    self.primaryExpression(0)
                    self.state = 909
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 910
                _la = self._input.LA(1)
                if not(_la==206 or _la==215):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 911
                self.primaryExpression(35)
                pass

            elif la_ == 9:
                localctx = RegelSpraakParser.WortelFuncExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 913
                self.match(RegelSpraakParser.DE_WORTEL_VAN)
                self.state = 914
                self.primaryExpression(33)
                pass

            elif la_ == 10:
                localctx = RegelSpraakParser.AbsValFuncExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 915
                self.match(RegelSpraakParser.DE_ABSOLUTE_WAARDE_VAN)
                self.state = 916
                self.match(RegelSpraakParser.LPAREN)
                self.state = 917
                self.primaryExpression(0)
                self.state = 918
                self.match(RegelSpraakParser.RPAREN)
                pass

            elif la_ == 11:
                localctx = RegelSpraakParser.MinValFuncExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 920
                self.match(RegelSpraakParser.DE_MINIMALE_WAARDE_VAN)
                self.state = 921
                self.primaryExpression(0)
                self.state = 926
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==258:
                    self.state = 922
                    self.match(RegelSpraakParser.COMMA)
                    self.state = 923
                    self.primaryExpression(0)
                    self.state = 928
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 929
                self.match(RegelSpraakParser.EN)
                self.state = 930
                self.primaryExpression(31)
                pass

            elif la_ == 12:
                localctx = RegelSpraakParser.MaxValFuncExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 932
                self.match(RegelSpraakParser.DE_MAXIMALE_WAARDE_VAN)
                self.state = 933
                self.primaryExpression(0)
                self.state = 938
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==258:
                    self.state = 934
                    self.match(RegelSpraakParser.COMMA)
                    self.state = 935
                    self.primaryExpression(0)
                    self.state = 940
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 941
                self.match(RegelSpraakParser.EN)
                self.state = 942
                self.primaryExpression(30)
                pass

            elif la_ == 13:
                localctx = RegelSpraakParser.JaarUitFuncExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 944
                self.match(RegelSpraakParser.HET)
                self.state = 945
                self.match(RegelSpraakParser.JAAR)
                self.state = 946
                self.match(RegelSpraakParser.UIT)
                self.state = 947
                self.primaryExpression(29)
                pass

            elif la_ == 14:
                localctx = RegelSpraakParser.MaandUitFuncExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 948
                self.match(RegelSpraakParser.DE)
                self.state = 949
                self.match(RegelSpraakParser.MAAND)
                self.state = 950
                self.match(RegelSpraakParser.UIT)
                self.state = 951
                self.primaryExpression(28)
                pass

            elif la_ == 15:
                localctx = RegelSpraakParser.DagUitFuncExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 952
                self.match(RegelSpraakParser.DE)
                self.state = 953
                self.match(RegelSpraakParser.DAG)
                self.state = 954
                self.match(RegelSpraakParser.UIT)
                self.state = 955
                self.primaryExpression(27)
                pass

            elif la_ == 16:
                localctx = RegelSpraakParser.DatumMetFuncExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 956
                self.match(RegelSpraakParser.DE_DATUM_MET)
                self.state = 957
                self.match(RegelSpraakParser.LPAREN)
                self.state = 958
                self.primaryExpression(0)
                self.state = 959
                self.match(RegelSpraakParser.COMMA)
                self.state = 960
                self.primaryExpression(0)
                self.state = 961
                self.match(RegelSpraakParser.COMMA)
                self.state = 962
                self.primaryExpression(0)
                self.state = 963
                self.match(RegelSpraakParser.RPAREN)
                pass

            elif la_ == 17:
                localctx = RegelSpraakParser.PasenFuncExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 965
                self.match(RegelSpraakParser.DE_EERSTE_PAASDAG_VAN)
                self.state = 966
                self.match(RegelSpraakParser.LPAREN)
                self.state = 967
                self.primaryExpression(0)
                self.state = 968
                self.match(RegelSpraakParser.RPAREN)
                pass

            elif la_ == 18:
                localctx = RegelSpraakParser.EersteDatumFuncExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 970
                self.match(RegelSpraakParser.EERSTE_VAN)
                self.state = 971
                self.primaryExpression(0)
                self.state = 976
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==258:
                    self.state = 972
                    self.match(RegelSpraakParser.COMMA)
                    self.state = 973
                    self.primaryExpression(0)
                    self.state = 978
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 979
                self.match(RegelSpraakParser.EN)
                self.state = 980
                self.primaryExpression(23)
                pass

            elif la_ == 19:
                localctx = RegelSpraakParser.LaatsteDatumFuncExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 982
                self.match(RegelSpraakParser.LAATSTE_VAN)
                self.state = 983
                self.primaryExpression(0)
                self.state = 988
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==258:
                    self.state = 984
                    self.match(RegelSpraakParser.COMMA)
                    self.state = 985
                    self.primaryExpression(0)
                    self.state = 990
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 991
                self.match(RegelSpraakParser.EN)
                self.state = 992
                self.primaryExpression(22)
                pass

            elif la_ == 20:
                localctx = RegelSpraakParser.TotaalVanExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 994
                self.match(RegelSpraakParser.HET_TOTAAL_VAN)
                self.state = 995
                self.expressie()
                self.state = 998
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,118,self._ctx)
                if la_ == 1:
                    self.state = 996
                    self.match(RegelSpraakParser.GEDURENDE_DE_TIJD_DAT)
                    self.state = 997
                    localctx.condition = self.expressie()


                pass

            elif la_ == 21:
                localctx = RegelSpraakParser.HetAantalDagenInExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1000
                self.match(RegelSpraakParser.HET_AANTAL_DAGEN_IN)
                self.state = 1005
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [202]:
                    self.state = 1001
                    self.match(RegelSpraakParser.DE)
                    self.state = 1002
                    self.match(RegelSpraakParser.MAAND)
                    pass
                elif token in [207]:
                    self.state = 1003
                    self.match(RegelSpraakParser.HET)
                    self.state = 1004
                    self.match(RegelSpraakParser.JAAR)
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 1007
                self.match(RegelSpraakParser.DAT)
                self.state = 1008
                self.expressie()
                pass

            elif la_ == 22:
                localctx = RegelSpraakParser.CapitalizedTotaalVanExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1010 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 1009
                    self.identifier()
                    self.state = 1012 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==247):
                        break

                self.state = 1014
                self.match(RegelSpraakParser.HET_TOTAAL_VAN)
                self.state = 1015
                self.expressie()
                self.state = 1018
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,121,self._ctx)
                if la_ == 1:
                    self.state = 1016
                    self.match(RegelSpraakParser.GEDURENDE_DE_TIJD_DAT)
                    self.state = 1017
                    localctx.condition = self.expressie()


                pass

            elif la_ == 23:
                localctx = RegelSpraakParser.TijdsevenredigDeelExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1020
                self.match(RegelSpraakParser.HET_TIJDSEVENREDIG_DEEL_PER)
                self.state = 1021
                _la = self._input.LA(1)
                if not(_la==210 or _la==212):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1022
                self.match(RegelSpraakParser.VAN)
                self.state = 1023
                self.expressie()
                self.state = 1026
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,122,self._ctx)
                if la_ == 1:
                    self.state = 1024
                    self.match(RegelSpraakParser.GEDURENDE_DE_TIJD_DAT)
                    self.state = 1025
                    localctx.condition = self.expressie()


                pass

            elif la_ == 24:
                localctx = RegelSpraakParser.CapitalizedTijdsevenredigDeelExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1029 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 1028
                    self.identifier()
                    self.state = 1031 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==247):
                        break

                self.state = 1033
                self.match(RegelSpraakParser.HET_TIJDSEVENREDIG_DEEL_PER)
                self.state = 1034
                _la = self._input.LA(1)
                if not(_la==210 or _la==212):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1035
                self.match(RegelSpraakParser.VAN)
                self.state = 1036
                self.expressie()
                self.state = 1039
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,124,self._ctx)
                if la_ == 1:
                    self.state = 1037
                    self.match(RegelSpraakParser.GEDURENDE_DE_TIJD_DAT)
                    self.state = 1038
                    localctx.condition = self.expressie()


                pass

            elif la_ == 25:
                localctx = RegelSpraakParser.DimensieAggExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1043
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [16, 17, 180, 185, 207]:
                    self.state = 1041
                    self.getalAggregatieFunctie()
                    pass
                elif token in [181, 183]:
                    self.state = 1042
                    self.datumAggregatieFunctie()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 1045
                self.attribuutReferentie()
                self.state = 1046
                self.dimensieSelectie()
                pass

            elif la_ == 26:
                localctx = RegelSpraakParser.AttrRefExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1048
                self.attribuutReferentie()
                pass

            elif la_ == 27:
                localctx = RegelSpraakParser.BezieldeRefExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1049
                self.bezieldeReferentie()
                pass

            elif la_ == 28:
                localctx = RegelSpraakParser.OnderwerpRefExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1050
                self.onderwerpReferentie()
                pass

            elif la_ == 29:
                localctx = RegelSpraakParser.NaamwoordExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1051
                self.naamwoord()
                pass

            elif la_ == 30:
                localctx = RegelSpraakParser.ParamRefExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1052
                self.parameterMetLidwoord()
                pass

            elif la_ == 31:
                localctx = RegelSpraakParser.RekendatumKeywordExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1053
                self.match(RegelSpraakParser.REKENDATUM)
                pass

            elif la_ == 32:
                localctx = RegelSpraakParser.IdentifierExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1054
                self.identifier()
                pass

            elif la_ == 33:
                localctx = RegelSpraakParser.NumberLiteralExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1055
                self.match(RegelSpraakParser.NUMBER)
                pass

            elif la_ == 34:
                localctx = RegelSpraakParser.StringLiteralExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1056
                self.match(RegelSpraakParser.STRING_LITERAL)
                pass

            elif la_ == 35:
                localctx = RegelSpraakParser.EnumLiteralExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1057
                self.match(RegelSpraakParser.ENUM_LITERAL)
                pass

            elif la_ == 36:
                localctx = RegelSpraakParser.DatumLiteralExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1058
                self.datumLiteral()
                pass

            elif la_ == 37:
                localctx = RegelSpraakParser.BooleanTrueLiteralExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1059
                self.match(RegelSpraakParser.WAAR)
                pass

            elif la_ == 38:
                localctx = RegelSpraakParser.BooleanFalseLiteralExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1060
                self.match(RegelSpraakParser.ONWAAR)
                pass

            elif la_ == 39:
                localctx = RegelSpraakParser.PronounExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1061
                self.match(RegelSpraakParser.HIJ)
                pass

            elif la_ == 40:
                localctx = RegelSpraakParser.ParenExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1062
                self.match(RegelSpraakParser.LPAREN)
                self.state = 1063
                self.expressie()
                self.state = 1064
                self.match(RegelSpraakParser.RPAREN)
                pass


            self._ctx.stop = self._input.LT(-1)
            self.state = 1090
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,129,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    self.state = 1088
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,128,self._ctx)
                    if la_ == 1:
                        localctx = RegelSpraakParser.SimpleConcatenatieExprContext(self, RegelSpraakParser.PrimaryExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_primaryExpression)
                        self.state = 1068
                        if not self.precpred(self._ctx, 34):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 34)")
                        self.state = 1071 
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        while True:
                            self.state = 1069
                            self.match(RegelSpraakParser.COMMA)
                            self.state = 1070
                            self.primaryExpression(0)
                            self.state = 1073 
                            self._errHandler.sync(self)
                            _la = self._input.LA(1)
                            if not (_la==258):
                                break

                        self.state = 1075
                        _la = self._input.LA(1)
                        if not(_la==206 or _la==215):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 1076
                        self.primaryExpression(35)
                        pass

                    elif la_ == 2:
                        localctx = RegelSpraakParser.AfrondingExprContext(self, RegelSpraakParser.PrimaryExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_primaryExpression)
                        self.state = 1078
                        if not self.precpred(self._ctx, 37):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 37)")
                        self.state = 1079
                        self.afronding()
                        pass

                    elif la_ == 3:
                        localctx = RegelSpraakParser.BegrenzingExprContext(self, RegelSpraakParser.PrimaryExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_primaryExpression)
                        self.state = 1080
                        if not self.precpred(self._ctx, 36):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 36)")
                        self.state = 1081
                        self.match(RegelSpraakParser.COMMA)
                        self.state = 1082
                        self.begrenzing()
                        pass

                    elif la_ == 4:
                        localctx = RegelSpraakParser.DateCalcExprContext(self, RegelSpraakParser.PrimaryExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_primaryExpression)
                        self.state = 1083
                        if not self.precpred(self._ctx, 24):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 24)")
                        self.state = 1084
                        _la = self._input.LA(1)
                        if not(_la==132 or _la==137):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 1085
                        self.primaryExpression(0)
                        self.state = 1086
                        self.identifier()
                        pass

             
                self.state = 1092
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,129,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class AfrondingContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def AFGEROND_OP(self):
            return self.getToken(RegelSpraakParser.AFGEROND_OP, 0)

        def NUMBER(self):
            return self.getToken(RegelSpraakParser.NUMBER, 0)

        def DECIMALEN(self):
            return self.getToken(RegelSpraakParser.DECIMALEN, 0)

        def NAAR_BENEDEN(self):
            return self.getToken(RegelSpraakParser.NAAR_BENEDEN, 0)

        def NAAR_BOVEN(self):
            return self.getToken(RegelSpraakParser.NAAR_BOVEN, 0)

        def REKENKUNDIG(self):
            return self.getToken(RegelSpraakParser.REKENKUNDIG, 0)

        def RICHTING_NUL(self):
            return self.getToken(RegelSpraakParser.RICHTING_NUL, 0)

        def WEG_VAN_NUL(self):
            return self.getToken(RegelSpraakParser.WEG_VAN_NUL, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_afronding

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAfronding" ):
                listener.enterAfronding(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAfronding" ):
                listener.exitAfronding(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAfronding" ):
                return visitor.visitAfronding(self)
            else:
                return visitor.visitChildren(self)




    def afronding(self):

        localctx = RegelSpraakParser.AfrondingContext(self, self._ctx, self.state)
        self.enterRule(localctx, 144, self.RULE_afronding)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1093
            _la = self._input.LA(1)
            if not(((((_la - 133)) & ~0x3f) == 0 and ((1 << (_la - 133)) & 65635) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 1094
            self.match(RegelSpraakParser.AFGEROND_OP)
            self.state = 1095
            self.match(RegelSpraakParser.NUMBER)
            self.state = 1096
            self.match(RegelSpraakParser.DECIMALEN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BegrenzingContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def begrenzingMinimum(self):
            return self.getTypedRuleContext(RegelSpraakParser.BegrenzingMinimumContext,0)


        def begrenzingMaximum(self):
            return self.getTypedRuleContext(RegelSpraakParser.BegrenzingMaximumContext,0)


        def EN(self):
            return self.getToken(RegelSpraakParser.EN, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_begrenzing

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBegrenzing" ):
                listener.enterBegrenzing(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBegrenzing" ):
                listener.exitBegrenzing(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBegrenzing" ):
                return visitor.visitBegrenzing(self)
            else:
                return visitor.visitChildren(self)




    def begrenzing(self):

        localctx = RegelSpraakParser.BegrenzingContext(self, self._ctx, self.state)
        self.enterRule(localctx, 146, self.RULE_begrenzing)
        try:
            self.state = 1104
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,130,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1098
                self.begrenzingMinimum()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1099
                self.begrenzingMaximum()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1100
                self.begrenzingMinimum()
                self.state = 1101
                self.match(RegelSpraakParser.EN)
                self.state = 1102
                self.begrenzingMaximum()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BegrenzingMinimumContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MET_EEN_MINIMUM_VAN(self):
            return self.getToken(RegelSpraakParser.MET_EEN_MINIMUM_VAN, 0)

        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_begrenzingMinimum

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBegrenzingMinimum" ):
                listener.enterBegrenzingMinimum(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBegrenzingMinimum" ):
                listener.exitBegrenzingMinimum(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBegrenzingMinimum" ):
                return visitor.visitBegrenzingMinimum(self)
            else:
                return visitor.visitChildren(self)




    def begrenzingMinimum(self):

        localctx = RegelSpraakParser.BegrenzingMinimumContext(self, self._ctx, self.state)
        self.enterRule(localctx, 148, self.RULE_begrenzingMinimum)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1106
            self.match(RegelSpraakParser.MET_EEN_MINIMUM_VAN)
            self.state = 1107
            self.expressie()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BegrenzingMaximumContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MET_EEN_MAXIMUM_VAN(self):
            return self.getToken(RegelSpraakParser.MET_EEN_MAXIMUM_VAN, 0)

        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_begrenzingMaximum

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBegrenzingMaximum" ):
                listener.enterBegrenzingMaximum(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBegrenzingMaximum" ):
                listener.exitBegrenzingMaximum(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBegrenzingMaximum" ):
                return visitor.visitBegrenzingMaximum(self)
            else:
                return visitor.visitChildren(self)




    def begrenzingMaximum(self):

        localctx = RegelSpraakParser.BegrenzingMaximumContext(self, self._ctx, self.state)
        self.enterRule(localctx, 150, self.RULE_begrenzingMaximum)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1109
            self.match(RegelSpraakParser.MET_EEN_MAXIMUM_VAN)
            self.state = 1110
            self.expressie()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConditieBijExpressieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.condition = None # ExpressieContext

        def GEDURENDE_DE_TIJD_DAT(self):
            return self.getToken(RegelSpraakParser.GEDURENDE_DE_TIJD_DAT, 0)

        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)


        def periodevergelijkingEnkelvoudig(self):
            return self.getTypedRuleContext(RegelSpraakParser.PeriodevergelijkingEnkelvoudigContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_conditieBijExpressie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConditieBijExpressie" ):
                listener.enterConditieBijExpressie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConditieBijExpressie" ):
                listener.exitConditieBijExpressie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConditieBijExpressie" ):
                return visitor.visitConditieBijExpressie(self)
            else:
                return visitor.visitChildren(self)




    def conditieBijExpressie(self):

        localctx = RegelSpraakParser.ConditieBijExpressieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 152, self.RULE_conditieBijExpressie)
        try:
            self.state = 1115
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [8]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1112
                self.match(RegelSpraakParser.GEDURENDE_DE_TIJD_DAT)
                self.state = 1113
                localctx.condition = self.expressie()
                pass
            elif token in [140, 142, 144, 227]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1114
                self.periodevergelijkingEnkelvoudig()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PeriodevergelijkingEnkelvoudigContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def VANAF(self):
            return self.getToken(RegelSpraakParser.VANAF, 0)

        def datumLiteral(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.DatumLiteralContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.DatumLiteralContext,i)


        def VAN(self):
            return self.getToken(RegelSpraakParser.VAN, 0)

        def TOT(self):
            return self.getToken(RegelSpraakParser.TOT, 0)

        def TOT_EN_MET(self):
            return self.getToken(RegelSpraakParser.TOT_EN_MET, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_periodevergelijkingEnkelvoudig

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPeriodevergelijkingEnkelvoudig" ):
                listener.enterPeriodevergelijkingEnkelvoudig(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPeriodevergelijkingEnkelvoudig" ):
                listener.exitPeriodevergelijkingEnkelvoudig(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPeriodevergelijkingEnkelvoudig" ):
                return visitor.visitPeriodevergelijkingEnkelvoudig(self)
            else:
                return visitor.visitChildren(self)




    def periodevergelijkingEnkelvoudig(self):

        localctx = RegelSpraakParser.PeriodevergelijkingEnkelvoudigContext(self, self._ctx, self.state)
        self.enterRule(localctx, 154, self.RULE_periodevergelijkingEnkelvoudig)
        try:
            self.state = 1133
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,132,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1117
                self.match(RegelSpraakParser.VANAF)
                self.state = 1118
                self.datumLiteral()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1119
                self.match(RegelSpraakParser.VAN)
                self.state = 1120
                self.datumLiteral()
                self.state = 1121
                self.match(RegelSpraakParser.TOT)
                self.state = 1122
                self.datumLiteral()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1124
                self.match(RegelSpraakParser.VAN)
                self.state = 1125
                self.datumLiteral()
                self.state = 1126
                self.match(RegelSpraakParser.TOT_EN_MET)
                self.state = 1127
                self.datumLiteral()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 1129
                self.match(RegelSpraakParser.TOT)
                self.state = 1130
                self.datumLiteral()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 1131
                self.match(RegelSpraakParser.TOT_EN_MET)
                self.state = 1132
                self.datumLiteral()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GetalAggregatieFunctieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def AANTAL(self):
            return self.getToken(RegelSpraakParser.AANTAL, 0)

        def HET(self):
            return self.getToken(RegelSpraakParser.HET, 0)

        def DE_MAXIMALE_WAARDE_VAN(self):
            return self.getToken(RegelSpraakParser.DE_MAXIMALE_WAARDE_VAN, 0)

        def DE_MINIMALE_WAARDE_VAN(self):
            return self.getToken(RegelSpraakParser.DE_MINIMALE_WAARDE_VAN, 0)

        def SOM_VAN(self):
            return self.getToken(RegelSpraakParser.SOM_VAN, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_getalAggregatieFunctie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGetalAggregatieFunctie" ):
                listener.enterGetalAggregatieFunctie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGetalAggregatieFunctie" ):
                listener.exitGetalAggregatieFunctie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGetalAggregatieFunctie" ):
                return visitor.visitGetalAggregatieFunctie(self)
            else:
                return visitor.visitChildren(self)




    def getalAggregatieFunctie(self):

        localctx = RegelSpraakParser.GetalAggregatieFunctieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 156, self.RULE_getalAggregatieFunctie)
        self._la = 0 # Token type
        try:
            self.state = 1142
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [180, 207]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1136
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==207:
                    self.state = 1135
                    self.match(RegelSpraakParser.HET)


                self.state = 1138
                self.match(RegelSpraakParser.AANTAL)
                pass
            elif token in [16]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1139
                self.match(RegelSpraakParser.DE_MAXIMALE_WAARDE_VAN)
                pass
            elif token in [17]:
                self.enterOuterAlt(localctx, 3)
                self.state = 1140
                self.match(RegelSpraakParser.DE_MINIMALE_WAARDE_VAN)
                pass
            elif token in [185]:
                self.enterOuterAlt(localctx, 4)
                self.state = 1141
                self.match(RegelSpraakParser.SOM_VAN)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DatumAggregatieFunctieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EERSTE_VAN(self):
            return self.getToken(RegelSpraakParser.EERSTE_VAN, 0)

        def LAATSTE_VAN(self):
            return self.getToken(RegelSpraakParser.LAATSTE_VAN, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_datumAggregatieFunctie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDatumAggregatieFunctie" ):
                listener.enterDatumAggregatieFunctie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDatumAggregatieFunctie" ):
                listener.exitDatumAggregatieFunctie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDatumAggregatieFunctie" ):
                return visitor.visitDatumAggregatieFunctie(self)
            else:
                return visitor.visitChildren(self)




    def datumAggregatieFunctie(self):

        localctx = RegelSpraakParser.DatumAggregatieFunctieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 158, self.RULE_datumAggregatieFunctie)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1144
            _la = self._input.LA(1)
            if not(_la==181 or _la==183):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DimensieSelectieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OVER(self):
            return self.getToken(RegelSpraakParser.OVER, 0)

        def DOT(self):
            return self.getToken(RegelSpraakParser.DOT, 0)

        def aggregerenOverAlleDimensies(self):
            return self.getTypedRuleContext(RegelSpraakParser.AggregerenOverAlleDimensiesContext,0)


        def aggregerenOverVerzameling(self):
            return self.getTypedRuleContext(RegelSpraakParser.AggregerenOverVerzamelingContext,0)


        def aggregerenOverBereik(self):
            return self.getTypedRuleContext(RegelSpraakParser.AggregerenOverBereikContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_dimensieSelectie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDimensieSelectie" ):
                listener.enterDimensieSelectie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDimensieSelectie" ):
                listener.exitDimensieSelectie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDimensieSelectie" ):
                return visitor.visitDimensieSelectie(self)
            else:
                return visitor.visitChildren(self)




    def dimensieSelectie(self):

        localctx = RegelSpraakParser.DimensieSelectieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 160, self.RULE_dimensieSelectie)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1146
            self.match(RegelSpraakParser.OVER)
            self.state = 1150
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,135,self._ctx)
            if la_ == 1:
                self.state = 1147
                self.aggregerenOverAlleDimensies()
                pass

            elif la_ == 2:
                self.state = 1148
                self.aggregerenOverVerzameling()
                pass

            elif la_ == 3:
                self.state = 1149
                self.aggregerenOverBereik()
                pass


            self.state = 1152
            self.match(RegelSpraakParser.DOT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AggregerenOverAlleDimensiesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ALLE(self):
            return self.getToken(RegelSpraakParser.ALLE, 0)

        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_aggregerenOverAlleDimensies

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAggregerenOverAlleDimensies" ):
                listener.enterAggregerenOverAlleDimensies(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAggregerenOverAlleDimensies" ):
                listener.exitAggregerenOverAlleDimensies(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAggregerenOverAlleDimensies" ):
                return visitor.visitAggregerenOverAlleDimensies(self)
            else:
                return visitor.visitChildren(self)




    def aggregerenOverAlleDimensies(self):

        localctx = RegelSpraakParser.AggregerenOverAlleDimensiesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 162, self.RULE_aggregerenOverAlleDimensies)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1154
            self.match(RegelSpraakParser.ALLE)
            self.state = 1155
            self.naamwoord()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AggregerenOverVerzamelingContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DE(self):
            return self.getToken(RegelSpraakParser.DE, 0)

        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def VANAF(self):
            return self.getToken(RegelSpraakParser.VANAF, 0)

        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.IdentifierContext,i)


        def TM(self):
            return self.getToken(RegelSpraakParser.TM, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_aggregerenOverVerzameling

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAggregerenOverVerzameling" ):
                listener.enterAggregerenOverVerzameling(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAggregerenOverVerzameling" ):
                listener.exitAggregerenOverVerzameling(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAggregerenOverVerzameling" ):
                return visitor.visitAggregerenOverVerzameling(self)
            else:
                return visitor.visitChildren(self)




    def aggregerenOverVerzameling(self):

        localctx = RegelSpraakParser.AggregerenOverVerzamelingContext(self, self._ctx, self.state)
        self.enterRule(localctx, 164, self.RULE_aggregerenOverVerzameling)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1157
            self.match(RegelSpraakParser.DE)
            self.state = 1158
            self.naamwoord()
            self.state = 1159
            self.match(RegelSpraakParser.VANAF)
            self.state = 1160
            self.identifier()
            self.state = 1161
            self.match(RegelSpraakParser.TM)
            self.state = 1162
            self.identifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AggregerenOverBereikContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DE(self):
            return self.getToken(RegelSpraakParser.DE, 0)

        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def IN(self):
            return self.getToken(RegelSpraakParser.IN, 0)

        def LBRACE(self):
            return self.getToken(RegelSpraakParser.LBRACE, 0)

        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.IdentifierContext,i)


        def EN(self):
            return self.getToken(RegelSpraakParser.EN, 0)

        def RBRACE(self):
            return self.getToken(RegelSpraakParser.RBRACE, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.COMMA)
            else:
                return self.getToken(RegelSpraakParser.COMMA, i)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_aggregerenOverBereik

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAggregerenOverBereik" ):
                listener.enterAggregerenOverBereik(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAggregerenOverBereik" ):
                listener.exitAggregerenOverBereik(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAggregerenOverBereik" ):
                return visitor.visitAggregerenOverBereik(self)
            else:
                return visitor.visitChildren(self)




    def aggregerenOverBereik(self):

        localctx = RegelSpraakParser.AggregerenOverBereikContext(self, self._ctx, self.state)
        self.enterRule(localctx, 166, self.RULE_aggregerenOverBereik)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1164
            self.match(RegelSpraakParser.DE)
            self.state = 1165
            self.naamwoord()
            self.state = 1166
            self.match(RegelSpraakParser.IN)
            self.state = 1167
            self.match(RegelSpraakParser.LBRACE)
            self.state = 1168
            self.identifier()
            self.state = 1173
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==258:
                self.state = 1169
                self.match(RegelSpraakParser.COMMA)
                self.state = 1170
                self.identifier()
                self.state = 1175
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1176
            self.match(RegelSpraakParser.EN)
            self.state = 1177
            self.identifier()
            self.state = 1178
            self.match(RegelSpraakParser.RBRACE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UnaryConditionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_unaryCondition

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class UnaryCheckConditionContext(UnaryConditionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.UnaryConditionContext
            super().__init__(parser)
            self.expr = None # PrimaryExpressionContext
            self.op = None # Token
            self.copyFrom(ctx)

        def primaryExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,0)

        def IS_LEEG(self):
            return self.getToken(RegelSpraakParser.IS_LEEG, 0)
        def IS_GEVULD(self):
            return self.getToken(RegelSpraakParser.IS_GEVULD, 0)
        def VOLDOET_AAN_DE_ELFPROEF(self):
            return self.getToken(RegelSpraakParser.VOLDOET_AAN_DE_ELFPROEF, 0)
        def VOLDOET_NIET_AAN_DE_ELFPROEF(self):
            return self.getToken(RegelSpraakParser.VOLDOET_NIET_AAN_DE_ELFPROEF, 0)
        def ZIJN_LEEG(self):
            return self.getToken(RegelSpraakParser.ZIJN_LEEG, 0)
        def ZIJN_GEVULD(self):
            return self.getToken(RegelSpraakParser.ZIJN_GEVULD, 0)
        def VOLDOEN_AAN_DE_ELFPROEF(self):
            return self.getToken(RegelSpraakParser.VOLDOEN_AAN_DE_ELFPROEF, 0)
        def VOLDOEN_NIET_AAN_DE_ELFPROEF(self):
            return self.getToken(RegelSpraakParser.VOLDOEN_NIET_AAN_DE_ELFPROEF, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnaryCheckCondition" ):
                listener.enterUnaryCheckCondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnaryCheckCondition" ):
                listener.exitUnaryCheckCondition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnaryCheckCondition" ):
                return visitor.visitUnaryCheckCondition(self)
            else:
                return visitor.visitChildren(self)


    class UnaryKenmerkConditionContext(UnaryConditionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.UnaryConditionContext
            super().__init__(parser)
            self.expr = None # PrimaryExpressionContext
            self.op = None # Token
            self.kenmerk = None # IdentifierContext
            self.copyFrom(ctx)

        def primaryExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,0)

        def identifier(self):
            return self.getTypedRuleContext(RegelSpraakParser.IdentifierContext,0)

        def IS_KENMERK(self):
            return self.getToken(RegelSpraakParser.IS_KENMERK, 0)
        def ZIJN_KENMERK(self):
            return self.getToken(RegelSpraakParser.ZIJN_KENMERK, 0)
        def IS_NIET_KENMERK(self):
            return self.getToken(RegelSpraakParser.IS_NIET_KENMERK, 0)
        def ZIJN_NIET_KENMERK(self):
            return self.getToken(RegelSpraakParser.ZIJN_NIET_KENMERK, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnaryKenmerkCondition" ):
                listener.enterUnaryKenmerkCondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnaryKenmerkCondition" ):
                listener.exitUnaryKenmerkCondition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnaryKenmerkCondition" ):
                return visitor.visitUnaryKenmerkCondition(self)
            else:
                return visitor.visitChildren(self)


    class UnaryNumeriekExactConditionContext(UnaryConditionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.UnaryConditionContext
            super().__init__(parser)
            self.expr = None # PrimaryExpressionContext
            self.op = None # Token
            self.copyFrom(ctx)

        def NUMBER(self):
            return self.getToken(RegelSpraakParser.NUMBER, 0)
        def CIJFERS(self):
            return self.getToken(RegelSpraakParser.CIJFERS, 0)
        def primaryExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,0)

        def IS_NUMERIEK_MET_EXACT(self):
            return self.getToken(RegelSpraakParser.IS_NUMERIEK_MET_EXACT, 0)
        def IS_NIET_NUMERIEK_MET_EXACT(self):
            return self.getToken(RegelSpraakParser.IS_NIET_NUMERIEK_MET_EXACT, 0)
        def ZIJN_NUMERIEK_MET_EXACT(self):
            return self.getToken(RegelSpraakParser.ZIJN_NUMERIEK_MET_EXACT, 0)
        def ZIJN_NIET_NUMERIEK_MET_EXACT(self):
            return self.getToken(RegelSpraakParser.ZIJN_NIET_NUMERIEK_MET_EXACT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnaryNumeriekExactCondition" ):
                listener.enterUnaryNumeriekExactCondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnaryNumeriekExactCondition" ):
                listener.exitUnaryNumeriekExactCondition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnaryNumeriekExactCondition" ):
                return visitor.visitUnaryNumeriekExactCondition(self)
            else:
                return visitor.visitChildren(self)


    class UnaryRolConditionContext(UnaryConditionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.UnaryConditionContext
            super().__init__(parser)
            self.expr = None # PrimaryExpressionContext
            self.op = None # Token
            self.rol = None # IdentifierContext
            self.copyFrom(ctx)

        def primaryExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,0)

        def identifier(self):
            return self.getTypedRuleContext(RegelSpraakParser.IdentifierContext,0)

        def IS_ROL(self):
            return self.getToken(RegelSpraakParser.IS_ROL, 0)
        def ZIJN_ROL(self):
            return self.getToken(RegelSpraakParser.ZIJN_ROL, 0)
        def IS_NIET_ROL(self):
            return self.getToken(RegelSpraakParser.IS_NIET_ROL, 0)
        def ZIJN_NIET_ROL(self):
            return self.getToken(RegelSpraakParser.ZIJN_NIET_ROL, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnaryRolCondition" ):
                listener.enterUnaryRolCondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnaryRolCondition" ):
                listener.exitUnaryRolCondition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnaryRolCondition" ):
                return visitor.visitUnaryRolCondition(self)
            else:
                return visitor.visitChildren(self)


    class UnaryDagsoortConditionContext(UnaryConditionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.UnaryConditionContext
            super().__init__(parser)
            self.expr = None # PrimaryExpressionContext
            self.op = None # Token
            self.dagsoort = None # IdentifierContext
            self.copyFrom(ctx)

        def primaryExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,0)

        def identifier(self):
            return self.getTypedRuleContext(RegelSpraakParser.IdentifierContext,0)

        def IS_EEN_DAGSOORT(self):
            return self.getToken(RegelSpraakParser.IS_EEN_DAGSOORT, 0)
        def ZIJN_EEN_DAGSOORT(self):
            return self.getToken(RegelSpraakParser.ZIJN_EEN_DAGSOORT, 0)
        def IS_GEEN_DAGSOORT(self):
            return self.getToken(RegelSpraakParser.IS_GEEN_DAGSOORT, 0)
        def ZIJN_GEEN_DAGSOORT(self):
            return self.getToken(RegelSpraakParser.ZIJN_GEEN_DAGSOORT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnaryDagsoortCondition" ):
                listener.enterUnaryDagsoortCondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnaryDagsoortCondition" ):
                listener.exitUnaryDagsoortCondition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnaryDagsoortCondition" ):
                return visitor.visitUnaryDagsoortCondition(self)
            else:
                return visitor.visitChildren(self)


    class UnaryInconsistentDataConditionContext(UnaryConditionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.UnaryConditionContext
            super().__init__(parser)
            self.expr = None # PrimaryExpressionContext
            self.copyFrom(ctx)

        def IS_INCONSISTENT(self):
            return self.getToken(RegelSpraakParser.IS_INCONSISTENT, 0)
        def primaryExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnaryInconsistentDataCondition" ):
                listener.enterUnaryInconsistentDataCondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnaryInconsistentDataCondition" ):
                listener.exitUnaryInconsistentDataCondition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnaryInconsistentDataCondition" ):
                return visitor.visitUnaryInconsistentDataCondition(self)
            else:
                return visitor.visitChildren(self)


    class UnaryUniekConditionContext(UnaryConditionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.UnaryConditionContext
            super().__init__(parser)
            self.ref = None # OnderwerpReferentieContext
            self.copyFrom(ctx)

        def MOETEN_UNIEK_ZIJN(self):
            return self.getToken(RegelSpraakParser.MOETEN_UNIEK_ZIJN, 0)
        def onderwerpReferentie(self):
            return self.getTypedRuleContext(RegelSpraakParser.OnderwerpReferentieContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnaryUniekCondition" ):
                listener.enterUnaryUniekCondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnaryUniekCondition" ):
                listener.exitUnaryUniekCondition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnaryUniekCondition" ):
                return visitor.visitUnaryUniekCondition(self)
            else:
                return visitor.visitChildren(self)



    def unaryCondition(self):

        localctx = RegelSpraakParser.UnaryConditionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 168, self.RULE_unaryCondition)
        self._la = 0 # Token type
        try:
            self.state = 1206
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,137,self._ctx)
            if la_ == 1:
                localctx = RegelSpraakParser.UnaryCheckConditionContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1180
                localctx.expr = self.primaryExpression(0)
                self.state = 1181
                localctx.op = self._input.LT(1)
                _la = self._input.LA(1)
                if not(((((_la - 70)) & ~0x3f) == 0 and ((1 << (_la - 70)) & 61455) != 0)):
                    localctx.op = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass

            elif la_ == 2:
                localctx = RegelSpraakParser.UnaryNumeriekExactConditionContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1183
                localctx.expr = self.primaryExpression(0)
                self.state = 1184
                localctx.op = self._input.LT(1)
                _la = self._input.LA(1)
                if not(((((_la - 86)) & ~0x3f) == 0 and ((1 << (_la - 86)) & 15) != 0)):
                    localctx.op = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1185
                self.match(RegelSpraakParser.NUMBER)
                self.state = 1186
                self.match(RegelSpraakParser.CIJFERS)
                pass

            elif la_ == 3:
                localctx = RegelSpraakParser.UnaryDagsoortConditionContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 1188
                localctx.expr = self.primaryExpression(0)
                self.state = 1189
                localctx.op = self._input.LT(1)
                _la = self._input.LA(1)
                if not(((((_la - 90)) & ~0x3f) == 0 and ((1 << (_la - 90)) & 15) != 0)):
                    localctx.op = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1190
                localctx.dagsoort = self.identifier()
                pass

            elif la_ == 4:
                localctx = RegelSpraakParser.UnaryKenmerkConditionContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 1192
                localctx.expr = self.primaryExpression(0)
                self.state = 1193
                localctx.op = self._input.LT(1)
                _la = self._input.LA(1)
                if not(((((_la - 74)) & ~0x3f) == 0 and ((1 << (_la - 74)) & 85) != 0)):
                    localctx.op = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1194
                localctx.kenmerk = self.identifier()
                pass

            elif la_ == 5:
                localctx = RegelSpraakParser.UnaryRolConditionContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 1196
                localctx.expr = self.primaryExpression(0)
                self.state = 1197
                localctx.op = self._input.LT(1)
                _la = self._input.LA(1)
                if not(((((_la - 75)) & ~0x3f) == 0 and ((1 << (_la - 75)) & 85) != 0)):
                    localctx.op = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1198
                localctx.rol = self.identifier()
                pass

            elif la_ == 6:
                localctx = RegelSpraakParser.UnaryUniekConditionContext(self, localctx)
                self.enterOuterAlt(localctx, 6)
                self.state = 1200
                localctx.ref = self.onderwerpReferentie()
                self.state = 1201
                self.match(RegelSpraakParser.MOETEN_UNIEK_ZIJN)
                pass

            elif la_ == 7:
                localctx = RegelSpraakParser.UnaryInconsistentDataConditionContext(self, localctx)
                self.enterOuterAlt(localctx, 7)
                self.state = 1203
                localctx.expr = self.primaryExpression(0)
                self.state = 1204
                self.match(RegelSpraakParser.IS_INCONSISTENT)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RegelStatusConditionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_regelStatusCondition

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class RegelStatusCheckContext(RegelStatusConditionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.RegelStatusConditionContext
            super().__init__(parser)
            self.name = None # NaamwoordContext
            self.op = None # Token
            self.copyFrom(ctx)

        def REGEL(self):
            return self.getToken(RegelSpraakParser.REGEL, 0)
        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)

        def IS_GEVUURD(self):
            return self.getToken(RegelSpraakParser.IS_GEVUURD, 0)
        def IS_INCONSISTENT(self):
            return self.getToken(RegelSpraakParser.IS_INCONSISTENT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRegelStatusCheck" ):
                listener.enterRegelStatusCheck(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRegelStatusCheck" ):
                listener.exitRegelStatusCheck(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRegelStatusCheck" ):
                return visitor.visitRegelStatusCheck(self)
            else:
                return visitor.visitChildren(self)



    def regelStatusCondition(self):

        localctx = RegelSpraakParser.RegelStatusConditionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 170, self.RULE_regelStatusCondition)
        self._la = 0 # Token type
        try:
            localctx = RegelSpraakParser.RegelStatusCheckContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 1208
            self.match(RegelSpraakParser.REGEL)
            self.state = 1209
            localctx.name = self.naamwoord()
            self.state = 1210
            localctx.op = self._input.LT(1)
            _la = self._input.LA(1)
            if not(_la==95 or _la==96):
                localctx.op = self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DagsoortDefinitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DAGSOORT(self):
            return self.getToken(RegelSpraakParser.DAGSOORT, 0)

        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def SEMICOLON(self):
            return self.getToken(RegelSpraakParser.SEMICOLON, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_dagsoortDefinition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDagsoortDefinition" ):
                listener.enterDagsoortDefinition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDagsoortDefinition" ):
                listener.exitDagsoortDefinition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDagsoortDefinition" ):
                return visitor.visitDagsoortDefinition(self)
            else:
                return visitor.visitChildren(self)




    def dagsoortDefinition(self):

        localctx = RegelSpraakParser.DagsoortDefinitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 172, self.RULE_dagsoortDefinition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1212
            self.match(RegelSpraakParser.DAGSOORT)
            self.state = 1213
            self.naamwoord()
            self.state = 1215
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==261:
                self.state = 1214
                self.match(RegelSpraakParser.SEMICOLON)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx



    def sempred(self, localctx:RuleContext, ruleIndex:int, predIndex:int):
        if self._predicates == None:
            self._predicates = dict()
        self._predicates[71] = self.primaryExpression_sempred
        pred = self._predicates.get(ruleIndex, None)
        if pred is None:
            raise Exception("No predicate with index:" + str(ruleIndex))
        else:
            return pred(localctx, predIndex)

    def primaryExpression_sempred(self, localctx:PrimaryExpressionContext, predIndex:int):
            if predIndex == 0:
                return self.precpred(self._ctx, 34)
         

            if predIndex == 1:
                return self.precpred(self._ctx, 37)
         

            if predIndex == 2:
                return self.precpred(self._ctx, 36)
         

            if predIndex == 3:
                return self.precpred(self._ctx, 24)
         




