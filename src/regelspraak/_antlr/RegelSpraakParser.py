# Generated from RegelSpraak.g4 by ANTLR 4.13.1
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO

def serializedATN():
    return [
        4,1,292,2106,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,
        7,6,2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,
        13,2,14,7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,
        20,7,20,2,21,7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,
        26,2,27,7,27,2,28,7,28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,
        33,7,33,2,34,7,34,2,35,7,35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,
        39,2,40,7,40,2,41,7,41,2,42,7,42,2,43,7,43,2,44,7,44,2,45,7,45,2,
        46,7,46,2,47,7,47,2,48,7,48,2,49,7,49,2,50,7,50,2,51,7,51,2,52,7,
        52,2,53,7,53,2,54,7,54,2,55,7,55,2,56,7,56,2,57,7,57,2,58,7,58,2,
        59,7,59,2,60,7,60,2,61,7,61,2,62,7,62,2,63,7,63,2,64,7,64,2,65,7,
        65,2,66,7,66,2,67,7,67,2,68,7,68,2,69,7,69,2,70,7,70,2,71,7,71,2,
        72,7,72,2,73,7,73,2,74,7,74,2,75,7,75,2,76,7,76,2,77,7,77,2,78,7,
        78,2,79,7,79,2,80,7,80,2,81,7,81,2,82,7,82,2,83,7,83,2,84,7,84,2,
        85,7,85,2,86,7,86,2,87,7,87,2,88,7,88,2,89,7,89,2,90,7,90,2,91,7,
        91,2,92,7,92,2,93,7,93,2,94,7,94,2,95,7,95,2,96,7,96,2,97,7,97,2,
        98,7,98,2,99,7,99,2,100,7,100,2,101,7,101,2,102,7,102,2,103,7,103,
        2,104,7,104,2,105,7,105,2,106,7,106,2,107,7,107,2,108,7,108,2,109,
        7,109,2,110,7,110,2,111,7,111,2,112,7,112,2,113,7,113,2,114,7,114,
        2,115,7,115,2,116,7,116,2,117,7,117,2,118,7,118,2,119,7,119,2,120,
        7,120,2,121,7,121,2,122,7,122,2,123,7,123,2,124,7,124,2,125,7,125,
        2,126,7,126,2,127,7,127,2,128,7,128,2,129,7,129,2,130,7,130,2,131,
        7,131,2,132,7,132,2,133,7,133,2,134,7,134,2,135,7,135,2,136,7,136,
        2,137,7,137,2,138,7,138,2,139,7,139,2,140,7,140,2,141,7,141,2,142,
        7,142,2,143,7,143,2,144,7,144,2,145,7,145,2,146,7,146,2,147,7,147,
        2,148,7,148,2,149,7,149,2,150,7,150,2,151,7,151,2,152,7,152,2,153,
        7,153,2,154,7,154,2,155,7,155,2,156,7,156,2,157,7,157,2,158,7,158,
        2,159,7,159,2,160,7,160,2,161,7,161,2,162,7,162,2,163,7,163,1,0,
        1,0,1,0,1,0,1,0,1,0,5,0,335,8,0,10,0,12,0,338,9,0,1,0,1,0,1,1,1,
        1,1,1,1,1,1,1,1,1,3,1,348,8,1,1,2,1,2,1,2,3,2,353,8,2,1,2,1,2,1,
        3,1,3,1,3,4,3,360,8,3,11,3,12,3,361,1,4,1,4,3,4,366,8,4,1,4,1,4,
        1,4,1,4,1,4,5,4,373,8,4,10,4,12,4,376,9,4,1,4,3,4,379,8,4,1,5,3,
        5,382,8,5,1,5,4,5,385,8,5,11,5,12,5,386,1,5,3,5,390,8,5,4,5,392,
        8,5,11,5,12,5,393,1,5,5,5,397,8,5,10,5,12,5,400,9,5,1,6,1,6,1,6,
        1,6,1,6,1,6,1,6,1,6,5,6,410,8,6,10,6,12,6,413,9,6,1,6,3,6,416,8,
        6,1,7,1,7,3,7,420,8,7,1,8,4,8,423,8,8,11,8,12,8,424,1,9,1,9,1,10,
        1,10,1,11,1,11,1,12,3,12,434,8,12,1,12,4,12,437,8,12,11,12,12,12,
        438,1,12,4,12,442,8,12,11,12,12,12,443,1,12,1,12,4,12,448,8,12,11,
        12,12,12,449,1,12,1,12,4,12,454,8,12,11,12,12,12,455,1,12,1,12,4,
        12,460,8,12,11,12,12,12,461,1,12,4,12,465,8,12,11,12,12,12,466,1,
        12,1,12,4,12,471,8,12,11,12,12,12,472,1,12,1,12,4,12,477,8,12,11,
        12,12,12,478,1,12,1,12,1,12,1,12,1,12,4,12,486,8,12,11,12,12,12,
        487,3,12,490,8,12,1,13,3,13,493,8,13,1,13,4,13,496,8,13,11,13,12,
        13,497,1,13,4,13,501,8,13,11,13,12,13,502,1,13,1,13,4,13,507,8,13,
        11,13,12,13,508,1,13,1,13,4,13,513,8,13,11,13,12,13,514,1,13,1,13,
        4,13,519,8,13,11,13,12,13,520,1,13,4,13,524,8,13,11,13,12,13,525,
        1,13,1,13,4,13,530,8,13,11,13,12,13,531,1,13,1,13,4,13,536,8,13,
        11,13,12,13,537,1,13,1,13,1,13,1,13,1,13,4,13,545,8,13,11,13,12,
        13,546,3,13,549,8,13,1,14,1,14,3,14,553,8,14,1,15,3,15,556,8,15,
        1,15,4,15,559,8,15,11,15,12,15,560,1,15,4,15,564,8,15,11,15,12,15,
        565,1,15,1,15,4,15,570,8,15,11,15,12,15,571,1,15,1,15,4,15,576,8,
        15,11,15,12,15,577,1,15,1,15,4,15,582,8,15,11,15,12,15,583,1,15,
        4,15,587,8,15,11,15,12,15,588,1,15,1,15,4,15,593,8,15,11,15,12,15,
        594,1,15,1,15,4,15,599,8,15,11,15,12,15,600,3,15,603,8,15,1,16,1,
        16,1,16,1,16,5,16,609,8,16,10,16,12,16,612,9,16,1,17,1,17,1,17,1,
        17,5,17,618,8,17,10,17,12,17,621,9,17,1,18,1,18,1,18,1,18,5,18,627,
        8,18,10,18,12,18,630,9,18,1,19,1,19,1,20,1,20,1,21,1,21,1,22,1,22,
        1,23,1,23,1,23,1,23,4,23,644,8,23,11,23,12,23,645,1,23,3,23,649,
        8,23,1,23,3,23,652,8,23,1,23,5,23,655,8,23,10,23,12,23,658,9,23,
        1,24,1,24,3,24,662,8,24,1,24,1,24,1,25,3,25,667,8,25,1,25,1,25,3,
        25,671,8,25,1,25,1,25,3,25,675,8,25,1,25,3,25,678,8,25,1,26,1,26,
        1,26,1,26,3,26,684,8,26,1,26,1,26,3,26,688,8,26,1,26,1,26,1,26,1,
        26,5,26,694,8,26,10,26,12,26,697,9,26,3,26,699,8,26,1,26,3,26,702,
        8,26,1,27,1,27,1,27,1,27,1,27,1,27,3,27,710,8,27,1,28,1,28,1,28,
        1,28,1,28,3,28,717,8,28,1,29,1,29,1,29,1,29,1,29,3,29,724,8,29,1,
        30,1,30,1,31,1,31,1,31,1,31,1,31,3,31,733,8,31,1,32,1,32,1,33,1,
        33,1,34,3,34,740,8,34,1,34,1,34,1,34,1,34,1,34,1,34,3,34,748,8,34,
        1,35,1,35,1,35,1,35,1,35,1,35,3,35,756,8,35,1,35,3,35,759,8,35,1,
        36,1,36,1,36,1,36,1,36,3,36,766,8,36,1,37,1,37,4,37,770,8,37,11,
        37,12,37,771,1,38,1,38,1,39,1,39,1,40,1,40,1,40,5,40,781,8,40,10,
        40,12,40,784,9,40,1,41,1,41,1,41,1,41,1,41,1,41,3,41,792,8,41,1,
        41,1,41,3,41,796,8,41,1,41,1,41,3,41,800,8,41,1,41,1,41,3,41,804,
        8,41,1,42,1,42,1,43,1,43,1,43,3,43,811,8,43,1,43,1,43,1,43,1,43,
        3,43,817,8,43,1,44,1,44,1,44,3,44,822,8,44,1,45,1,45,1,45,3,45,827,
        8,45,1,45,1,45,1,45,1,45,4,45,833,8,45,11,45,12,45,834,1,46,1,46,
        1,46,1,46,3,46,841,8,46,1,46,3,46,844,8,46,1,47,1,47,1,47,1,47,1,
        48,1,48,1,49,1,49,1,50,1,50,1,50,1,50,1,50,3,50,859,8,50,1,50,1,
        50,3,50,863,8,50,1,50,1,50,3,50,867,8,50,1,50,3,50,870,8,50,1,51,
        3,51,873,8,51,1,51,1,51,1,51,1,51,5,51,879,8,51,10,51,12,51,882,
        9,51,1,52,4,52,885,8,52,11,52,12,52,886,1,53,3,53,890,8,53,1,53,
        1,53,1,53,1,53,5,53,896,8,53,10,53,12,53,899,9,53,1,53,3,53,902,
        8,53,1,54,1,54,1,54,1,54,4,54,908,8,54,11,54,12,54,909,1,54,1,54,
        1,54,1,54,1,54,1,54,1,54,3,54,919,8,54,1,55,1,55,1,55,1,55,1,55,
        1,55,3,55,927,8,55,1,55,3,55,930,8,55,1,56,4,56,933,8,56,11,56,12,
        56,934,1,57,1,57,4,57,939,8,57,11,57,12,57,940,1,58,4,58,944,8,58,
        11,58,12,58,945,1,59,1,59,1,60,1,60,1,60,3,60,953,8,60,1,60,1,60,
        1,60,1,60,3,60,959,8,60,1,60,3,60,962,8,60,1,60,3,60,965,8,60,1,
        61,1,61,1,61,3,61,970,8,61,1,61,1,61,4,61,974,8,61,11,61,12,61,975,
        1,62,1,62,5,62,980,8,62,10,62,12,62,983,9,62,1,63,1,63,1,63,1,63,
        1,63,1,63,1,63,1,63,1,63,1,63,1,63,1,63,1,63,1,63,3,63,999,8,63,
        1,64,1,64,1,64,1,65,1,65,1,65,1,65,1,65,3,65,1009,8,65,3,65,1011,
        8,65,1,66,1,66,1,66,1,66,1,66,1,66,1,66,1,66,1,66,1,66,1,66,1,66,
        3,66,1025,8,66,1,66,3,66,1028,8,66,1,66,1,66,1,66,1,66,1,66,1,66,
        1,66,1,66,1,66,1,66,3,66,1040,8,66,1,66,1,66,1,66,1,66,1,66,1,66,
        1,66,1,66,1,66,1,66,1,66,3,66,1053,8,66,1,67,1,67,1,68,1,68,1,68,
        1,68,1,68,1,68,1,68,1,68,1,68,1,68,1,68,1,68,1,69,4,69,1070,8,69,
        11,69,12,69,1071,1,70,4,70,1075,8,70,11,70,12,70,1076,1,71,1,71,
        1,71,1,71,1,71,3,71,1084,8,71,1,72,1,72,3,72,1088,8,72,1,73,1,73,
        1,74,1,74,1,74,1,74,3,74,1096,8,74,1,74,3,74,1099,8,74,1,74,1,74,
        1,74,1,74,1,74,3,74,1106,8,74,1,74,3,74,1109,8,74,3,74,1111,8,74,
        1,75,1,75,1,75,1,75,1,75,5,75,1118,8,75,10,75,12,75,1121,9,75,1,
        76,1,76,1,76,1,76,1,76,1,77,1,77,1,78,1,78,1,78,1,78,1,78,1,78,3,
        78,1136,8,78,1,78,3,78,1139,8,78,3,78,1141,8,78,1,79,1,79,1,79,3,
        79,1146,8,79,1,80,1,80,1,80,1,80,1,80,1,80,1,81,3,81,1155,8,81,1,
        81,1,81,1,81,1,82,1,82,1,82,3,82,1163,8,82,1,83,1,83,1,83,1,83,1,
        83,1,83,4,83,1171,8,83,11,83,12,83,1172,1,83,1,83,1,83,1,83,3,83,
        1179,8,83,1,83,1,83,1,83,1,83,1,83,1,83,4,83,1187,8,83,11,83,12,
        83,1188,1,83,1,83,1,83,1,83,3,83,1195,8,83,1,83,1,83,1,83,1,83,1,
        83,1,83,4,83,1203,8,83,11,83,12,83,1204,3,83,1207,8,83,1,84,1,84,
        1,84,1,84,1,84,1,84,1,84,1,84,1,84,1,84,1,84,1,84,1,84,1,84,3,84,
        1223,8,84,1,85,1,85,1,85,3,85,1228,8,85,1,86,4,86,1231,8,86,11,86,
        12,86,1232,1,87,1,87,1,88,1,88,1,88,3,88,1240,8,88,1,88,1,88,1,88,
        1,88,1,88,1,88,4,88,1248,8,88,11,88,12,88,1249,1,89,1,89,1,89,3,
        89,1255,8,89,1,90,1,90,1,90,3,90,1260,8,90,1,91,1,91,1,91,1,91,5,
        91,1266,8,91,10,91,12,91,1269,9,91,1,92,1,92,1,92,1,92,5,92,1275,
        8,92,10,92,12,92,1278,9,92,1,93,1,93,4,93,1282,8,93,11,93,12,93,
        1283,1,93,3,93,1287,8,93,1,94,1,94,4,94,1291,8,94,11,94,12,94,1292,
        1,94,3,94,1296,8,94,1,95,1,95,1,95,1,95,1,96,1,96,1,97,3,97,1305,
        8,97,1,97,1,97,1,98,3,98,1310,8,98,1,98,3,98,1313,8,98,1,98,4,98,
        1316,8,98,11,98,12,98,1317,1,99,1,99,1,99,1,100,1,100,3,100,1325,
        8,100,1,101,1,101,1,101,1,101,1,101,3,101,1332,8,101,1,102,1,102,
        1,103,3,103,1337,8,103,1,103,1,103,3,103,1341,8,103,1,103,1,103,
        1,104,1,104,1,105,3,105,1348,8,105,1,105,1,105,1,105,1,105,1,105,
        1,106,1,106,1,106,1,107,1,107,1,107,1,108,1,108,1,108,1,109,1,109,
        1,109,1,109,1,109,1,109,1,109,4,109,1371,8,109,11,109,12,109,1372,
        1,110,1,110,1,110,1,110,1,110,1,110,3,110,1381,8,110,1,111,1,111,
        1,112,1,112,1,112,1,112,1,112,1,112,1,112,1,112,1,112,1,112,1,112,
        3,112,1396,8,112,1,113,1,113,1,113,1,113,3,113,1402,8,113,1,113,
        1,113,1,113,1,113,1,113,1,113,4,113,1410,8,113,11,113,12,113,1411,
        1,114,1,114,1,115,1,115,1,116,1,116,1,117,1,117,1,118,1,118,1,119,
        1,119,1,120,1,120,5,120,1428,8,120,10,120,12,120,1431,9,120,1,120,
        1,120,1,121,3,121,1436,8,121,1,121,1,121,1,121,1,121,1,122,1,122,
        1,122,3,122,1445,8,122,1,122,1,122,5,122,1449,8,122,10,122,12,122,
        1452,9,122,1,123,1,123,1,123,1,123,1,123,1,123,1,123,1,123,1,123,
        1,123,1,123,1,123,1,123,3,123,1467,8,123,1,124,1,124,1,124,1,124,
        1,124,1,124,1,124,1,124,1,124,1,124,1,124,1,124,1,124,3,124,1482,
        8,124,1,125,1,125,1,125,3,125,1487,8,125,1,126,1,126,1,126,1,126,
        1,126,1,126,1,126,1,126,1,126,1,126,1,126,1,126,1,126,1,126,1,126,
        5,126,1504,8,126,10,126,12,126,1507,9,126,1,126,1,126,1,126,1,126,
        1,126,1,126,1,126,3,126,1516,8,126,1,126,1,126,3,126,1520,8,126,
        1,127,1,127,1,127,1,127,3,127,1526,8,127,1,127,1,127,1,127,3,127,
        1531,8,127,1,128,1,128,1,129,1,129,1,130,1,130,1,130,1,130,5,130,
        1541,8,130,10,130,12,130,1544,9,130,1,131,1,131,1,132,1,132,1,132,
        1,132,5,132,1552,8,132,10,132,12,132,1555,9,132,1,133,1,133,1,134,
        1,134,1,134,1,134,5,134,1563,8,134,10,134,12,134,1566,9,134,1,135,
        1,135,1,136,1,136,1,136,1,136,1,136,1,136,1,136,1,136,1,136,1,136,
        1,136,1,136,1,136,3,136,1583,8,136,1,136,1,136,1,136,1,136,1,136,
        1,136,3,136,1591,8,136,1,136,1,136,1,136,1,136,5,136,1597,8,136,
        10,136,12,136,1600,9,136,1,136,1,136,1,136,1,136,1,136,1,136,1,136,
        1,136,1,136,1,136,1,136,1,136,1,136,1,136,1,136,1,136,1,136,1,136,
        1,136,1,136,1,136,1,136,1,136,1,136,1,136,1,136,1,136,1,136,1,136,
        3,136,1631,8,136,1,136,3,136,1634,8,136,1,136,1,136,1,136,1,136,
        1,136,1,136,1,136,1,136,1,136,5,136,1645,8,136,10,136,12,136,1648,
        9,136,1,136,1,136,1,136,1,136,1,136,1,136,1,136,1,136,1,136,1,136,
        1,136,1,136,1,136,1,136,5,136,1664,8,136,10,136,12,136,1667,9,136,
        1,136,1,136,1,136,1,136,1,136,1,136,1,136,1,136,1,136,1,136,5,136,
        1679,8,136,10,136,12,136,1682,9,136,1,136,1,136,1,136,1,136,1,136,
        1,136,1,136,1,136,1,136,1,136,1,136,1,136,1,136,1,136,1,136,1,136,
        1,136,1,136,1,136,1,136,1,136,1,136,1,136,1,136,1,136,1,136,1,136,
        1,136,1,136,1,136,1,136,1,136,1,136,1,136,1,136,1,136,5,136,1720,
        8,136,10,136,12,136,1723,9,136,1,136,1,136,1,136,1,136,1,136,1,136,
        1,136,5,136,1732,8,136,10,136,12,136,1735,9,136,1,136,1,136,1,136,
        1,136,1,136,1,136,3,136,1743,8,136,1,136,1,136,1,136,1,136,1,136,
        3,136,1750,8,136,1,136,1,136,3,136,1754,8,136,1,136,3,136,1757,8,
        136,1,136,1,136,1,136,4,136,1762,8,136,11,136,12,136,1763,1,136,
        1,136,1,136,3,136,1769,8,136,1,136,1,136,1,136,1,136,1,136,3,136,
        1776,8,136,1,136,4,136,1779,8,136,11,136,12,136,1780,1,136,1,136,
        1,136,1,136,1,136,3,136,1788,8,136,1,136,1,136,3,136,1792,8,136,
        1,136,1,136,1,136,1,136,1,136,3,136,1799,8,136,1,136,1,136,3,136,
        1803,8,136,1,136,1,136,1,136,1,136,1,136,3,136,1810,8,136,1,136,
        1,136,3,136,1814,8,136,1,136,1,136,1,136,1,136,1,136,1,136,1,136,
        1,136,1,136,1,136,1,136,1,136,1,136,1,136,1,136,1,136,1,136,1,136,
        3,136,1834,8,136,1,136,1,136,1,136,4,136,1839,8,136,11,136,12,136,
        1840,1,136,1,136,1,136,1,136,1,136,1,136,1,136,1,136,1,136,1,136,
        1,136,1,136,1,136,1,136,1,136,1,136,1,136,1,136,5,136,1861,8,136,
        10,136,12,136,1864,9,136,1,137,1,137,1,137,1,137,1,137,1,138,1,138,
        1,138,1,138,1,138,1,138,3,138,1877,8,138,1,139,1,139,1,139,1,140,
        1,140,1,140,1,141,1,141,1,141,3,141,1888,8,141,1,142,1,142,1,142,
        1,143,1,143,1,143,1,143,1,143,1,143,1,143,1,143,1,143,1,143,1,143,
        1,143,1,143,1,143,1,143,1,143,3,143,1909,8,143,1,144,1,144,1,144,
        1,144,1,144,1,144,1,144,1,144,1,144,1,144,1,144,1,144,1,144,1,144,
        1,144,1,144,3,144,1927,8,144,1,145,1,145,1,145,1,145,3,145,1933,
        8,145,1,146,1,146,1,146,1,146,1,146,1,146,3,146,1941,8,146,1,147,
        1,147,1,148,1,148,1,148,1,148,3,148,1949,8,148,1,148,1,148,1,148,
        1,148,3,148,1955,8,148,1,149,1,149,1,149,1,149,3,149,1961,8,149,
        1,150,1,150,1,150,1,150,1,150,1,150,1,150,1,151,1,151,1,151,1,151,
        1,151,1,151,1,151,5,151,1977,8,151,10,151,12,151,1980,9,151,1,151,
        1,151,1,151,1,151,1,152,1,152,1,152,1,152,1,152,1,152,1,152,1,152,
        1,152,1,152,1,152,1,152,1,152,1,152,1,152,1,152,1,152,1,152,1,152,
        1,152,1,152,1,152,1,152,1,152,1,152,1,152,3,152,2012,8,152,1,153,
        1,153,1,153,1,153,1,153,1,153,1,153,1,153,3,153,2022,8,153,1,154,
        1,154,1,154,1,154,1,154,1,154,1,154,1,154,1,154,1,154,1,154,1,154,
        3,154,2036,8,154,1,155,1,155,1,155,1,155,4,155,2042,8,155,11,155,
        12,155,2043,1,155,3,155,2047,8,155,1,155,3,155,2050,8,155,1,156,
        1,156,1,157,1,157,1,157,1,157,1,157,1,157,1,157,3,157,2061,8,157,
        1,157,3,157,2064,8,157,1,158,1,158,1,159,1,159,1,159,3,159,2071,
        8,159,1,160,1,160,5,160,2075,8,160,10,160,12,160,2078,9,160,1,161,
        1,161,1,161,3,161,2083,8,161,1,162,1,162,1,162,1,162,1,162,1,162,
        1,162,1,162,1,162,1,162,1,162,1,162,1,162,1,162,3,162,2099,8,162,
        1,163,1,163,1,163,3,163,2104,8,163,1,163,0,1,272,164,0,2,4,6,8,10,
        12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,
        56,58,60,62,64,66,68,70,72,74,76,78,80,82,84,86,88,90,92,94,96,98,
        100,102,104,106,108,110,112,114,116,118,120,122,124,126,128,130,
        132,134,136,138,140,142,144,146,148,150,152,154,156,158,160,162,
        164,166,168,170,172,174,176,178,180,182,184,186,188,190,192,194,
        196,198,200,202,204,206,208,210,212,214,216,218,220,222,224,226,
        228,230,232,234,236,238,240,242,244,246,248,250,252,254,256,258,
        260,262,264,266,268,270,272,274,276,278,280,282,284,286,288,290,
        292,294,296,298,300,302,304,306,308,310,312,314,316,318,320,322,
        324,326,0,51,1,0,289,289,16,0,96,96,110,110,113,113,120,120,128,
        128,157,157,186,186,197,198,201,202,205,206,217,217,219,220,228,
        228,230,230,249,249,263,263,15,0,96,96,110,110,120,120,128,128,157,
        157,186,186,197,198,201,202,205,206,217,217,219,220,228,228,230,
        230,249,249,263,263,4,0,117,117,208,208,211,211,213,213,12,0,142,
        142,144,144,172,172,204,204,212,212,216,216,225,225,227,227,229,
        229,237,237,240,240,244,244,7,0,205,206,217,218,220,221,223,224,
        234,235,238,239,246,247,1,0,159,160,2,0,3,3,164,164,2,0,175,176,
        179,179,2,0,208,208,213,213,7,0,133,133,205,206,217,224,234,235,
        238,239,246,247,249,263,1,0,183,185,2,0,186,186,263,264,5,0,28,28,
        95,96,98,100,102,106,277,277,2,0,144,144,236,236,2,0,110,110,113,
        113,2,0,47,48,124,124,6,0,48,50,52,52,124,124,127,127,129,129,137,
        138,3,0,208,208,211,211,213,213,9,0,142,142,172,172,204,204,212,
        212,216,216,227,227,229,229,237,237,244,244,3,0,208,208,213,213,
        248,248,1,0,241,242,1,0,153,154,4,0,197,198,201,202,211,211,264,
        264,3,0,280,281,285,285,288,288,2,0,207,207,210,210,2,0,109,109,
        117,117,1,0,157,158,1,0,149,150,2,0,113,113,117,117,1,0,54,59,1,
        0,54,55,2,0,54,55,64,67,2,0,212,212,225,225,3,0,47,48,54,54,124,
        124,11,0,22,25,38,39,47,67,113,113,121,121,124,124,127,127,129,130,
        136,136,138,138,216,216,3,0,133,133,139,139,148,148,2,0,122,123,
        132,132,2,0,143,143,284,284,2,0,217,217,220,220,2,0,133,133,139,
        139,3,0,134,135,140,141,151,151,2,0,187,187,189,189,2,0,68,71,80,
        83,1,0,84,87,1,0,88,91,4,0,72,72,74,74,76,76,78,78,4,0,73,73,75,
        75,77,77,79,79,1,0,274,275,2,0,193,193,196,196,1,0,134,135,2334,
        0,336,1,0,0,0,2,347,1,0,0,0,4,349,1,0,0,0,6,356,1,0,0,0,8,363,1,
        0,0,0,10,381,1,0,0,0,12,401,1,0,0,0,14,419,1,0,0,0,16,422,1,0,0,
        0,18,426,1,0,0,0,20,428,1,0,0,0,22,430,1,0,0,0,24,489,1,0,0,0,26,
        548,1,0,0,0,28,552,1,0,0,0,30,602,1,0,0,0,32,604,1,0,0,0,34,613,
        1,0,0,0,36,622,1,0,0,0,38,631,1,0,0,0,40,633,1,0,0,0,42,635,1,0,
        0,0,44,637,1,0,0,0,46,639,1,0,0,0,48,661,1,0,0,0,50,670,1,0,0,0,
        52,679,1,0,0,0,54,709,1,0,0,0,56,711,1,0,0,0,58,718,1,0,0,0,60,725,
        1,0,0,0,62,727,1,0,0,0,64,734,1,0,0,0,66,736,1,0,0,0,68,739,1,0,
        0,0,70,749,1,0,0,0,72,765,1,0,0,0,74,767,1,0,0,0,76,773,1,0,0,0,
        78,775,1,0,0,0,80,777,1,0,0,0,82,785,1,0,0,0,84,805,1,0,0,0,86,816,
        1,0,0,0,88,818,1,0,0,0,90,823,1,0,0,0,92,843,1,0,0,0,94,845,1,0,
        0,0,96,849,1,0,0,0,98,851,1,0,0,0,100,853,1,0,0,0,102,872,1,0,0,
        0,104,884,1,0,0,0,106,901,1,0,0,0,108,918,1,0,0,0,110,920,1,0,0,
        0,112,932,1,0,0,0,114,938,1,0,0,0,116,943,1,0,0,0,118,947,1,0,0,
        0,120,949,1,0,0,0,122,966,1,0,0,0,124,977,1,0,0,0,126,998,1,0,0,
        0,128,1000,1,0,0,0,130,1010,1,0,0,0,132,1052,1,0,0,0,134,1054,1,
        0,0,0,136,1056,1,0,0,0,138,1069,1,0,0,0,140,1074,1,0,0,0,142,1083,
        1,0,0,0,144,1087,1,0,0,0,146,1089,1,0,0,0,148,1110,1,0,0,0,150,1112,
        1,0,0,0,152,1122,1,0,0,0,154,1127,1,0,0,0,156,1129,1,0,0,0,158,1142,
        1,0,0,0,160,1147,1,0,0,0,162,1154,1,0,0,0,164,1159,1,0,0,0,166,1206,
        1,0,0,0,168,1222,1,0,0,0,170,1224,1,0,0,0,172,1230,1,0,0,0,174,1234,
        1,0,0,0,176,1239,1,0,0,0,178,1251,1,0,0,0,180,1256,1,0,0,0,182,1261,
        1,0,0,0,184,1270,1,0,0,0,186,1286,1,0,0,0,188,1295,1,0,0,0,190,1297,
        1,0,0,0,192,1301,1,0,0,0,194,1304,1,0,0,0,196,1309,1,0,0,0,198,1319,
        1,0,0,0,200,1324,1,0,0,0,202,1331,1,0,0,0,204,1333,1,0,0,0,206,1336,
        1,0,0,0,208,1344,1,0,0,0,210,1347,1,0,0,0,212,1354,1,0,0,0,214,1357,
        1,0,0,0,216,1360,1,0,0,0,218,1363,1,0,0,0,220,1380,1,0,0,0,222,1382,
        1,0,0,0,224,1395,1,0,0,0,226,1401,1,0,0,0,228,1413,1,0,0,0,230,1415,
        1,0,0,0,232,1417,1,0,0,0,234,1419,1,0,0,0,236,1421,1,0,0,0,238,1423,
        1,0,0,0,240,1425,1,0,0,0,242,1435,1,0,0,0,244,1441,1,0,0,0,246,1466,
        1,0,0,0,248,1481,1,0,0,0,250,1483,1,0,0,0,252,1519,1,0,0,0,254,1530,
        1,0,0,0,256,1532,1,0,0,0,258,1534,1,0,0,0,260,1536,1,0,0,0,262,1545,
        1,0,0,0,264,1547,1,0,0,0,266,1556,1,0,0,0,268,1558,1,0,0,0,270,1567,
        1,0,0,0,272,1833,1,0,0,0,274,1865,1,0,0,0,276,1876,1,0,0,0,278,1878,
        1,0,0,0,280,1881,1,0,0,0,282,1887,1,0,0,0,284,1889,1,0,0,0,286,1908,
        1,0,0,0,288,1926,1,0,0,0,290,1932,1,0,0,0,292,1940,1,0,0,0,294,1942,
        1,0,0,0,296,1954,1,0,0,0,298,1956,1,0,0,0,300,1962,1,0,0,0,302,1969,
        1,0,0,0,304,2011,1,0,0,0,306,2021,1,0,0,0,308,2035,1,0,0,0,310,2037,
        1,0,0,0,312,2051,1,0,0,0,314,2053,1,0,0,0,316,2065,1,0,0,0,318,2067,
        1,0,0,0,320,2072,1,0,0,0,322,2079,1,0,0,0,324,2098,1,0,0,0,326,2100,
        1,0,0,0,328,335,3,2,1,0,329,335,3,120,60,0,330,335,3,122,61,0,331,
        335,3,4,2,0,332,335,3,156,78,0,333,335,3,80,40,0,334,328,1,0,0,0,
        334,329,1,0,0,0,334,330,1,0,0,0,334,331,1,0,0,0,334,332,1,0,0,0,
        334,333,1,0,0,0,335,338,1,0,0,0,336,334,1,0,0,0,336,337,1,0,0,0,
        337,339,1,0,0,0,338,336,1,0,0,0,339,340,5,0,0,1,340,1,1,0,0,0,341,
        348,3,46,23,0,342,348,3,70,35,0,343,348,3,100,50,0,344,348,3,90,
        45,0,345,348,3,108,54,0,346,348,3,310,155,0,347,341,1,0,0,0,347,
        342,1,0,0,0,347,343,1,0,0,0,347,344,1,0,0,0,347,345,1,0,0,0,347,
        346,1,0,0,0,348,3,1,0,0,0,349,350,5,98,0,0,350,352,3,32,16,0,351,
        353,3,128,64,0,352,351,1,0,0,0,352,353,1,0,0,0,353,354,1,0,0,0,354,
        355,3,6,3,0,355,5,1,0,0,0,356,357,3,8,4,0,357,359,3,10,5,0,358,360,
        3,12,6,0,359,358,1,0,0,0,360,361,1,0,0,0,361,359,1,0,0,0,361,362,
        1,0,0,0,362,7,1,0,0,0,363,365,5,289,0,0,364,366,5,289,0,0,365,364,
        1,0,0,0,365,366,1,0,0,0,366,367,1,0,0,0,367,368,3,16,8,0,368,369,
        5,289,0,0,369,374,3,16,8,0,370,371,5,289,0,0,371,373,3,16,8,0,372,
        370,1,0,0,0,373,376,1,0,0,0,374,372,1,0,0,0,374,375,1,0,0,0,375,
        378,1,0,0,0,376,374,1,0,0,0,377,379,5,289,0,0,378,377,1,0,0,0,378,
        379,1,0,0,0,379,9,1,0,0,0,380,382,5,289,0,0,381,380,1,0,0,0,381,
        382,1,0,0,0,382,391,1,0,0,0,383,385,5,288,0,0,384,383,1,0,0,0,385,
        386,1,0,0,0,386,384,1,0,0,0,386,387,1,0,0,0,387,389,1,0,0,0,388,
        390,5,289,0,0,389,388,1,0,0,0,389,390,1,0,0,0,390,392,1,0,0,0,391,
        384,1,0,0,0,392,393,1,0,0,0,393,391,1,0,0,0,393,394,1,0,0,0,394,
        398,1,0,0,0,395,397,5,288,0,0,396,395,1,0,0,0,397,400,1,0,0,0,398,
        396,1,0,0,0,398,399,1,0,0,0,399,11,1,0,0,0,400,398,1,0,0,0,401,402,
        5,289,0,0,402,403,5,264,0,0,403,404,5,289,0,0,404,405,3,246,123,
        0,405,406,5,289,0,0,406,411,3,14,7,0,407,408,5,289,0,0,408,410,3,
        14,7,0,409,407,1,0,0,0,410,413,1,0,0,0,411,409,1,0,0,0,411,412,1,
        0,0,0,412,415,1,0,0,0,413,411,1,0,0,0,414,416,5,289,0,0,415,414,
        1,0,0,0,415,416,1,0,0,0,416,13,1,0,0,0,417,420,3,246,123,0,418,420,
        5,290,0,0,419,417,1,0,0,0,419,418,1,0,0,0,420,15,1,0,0,0,421,423,
        8,0,0,0,422,421,1,0,0,0,423,424,1,0,0,0,424,422,1,0,0,0,424,425,
        1,0,0,0,425,17,1,0,0,0,426,427,5,263,0,0,427,19,1,0,0,0,428,429,
        7,1,0,0,429,21,1,0,0,0,430,431,7,2,0,0,431,23,1,0,0,0,432,434,7,
        3,0,0,433,432,1,0,0,0,433,434,1,0,0,0,434,436,1,0,0,0,435,437,3,
        20,10,0,436,435,1,0,0,0,437,438,1,0,0,0,438,436,1,0,0,0,438,439,
        1,0,0,0,439,490,1,0,0,0,440,442,3,20,10,0,441,440,1,0,0,0,442,443,
        1,0,0,0,443,441,1,0,0,0,443,444,1,0,0,0,444,490,1,0,0,0,445,447,
        5,45,0,0,446,448,3,20,10,0,447,446,1,0,0,0,448,449,1,0,0,0,449,447,
        1,0,0,0,449,450,1,0,0,0,450,490,1,0,0,0,451,453,5,45,0,0,452,454,
        3,20,10,0,453,452,1,0,0,0,454,455,1,0,0,0,455,453,1,0,0,0,455,456,
        1,0,0,0,456,457,1,0,0,0,457,459,5,172,0,0,458,460,3,20,10,0,459,
        458,1,0,0,0,460,461,1,0,0,0,461,459,1,0,0,0,461,462,1,0,0,0,462,
        490,1,0,0,0,463,465,3,20,10,0,464,463,1,0,0,0,465,466,1,0,0,0,466,
        464,1,0,0,0,466,467,1,0,0,0,467,468,1,0,0,0,468,470,5,172,0,0,469,
        471,3,20,10,0,470,469,1,0,0,0,471,472,1,0,0,0,472,470,1,0,0,0,472,
        473,1,0,0,0,473,490,1,0,0,0,474,476,5,136,0,0,475,477,3,20,10,0,
        476,475,1,0,0,0,477,478,1,0,0,0,478,476,1,0,0,0,478,479,1,0,0,0,
        479,490,1,0,0,0,480,481,5,213,0,0,481,482,5,186,0,0,482,483,5,206,
        0,0,483,485,5,216,0,0,484,486,3,20,10,0,485,484,1,0,0,0,486,487,
        1,0,0,0,487,485,1,0,0,0,487,488,1,0,0,0,488,490,1,0,0,0,489,433,
        1,0,0,0,489,441,1,0,0,0,489,445,1,0,0,0,489,451,1,0,0,0,489,464,
        1,0,0,0,489,474,1,0,0,0,489,480,1,0,0,0,490,25,1,0,0,0,491,493,7,
        3,0,0,492,491,1,0,0,0,492,493,1,0,0,0,493,495,1,0,0,0,494,496,3,
        28,14,0,495,494,1,0,0,0,496,497,1,0,0,0,497,495,1,0,0,0,497,498,
        1,0,0,0,498,549,1,0,0,0,499,501,3,28,14,0,500,499,1,0,0,0,501,502,
        1,0,0,0,502,500,1,0,0,0,502,503,1,0,0,0,503,549,1,0,0,0,504,506,
        5,45,0,0,505,507,3,28,14,0,506,505,1,0,0,0,507,508,1,0,0,0,508,506,
        1,0,0,0,508,509,1,0,0,0,509,549,1,0,0,0,510,512,5,45,0,0,511,513,
        3,28,14,0,512,511,1,0,0,0,513,514,1,0,0,0,514,512,1,0,0,0,514,515,
        1,0,0,0,515,516,1,0,0,0,516,518,5,172,0,0,517,519,3,28,14,0,518,
        517,1,0,0,0,519,520,1,0,0,0,520,518,1,0,0,0,520,521,1,0,0,0,521,
        549,1,0,0,0,522,524,3,28,14,0,523,522,1,0,0,0,524,525,1,0,0,0,525,
        523,1,0,0,0,525,526,1,0,0,0,526,527,1,0,0,0,527,529,5,172,0,0,528,
        530,3,28,14,0,529,528,1,0,0,0,530,531,1,0,0,0,531,529,1,0,0,0,531,
        532,1,0,0,0,532,549,1,0,0,0,533,535,5,136,0,0,534,536,3,28,14,0,
        535,534,1,0,0,0,536,537,1,0,0,0,537,535,1,0,0,0,537,538,1,0,0,0,
        538,549,1,0,0,0,539,540,5,213,0,0,540,541,5,186,0,0,541,542,5,206,
        0,0,542,544,5,216,0,0,543,545,3,28,14,0,544,543,1,0,0,0,545,546,
        1,0,0,0,546,544,1,0,0,0,546,547,1,0,0,0,547,549,1,0,0,0,548,492,
        1,0,0,0,548,500,1,0,0,0,548,504,1,0,0,0,548,510,1,0,0,0,548,523,
        1,0,0,0,548,533,1,0,0,0,548,539,1,0,0,0,549,27,1,0,0,0,550,553,3,
        20,10,0,551,553,5,264,0,0,552,550,1,0,0,0,552,551,1,0,0,0,553,29,
        1,0,0,0,554,556,7,3,0,0,555,554,1,0,0,0,555,556,1,0,0,0,556,558,
        1,0,0,0,557,559,3,22,11,0,558,557,1,0,0,0,559,560,1,0,0,0,560,558,
        1,0,0,0,560,561,1,0,0,0,561,603,1,0,0,0,562,564,3,22,11,0,563,562,
        1,0,0,0,564,565,1,0,0,0,565,563,1,0,0,0,565,566,1,0,0,0,566,603,
        1,0,0,0,567,569,5,45,0,0,568,570,3,22,11,0,569,568,1,0,0,0,570,571,
        1,0,0,0,571,569,1,0,0,0,571,572,1,0,0,0,572,603,1,0,0,0,573,575,
        5,45,0,0,574,576,3,22,11,0,575,574,1,0,0,0,576,577,1,0,0,0,577,575,
        1,0,0,0,577,578,1,0,0,0,578,579,1,0,0,0,579,581,5,172,0,0,580,582,
        3,22,11,0,581,580,1,0,0,0,582,583,1,0,0,0,583,581,1,0,0,0,583,584,
        1,0,0,0,584,603,1,0,0,0,585,587,3,22,11,0,586,585,1,0,0,0,587,588,
        1,0,0,0,588,586,1,0,0,0,588,589,1,0,0,0,589,590,1,0,0,0,590,592,
        5,172,0,0,591,593,3,22,11,0,592,591,1,0,0,0,593,594,1,0,0,0,594,
        592,1,0,0,0,594,595,1,0,0,0,595,603,1,0,0,0,596,598,5,136,0,0,597,
        599,3,22,11,0,598,597,1,0,0,0,599,600,1,0,0,0,600,598,1,0,0,0,600,
        601,1,0,0,0,601,603,1,0,0,0,602,555,1,0,0,0,602,563,1,0,0,0,602,
        567,1,0,0,0,602,573,1,0,0,0,602,586,1,0,0,0,602,596,1,0,0,0,603,
        31,1,0,0,0,604,610,3,24,12,0,605,606,3,38,19,0,606,607,3,24,12,0,
        607,609,1,0,0,0,608,605,1,0,0,0,609,612,1,0,0,0,610,608,1,0,0,0,
        610,611,1,0,0,0,611,33,1,0,0,0,612,610,1,0,0,0,613,619,3,26,13,0,
        614,615,3,38,19,0,615,616,3,26,13,0,616,618,1,0,0,0,617,614,1,0,
        0,0,618,621,1,0,0,0,619,617,1,0,0,0,619,620,1,0,0,0,620,35,1,0,0,
        0,621,619,1,0,0,0,622,628,3,30,15,0,623,624,3,38,19,0,624,625,3,
        30,15,0,625,627,1,0,0,0,626,623,1,0,0,0,627,630,1,0,0,0,628,626,
        1,0,0,0,628,629,1,0,0,0,629,37,1,0,0,0,630,628,1,0,0,0,631,632,7,
        4,0,0,632,39,1,0,0,0,633,634,5,266,0,0,634,41,1,0,0,0,635,636,5,
        263,0,0,636,43,1,0,0,0,637,638,7,5,0,0,638,45,1,0,0,0,639,640,5,
        99,0,0,640,648,3,36,18,0,641,643,5,174,0,0,642,644,5,263,0,0,643,
        642,1,0,0,0,644,645,1,0,0,0,645,643,1,0,0,0,645,646,1,0,0,0,646,
        647,1,0,0,0,647,649,5,271,0,0,648,641,1,0,0,0,648,649,1,0,0,0,649,
        651,1,0,0,0,650,652,5,161,0,0,651,650,1,0,0,0,651,652,1,0,0,0,652,
        656,1,0,0,0,653,655,3,48,24,0,654,653,1,0,0,0,655,658,1,0,0,0,656,
        654,1,0,0,0,656,657,1,0,0,0,657,47,1,0,0,0,658,656,1,0,0,0,659,662,
        3,50,25,0,660,662,3,52,26,0,661,659,1,0,0,0,661,660,1,0,0,0,662,
        663,1,0,0,0,663,664,5,277,0,0,664,49,1,0,0,0,665,667,5,113,0,0,666,
        665,1,0,0,0,666,667,1,0,0,0,667,668,1,0,0,0,668,671,3,18,9,0,669,
        671,3,34,17,0,670,666,1,0,0,0,670,669,1,0,0,0,671,672,1,0,0,0,672,
        674,5,170,0,0,673,675,7,6,0,0,674,673,1,0,0,0,674,675,1,0,0,0,675,
        677,1,0,0,0,676,678,3,96,48,0,677,676,1,0,0,0,677,678,1,0,0,0,678,
        51,1,0,0,0,679,683,3,34,17,0,680,684,3,54,27,0,681,684,3,76,38,0,
        682,684,3,78,39,0,683,680,1,0,0,0,683,681,1,0,0,0,683,682,1,0,0,
        0,684,687,1,0,0,0,685,686,5,173,0,0,686,688,3,84,42,0,687,685,1,
        0,0,0,687,688,1,0,0,0,688,698,1,0,0,0,689,690,5,167,0,0,690,695,
        3,98,49,0,691,692,5,212,0,0,692,694,3,98,49,0,693,691,1,0,0,0,694,
        697,1,0,0,0,695,693,1,0,0,0,695,696,1,0,0,0,696,699,1,0,0,0,697,
        695,1,0,0,0,698,689,1,0,0,0,698,699,1,0,0,0,699,701,1,0,0,0,700,
        702,3,96,48,0,701,700,1,0,0,0,701,702,1,0,0,0,702,53,1,0,0,0,703,
        710,3,58,29,0,704,710,3,60,30,0,705,710,3,64,32,0,706,710,3,66,33,
        0,707,710,3,56,28,0,708,710,3,62,31,0,709,703,1,0,0,0,709,704,1,
        0,0,0,709,705,1,0,0,0,709,706,1,0,0,0,709,707,1,0,0,0,709,708,1,
        0,0,0,710,55,1,0,0,0,711,712,5,101,0,0,712,716,5,240,0,0,713,717,
        3,54,27,0,714,717,3,76,38,0,715,717,3,78,39,0,716,713,1,0,0,0,716,
        714,1,0,0,0,716,715,1,0,0,0,717,57,1,0,0,0,718,723,5,177,0,0,719,
        720,5,270,0,0,720,721,3,68,34,0,721,722,5,271,0,0,722,724,1,0,0,
        0,723,719,1,0,0,0,723,724,1,0,0,0,724,59,1,0,0,0,725,726,5,182,0,
        0,726,61,1,0,0,0,727,732,5,178,0,0,728,729,5,270,0,0,729,730,3,68,
        34,0,730,731,5,271,0,0,731,733,1,0,0,0,732,728,1,0,0,0,732,733,1,
        0,0,0,733,63,1,0,0,0,734,735,5,162,0,0,735,65,1,0,0,0,736,737,7,
        7,0,0,737,67,1,0,0,0,738,740,7,8,0,0,739,738,1,0,0,0,739,740,1,0,
        0,0,740,747,1,0,0,0,741,748,5,168,0,0,742,743,5,169,0,0,743,744,
        5,172,0,0,744,745,5,264,0,0,745,748,5,165,0,0,746,748,5,169,0,0,
        747,741,1,0,0,0,747,742,1,0,0,0,747,746,1,0,0,0,748,69,1,0,0,0,749,
        750,5,100,0,0,750,751,5,263,0,0,751,752,5,29,0,0,752,755,3,72,36,
        0,753,754,5,173,0,0,754,756,3,86,43,0,755,753,1,0,0,0,755,756,1,
        0,0,0,756,758,1,0,0,0,757,759,5,277,0,0,758,757,1,0,0,0,758,759,
        1,0,0,0,759,71,1,0,0,0,760,766,3,74,37,0,761,766,3,58,29,0,762,766,
        3,60,30,0,763,766,3,64,32,0,764,766,3,66,33,0,765,760,1,0,0,0,765,
        761,1,0,0,0,765,762,1,0,0,0,765,763,1,0,0,0,765,764,1,0,0,0,766,
        73,1,0,0,0,767,769,5,166,0,0,768,770,5,269,0,0,769,768,1,0,0,0,770,
        771,1,0,0,0,771,769,1,0,0,0,771,772,1,0,0,0,772,75,1,0,0,0,773,774,
        5,263,0,0,774,77,1,0,0,0,775,776,5,263,0,0,776,79,1,0,0,0,777,778,
        5,103,0,0,778,782,3,18,9,0,779,781,3,82,41,0,780,779,1,0,0,0,781,
        784,1,0,0,0,782,780,1,0,0,0,782,783,1,0,0,0,783,81,1,0,0,0,784,782,
        1,0,0,0,785,786,7,9,0,0,786,791,3,84,42,0,787,788,5,174,0,0,788,
        789,3,84,42,0,789,790,5,271,0,0,790,792,1,0,0,0,791,787,1,0,0,0,
        791,792,1,0,0,0,792,793,1,0,0,0,793,795,3,84,42,0,794,796,3,84,42,
        0,795,794,1,0,0,0,795,796,1,0,0,0,796,803,1,0,0,0,797,799,5,265,
        0,0,798,800,5,278,0,0,799,798,1,0,0,0,799,800,1,0,0,0,800,801,1,
        0,0,0,801,802,5,264,0,0,802,804,3,84,42,0,803,797,1,0,0,0,803,804,
        1,0,0,0,804,83,1,0,0,0,805,806,7,10,0,0,806,85,1,0,0,0,807,810,3,
        88,44,0,808,809,5,278,0,0,809,811,3,88,44,0,810,808,1,0,0,0,810,
        811,1,0,0,0,811,817,1,0,0,0,812,817,5,264,0,0,813,817,5,279,0,0,
        814,817,5,260,0,0,815,817,5,261,0,0,816,807,1,0,0,0,816,812,1,0,
        0,0,816,813,1,0,0,0,816,814,1,0,0,0,816,815,1,0,0,0,817,87,1,0,0,
        0,818,821,3,84,42,0,819,820,5,284,0,0,820,822,5,264,0,0,821,819,
        1,0,0,0,821,822,1,0,0,0,822,89,1,0,0,0,823,824,5,102,0,0,824,826,
        3,32,16,0,825,827,5,274,0,0,826,825,1,0,0,0,826,827,1,0,0,0,827,
        828,1,0,0,0,828,829,5,27,0,0,829,830,3,32,16,0,830,832,3,92,46,0,
        831,833,3,94,47,0,832,831,1,0,0,0,833,834,1,0,0,0,834,832,1,0,0,
        0,834,835,1,0,0,0,835,91,1,0,0,0,836,837,5,2,0,0,837,838,3,38,19,
        0,838,840,5,271,0,0,839,841,5,276,0,0,840,839,1,0,0,0,840,841,1,
        0,0,0,841,844,1,0,0,0,842,844,5,1,0,0,843,836,1,0,0,0,843,842,1,
        0,0,0,844,93,1,0,0,0,845,846,5,264,0,0,846,847,5,275,0,0,847,848,
        3,32,16,0,848,95,1,0,0,0,849,850,7,11,0,0,850,97,1,0,0,0,851,852,
        5,263,0,0,852,99,1,0,0,0,853,854,5,104,0,0,854,855,3,102,51,0,855,
        858,5,276,0,0,856,859,3,54,27,0,857,859,3,76,38,0,858,856,1,0,0,
        0,858,857,1,0,0,0,859,862,1,0,0,0,860,861,5,173,0,0,861,863,3,86,
        43,0,862,860,1,0,0,0,862,863,1,0,0,0,863,866,1,0,0,0,864,865,5,113,
        0,0,865,867,3,246,123,0,866,864,1,0,0,0,866,867,1,0,0,0,867,869,
        1,0,0,0,868,870,3,96,48,0,869,868,1,0,0,0,869,870,1,0,0,0,870,101,
        1,0,0,0,871,873,7,9,0,0,872,871,1,0,0,0,872,873,1,0,0,0,873,874,
        1,0,0,0,874,880,3,104,52,0,875,876,3,38,19,0,876,877,3,104,52,0,
        877,879,1,0,0,0,878,875,1,0,0,0,879,882,1,0,0,0,880,878,1,0,0,0,
        880,881,1,0,0,0,881,103,1,0,0,0,882,880,1,0,0,0,883,885,7,12,0,0,
        884,883,1,0,0,0,885,886,1,0,0,0,886,884,1,0,0,0,886,887,1,0,0,0,
        887,105,1,0,0,0,888,890,7,9,0,0,889,888,1,0,0,0,889,890,1,0,0,0,
        890,891,1,0,0,0,891,897,3,104,52,0,892,893,3,38,19,0,893,894,3,104,
        52,0,894,896,1,0,0,0,895,892,1,0,0,0,896,899,1,0,0,0,897,895,1,0,
        0,0,897,898,1,0,0,0,898,902,1,0,0,0,899,897,1,0,0,0,900,902,3,32,
        16,0,901,889,1,0,0,0,901,900,1,0,0,0,902,107,1,0,0,0,903,904,5,105,
        0,0,904,905,3,32,16,0,905,907,3,110,55,0,906,908,3,110,55,0,907,
        906,1,0,0,0,908,909,1,0,0,0,909,907,1,0,0,0,909,910,1,0,0,0,910,
        911,1,0,0,0,911,912,3,116,58,0,912,919,1,0,0,0,913,914,5,28,0,0,
        914,915,3,32,16,0,915,916,3,110,55,0,916,917,3,116,58,0,917,919,
        1,0,0,0,918,903,1,0,0,0,918,913,1,0,0,0,919,109,1,0,0,0,920,921,
        7,9,0,0,921,926,3,114,57,0,922,923,5,174,0,0,923,924,3,32,16,0,924,
        925,5,271,0,0,925,927,1,0,0,0,926,922,1,0,0,0,926,927,1,0,0,0,927,
        929,1,0,0,0,928,930,3,112,56,0,929,928,1,0,0,0,929,930,1,0,0,0,930,
        111,1,0,0,0,931,933,3,20,10,0,932,931,1,0,0,0,933,934,1,0,0,0,934,
        932,1,0,0,0,934,935,1,0,0,0,935,113,1,0,0,0,936,939,3,20,10,0,937,
        939,3,38,19,0,938,936,1,0,0,0,938,937,1,0,0,0,939,940,1,0,0,0,940,
        938,1,0,0,0,940,941,1,0,0,0,941,115,1,0,0,0,942,944,3,118,59,0,943,
        942,1,0,0,0,944,945,1,0,0,0,945,943,1,0,0,0,945,946,1,0,0,0,946,
        117,1,0,0,0,947,948,8,13,0,0,948,119,1,0,0,0,949,950,5,96,0,0,950,
        952,3,124,62,0,951,953,5,264,0,0,952,951,1,0,0,0,952,953,1,0,0,0,
        953,954,1,0,0,0,954,955,3,128,64,0,955,961,3,132,66,0,956,958,3,
        164,82,0,957,959,5,275,0,0,958,957,1,0,0,0,958,959,1,0,0,0,959,962,
        1,0,0,0,960,962,5,275,0,0,961,956,1,0,0,0,961,960,1,0,0,0,961,962,
        1,0,0,0,962,964,1,0,0,0,963,965,3,240,120,0,964,963,1,0,0,0,964,
        965,1,0,0,0,965,121,1,0,0,0,966,967,5,97,0,0,967,969,3,32,16,0,968,
        970,5,112,0,0,969,968,1,0,0,0,969,970,1,0,0,0,970,973,1,0,0,0,971,
        974,3,120,60,0,972,974,3,156,78,0,973,971,1,0,0,0,973,972,1,0,0,
        0,974,975,1,0,0,0,975,973,1,0,0,0,975,976,1,0,0,0,976,123,1,0,0,
        0,977,981,3,34,17,0,978,980,3,126,63,0,979,978,1,0,0,0,980,983,1,
        0,0,0,981,979,1,0,0,0,981,982,1,0,0,0,982,125,1,0,0,0,983,981,1,
        0,0,0,984,999,5,194,0,0,985,986,5,274,0,0,986,999,3,34,17,0,987,
        988,5,274,0,0,988,989,5,172,0,0,989,999,3,34,17,0,990,991,5,212,
        0,0,991,999,3,34,17,0,992,993,5,113,0,0,993,999,3,34,17,0,994,995,
        5,200,0,0,995,996,3,34,17,0,996,997,5,113,0,0,997,999,1,0,0,0,998,
        984,1,0,0,0,998,985,1,0,0,0,998,987,1,0,0,0,998,990,1,0,0,0,998,
        992,1,0,0,0,998,994,1,0,0,0,999,127,1,0,0,0,1000,1001,5,108,0,0,
        1001,1002,3,130,65,0,1002,129,1,0,0,0,1003,1011,5,203,0,0,1004,1005,
        5,146,0,0,1005,1008,3,40,20,0,1006,1007,7,14,0,0,1007,1009,3,40,
        20,0,1008,1006,1,0,0,0,1008,1009,1,0,0,0,1009,1011,1,0,0,0,1010,
        1003,1,0,0,0,1010,1004,1,0,0,0,1011,131,1,0,0,0,1012,1013,5,211,
        0,0,1013,1014,5,205,0,0,1014,1015,5,113,0,0,1015,1016,5,211,0,0,
        1016,1053,3,32,16,0,1017,1024,3,190,95,0,1018,1019,5,8,0,0,1019,
        1025,3,246,123,0,1020,1021,5,9,0,0,1021,1025,3,246,123,0,1022,1023,
        5,10,0,0,1023,1025,3,246,123,0,1024,1018,1,0,0,0,1024,1020,1,0,0,
        0,1024,1022,1,0,0,0,1025,1027,1,0,0,0,1026,1028,3,288,144,0,1027,
        1026,1,0,0,0,1027,1028,1,0,0,0,1028,1053,1,0,0,0,1029,1030,3,190,
        95,0,1030,1031,5,114,0,0,1031,1032,3,134,67,0,1032,1033,3,246,123,
        0,1033,1053,1,0,0,0,1034,1053,3,136,68,0,1035,1036,3,178,89,0,1036,
        1037,7,15,0,0,1037,1039,3,194,97,0,1038,1040,3,288,144,0,1039,1038,
        1,0,0,0,1039,1040,1,0,0,0,1040,1053,1,0,0,0,1041,1042,3,178,89,0,
        1042,1043,5,110,0,0,1043,1044,7,9,0,0,1044,1045,3,32,16,0,1045,1046,
        5,172,0,0,1046,1047,3,192,96,0,1047,1048,7,16,0,0,1048,1049,3,246,
        123,0,1049,1053,1,0,0,0,1050,1053,3,148,74,0,1051,1053,3,314,157,
        0,1052,1012,1,0,0,0,1052,1017,1,0,0,0,1052,1029,1,0,0,0,1052,1034,
        1,0,0,0,1052,1035,1,0,0,0,1052,1041,1,0,0,0,1052,1050,1,0,0,0,1052,
        1051,1,0,0,0,1053,133,1,0,0,0,1054,1055,7,17,0,0,1055,135,1,0,0,
        0,1056,1057,5,211,0,0,1057,1058,3,138,69,0,1058,1059,5,240,0,0,1059,
        1060,5,211,0,0,1060,1061,3,140,70,0,1061,1062,5,113,0,0,1062,1063,
        7,18,0,0,1063,1064,3,138,69,0,1064,1065,5,240,0,0,1065,1066,7,18,
        0,0,1066,1067,3,140,70,0,1067,137,1,0,0,0,1068,1070,3,144,72,0,1069,
        1068,1,0,0,0,1070,1071,1,0,0,0,1071,1069,1,0,0,0,1071,1072,1,0,0,
        0,1072,139,1,0,0,0,1073,1075,3,142,71,0,1074,1073,1,0,0,0,1075,1076,
        1,0,0,0,1076,1074,1,0,0,0,1076,1077,1,0,0,0,1077,141,1,0,0,0,1078,
        1084,3,20,10,0,1079,1084,3,38,19,0,1080,1084,5,208,0,0,1081,1084,
        5,213,0,0,1082,1084,5,211,0,0,1083,1078,1,0,0,0,1083,1079,1,0,0,
        0,1083,1080,1,0,0,0,1083,1081,1,0,0,0,1083,1082,1,0,0,0,1084,143,
        1,0,0,0,1085,1088,3,20,10,0,1086,1088,3,146,73,0,1087,1085,1,0,0,
        0,1087,1086,1,0,0,0,1088,145,1,0,0,0,1089,1090,7,19,0,0,1090,147,
        1,0,0,0,1091,1092,5,41,0,0,1092,1093,3,32,16,0,1093,1095,5,43,0,
        0,1094,1096,3,150,75,0,1095,1094,1,0,0,0,1095,1096,1,0,0,0,1096,
        1098,1,0,0,0,1097,1099,5,275,0,0,1098,1097,1,0,0,0,1098,1099,1,0,
        0,0,1099,1111,1,0,0,0,1100,1101,5,44,0,0,1101,1102,5,211,0,0,1102,
        1103,5,45,0,0,1103,1105,3,32,16,0,1104,1106,3,150,75,0,1105,1104,
        1,0,0,0,1105,1106,1,0,0,0,1106,1108,1,0,0,0,1107,1109,5,275,0,0,
        1108,1107,1,0,0,0,1108,1109,1,0,0,0,1109,1111,1,0,0,0,1110,1091,
        1,0,0,0,1110,1100,1,0,0,0,1111,149,1,0,0,0,1112,1113,5,172,0,0,1113,
        1114,3,154,77,0,1114,1115,5,124,0,0,1115,1119,3,248,124,0,1116,1118,
        3,152,76,0,1117,1116,1,0,0,0,1118,1121,1,0,0,0,1119,1117,1,0,0,0,
        1119,1120,1,0,0,0,1120,151,1,0,0,0,1121,1119,1,0,0,0,1122,1123,5,
        212,0,0,1123,1124,3,154,77,0,1124,1125,5,124,0,0,1125,1126,3,248,
        124,0,1126,153,1,0,0,0,1127,1128,3,24,12,0,1128,155,1,0,0,0,1129,
        1130,5,95,0,0,1130,1140,3,32,16,0,1131,1141,3,158,79,0,1132,1138,
        3,162,81,0,1133,1135,3,164,82,0,1134,1136,5,275,0,0,1135,1134,1,
        0,0,0,1135,1136,1,0,0,0,1136,1139,1,0,0,0,1137,1139,5,275,0,0,1138,
        1133,1,0,0,0,1138,1137,1,0,0,0,1138,1139,1,0,0,0,1139,1141,1,0,0,
        0,1140,1131,1,0,0,0,1140,1132,1,0,0,0,1141,157,1,0,0,0,1142,1143,
        3,160,80,0,1143,1145,5,92,0,0,1144,1146,5,275,0,0,1145,1144,1,0,
        0,0,1145,1146,1,0,0,0,1146,159,1,0,0,0,1147,1148,5,208,0,0,1148,
        1149,3,32,16,0,1149,1150,5,240,0,0,1150,1151,5,120,0,0,1151,1152,
        3,32,16,0,1152,161,1,0,0,0,1153,1155,7,20,0,0,1154,1153,1,0,0,0,
        1154,1155,1,0,0,0,1155,1156,1,0,0,0,1156,1157,3,32,16,0,1157,1158,
        5,94,0,0,1158,163,1,0,0,0,1159,1162,5,111,0,0,1160,1163,3,246,123,
        0,1161,1163,3,166,83,0,1162,1160,1,0,0,0,1162,1161,1,0,0,0,1163,
        165,1,0,0,0,1164,1165,5,46,0,0,1165,1166,3,168,84,0,1166,1167,7,
        21,0,0,1167,1168,5,40,0,0,1168,1170,5,276,0,0,1169,1171,3,170,85,
        0,1170,1169,1,0,0,0,1171,1172,1,0,0,0,1172,1170,1,0,0,0,1172,1173,
        1,0,0,0,1173,1207,1,0,0,0,1174,1179,3,178,89,0,1175,1179,5,215,0,
        0,1176,1179,5,213,0,0,1177,1179,5,248,0,0,1178,1174,1,0,0,0,1178,
        1175,1,0,0,0,1178,1176,1,0,0,0,1178,1177,1,0,0,0,1179,1180,1,0,0,
        0,1180,1181,5,118,0,0,1181,1182,3,168,84,0,1182,1183,7,21,0,0,1183,
        1184,5,150,0,0,1184,1186,5,276,0,0,1185,1187,3,170,85,0,1186,1185,
        1,0,0,0,1187,1188,1,0,0,0,1188,1186,1,0,0,0,1188,1189,1,0,0,0,1189,
        1207,1,0,0,0,1190,1195,3,178,89,0,1191,1195,5,215,0,0,1192,1195,
        5,213,0,0,1193,1195,5,248,0,0,1194,1190,1,0,0,0,1194,1191,1,0,0,
        0,1194,1192,1,0,0,0,1194,1193,1,0,0,0,1195,1196,1,0,0,0,1196,1197,
        5,150,0,0,1197,1198,5,118,0,0,1198,1199,3,168,84,0,1199,1200,7,21,
        0,0,1200,1202,5,276,0,0,1201,1203,3,170,85,0,1202,1201,1,0,0,0,1203,
        1204,1,0,0,0,1204,1202,1,0,0,0,1204,1205,1,0,0,0,1205,1207,1,0,0,
        0,1206,1164,1,0,0,0,1206,1178,1,0,0,0,1206,1194,1,0,0,0,1207,167,
        1,0,0,0,1208,1223,5,120,0,0,1209,1223,5,199,0,0,1210,1211,7,22,0,
        0,1211,1212,7,23,0,0,1212,1213,5,240,0,0,1213,1223,5,208,0,0,1214,
        1215,5,155,0,0,1215,1216,7,23,0,0,1216,1217,5,240,0,0,1217,1223,
        5,208,0,0,1218,1219,5,156,0,0,1219,1220,7,23,0,0,1220,1221,5,240,
        0,0,1221,1223,5,208,0,0,1222,1208,1,0,0,0,1222,1209,1,0,0,0,1222,
        1210,1,0,0,0,1222,1214,1,0,0,0,1222,1218,1,0,0,0,1223,169,1,0,0,
        0,1224,1227,3,172,86,0,1225,1228,3,174,87,0,1226,1228,3,176,88,0,
        1227,1225,1,0,0,0,1227,1226,1,0,0,0,1228,171,1,0,0,0,1229,1231,7,
        24,0,0,1230,1229,1,0,0,0,1231,1232,1,0,0,0,1232,1230,1,0,0,0,1232,
        1233,1,0,0,0,1233,173,1,0,0,0,1234,1235,3,246,123,0,1235,175,1,0,
        0,0,1236,1240,3,178,89,0,1237,1240,5,215,0,0,1238,1240,5,248,0,0,
        1239,1236,1,0,0,0,1239,1237,1,0,0,0,1239,1238,1,0,0,0,1240,1241,
        1,0,0,0,1241,1242,5,150,0,0,1242,1243,5,118,0,0,1243,1244,3,168,
        84,0,1244,1245,7,21,0,0,1245,1247,5,276,0,0,1246,1248,3,170,85,0,
        1247,1246,1,0,0,0,1248,1249,1,0,0,0,1249,1247,1,0,0,0,1249,1250,
        1,0,0,0,1250,177,1,0,0,0,1251,1254,3,182,91,0,1252,1253,7,25,0,0,
        1253,1255,3,200,100,0,1254,1252,1,0,0,0,1254,1255,1,0,0,0,1255,179,
        1,0,0,0,1256,1259,3,184,92,0,1257,1258,7,25,0,0,1258,1260,3,200,
        100,0,1259,1257,1,0,0,0,1259,1260,1,0,0,0,1260,181,1,0,0,0,1261,
        1267,3,186,93,0,1262,1263,3,38,19,0,1263,1264,3,186,93,0,1264,1266,
        1,0,0,0,1265,1262,1,0,0,0,1266,1269,1,0,0,0,1267,1265,1,0,0,0,1267,
        1268,1,0,0,0,1268,183,1,0,0,0,1269,1267,1,0,0,0,1270,1276,3,188,
        94,0,1271,1272,3,38,19,0,1272,1273,3,188,94,0,1273,1275,1,0,0,0,
        1274,1271,1,0,0,0,1275,1278,1,0,0,0,1276,1274,1,0,0,0,1276,1277,
        1,0,0,0,1277,185,1,0,0,0,1278,1276,1,0,0,0,1279,1281,7,3,0,0,1280,
        1282,3,20,10,0,1281,1280,1,0,0,0,1282,1283,1,0,0,0,1283,1281,1,0,
        0,0,1283,1284,1,0,0,0,1284,1287,1,0,0,0,1285,1287,5,215,0,0,1286,
        1279,1,0,0,0,1286,1285,1,0,0,0,1287,187,1,0,0,0,1288,1290,7,3,0,
        0,1289,1291,3,28,14,0,1290,1289,1,0,0,0,1291,1292,1,0,0,0,1292,1290,
        1,0,0,0,1292,1293,1,0,0,0,1293,1296,1,0,0,0,1294,1296,5,215,0,0,
        1295,1288,1,0,0,0,1295,1294,1,0,0,0,1296,189,1,0,0,0,1297,1298,3,
        192,96,0,1298,1299,5,240,0,0,1299,1300,3,178,89,0,1300,191,1,0,0,
        0,1301,1302,3,36,18,0,1302,193,1,0,0,0,1303,1305,3,38,19,0,1304,
        1303,1,0,0,0,1304,1305,1,0,0,0,1305,1306,1,0,0,0,1306,1307,3,34,
        17,0,1307,195,1,0,0,0,1308,1310,3,38,19,0,1309,1308,1,0,0,0,1309,
        1310,1,0,0,0,1310,1312,1,0,0,0,1311,1313,7,18,0,0,1312,1311,1,0,
        0,0,1312,1313,1,0,0,0,1313,1315,1,0,0,0,1314,1316,3,28,14,0,1315,
        1314,1,0,0,0,1316,1317,1,0,0,0,1317,1315,1,0,0,0,1317,1318,1,0,0,
        0,1318,197,1,0,0,0,1319,1320,5,117,0,0,1320,1321,3,32,16,0,1321,
        199,1,0,0,0,1322,1325,3,202,101,0,1323,1325,3,218,109,0,1324,1322,
        1,0,0,0,1324,1323,1,0,0,0,1325,201,1,0,0,0,1326,1332,3,210,105,0,
        1327,1332,3,204,102,0,1328,1332,3,212,106,0,1329,1332,3,214,107,
        0,1330,1332,3,216,108,0,1331,1326,1,0,0,0,1331,1327,1,0,0,0,1331,
        1328,1,0,0,0,1331,1329,1,0,0,0,1331,1330,1,0,0,0,1332,203,1,0,0,
        0,1333,1334,3,206,103,0,1334,205,1,0,0,0,1335,1337,5,211,0,0,1336,
        1335,1,0,0,0,1336,1337,1,0,0,0,1337,1340,1,0,0,0,1338,1341,3,194,
        97,0,1339,1341,3,208,104,0,1340,1338,1,0,0,0,1340,1339,1,0,0,0,1341,
        1342,1,0,0,0,1342,1343,7,26,0,0,1343,207,1,0,0,0,1344,1345,3,32,
        16,0,1345,209,1,0,0,0,1346,1348,5,211,0,0,1347,1346,1,0,0,0,1347,
        1348,1,0,0,0,1348,1349,1,0,0,0,1349,1350,3,32,16,0,1350,1351,5,109,
        0,0,1351,1352,3,258,129,0,1352,1353,3,246,123,0,1353,211,1,0,0,0,
        1354,1355,3,228,114,0,1355,1356,3,234,117,0,1356,213,1,0,0,0,1357,
        1358,3,230,115,0,1358,1359,3,236,118,0,1359,215,1,0,0,0,1360,1361,
        3,232,116,0,1361,1362,3,238,119,0,1362,217,1,0,0,0,1363,1364,5,118,
        0,0,1364,1365,3,168,84,0,1365,1366,5,243,0,0,1366,1367,7,27,0,0,
        1367,1368,7,28,0,0,1368,1370,5,276,0,0,1369,1371,3,220,110,0,1370,
        1369,1,0,0,0,1371,1372,1,0,0,0,1372,1370,1,0,0,0,1372,1373,1,0,0,
        0,1373,219,1,0,0,0,1374,1375,3,172,86,0,1375,1376,3,222,111,0,1376,
        1381,1,0,0,0,1377,1378,3,172,86,0,1378,1379,3,226,113,0,1379,1381,
        1,0,0,0,1380,1374,1,0,0,0,1380,1377,1,0,0,0,1381,221,1,0,0,0,1382,
        1383,3,224,112,0,1383,223,1,0,0,0,1384,1385,3,190,95,0,1385,1386,
        3,258,129,0,1386,1387,3,246,123,0,1387,1396,1,0,0,0,1388,1389,3,
        178,89,0,1389,1390,3,206,103,0,1390,1396,1,0,0,0,1391,1392,3,190,
        95,0,1392,1393,7,29,0,0,1393,1394,3,194,97,0,1394,1396,1,0,0,0,1395,
        1384,1,0,0,0,1395,1388,1,0,0,0,1395,1391,1,0,0,0,1396,225,1,0,0,
        0,1397,1402,5,150,0,0,1398,1402,5,149,0,0,1399,1400,5,291,0,0,1400,
        1402,5,292,0,0,1401,1397,1,0,0,0,1401,1398,1,0,0,0,1401,1399,1,0,
        0,0,1402,1403,1,0,0,0,1403,1404,5,118,0,0,1404,1405,3,168,84,0,1405,
        1406,5,243,0,0,1406,1407,7,27,0,0,1407,1409,5,276,0,0,1408,1410,
        3,220,110,0,1409,1408,1,0,0,0,1410,1411,1,0,0,0,1411,1409,1,0,0,
        0,1411,1412,1,0,0,0,1412,227,1,0,0,0,1413,1414,7,30,0,0,1414,229,
        1,0,0,0,1415,1416,7,31,0,0,1416,231,1,0,0,0,1417,1418,7,32,0,0,1418,
        233,1,0,0,0,1419,1420,3,246,123,0,1420,235,1,0,0,0,1421,1422,3,246,
        123,0,1422,237,1,0,0,0,1423,1424,3,246,123,0,1424,239,1,0,0,0,1425,
        1429,5,107,0,0,1426,1428,3,242,121,0,1427,1426,1,0,0,0,1428,1431,
        1,0,0,0,1429,1427,1,0,0,0,1429,1430,1,0,0,0,1430,1432,1,0,0,0,1431,
        1429,1,0,0,0,1432,1433,5,275,0,0,1433,241,1,0,0,0,1434,1436,7,9,
        0,0,1435,1434,1,0,0,0,1435,1436,1,0,0,0,1436,1437,1,0,0,0,1437,1438,
        5,263,0,0,1438,1439,5,113,0,0,1439,1440,3,244,122,0,1440,243,1,0,
        0,0,1441,1450,3,272,136,0,1442,1445,3,262,131,0,1443,1445,3,266,
        133,0,1444,1442,1,0,0,0,1444,1443,1,0,0,0,1445,1446,1,0,0,0,1446,
        1447,3,272,136,0,1447,1449,1,0,0,0,1448,1444,1,0,0,0,1449,1452,1,
        0,0,0,1450,1448,1,0,0,0,1450,1451,1,0,0,0,1451,245,1,0,0,0,1452,
        1450,1,0,0,0,1453,1454,3,250,125,0,1454,1455,5,274,0,0,1455,1456,
        3,276,138,0,1456,1457,3,274,137,0,1457,1467,1,0,0,0,1458,1459,3,
        250,125,0,1459,1460,5,274,0,0,1460,1461,3,276,138,0,1461,1467,1,
        0,0,0,1462,1463,3,250,125,0,1463,1464,3,274,137,0,1464,1467,1,0,
        0,0,1465,1467,3,250,125,0,1466,1453,1,0,0,0,1466,1458,1,0,0,0,1466,
        1462,1,0,0,0,1466,1465,1,0,0,0,1467,247,1,0,0,0,1468,1469,3,252,
        126,0,1469,1470,5,274,0,0,1470,1471,3,276,138,0,1471,1472,3,274,
        137,0,1472,1482,1,0,0,0,1473,1474,3,252,126,0,1474,1475,5,274,0,
        0,1475,1476,3,276,138,0,1476,1482,1,0,0,0,1477,1478,3,252,126,0,
        1478,1479,3,274,137,0,1479,1482,1,0,0,0,1480,1482,3,252,126,0,1481,
        1468,1,0,0,0,1481,1473,1,0,0,0,1481,1477,1,0,0,0,1481,1480,1,0,0,
        0,1482,249,1,0,0,0,1483,1486,3,252,126,0,1484,1485,7,33,0,0,1485,
        1487,3,250,125,0,1486,1484,1,0,0,0,1486,1487,1,0,0,0,1487,251,1,
        0,0,0,1488,1520,3,308,154,0,1489,1520,3,284,142,0,1490,1491,3,260,
        130,0,1491,1492,5,113,0,0,1492,1493,3,34,17,0,1493,1520,1,0,0,0,
        1494,1495,3,260,130,0,1495,1496,5,110,0,0,1496,1497,3,34,17,0,1497,
        1520,1,0,0,0,1498,1499,3,260,130,0,1499,1500,3,256,128,0,1500,1505,
        3,254,127,0,1501,1502,5,274,0,0,1502,1504,3,254,127,0,1503,1501,
        1,0,0,0,1504,1507,1,0,0,0,1505,1503,1,0,0,0,1505,1506,1,0,0,0,1506,
        1508,1,0,0,0,1507,1505,1,0,0,0,1508,1509,5,225,0,0,1509,1510,3,254,
        127,0,1510,1520,1,0,0,0,1511,1515,3,260,130,0,1512,1513,3,258,129,
        0,1513,1514,3,260,130,0,1514,1516,1,0,0,0,1515,1512,1,0,0,0,1515,
        1516,1,0,0,0,1516,1520,1,0,0,0,1517,1520,3,304,152,0,1518,1520,3,
        306,153,0,1519,1488,1,0,0,0,1519,1489,1,0,0,0,1519,1490,1,0,0,0,
        1519,1494,1,0,0,0,1519,1498,1,0,0,0,1519,1511,1,0,0,0,1519,1517,
        1,0,0,0,1519,1518,1,0,0,0,1520,253,1,0,0,0,1521,1531,5,269,0,0,1522,
        1531,5,268,0,0,1523,1525,5,264,0,0,1524,1526,3,84,42,0,1525,1524,
        1,0,0,0,1525,1526,1,0,0,0,1526,1531,1,0,0,0,1527,1531,5,267,0,0,
        1528,1531,3,40,20,0,1529,1531,3,18,9,0,1530,1521,1,0,0,0,1530,1522,
        1,0,0,0,1530,1523,1,0,0,0,1530,1527,1,0,0,0,1530,1528,1,0,0,0,1530,
        1529,1,0,0,0,1531,255,1,0,0,0,1532,1533,7,34,0,0,1533,257,1,0,0,
        0,1534,1535,7,35,0,0,1535,259,1,0,0,0,1536,1542,3,264,132,0,1537,
        1538,3,262,131,0,1538,1539,3,264,132,0,1539,1541,1,0,0,0,1540,1537,
        1,0,0,0,1541,1544,1,0,0,0,1542,1540,1,0,0,0,1542,1543,1,0,0,0,1543,
        261,1,0,0,0,1544,1542,1,0,0,0,1545,1546,7,36,0,0,1546,263,1,0,0,
        0,1547,1553,3,268,134,0,1548,1549,3,266,133,0,1549,1550,3,268,134,
        0,1550,1552,1,0,0,0,1551,1548,1,0,0,0,1552,1555,1,0,0,0,1553,1551,
        1,0,0,0,1553,1554,1,0,0,0,1554,265,1,0,0,0,1555,1553,1,0,0,0,1556,
        1557,7,37,0,0,1557,267,1,0,0,0,1558,1564,3,272,136,0,1559,1560,3,
        270,135,0,1560,1561,3,272,136,0,1561,1563,1,0,0,0,1562,1559,1,0,
        0,0,1563,1566,1,0,0,0,1564,1562,1,0,0,0,1564,1565,1,0,0,0,1565,269,
        1,0,0,0,1566,1564,1,0,0,0,1567,1568,7,38,0,0,1568,271,1,0,0,0,1569,
        1570,6,136,-1,0,1570,1571,5,133,0,0,1571,1834,3,272,136,58,1572,
        1573,5,288,0,0,1573,1834,3,272,136,57,1574,1575,5,136,0,0,1575,1834,
        3,272,136,56,1576,1577,5,11,0,0,1577,1578,3,272,136,0,1578,1579,
        5,142,0,0,1579,1582,3,272,136,0,1580,1581,5,188,0,0,1581,1583,3,
        84,42,0,1582,1580,1,0,0,0,1582,1583,1,0,0,0,1583,1834,1,0,0,0,1584,
        1585,5,192,0,0,1585,1586,3,272,136,0,1586,1587,5,142,0,0,1587,1590,
        3,272,136,0,1588,1589,5,188,0,0,1589,1591,3,84,42,0,1590,1588,1,
        0,0,0,1590,1591,1,0,0,0,1591,1834,1,0,0,0,1592,1593,5,191,0,0,1593,
        1598,3,272,136,0,1594,1595,5,274,0,0,1595,1597,3,272,136,0,1596,
        1594,1,0,0,0,1597,1600,1,0,0,0,1598,1596,1,0,0,0,1598,1599,1,0,0,
        0,1599,1601,1,0,0,0,1600,1598,1,0,0,0,1601,1602,5,212,0,0,1602,1603,
        3,272,136,53,1603,1834,1,0,0,0,1604,1605,5,191,0,0,1605,1606,5,120,
        0,0,1606,1834,3,32,16,0,1607,1608,5,191,0,0,1608,1609,5,120,0,0,
        1609,1834,3,190,95,0,1610,1611,5,213,0,0,1611,1612,5,186,0,0,1612,
        1613,5,120,0,0,1613,1834,3,32,16,0,1614,1615,5,213,0,0,1615,1616,
        5,186,0,0,1616,1834,3,178,89,0,1617,1618,5,186,0,0,1618,1619,5,120,
        0,0,1619,1834,3,32,16,0,1620,1621,5,186,0,0,1621,1834,3,178,89,0,
        1622,1623,5,213,0,0,1623,1624,5,186,0,0,1624,1834,3,190,95,0,1625,
        1626,5,186,0,0,1626,1834,3,190,95,0,1627,1630,5,264,0,0,1628,1631,
        5,279,0,0,1629,1631,5,263,0,0,1630,1628,1,0,0,0,1630,1629,1,0,0,
        0,1631,1634,1,0,0,0,1632,1634,5,267,0,0,1633,1627,1,0,0,0,1633,1632,
        1,0,0,0,1634,1635,1,0,0,0,1635,1636,5,240,0,0,1636,1834,3,272,136,
        44,1637,1638,5,267,0,0,1638,1639,5,240,0,0,1639,1834,3,272,136,43,
        1640,1641,5,30,0,0,1641,1646,3,272,136,0,1642,1643,5,274,0,0,1643,
        1645,3,272,136,0,1644,1642,1,0,0,0,1645,1648,1,0,0,0,1646,1644,1,
        0,0,0,1646,1647,1,0,0,0,1647,1649,1,0,0,0,1648,1646,1,0,0,0,1649,
        1650,7,33,0,0,1650,1651,3,272,136,39,1651,1834,1,0,0,0,1652,1653,
        5,152,0,0,1653,1834,3,272,136,37,1654,1655,5,12,0,0,1655,1656,5,
        270,0,0,1656,1657,3,246,123,0,1657,1658,5,271,0,0,1658,1834,1,0,
        0,0,1659,1660,5,14,0,0,1660,1665,3,272,136,0,1661,1662,5,274,0,0,
        1662,1664,3,272,136,0,1663,1661,1,0,0,0,1664,1667,1,0,0,0,1665,1663,
        1,0,0,0,1665,1666,1,0,0,0,1666,1668,1,0,0,0,1667,1665,1,0,0,0,1668,
        1669,5,212,0,0,1669,1670,3,272,136,35,1670,1834,1,0,0,0,1671,1672,
        5,14,0,0,1672,1673,5,120,0,0,1673,1834,3,190,95,0,1674,1675,5,13,
        0,0,1675,1680,3,272,136,0,1676,1677,5,274,0,0,1677,1679,3,272,136,
        0,1678,1676,1,0,0,0,1679,1682,1,0,0,0,1680,1678,1,0,0,0,1680,1681,
        1,0,0,0,1681,1683,1,0,0,0,1682,1680,1,0,0,0,1683,1684,5,212,0,0,
        1684,1685,3,272,136,33,1685,1834,1,0,0,0,1686,1687,5,13,0,0,1687,
        1688,5,120,0,0,1688,1834,3,190,95,0,1689,1690,5,213,0,0,1690,1691,
        5,217,0,0,1691,1692,5,237,0,0,1692,1834,3,272,136,31,1693,1694,5,
        208,0,0,1694,1695,5,220,0,0,1695,1696,5,237,0,0,1696,1834,3,272,
        136,30,1697,1698,5,208,0,0,1698,1699,5,205,0,0,1699,1700,5,237,0,
        0,1700,1834,3,272,136,29,1701,1702,5,17,0,0,1702,1703,5,270,0,0,
        1703,1704,3,272,136,0,1704,1705,5,274,0,0,1705,1706,3,272,136,0,
        1706,1707,5,274,0,0,1707,1708,3,272,136,0,1708,1709,5,271,0,0,1709,
        1834,1,0,0,0,1710,1711,5,18,0,0,1711,1712,5,270,0,0,1712,1713,3,
        272,136,0,1713,1714,5,271,0,0,1714,1834,1,0,0,0,1715,1716,5,187,
        0,0,1716,1721,3,272,136,0,1717,1718,5,274,0,0,1718,1720,3,272,136,
        0,1719,1717,1,0,0,0,1720,1723,1,0,0,0,1721,1719,1,0,0,0,1721,1722,
        1,0,0,0,1722,1724,1,0,0,0,1723,1721,1,0,0,0,1724,1725,5,212,0,0,
        1725,1726,3,272,136,25,1726,1834,1,0,0,0,1727,1728,5,189,0,0,1728,
        1733,3,272,136,0,1729,1730,5,274,0,0,1730,1732,3,272,136,0,1731,
        1729,1,0,0,0,1732,1735,1,0,0,0,1733,1731,1,0,0,0,1733,1734,1,0,0,
        0,1734,1736,1,0,0,0,1735,1733,1,0,0,0,1736,1737,5,212,0,0,1737,1738,
        3,272,136,24,1738,1834,1,0,0,0,1739,1740,5,15,0,0,1740,1742,3,246,
        123,0,1741,1743,3,282,141,0,1742,1741,1,0,0,0,1742,1743,1,0,0,0,
        1743,1834,1,0,0,0,1744,1745,5,213,0,0,1745,1746,5,186,0,0,1746,1747,
        5,206,0,0,1747,1756,5,216,0,0,1748,1750,5,208,0,0,1749,1748,1,0,
        0,0,1749,1750,1,0,0,0,1750,1751,1,0,0,0,1751,1757,5,220,0,0,1752,
        1754,5,213,0,0,1753,1752,1,0,0,0,1753,1754,1,0,0,0,1754,1755,1,0,
        0,0,1755,1757,5,217,0,0,1756,1749,1,0,0,0,1756,1753,1,0,0,0,1757,
        1758,1,0,0,0,1758,1759,5,207,0,0,1759,1834,3,246,123,0,1760,1762,
        3,18,9,0,1761,1760,1,0,0,0,1762,1763,1,0,0,0,1763,1761,1,0,0,0,1763,
        1764,1,0,0,0,1764,1765,1,0,0,0,1765,1766,5,15,0,0,1766,1768,3,246,
        123,0,1767,1769,3,282,141,0,1768,1767,1,0,0,0,1768,1769,1,0,0,0,
        1769,1834,1,0,0,0,1770,1771,5,16,0,0,1771,1772,7,39,0,0,1772,1773,
        5,240,0,0,1773,1775,3,246,123,0,1774,1776,3,282,141,0,1775,1774,
        1,0,0,0,1775,1776,1,0,0,0,1776,1834,1,0,0,0,1777,1779,3,18,9,0,1778,
        1777,1,0,0,0,1779,1780,1,0,0,0,1780,1778,1,0,0,0,1780,1781,1,0,0,
        0,1781,1782,1,0,0,0,1782,1783,5,16,0,0,1783,1784,7,39,0,0,1784,1785,
        5,240,0,0,1785,1787,3,246,123,0,1786,1788,3,282,141,0,1787,1786,
        1,0,0,0,1787,1788,1,0,0,0,1788,1834,1,0,0,0,1789,1792,3,292,146,
        0,1790,1792,3,294,147,0,1791,1789,1,0,0,0,1791,1790,1,0,0,0,1792,
        1793,1,0,0,0,1793,1794,3,192,96,0,1794,1795,3,296,148,0,1795,1834,
        1,0,0,0,1796,1799,3,292,146,0,1797,1799,3,294,147,0,1798,1796,1,
        0,0,0,1798,1797,1,0,0,0,1799,1802,1,0,0,0,1800,1803,3,198,99,0,1801,
        1803,3,190,95,0,1802,1800,1,0,0,0,1802,1801,1,0,0,0,1803,1804,1,
        0,0,0,1804,1805,5,146,0,0,1805,1806,3,32,16,0,1806,1807,5,236,0,
        0,1807,1809,3,32,16,0,1808,1810,5,275,0,0,1809,1808,1,0,0,0,1809,
        1810,1,0,0,0,1810,1834,1,0,0,0,1811,1813,5,264,0,0,1812,1814,3,84,
        42,0,1813,1812,1,0,0,0,1813,1814,1,0,0,0,1814,1834,1,0,0,0,1815,
        1834,5,231,0,0,1816,1834,3,18,9,0,1817,1834,3,198,99,0,1818,1834,
        3,190,95,0,1819,1834,3,178,89,0,1820,1834,3,32,16,0,1821,1834,3,
        106,53,0,1822,1834,5,267,0,0,1823,1834,5,268,0,0,1824,1834,5,269,
        0,0,1825,1834,3,40,20,0,1826,1834,5,245,0,0,1827,1834,5,226,0,0,
        1828,1834,5,215,0,0,1829,1830,5,270,0,0,1830,1831,3,246,123,0,1831,
        1832,5,271,0,0,1832,1834,1,0,0,0,1833,1569,1,0,0,0,1833,1572,1,0,
        0,0,1833,1574,1,0,0,0,1833,1576,1,0,0,0,1833,1584,1,0,0,0,1833,1592,
        1,0,0,0,1833,1604,1,0,0,0,1833,1607,1,0,0,0,1833,1610,1,0,0,0,1833,
        1614,1,0,0,0,1833,1617,1,0,0,0,1833,1620,1,0,0,0,1833,1622,1,0,0,
        0,1833,1625,1,0,0,0,1833,1633,1,0,0,0,1833,1637,1,0,0,0,1833,1640,
        1,0,0,0,1833,1652,1,0,0,0,1833,1654,1,0,0,0,1833,1659,1,0,0,0,1833,
        1671,1,0,0,0,1833,1674,1,0,0,0,1833,1686,1,0,0,0,1833,1689,1,0,0,
        0,1833,1693,1,0,0,0,1833,1697,1,0,0,0,1833,1701,1,0,0,0,1833,1710,
        1,0,0,0,1833,1715,1,0,0,0,1833,1727,1,0,0,0,1833,1739,1,0,0,0,1833,
        1744,1,0,0,0,1833,1761,1,0,0,0,1833,1770,1,0,0,0,1833,1778,1,0,0,
        0,1833,1791,1,0,0,0,1833,1798,1,0,0,0,1833,1811,1,0,0,0,1833,1815,
        1,0,0,0,1833,1816,1,0,0,0,1833,1817,1,0,0,0,1833,1818,1,0,0,0,1833,
        1819,1,0,0,0,1833,1820,1,0,0,0,1833,1821,1,0,0,0,1833,1822,1,0,0,
        0,1833,1823,1,0,0,0,1833,1824,1,0,0,0,1833,1825,1,0,0,0,1833,1826,
        1,0,0,0,1833,1827,1,0,0,0,1833,1828,1,0,0,0,1833,1829,1,0,0,0,1834,
        1862,1,0,0,0,1835,1838,10,38,0,0,1836,1837,5,274,0,0,1837,1839,3,
        272,136,0,1838,1836,1,0,0,0,1839,1840,1,0,0,0,1840,1838,1,0,0,0,
        1840,1841,1,0,0,0,1841,1842,1,0,0,0,1842,1843,7,33,0,0,1843,1844,
        3,272,136,39,1844,1861,1,0,0,0,1845,1846,10,42,0,0,1846,1861,3,274,
        137,0,1847,1848,10,41,0,0,1848,1849,5,274,0,0,1849,1850,3,276,138,
        0,1850,1851,3,274,137,0,1851,1861,1,0,0,0,1852,1853,10,40,0,0,1853,
        1854,5,274,0,0,1854,1861,3,276,138,0,1855,1856,10,26,0,0,1856,1857,
        7,40,0,0,1857,1858,3,272,136,0,1858,1859,3,44,22,0,1859,1861,1,0,
        0,0,1860,1835,1,0,0,0,1860,1845,1,0,0,0,1860,1847,1,0,0,0,1860,1852,
        1,0,0,0,1860,1855,1,0,0,0,1861,1864,1,0,0,0,1862,1860,1,0,0,0,1862,
        1863,1,0,0,0,1863,273,1,0,0,0,1864,1862,1,0,0,0,1865,1866,7,41,0,
        0,1866,1867,5,119,0,0,1867,1868,5,264,0,0,1868,1869,5,165,0,0,1869,
        275,1,0,0,0,1870,1877,3,278,139,0,1871,1877,3,280,140,0,1872,1873,
        3,278,139,0,1873,1874,5,212,0,0,1874,1875,3,280,140,0,1875,1877,
        1,0,0,0,1876,1870,1,0,0,0,1876,1871,1,0,0,0,1876,1872,1,0,0,0,1877,
        277,1,0,0,0,1878,1879,5,20,0,0,1879,1880,3,246,123,0,1880,279,1,
        0,0,0,1881,1882,5,21,0,0,1882,1883,3,246,123,0,1883,281,1,0,0,0,
        1884,1885,5,4,0,0,1885,1888,3,246,123,0,1886,1888,3,286,143,0,1887,
        1884,1,0,0,0,1887,1886,1,0,0,0,1888,283,1,0,0,0,1889,1890,5,7,0,
        0,1890,1891,3,286,143,0,1891,285,1,0,0,0,1892,1893,5,146,0,0,1893,
        1909,3,238,119,0,1894,1895,5,240,0,0,1895,1896,3,238,119,0,1896,
        1897,5,142,0,0,1897,1898,3,238,119,0,1898,1909,1,0,0,0,1899,1900,
        5,240,0,0,1900,1901,3,238,119,0,1901,1902,5,144,0,0,1902,1903,3,
        238,119,0,1903,1909,1,0,0,0,1904,1905,5,142,0,0,1905,1909,3,238,
        119,0,1906,1907,5,144,0,0,1907,1909,3,238,119,0,1908,1892,1,0,0,
        0,1908,1894,1,0,0,0,1908,1899,1,0,0,0,1908,1904,1,0,0,0,1908,1906,
        1,0,0,0,1909,287,1,0,0,0,1910,1911,5,146,0,0,1911,1927,3,290,145,
        0,1912,1913,5,142,0,0,1913,1927,3,290,145,0,1914,1915,5,144,0,0,
        1915,1927,3,290,145,0,1916,1917,5,240,0,0,1917,1918,3,290,145,0,
        1918,1919,5,142,0,0,1919,1920,3,290,145,0,1920,1927,1,0,0,0,1921,
        1922,5,240,0,0,1922,1923,3,290,145,0,1923,1924,5,144,0,0,1924,1925,
        3,290,145,0,1925,1927,1,0,0,0,1926,1910,1,0,0,0,1926,1912,1,0,0,
        0,1926,1914,1,0,0,0,1926,1916,1,0,0,0,1926,1921,1,0,0,0,1927,289,
        1,0,0,0,1928,1933,3,40,20,0,1929,1933,5,231,0,0,1930,1933,5,232,
        0,0,1931,1933,3,190,95,0,1932,1928,1,0,0,0,1932,1929,1,0,0,0,1932,
        1930,1,0,0,0,1932,1931,1,0,0,0,1933,291,1,0,0,0,1934,1935,5,213,
        0,0,1935,1941,5,186,0,0,1936,1941,5,186,0,0,1937,1941,5,13,0,0,1938,
        1941,5,14,0,0,1939,1941,5,191,0,0,1940,1934,1,0,0,0,1940,1936,1,
        0,0,0,1940,1937,1,0,0,0,1940,1938,1,0,0,0,1940,1939,1,0,0,0,1941,
        293,1,0,0,0,1942,1943,7,42,0,0,1943,295,1,0,0,0,1944,1948,5,229,
        0,0,1945,1949,3,298,149,0,1946,1949,3,300,150,0,1947,1949,3,302,
        151,0,1948,1945,1,0,0,0,1948,1946,1,0,0,0,1948,1947,1,0,0,0,1949,
        1950,1,0,0,0,1950,1951,5,275,0,0,1951,1955,1,0,0,0,1952,1953,5,240,
        0,0,1953,1955,3,298,149,0,1954,1944,1,0,0,0,1954,1952,1,0,0,0,1955,
        297,1,0,0,0,1956,1957,5,120,0,0,1957,1960,3,32,16,0,1958,1959,7,
        25,0,0,1959,1961,3,200,100,0,1960,1958,1,0,0,0,1960,1961,1,0,0,0,
        1961,299,1,0,0,0,1962,1963,5,208,0,0,1963,1964,3,32,16,0,1964,1965,
        5,146,0,0,1965,1966,3,32,16,0,1966,1967,5,236,0,0,1967,1968,3,32,
        16,0,1968,301,1,0,0,0,1969,1970,5,208,0,0,1970,1971,3,32,16,0,1971,
        1972,5,216,0,0,1972,1973,5,272,0,0,1973,1978,3,32,16,0,1974,1975,
        5,274,0,0,1975,1977,3,32,16,0,1976,1974,1,0,0,0,1977,1980,1,0,0,
        0,1978,1976,1,0,0,0,1978,1979,1,0,0,0,1979,1981,1,0,0,0,1980,1978,
        1,0,0,0,1981,1982,5,212,0,0,1982,1983,3,32,16,0,1983,1984,5,273,
        0,0,1984,303,1,0,0,0,1985,1986,3,272,136,0,1986,1987,7,43,0,0,1987,
        2012,1,0,0,0,1988,1989,3,272,136,0,1989,1990,7,44,0,0,1990,1991,
        5,264,0,0,1991,1992,5,163,0,0,1992,2012,1,0,0,0,1993,1994,3,272,
        136,0,1994,1995,7,45,0,0,1995,1996,3,18,9,0,1996,2012,1,0,0,0,1997,
        1998,3,272,136,0,1998,1999,7,46,0,0,1999,2000,3,18,9,0,2000,2012,
        1,0,0,0,2001,2002,3,272,136,0,2002,2003,7,47,0,0,2003,2004,3,18,
        9,0,2004,2012,1,0,0,0,2005,2006,3,178,89,0,2006,2007,5,92,0,0,2007,
        2012,1,0,0,0,2008,2009,3,272,136,0,2009,2010,5,94,0,0,2010,2012,
        1,0,0,0,2011,1985,1,0,0,0,2011,1988,1,0,0,0,2011,1993,1,0,0,0,2011,
        1997,1,0,0,0,2011,2001,1,0,0,0,2011,2005,1,0,0,0,2011,2008,1,0,0,
        0,2012,305,1,0,0,0,2013,2014,5,233,0,0,2014,2015,3,32,16,0,2015,
        2016,5,93,0,0,2016,2022,1,0,0,0,2017,2018,5,233,0,0,2018,2019,3,
        32,16,0,2019,2020,5,94,0,0,2020,2022,1,0,0,0,2021,2013,1,0,0,0,2021,
        2017,1,0,0,0,2022,307,1,0,0,0,2023,2024,3,178,89,0,2024,2025,3,34,
        17,0,2025,2026,5,110,0,0,2026,2036,1,0,0,0,2027,2028,3,178,89,0,
        2028,2029,3,34,17,0,2029,2030,5,113,0,0,2030,2036,1,0,0,0,2031,2032,
        3,178,89,0,2032,2033,5,113,0,0,2033,2034,3,34,17,0,2034,2036,1,0,
        0,0,2035,2023,1,0,0,0,2035,2027,1,0,0,0,2035,2031,1,0,0,0,2036,309,
        1,0,0,0,2037,2038,5,106,0,0,2038,2046,3,32,16,0,2039,2041,5,174,
        0,0,2040,2042,5,263,0,0,2041,2040,1,0,0,0,2042,2043,1,0,0,0,2043,
        2041,1,0,0,0,2043,2044,1,0,0,0,2044,2045,1,0,0,0,2045,2047,5,271,
        0,0,2046,2039,1,0,0,0,2046,2047,1,0,0,0,2047,2049,1,0,0,0,2048,2050,
        5,277,0,0,2049,2048,1,0,0,0,2049,2050,1,0,0,0,2050,311,1,0,0,0,2051,
        2052,5,268,0,0,2052,313,1,0,0,0,2053,2054,3,246,123,0,2054,2055,
        5,116,0,0,2055,2056,3,246,123,0,2056,2057,5,274,0,0,2057,2060,5,
        26,0,0,2058,2061,3,316,158,0,2059,2061,3,318,159,0,2060,2058,1,0,
        0,0,2060,2059,1,0,0,0,2061,2063,1,0,0,0,2062,2064,3,326,163,0,2063,
        2062,1,0,0,0,2063,2064,1,0,0,0,2064,315,1,0,0,0,2065,2066,3,324,
        162,0,2066,317,1,0,0,0,2067,2068,5,276,0,0,2068,2070,3,320,160,0,
        2069,2071,5,275,0,0,2070,2069,1,0,0,0,2070,2071,1,0,0,0,2071,319,
        1,0,0,0,2072,2076,3,322,161,0,2073,2075,3,322,161,0,2074,2073,1,
        0,0,0,2075,2078,1,0,0,0,2076,2074,1,0,0,0,2076,2077,1,0,0,0,2077,
        321,1,0,0,0,2078,2076,1,0,0,0,2079,2080,5,288,0,0,2080,2082,3,324,
        162,0,2081,2083,7,48,0,0,2082,2081,1,0,0,0,2082,2083,1,0,0,0,2083,
        323,1,0,0,0,2084,2099,5,194,0,0,2085,2086,5,35,0,0,2086,2099,3,246,
        123,0,2087,2088,5,34,0,0,2088,2089,7,49,0,0,2089,2099,3,246,123,
        0,2090,2091,5,33,0,0,2091,2099,3,324,162,0,2092,2093,5,21,0,0,2093,
        2099,3,246,123,0,2094,2095,5,119,0,0,2095,2096,5,264,0,0,2096,2097,
        5,165,0,0,2097,2099,7,50,0,0,2098,2084,1,0,0,0,2098,2085,1,0,0,0,
        2098,2087,1,0,0,0,2098,2090,1,0,0,0,2098,2092,1,0,0,0,2098,2094,
        1,0,0,0,2099,325,1,0,0,0,2100,2101,5,19,0,0,2101,2103,3,246,123,
        0,2102,2104,5,195,0,0,2103,2102,1,0,0,0,2103,2104,1,0,0,0,2104,327,
        1,0,0,0,237,334,336,347,352,361,365,374,378,381,386,389,393,398,
        411,415,419,424,433,438,443,449,455,461,466,472,478,487,489,492,
        497,502,508,514,520,525,531,537,546,548,552,555,560,565,571,577,
        583,588,594,600,602,610,619,628,645,648,651,656,661,666,670,674,
        677,683,687,695,698,701,709,716,723,732,739,747,755,758,765,771,
        782,791,795,799,803,810,816,821,826,834,840,843,858,862,866,869,
        872,880,886,889,897,901,909,918,926,929,934,938,940,945,952,958,
        961,964,969,973,975,981,998,1008,1010,1024,1027,1039,1052,1071,1076,
        1083,1087,1095,1098,1105,1108,1110,1119,1135,1138,1140,1145,1154,
        1162,1172,1178,1188,1194,1204,1206,1222,1227,1232,1239,1249,1254,
        1259,1267,1276,1283,1286,1292,1295,1304,1309,1312,1317,1324,1331,
        1336,1340,1347,1372,1380,1395,1401,1411,1429,1435,1444,1450,1466,
        1481,1486,1505,1515,1519,1525,1530,1542,1553,1564,1582,1590,1598,
        1630,1633,1646,1665,1680,1721,1733,1742,1749,1753,1756,1763,1768,
        1775,1780,1787,1791,1798,1802,1809,1813,1833,1840,1860,1862,1876,
        1887,1908,1926,1932,1940,1948,1954,1960,1978,2011,2021,2035,2043,
        2046,2049,2060,2063,2070,2076,2082,2098,2103
    ]

class RegelSpraakParser ( Parser ):

    grammarFileName = "RegelSpraak.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'(voor het attribuut zonder voorzetsel):'", 
                     "'(na het attribuut met voorzetsel'", "'Datum en tijd in millisecondes'", 
                     "'gedurende de tijd dat'", "'gedurende het gehele'", 
                     "'gedurende de gehele'", "<INVALID>", "'moet berekend worden als'", 
                     "'moet gesteld worden op'", "'moet ge\\u00EFnitialiseerd worden op'", 
                     "'de absolute tijdsduur van'", "'de absolute waarde van'", 
                     "'de maximale waarde van'", "'de minimale waarde van'", 
                     "'het totaal van'", "'het tijdsevenredig deel per'", 
                     "'de datum met jaar, maand en dag'", "'de eerste paasdag van'", 
                     "'Als onverdeelde rest blijft'", "'met een minimum van'", 
                     "'met een maximum van'", "'groter of gelijk aan'", 
                     "'kleiner of gelijk aan'", "'later of gelijk aan'", 
                     "'eerder of gelijk aan'", "'waarbij wordt verdeeld'", 
                     "', bestaande uit de'", "'Wederkerig feittype'", "'is van het type'", 
                     "'de concatenatie van'", "'het volgende criterium:'", 
                     "'volgende criteria:'", "'bij een even groot criterium'", 
                     "'op volgorde van'", "'naar rato van'", "'numeriek met exact'", 
                     "'aan de elfproef'", "'groter is dan'", "'kleiner is dan'", 
                     "'wordt voldaan'", "<INVALID>", "'wordt een nieuw'", 
                     "'aangemaakt'", "'Cre\\u00EBer'", "'nieuwe'", "<INVALID>", 
                     "'gelijk is aan'", "'is gelijk aan'", "'is ongelijk aan'", 
                     "'is kleiner dan'", "'is kleiner of gelijk aan'", "'is groter dan'", 
                     "'is groter of gelijk aan'", "'zijn gelijk aan'", "'zijn ongelijk aan'", 
                     "'zijn groter dan'", "'zijn groter of gelijk aan'", 
                     "'zijn kleiner dan'", "'zijn kleiner of gelijk aan'", 
                     "'is later dan'", "'is later of gelijk aan'", "'is eerder dan'", 
                     "'is eerder of gelijk aan'", "'zijn later dan'", "'zijn later of gelijk aan'", 
                     "'zijn eerder dan'", "'zijn eerder of gelijk aan'", 
                     "'is leeg'", "'is gevuld'", "'zijn leeg'", "'zijn gevuld'", 
                     "'is kenmerk'", "'is rol'", "'zijn kenmerk'", "'zijn rol'", 
                     "'is niet kenmerk'", "'is niet rol'", "'zijn niet kenmerk'", 
                     "'zijn niet rol'", "'voldoet aan de elfproef'", "'voldoen aan de elfproef'", 
                     "'voldoet niet aan de elfproef'", "'voldoen niet aan de elfproef'", 
                     "'is numeriek met exact'", "'is niet numeriek met exact'", 
                     "'zijn numeriek met exact'", "'zijn niet numeriek met exact'", 
                     "'is een dagsoort'", "'zijn een dagsoort'", "'is geen dagsoort'", 
                     "'zijn geen dagsoort'", "'moeten uniek zijn'", "'is gevuurd'", 
                     "'is inconsistent'", "'Consistentieregel'", "'Regel'", 
                     "'Regelgroep'", "'Beslistabel'", "'Objecttype'", "'Domein'", 
                     "'Lijst'", "'Dimensie'", "'Eenheidsysteem'", "'Parameter'", 
                     "'Feittype'", "'Dagsoort'", "'Daarbij geldt:'", "'geldig'", 
                     "'hebben'", "'heeft'", "'indien'", "'is recursief'", 
                     "'is'", "'moet'", "'moeten'", "'wordt verdeeld over'", 
                     "'zijn'", "'aan'", "'afgerond op'", "'alle'", "'eerder dan'", 
                     "'gedeeld door'", "'gedeeld door (ABS)'", "'gelijk aan'", 
                     "'gevuld'", "'gevuurd'", "'groter dan'", "'inconsistent'", 
                     "'kleiner dan'", "'later dan'", "'leeg'", "'maal'", 
                     "'min'", "'naar beneden'", "'naar boven'", "'niet'", 
                     "'ongelijk zijn aan'", "'ongelijk aan'", "'plus'", 
                     "'rekenkundig'", "'richting nul'", "'tot'", "'tot de macht'", 
                     "'tot en met'", "'uniek'", "'vanaf'", "'verenigd met'", 
                     "'verminderd met'", "'voldoen'", "'voldoet'", "'weg van nul'", 
                     "'de wortel van'", "'tenminste'", "'ten minste'", "'ten hoogste'", 
                     "'precies'", "'voorwaarde'", "'voorwaarden'", "'(bezittelijk)'", 
                     "'(bijvoeglijk)'", "'(bezield)'", "'Boolean'", "'cijfers'", 
                     "'Datum in dagen'", "'decimalen'", "'Enumeratie'", 
                     "'gedimensioneerd met'", "'geheel getal'", "'getal'", 
                     "'kenmerk'", "'kenmerken'", "'met'", "'met eenheid'", 
                     "'(mv:'", "'negatief'", "'niet-negatief'", "'Numeriek'", 
                     "'Percentage'", "'positief'", "'rol'", "'rollen'", 
                     "'Tekst'", "'voor elk jaar'", "'voor elke dag'", "'voor elke maand'", 
                     "'aantal'", "'de eerste van'", "'in hele'", "'de laatste van'", 
                     "'reeks van teksten en waarden'", "'de som van'", "'de tijdsduur van'", 
                     "'afnemende'", "'in gelijke delen'", "'over.'", "'toenemende'", 
                     "'drie'", "'\\u00E9\\u00E9n'", "'geen van de'", "'geen'", 
                     "'twee'", "'vier'", "'altijd'", "'bij'", "'dag'", "'dagen'", 
                     "'dat'", "<INVALID>", "'dd.'", "'die'", "<INVALID>", 
                     "'en'", "<INVALID>", "'meerdere'", "'hij'", "'in'", 
                     "'jaar'", "'jaren'", "'kwartaal'", "'maand'", "'maanden'", 
                     "'milliseconde'", "'minuut'", "'minuten'", "'of'", 
                     "'onwaar'", "'op'", "'ouder'", "'over'", "'periode'", 
                     "'Rekendatum'", "'Rekenjaar'", "'regelversie'", "'seconde'", 
                     "'seconden'", "'t/m'", "'uit'", "'uur'", "'uren'", 
                     "'van'", "'volgende voorwaarde'", "'volgende voorwaarden'", 
                     "'volgende'", "'voor'", "'waar'", "'week'", "'weken'", 
                     "'er'", "'meter'", "'kilogram'", "'voet'", "'pond'", 
                     "'mijl'", "'m'", "'kg'", "'s'", "'ft'", "'lb'", "'mi'", 
                     "'\\u20AC'", "'$'", "'\\u00B0'", "<INVALID>", "<INVALID>", 
                     "'='", "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "'('", "')'", "'{'", "'}'", "','", "'.'", "':'", "';'", 
                     "'/'", "'%'", "'\\u2022'", "'*'", "'\\u00AB'", "'\\u00BB'", 
                     "'^'", "'..'", "<INVALID>", "<INVALID>", "'-'", "'|'", 
                     "'n.v.t.'" ]

    symbolicNames = [ "<INVALID>", "VOOR_HET_ATTRIBUUT_ZONDER_VOORZETSEL", 
                      "NA_HET_ATTRIBUUT_MET_VOORZETSEL", "DATUM_TIJD_MILLIS", 
                      "GEDURENDE_DE_TIJD_DAT", "GEDURENDE_HET_GEHELE", "GEDURENDE_DE_GEHELE", 
                      "HET_IS_DE_PERIODE", "WORDT_BEREKEND_ALS", "WORDT_GESTELD_OP", 
                      "WORDT_GEINITIALISEERD_OP", "DE_ABSOLUTE_TIJDSDUUR_VAN", 
                      "DE_ABSOLUTE_WAARDE_VAN", "DE_MAXIMALE_WAARDE_VAN", 
                      "DE_MINIMALE_WAARDE_VAN", "HET_TOTAAL_VAN", "HET_TIJDSEVENREDIG_DEEL_PER", 
                      "DE_DATUM_MET", "DE_EERSTE_PAASDAG_VAN", "ALS_ONVERDEELDE_REST_BLIJFT", 
                      "MET_EEN_MINIMUM_VAN", "MET_EEN_MAXIMUM_VAN", "GROTER_OF_GELIJK_AAN", 
                      "KLEINER_OF_GELIJK_AAN", "LATER_OF_GELIJK_AAN", "EERDER_OF_GELIJK_AAN", 
                      "WAARBIJ_WORDT_VERDEELD", "BESTAANDE_UIT", "WEDERKERIG_FEITTYPE", 
                      "IS_VAN_HET_TYPE", "CONCATENATIE_VAN", "VOLGEND_CRITERIUM", 
                      "VOLGENDE_CRITERIA", "BIJ_EVEN_GROOT_CRITERIUM", "OP_VOLGORDE_VAN", 
                      "NAAR_RATO_VAN", "NUMERIEK_MET_EXACT", "AAN_DE_ELFPROEF", 
                      "GROTER_IS_DAN", "KLEINER_IS_DAN", "WORDT_VOLDAAN", 
                      "ER_WORDT_EEN_NIEUW", "WORDT_EEN_NIEUW", "AANGEMAAKT", 
                      "CREEER", "NIEUWE", "ER_AAN", "GELIJK_IS_AAN", "IS_GELIJK_AAN", 
                      "IS_ONGELIJK_AAN", "IS_KLEINER_DAN", "IS_KLEINER_OF_GELIJK_AAN", 
                      "IS_GROTER_DAN", "IS_GROTER_OF_GELIJK_AAN", "ZIJN_GELIJK_AAN", 
                      "ZIJN_ONGELIJK_AAN", "ZIJN_GROTER_DAN", "ZIJN_GROTER_OF_GELIJK_AAN", 
                      "ZIJN_KLEINER_DAN", "ZIJN_KLEINER_OF_GELIJK_AAN", 
                      "IS_LATER_DAN", "IS_LATER_OF_GELIJK_AAN", "IS_EERDER_DAN", 
                      "IS_EERDER_OF_GELIJK_AAN", "ZIJN_LATER_DAN", "ZIJN_LATER_OF_GELIJK_AAN", 
                      "ZIJN_EERDER_DAN", "ZIJN_EERDER_OF_GELIJK_AAN", "IS_LEEG", 
                      "IS_GEVULD", "ZIJN_LEEG", "ZIJN_GEVULD", "IS_KENMERK", 
                      "IS_ROL", "ZIJN_KENMERK", "ZIJN_ROL", "IS_NIET_KENMERK", 
                      "IS_NIET_ROL", "ZIJN_NIET_KENMERK", "ZIJN_NIET_ROL", 
                      "VOLDOET_AAN_DE_ELFPROEF", "VOLDOEN_AAN_DE_ELFPROEF", 
                      "VOLDOET_NIET_AAN_DE_ELFPROEF", "VOLDOEN_NIET_AAN_DE_ELFPROEF", 
                      "IS_NUMERIEK_MET_EXACT", "IS_NIET_NUMERIEK_MET_EXACT", 
                      "ZIJN_NUMERIEK_MET_EXACT", "ZIJN_NIET_NUMERIEK_MET_EXACT", 
                      "IS_EEN_DAGSOORT", "ZIJN_EEN_DAGSOORT", "IS_GEEN_DAGSOORT", 
                      "ZIJN_GEEN_DAGSOORT", "MOETEN_UNIEK_ZIJN", "IS_GEVUURD", 
                      "IS_INCONSISTENT", "CONSISTENTIEREGEL", "REGEL", "REGELGROEP", 
                      "BESLISTABEL", "OBJECTTYPE", "DOMEIN", "LIJST", "DIMENSIE", 
                      "EENHEIDSYSTEEM", "PARAMETER", "FEITTYPE", "DAGSOORT", 
                      "DAARBIJ_GELDT", "GELDIG", "HEBBEN", "HEEFT", "INDIEN", 
                      "IS_RECURSIEF", "IS", "MOET", "MOETEN", "WORDT_VERDEELD_OVER", 
                      "ZIJN", "AAN", "AFGEROND_OP", "ALLE", "EERDER_DAN", 
                      "GEDEELD_DOOR", "GEDEELD_DOOR_ABS", "GELIJK_AAN", 
                      "GEVULD", "GEVUURD", "GROTER_DAN", "INCONSISTENT", 
                      "KLEINER_DAN", "LATER_DAN", "LEEG", "MAAL", "MIN", 
                      "NAAR_BENEDEN", "NAAR_BOVEN", "NIET", "ONGELIJK_ZIJN_AAN", 
                      "ONGELIJK_AAN", "PLUS", "REKENKUNDIG", "RICHTING_NUL", 
                      "TOT", "TOT_DE_MACHT", "TOT_EN_MET", "UNIEK", "VANAF", 
                      "VERENIGD_MET", "VERMINDERD_MET", "VOLDOEN", "VOLDOET", 
                      "WEG_VAN_NUL", "DE_WORTEL_VAN", "TENMINSTE", "TEN_MINSTE", 
                      "TEN_HOOGSTE", "PRECIES", "VOORWAARDE", "VOORWAARDEN", 
                      "BEZITTELIJK", "BIJVOEGLIJK", "BEZIELD", "BOOLEAN", 
                      "CIJFERS", "DATUM_IN_DAGEN", "DECIMALEN", "ENUMERATIE", 
                      "GEDIMENSIONEERD_MET", "GEHEEL_GETAL", "GETAL", "KENMERK", 
                      "KENMERKEN", "MET", "MET_EENHEID", "MV_START", "NEGATIEF", 
                      "NIET_NEGATIEF", "NUMERIEK", "PERCENTAGE", "POSITIEF", 
                      "ROL", "ROLLEN", "TEKST", "VOOR_ELK_JAAR", "VOOR_ELKE_DAG", 
                      "VOOR_ELKE_MAAND", "AANTAL", "EERSTE_VAN", "IN_HELE", 
                      "LAATSTE_VAN", "REEKS_VAN_TEKSTEN_EN_WAARDEN", "SOM_VAN", 
                      "TIJDSDUUR_VAN", "AFNEMENDE", "IN_GELIJKE_DELEN", 
                      "OVER_VERDELING", "TOENEMENDE", "DRIE_TELWOORD", "EEN_TELWOORD", 
                      "GEEN_VAN_DE", "GEEN", "TWEE_TELWOORD", "VIER_TELWOORD", 
                      "ALTIJD", "BIJ", "DAG", "DAGEN", "DAT", "DE", "DD_PUNT", 
                      "DIE", "EEN", "EN", "HET", "MEERDERE", "HIJ", "IN", 
                      "JAAR", "JAREN", "KWARTAAL", "MAAND", "MAANDEN", "MILLISECONDE", 
                      "MINUUT", "MINUTEN", "OF", "ONWAAR", "OP", "OUDER", 
                      "OVER", "PERIODE", "REKENDATUM", "REKENJAAR", "REGELVERSIE", 
                      "SECONDE", "SECONDEN", "TM", "UIT", "UUR", "UREN", 
                      "VAN", "VOLGENDE_VOORWAARDE", "VOLGENDE_VOORWAARDEN", 
                      "VOLGENDE", "VOOR", "WAAR", "WEEK", "WEKEN", "ER", 
                      "METER", "KILOGRAM", "VOET", "POND", "MIJL", "M", 
                      "KG", "S", "FT", "LB", "MI", "EURO_SYMBOL", "DOLLAR_SYMBOL", 
                      "DEGREE_SYMBOL", "IDENTIFIER", "NUMBER", "EQUALS", 
                      "DATE_TIME_LITERAL", "PERCENTAGE_LITERAL", "STRING_LITERAL", 
                      "ENUM_LITERAL", "LPAREN", "RPAREN", "LBRACE", "RBRACE", 
                      "COMMA", "DOT", "COLON", "SEMICOLON", "SLASH", "PERCENT_SIGN", 
                      "BULLET", "ASTERISK", "L_ANGLE_QUOTE", "R_ANGLE_QUOTE", 
                      "CARET", "DOUBLE_DOT", "WS", "LINE_COMMENT", "MINUS", 
                      "PIPE", "NVT", "WORDT", "VOLDAAN" ]

    RULE_regelSpraakDocument = 0
    RULE_definitie = 1
    RULE_beslistabel = 2
    RULE_beslistabelTable = 3
    RULE_beslistabelHeader = 4
    RULE_beslistabelSeparator = 5
    RULE_beslistabelRow = 6
    RULE_beslistabelCellValue = 7
    RULE_beslistabelColumnText = 8
    RULE_identifier = 9
    RULE_identifierOrKeyword = 10
    RULE_identifierOrKeywordNoIs = 11
    RULE_naamPhrase = 12
    RULE_naamPhraseWithNumbers = 13
    RULE_identifierOrKeywordWithNumbers = 14
    RULE_naamPhraseNoIs = 15
    RULE_naamwoord = 16
    RULE_naamwoordWithNumbers = 17
    RULE_naamwoordNoIs = 18
    RULE_voorzetsel = 19
    RULE_datumLiteral = 20
    RULE_unit = 21
    RULE_timeUnit = 22
    RULE_objectTypeDefinition = 23
    RULE_objectTypeMember = 24
    RULE_kenmerkSpecificatie = 25
    RULE_attribuutSpecificatie = 26
    RULE_datatype = 27
    RULE_lijstDatatype = 28
    RULE_numeriekDatatype = 29
    RULE_tekstDatatype = 30
    RULE_percentageDatatype = 31
    RULE_booleanDatatype = 32
    RULE_datumTijdDatatype = 33
    RULE_getalSpecificatie = 34
    RULE_domeinDefinition = 35
    RULE_domeinType = 36
    RULE_enumeratieSpecificatie = 37
    RULE_domeinRef = 38
    RULE_objectTypeRef = 39
    RULE_eenheidsysteemDefinition = 40
    RULE_eenheidEntry = 41
    RULE_unitIdentifier = 42
    RULE_eenheidExpressie = 43
    RULE_eenheidMacht = 44
    RULE_dimensieDefinition = 45
    RULE_voorzetselSpecificatie = 46
    RULE_labelWaardeSpecificatie = 47
    RULE_tijdlijn = 48
    RULE_dimensieRef = 49
    RULE_parameterDefinition = 50
    RULE_parameterNamePhrase = 51
    RULE_parameterNamePart = 52
    RULE_parameterMetLidwoord = 53
    RULE_feitTypeDefinition = 54
    RULE_rolDefinition = 55
    RULE_rolObjectType = 56
    RULE_rolContentWords = 57
    RULE_cardinalityLine = 58
    RULE_cardinalityWord = 59
    RULE_regel = 60
    RULE_regelGroep = 61
    RULE_regelName = 62
    RULE_regelNameExtension = 63
    RULE_regelVersie = 64
    RULE_versieGeldigheid = 65
    RULE_resultaatDeel = 66
    RULE_consistencyOperator = 67
    RULE_feitCreatiePattern = 68
    RULE_feitCreatieRolPhrase = 69
    RULE_feitCreatieSubjectPhrase = 70
    RULE_feitCreatieSubjectWord = 71
    RULE_feitCreatieWord = 72
    RULE_voorzetselNietVan = 73
    RULE_objectCreatie = 74
    RULE_objectAttributeInit = 75
    RULE_attributeInitVervolg = 76
    RULE_simpleNaamwoord = 77
    RULE_consistentieregel = 78
    RULE_uniekzijnResultaat = 79
    RULE_alleAttributenVanObjecttype = 80
    RULE_inconsistentResultaat = 81
    RULE_voorwaardeDeel = 82
    RULE_toplevelSamengesteldeVoorwaarde = 83
    RULE_voorwaardeKwantificatie = 84
    RULE_samengesteldeVoorwaardeOnderdeel = 85
    RULE_bulletPrefix = 86
    RULE_elementaireVoorwaarde = 87
    RULE_genesteSamengesteldeVoorwaarde = 88
    RULE_onderwerpReferentie = 89
    RULE_onderwerpReferentieWithNumbers = 90
    RULE_onderwerpBasis = 91
    RULE_onderwerpBasisWithNumbers = 92
    RULE_basisOnderwerp = 93
    RULE_basisOnderwerpWithNumbers = 94
    RULE_attribuutReferentie = 95
    RULE_attribuutMetLidwoord = 96
    RULE_kenmerkNaam = 97
    RULE_kenmerkPhrase = 98
    RULE_bezieldeReferentie = 99
    RULE_predicaat = 100
    RULE_elementairPredicaat = 101
    RULE_objectPredicaat = 102
    RULE_eenzijdigeObjectVergelijking = 103
    RULE_rolNaam = 104
    RULE_attribuutVergelijkingsPredicaat = 105
    RULE_getalPredicaat = 106
    RULE_tekstPredicaat = 107
    RULE_datumPredicaat = 108
    RULE_samengesteldPredicaat = 109
    RULE_samengesteldeVoorwaardeOnderdeelInPredicaat = 110
    RULE_elementaireVoorwaardeInPredicaat = 111
    RULE_vergelijkingInPredicaat = 112
    RULE_genesteSamengesteldeVoorwaardeInPredicaat = 113
    RULE_getalVergelijkingsOperatorMeervoud = 114
    RULE_tekstVergelijkingsOperatorMeervoud = 115
    RULE_datumVergelijkingsOperatorMeervoud = 116
    RULE_getalExpressie = 117
    RULE_tekstExpressie = 118
    RULE_datumExpressie = 119
    RULE_variabeleDeel = 120
    RULE_variabeleToekenning = 121
    RULE_variabeleExpressie = 122
    RULE_expressie = 123
    RULE_simpleExpressie = 124
    RULE_logicalExpression = 125
    RULE_comparisonExpression = 126
    RULE_literalValue = 127
    RULE_gelijkIsAanOperator = 128
    RULE_comparisonOperator = 129
    RULE_additiveExpression = 130
    RULE_additiveOperator = 131
    RULE_multiplicativeExpression = 132
    RULE_multiplicativeOperator = 133
    RULE_powerExpression = 134
    RULE_powerOperator = 135
    RULE_primaryExpression = 136
    RULE_afronding = 137
    RULE_begrenzing = 138
    RULE_begrenzingMinimum = 139
    RULE_begrenzingMaximum = 140
    RULE_conditieBijExpressie = 141
    RULE_periodevergelijkingElementair = 142
    RULE_periodevergelijkingEnkelvoudig = 143
    RULE_periodeDefinitie = 144
    RULE_dateExpression = 145
    RULE_getalAggregatieFunctie = 146
    RULE_datumAggregatieFunctie = 147
    RULE_dimensieSelectie = 148
    RULE_aggregerenOverAlleDimensies = 149
    RULE_aggregerenOverVerzameling = 150
    RULE_aggregerenOverBereik = 151
    RULE_unaryCondition = 152
    RULE_regelStatusCondition = 153
    RULE_subordinateClauseExpression = 154
    RULE_dagsoortDefinition = 155
    RULE_tekstreeksExpr = 156
    RULE_verdelingResultaat = 157
    RULE_verdelingMethodeSimple = 158
    RULE_verdelingMethodeMultiLine = 159
    RULE_verdelingMethodeBulletList = 160
    RULE_verdelingMethodeBullet = 161
    RULE_verdelingMethode = 162
    RULE_verdelingRest = 163

    ruleNames =  [ "regelSpraakDocument", "definitie", "beslistabel", "beslistabelTable", 
                   "beslistabelHeader", "beslistabelSeparator", "beslistabelRow", 
                   "beslistabelCellValue", "beslistabelColumnText", "identifier", 
                   "identifierOrKeyword", "identifierOrKeywordNoIs", "naamPhrase", 
                   "naamPhraseWithNumbers", "identifierOrKeywordWithNumbers", 
                   "naamPhraseNoIs", "naamwoord", "naamwoordWithNumbers", 
                   "naamwoordNoIs", "voorzetsel", "datumLiteral", "unit", 
                   "timeUnit", "objectTypeDefinition", "objectTypeMember", 
                   "kenmerkSpecificatie", "attribuutSpecificatie", "datatype", 
                   "lijstDatatype", "numeriekDatatype", "tekstDatatype", 
                   "percentageDatatype", "booleanDatatype", "datumTijdDatatype", 
                   "getalSpecificatie", "domeinDefinition", "domeinType", 
                   "enumeratieSpecificatie", "domeinRef", "objectTypeRef", 
                   "eenheidsysteemDefinition", "eenheidEntry", "unitIdentifier", 
                   "eenheidExpressie", "eenheidMacht", "dimensieDefinition", 
                   "voorzetselSpecificatie", "labelWaardeSpecificatie", 
                   "tijdlijn", "dimensieRef", "parameterDefinition", "parameterNamePhrase", 
                   "parameterNamePart", "parameterMetLidwoord", "feitTypeDefinition", 
                   "rolDefinition", "rolObjectType", "rolContentWords", 
                   "cardinalityLine", "cardinalityWord", "regel", "regelGroep", 
                   "regelName", "regelNameExtension", "regelVersie", "versieGeldigheid", 
                   "resultaatDeel", "consistencyOperator", "feitCreatiePattern", 
                   "feitCreatieRolPhrase", "feitCreatieSubjectPhrase", "feitCreatieSubjectWord", 
                   "feitCreatieWord", "voorzetselNietVan", "objectCreatie", 
                   "objectAttributeInit", "attributeInitVervolg", "simpleNaamwoord", 
                   "consistentieregel", "uniekzijnResultaat", "alleAttributenVanObjecttype", 
                   "inconsistentResultaat", "voorwaardeDeel", "toplevelSamengesteldeVoorwaarde", 
                   "voorwaardeKwantificatie", "samengesteldeVoorwaardeOnderdeel", 
                   "bulletPrefix", "elementaireVoorwaarde", "genesteSamengesteldeVoorwaarde", 
                   "onderwerpReferentie", "onderwerpReferentieWithNumbers", 
                   "onderwerpBasis", "onderwerpBasisWithNumbers", "basisOnderwerp", 
                   "basisOnderwerpWithNumbers", "attribuutReferentie", "attribuutMetLidwoord", 
                   "kenmerkNaam", "kenmerkPhrase", "bezieldeReferentie", 
                   "predicaat", "elementairPredicaat", "objectPredicaat", 
                   "eenzijdigeObjectVergelijking", "rolNaam", "attribuutVergelijkingsPredicaat", 
                   "getalPredicaat", "tekstPredicaat", "datumPredicaat", 
                   "samengesteldPredicaat", "samengesteldeVoorwaardeOnderdeelInPredicaat", 
                   "elementaireVoorwaardeInPredicaat", "vergelijkingInPredicaat", 
                   "genesteSamengesteldeVoorwaardeInPredicaat", "getalVergelijkingsOperatorMeervoud", 
                   "tekstVergelijkingsOperatorMeervoud", "datumVergelijkingsOperatorMeervoud", 
                   "getalExpressie", "tekstExpressie", "datumExpressie", 
                   "variabeleDeel", "variabeleToekenning", "variabeleExpressie", 
                   "expressie", "simpleExpressie", "logicalExpression", 
                   "comparisonExpression", "literalValue", "gelijkIsAanOperator", 
                   "comparisonOperator", "additiveExpression", "additiveOperator", 
                   "multiplicativeExpression", "multiplicativeOperator", 
                   "powerExpression", "powerOperator", "primaryExpression", 
                   "afronding", "begrenzing", "begrenzingMinimum", "begrenzingMaximum", 
                   "conditieBijExpressie", "periodevergelijkingElementair", 
                   "periodevergelijkingEnkelvoudig", "periodeDefinitie", 
                   "dateExpression", "getalAggregatieFunctie", "datumAggregatieFunctie", 
                   "dimensieSelectie", "aggregerenOverAlleDimensies", "aggregerenOverVerzameling", 
                   "aggregerenOverBereik", "unaryCondition", "regelStatusCondition", 
                   "subordinateClauseExpression", "dagsoortDefinition", 
                   "tekstreeksExpr", "verdelingResultaat", "verdelingMethodeSimple", 
                   "verdelingMethodeMultiLine", "verdelingMethodeBulletList", 
                   "verdelingMethodeBullet", "verdelingMethode", "verdelingRest" ]

    EOF = Token.EOF
    VOOR_HET_ATTRIBUUT_ZONDER_VOORZETSEL=1
    NA_HET_ATTRIBUUT_MET_VOORZETSEL=2
    DATUM_TIJD_MILLIS=3
    GEDURENDE_DE_TIJD_DAT=4
    GEDURENDE_HET_GEHELE=5
    GEDURENDE_DE_GEHELE=6
    HET_IS_DE_PERIODE=7
    WORDT_BEREKEND_ALS=8
    WORDT_GESTELD_OP=9
    WORDT_GEINITIALISEERD_OP=10
    DE_ABSOLUTE_TIJDSDUUR_VAN=11
    DE_ABSOLUTE_WAARDE_VAN=12
    DE_MAXIMALE_WAARDE_VAN=13
    DE_MINIMALE_WAARDE_VAN=14
    HET_TOTAAL_VAN=15
    HET_TIJDSEVENREDIG_DEEL_PER=16
    DE_DATUM_MET=17
    DE_EERSTE_PAASDAG_VAN=18
    ALS_ONVERDEELDE_REST_BLIJFT=19
    MET_EEN_MINIMUM_VAN=20
    MET_EEN_MAXIMUM_VAN=21
    GROTER_OF_GELIJK_AAN=22
    KLEINER_OF_GELIJK_AAN=23
    LATER_OF_GELIJK_AAN=24
    EERDER_OF_GELIJK_AAN=25
    WAARBIJ_WORDT_VERDEELD=26
    BESTAANDE_UIT=27
    WEDERKERIG_FEITTYPE=28
    IS_VAN_HET_TYPE=29
    CONCATENATIE_VAN=30
    VOLGEND_CRITERIUM=31
    VOLGENDE_CRITERIA=32
    BIJ_EVEN_GROOT_CRITERIUM=33
    OP_VOLGORDE_VAN=34
    NAAR_RATO_VAN=35
    NUMERIEK_MET_EXACT=36
    AAN_DE_ELFPROEF=37
    GROTER_IS_DAN=38
    KLEINER_IS_DAN=39
    WORDT_VOLDAAN=40
    ER_WORDT_EEN_NIEUW=41
    WORDT_EEN_NIEUW=42
    AANGEMAAKT=43
    CREEER=44
    NIEUWE=45
    ER_AAN=46
    GELIJK_IS_AAN=47
    IS_GELIJK_AAN=48
    IS_ONGELIJK_AAN=49
    IS_KLEINER_DAN=50
    IS_KLEINER_OF_GELIJK_AAN=51
    IS_GROTER_DAN=52
    IS_GROTER_OF_GELIJK_AAN=53
    ZIJN_GELIJK_AAN=54
    ZIJN_ONGELIJK_AAN=55
    ZIJN_GROTER_DAN=56
    ZIJN_GROTER_OF_GELIJK_AAN=57
    ZIJN_KLEINER_DAN=58
    ZIJN_KLEINER_OF_GELIJK_AAN=59
    IS_LATER_DAN=60
    IS_LATER_OF_GELIJK_AAN=61
    IS_EERDER_DAN=62
    IS_EERDER_OF_GELIJK_AAN=63
    ZIJN_LATER_DAN=64
    ZIJN_LATER_OF_GELIJK_AAN=65
    ZIJN_EERDER_DAN=66
    ZIJN_EERDER_OF_GELIJK_AAN=67
    IS_LEEG=68
    IS_GEVULD=69
    ZIJN_LEEG=70
    ZIJN_GEVULD=71
    IS_KENMERK=72
    IS_ROL=73
    ZIJN_KENMERK=74
    ZIJN_ROL=75
    IS_NIET_KENMERK=76
    IS_NIET_ROL=77
    ZIJN_NIET_KENMERK=78
    ZIJN_NIET_ROL=79
    VOLDOET_AAN_DE_ELFPROEF=80
    VOLDOEN_AAN_DE_ELFPROEF=81
    VOLDOET_NIET_AAN_DE_ELFPROEF=82
    VOLDOEN_NIET_AAN_DE_ELFPROEF=83
    IS_NUMERIEK_MET_EXACT=84
    IS_NIET_NUMERIEK_MET_EXACT=85
    ZIJN_NUMERIEK_MET_EXACT=86
    ZIJN_NIET_NUMERIEK_MET_EXACT=87
    IS_EEN_DAGSOORT=88
    ZIJN_EEN_DAGSOORT=89
    IS_GEEN_DAGSOORT=90
    ZIJN_GEEN_DAGSOORT=91
    MOETEN_UNIEK_ZIJN=92
    IS_GEVUURD=93
    IS_INCONSISTENT=94
    CONSISTENTIEREGEL=95
    REGEL=96
    REGELGROEP=97
    BESLISTABEL=98
    OBJECTTYPE=99
    DOMEIN=100
    LIJST=101
    DIMENSIE=102
    EENHEIDSYSTEEM=103
    PARAMETER=104
    FEITTYPE=105
    DAGSOORT=106
    DAARBIJ_GELDT=107
    GELDIG=108
    HEBBEN=109
    HEEFT=110
    INDIEN=111
    IS_RECURSIEF=112
    IS=113
    MOET=114
    MOETEN=115
    WORDT_VERDEELD_OVER=116
    ZIJN=117
    AAN=118
    AFGEROND_OP=119
    ALLE=120
    EERDER_DAN=121
    GEDEELD_DOOR=122
    GEDEELD_DOOR_ABS=123
    GELIJK_AAN=124
    GEVULD=125
    GEVUURD=126
    GROTER_DAN=127
    INCONSISTENT=128
    KLEINER_DAN=129
    LATER_DAN=130
    LEEG=131
    MAAL=132
    MIN=133
    NAAR_BENEDEN=134
    NAAR_BOVEN=135
    NIET=136
    ONGELIJK_ZIJN_AAN=137
    ONGELIJK_AAN=138
    PLUS=139
    REKENKUNDIG=140
    RICHTING_NUL=141
    TOT=142
    TOT_DE_MACHT=143
    TOT_EN_MET=144
    UNIEK=145
    VANAF=146
    VERENIGD_MET=147
    VERMINDERD_MET=148
    VOLDOEN=149
    VOLDOET=150
    WEG_VAN_NUL=151
    DE_WORTEL_VAN=152
    TENMINSTE=153
    TEN_MINSTE=154
    TEN_HOOGSTE=155
    PRECIES=156
    VOORWAARDE=157
    VOORWAARDEN=158
    BEZITTELIJK=159
    BIJVOEGLIJK=160
    BEZIELD=161
    BOOLEAN=162
    CIJFERS=163
    DATUM_IN_DAGEN=164
    DECIMALEN=165
    ENUMERATIE=166
    GEDIMENSIONEERD_MET=167
    GEHEEL_GETAL=168
    GETAL=169
    KENMERK=170
    KENMERKEN=171
    MET=172
    MET_EENHEID=173
    MV_START=174
    NEGATIEF=175
    NIET_NEGATIEF=176
    NUMERIEK=177
    PERCENTAGE=178
    POSITIEF=179
    ROL=180
    ROLLEN=181
    TEKST=182
    VOOR_ELK_JAAR=183
    VOOR_ELKE_DAG=184
    VOOR_ELKE_MAAND=185
    AANTAL=186
    EERSTE_VAN=187
    IN_HELE=188
    LAATSTE_VAN=189
    REEKS_VAN_TEKSTEN_EN_WAARDEN=190
    SOM_VAN=191
    TIJDSDUUR_VAN=192
    AFNEMENDE=193
    IN_GELIJKE_DELEN=194
    OVER_VERDELING=195
    TOENEMENDE=196
    DRIE_TELWOORD=197
    EEN_TELWOORD=198
    GEEN_VAN_DE=199
    GEEN=200
    TWEE_TELWOORD=201
    VIER_TELWOORD=202
    ALTIJD=203
    BIJ=204
    DAG=205
    DAGEN=206
    DAT=207
    DE=208
    DD_PUNT=209
    DIE=210
    EEN=211
    EN=212
    HET=213
    MEERDERE=214
    HIJ=215
    IN=216
    JAAR=217
    JAREN=218
    KWARTAAL=219
    MAAND=220
    MAANDEN=221
    MILLISECONDE=222
    MINUUT=223
    MINUTEN=224
    OF=225
    ONWAAR=226
    OP=227
    OUDER=228
    OVER=229
    PERIODE=230
    REKENDATUM=231
    REKENJAAR=232
    REGELVERSIE=233
    SECONDE=234
    SECONDEN=235
    TM=236
    UIT=237
    UUR=238
    UREN=239
    VAN=240
    VOLGENDE_VOORWAARDE=241
    VOLGENDE_VOORWAARDEN=242
    VOLGENDE=243
    VOOR=244
    WAAR=245
    WEEK=246
    WEKEN=247
    ER=248
    METER=249
    KILOGRAM=250
    VOET=251
    POND=252
    MIJL=253
    M=254
    KG=255
    S=256
    FT=257
    LB=258
    MI=259
    EURO_SYMBOL=260
    DOLLAR_SYMBOL=261
    DEGREE_SYMBOL=262
    IDENTIFIER=263
    NUMBER=264
    EQUALS=265
    DATE_TIME_LITERAL=266
    PERCENTAGE_LITERAL=267
    STRING_LITERAL=268
    ENUM_LITERAL=269
    LPAREN=270
    RPAREN=271
    LBRACE=272
    RBRACE=273
    COMMA=274
    DOT=275
    COLON=276
    SEMICOLON=277
    SLASH=278
    PERCENT_SIGN=279
    BULLET=280
    ASTERISK=281
    L_ANGLE_QUOTE=282
    R_ANGLE_QUOTE=283
    CARET=284
    DOUBLE_DOT=285
    WS=286
    LINE_COMMENT=287
    MINUS=288
    PIPE=289
    NVT=290
    WORDT=291
    VOLDAAN=292

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.13.1")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class RegelSpraakDocumentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOF(self):
            return self.getToken(RegelSpraakParser.EOF, 0)

        def definitie(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.DefinitieContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.DefinitieContext,i)


        def regel(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.RegelContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.RegelContext,i)


        def regelGroep(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.RegelGroepContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.RegelGroepContext,i)


        def beslistabel(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.BeslistabelContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.BeslistabelContext,i)


        def consistentieregel(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.ConsistentieregelContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.ConsistentieregelContext,i)


        def eenheidsysteemDefinition(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.EenheidsysteemDefinitionContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.EenheidsysteemDefinitionContext,i)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_regelSpraakDocument

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRegelSpraakDocument" ):
                listener.enterRegelSpraakDocument(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRegelSpraakDocument" ):
                listener.exitRegelSpraakDocument(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRegelSpraakDocument" ):
                return visitor.visitRegelSpraakDocument(self)
            else:
                return visitor.visitChildren(self)




    def regelSpraakDocument(self):

        localctx = RegelSpraakParser.RegelSpraakDocumentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_regelSpraakDocument)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 336
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==28 or ((((_la - 95)) & ~0x3f) == 0 and ((1 << (_la - 95)) & 4031) != 0):
                self.state = 334
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [28, 99, 100, 102, 104, 105, 106]:
                    self.state = 328
                    self.definitie()
                    pass
                elif token in [96]:
                    self.state = 329
                    self.regel()
                    pass
                elif token in [97]:
                    self.state = 330
                    self.regelGroep()
                    pass
                elif token in [98]:
                    self.state = 331
                    self.beslistabel()
                    pass
                elif token in [95]:
                    self.state = 332
                    self.consistentieregel()
                    pass
                elif token in [103]:
                    self.state = 333
                    self.eenheidsysteemDefinition()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 338
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 339
            self.match(RegelSpraakParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DefinitieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def objectTypeDefinition(self):
            return self.getTypedRuleContext(RegelSpraakParser.ObjectTypeDefinitionContext,0)


        def domeinDefinition(self):
            return self.getTypedRuleContext(RegelSpraakParser.DomeinDefinitionContext,0)


        def parameterDefinition(self):
            return self.getTypedRuleContext(RegelSpraakParser.ParameterDefinitionContext,0)


        def dimensieDefinition(self):
            return self.getTypedRuleContext(RegelSpraakParser.DimensieDefinitionContext,0)


        def feitTypeDefinition(self):
            return self.getTypedRuleContext(RegelSpraakParser.FeitTypeDefinitionContext,0)


        def dagsoortDefinition(self):
            return self.getTypedRuleContext(RegelSpraakParser.DagsoortDefinitionContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_definitie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDefinitie" ):
                listener.enterDefinitie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDefinitie" ):
                listener.exitDefinitie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDefinitie" ):
                return visitor.visitDefinitie(self)
            else:
                return visitor.visitChildren(self)




    def definitie(self):

        localctx = RegelSpraakParser.DefinitieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_definitie)
        try:
            self.state = 347
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [99]:
                self.enterOuterAlt(localctx, 1)
                self.state = 341
                self.objectTypeDefinition()
                pass
            elif token in [100]:
                self.enterOuterAlt(localctx, 2)
                self.state = 342
                self.domeinDefinition()
                pass
            elif token in [104]:
                self.enterOuterAlt(localctx, 3)
                self.state = 343
                self.parameterDefinition()
                pass
            elif token in [102]:
                self.enterOuterAlt(localctx, 4)
                self.state = 344
                self.dimensieDefinition()
                pass
            elif token in [28, 105]:
                self.enterOuterAlt(localctx, 5)
                self.state = 345
                self.feitTypeDefinition()
                pass
            elif token in [106]:
                self.enterOuterAlt(localctx, 6)
                self.state = 346
                self.dagsoortDefinition()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BeslistabelContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BESLISTABEL(self):
            return self.getToken(RegelSpraakParser.BESLISTABEL, 0)

        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def beslistabelTable(self):
            return self.getTypedRuleContext(RegelSpraakParser.BeslistabelTableContext,0)


        def regelVersie(self):
            return self.getTypedRuleContext(RegelSpraakParser.RegelVersieContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_beslistabel

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBeslistabel" ):
                listener.enterBeslistabel(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBeslistabel" ):
                listener.exitBeslistabel(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBeslistabel" ):
                return visitor.visitBeslistabel(self)
            else:
                return visitor.visitChildren(self)




    def beslistabel(self):

        localctx = RegelSpraakParser.BeslistabelContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_beslistabel)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 349
            self.match(RegelSpraakParser.BESLISTABEL)
            self.state = 350
            self.naamwoord()
            self.state = 352
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==108:
                self.state = 351
                self.regelVersie()


            self.state = 354
            self.beslistabelTable()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BeslistabelTableContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def beslistabelHeader(self):
            return self.getTypedRuleContext(RegelSpraakParser.BeslistabelHeaderContext,0)


        def beslistabelSeparator(self):
            return self.getTypedRuleContext(RegelSpraakParser.BeslistabelSeparatorContext,0)


        def beslistabelRow(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.BeslistabelRowContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.BeslistabelRowContext,i)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_beslistabelTable

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBeslistabelTable" ):
                listener.enterBeslistabelTable(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBeslistabelTable" ):
                listener.exitBeslistabelTable(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBeslistabelTable" ):
                return visitor.visitBeslistabelTable(self)
            else:
                return visitor.visitChildren(self)




    def beslistabelTable(self):

        localctx = RegelSpraakParser.BeslistabelTableContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_beslistabelTable)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 356
            self.beslistabelHeader()
            self.state = 357
            self.beslistabelSeparator()
            self.state = 359 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 358
                self.beslistabelRow()
                self.state = 361 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==289):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BeslistabelHeaderContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.resultColumn = None # BeslistabelColumnTextContext
            self._beslistabelColumnText = None # BeslistabelColumnTextContext
            self.conditionColumns = list() # of BeslistabelColumnTextContexts

        def PIPE(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.PIPE)
            else:
                return self.getToken(RegelSpraakParser.PIPE, i)

        def beslistabelColumnText(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.BeslistabelColumnTextContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.BeslistabelColumnTextContext,i)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_beslistabelHeader

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBeslistabelHeader" ):
                listener.enterBeslistabelHeader(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBeslistabelHeader" ):
                listener.exitBeslistabelHeader(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBeslistabelHeader" ):
                return visitor.visitBeslistabelHeader(self)
            else:
                return visitor.visitChildren(self)




    def beslistabelHeader(self):

        localctx = RegelSpraakParser.BeslistabelHeaderContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_beslistabelHeader)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 363
            self.match(RegelSpraakParser.PIPE)
            self.state = 365
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==289:
                self.state = 364
                self.match(RegelSpraakParser.PIPE)


            self.state = 367
            localctx.resultColumn = self.beslistabelColumnText()
            self.state = 368
            self.match(RegelSpraakParser.PIPE)
            self.state = 369
            localctx._beslistabelColumnText = self.beslistabelColumnText()
            localctx.conditionColumns.append(localctx._beslistabelColumnText)
            self.state = 374
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,6,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 370
                    self.match(RegelSpraakParser.PIPE)
                    self.state = 371
                    localctx._beslistabelColumnText = self.beslistabelColumnText()
                    localctx.conditionColumns.append(localctx._beslistabelColumnText) 
                self.state = 376
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,6,self._ctx)

            self.state = 378
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,7,self._ctx)
            if la_ == 1:
                self.state = 377
                self.match(RegelSpraakParser.PIPE)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BeslistabelSeparatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PIPE(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.PIPE)
            else:
                return self.getToken(RegelSpraakParser.PIPE, i)

        def MINUS(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.MINUS)
            else:
                return self.getToken(RegelSpraakParser.MINUS, i)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_beslistabelSeparator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBeslistabelSeparator" ):
                listener.enterBeslistabelSeparator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBeslistabelSeparator" ):
                listener.exitBeslistabelSeparator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBeslistabelSeparator" ):
                return visitor.visitBeslistabelSeparator(self)
            else:
                return visitor.visitChildren(self)




    def beslistabelSeparator(self):

        localctx = RegelSpraakParser.BeslistabelSeparatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_beslistabelSeparator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 381
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==289:
                self.state = 380
                self.match(RegelSpraakParser.PIPE)


            self.state = 391 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 384 
                    self._errHandler.sync(self)
                    _alt = 1
                    while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                        if _alt == 1:
                            self.state = 383
                            self.match(RegelSpraakParser.MINUS)

                        else:
                            raise NoViableAltException(self)
                        self.state = 386 
                        self._errHandler.sync(self)
                        _alt = self._interp.adaptivePredict(self._input,9,self._ctx)

                    self.state = 389
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,10,self._ctx)
                    if la_ == 1:
                        self.state = 388
                        self.match(RegelSpraakParser.PIPE)



                else:
                    raise NoViableAltException(self)
                self.state = 393 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,11,self._ctx)

            self.state = 398
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==288:
                self.state = 395
                self.match(RegelSpraakParser.MINUS)
                self.state = 400
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BeslistabelRowContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.rowNumber = None # Token
            self.resultExpression = None # ExpressieContext
            self._beslistabelCellValue = None # BeslistabelCellValueContext
            self.conditionValues = list() # of BeslistabelCellValueContexts

        def PIPE(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.PIPE)
            else:
                return self.getToken(RegelSpraakParser.PIPE, i)

        def NUMBER(self):
            return self.getToken(RegelSpraakParser.NUMBER, 0)

        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)


        def beslistabelCellValue(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.BeslistabelCellValueContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.BeslistabelCellValueContext,i)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_beslistabelRow

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBeslistabelRow" ):
                listener.enterBeslistabelRow(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBeslistabelRow" ):
                listener.exitBeslistabelRow(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBeslistabelRow" ):
                return visitor.visitBeslistabelRow(self)
            else:
                return visitor.visitChildren(self)




    def beslistabelRow(self):

        localctx = RegelSpraakParser.BeslistabelRowContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_beslistabelRow)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 401
            self.match(RegelSpraakParser.PIPE)
            self.state = 402
            localctx.rowNumber = self.match(RegelSpraakParser.NUMBER)
            self.state = 403
            self.match(RegelSpraakParser.PIPE)
            self.state = 404
            localctx.resultExpression = self.expressie()
            self.state = 405
            self.match(RegelSpraakParser.PIPE)
            self.state = 406
            localctx._beslistabelCellValue = self.beslistabelCellValue()
            localctx.conditionValues.append(localctx._beslistabelCellValue)
            self.state = 411
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,13,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 407
                    self.match(RegelSpraakParser.PIPE)
                    self.state = 408
                    localctx._beslistabelCellValue = self.beslistabelCellValue()
                    localctx.conditionValues.append(localctx._beslistabelCellValue) 
                self.state = 413
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,13,self._ctx)

            self.state = 415
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,14,self._ctx)
            if la_ == 1:
                self.state = 414
                self.match(RegelSpraakParser.PIPE)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BeslistabelCellValueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)


        def NVT(self):
            return self.getToken(RegelSpraakParser.NVT, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_beslistabelCellValue

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBeslistabelCellValue" ):
                listener.enterBeslistabelCellValue(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBeslistabelCellValue" ):
                listener.exitBeslistabelCellValue(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBeslistabelCellValue" ):
                return visitor.visitBeslistabelCellValue(self)
            else:
                return visitor.visitChildren(self)




    def beslistabelCellValue(self):

        localctx = RegelSpraakParser.BeslistabelCellValueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_beslistabelCellValue)
        try:
            self.state = 419
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [7, 11, 12, 13, 14, 15, 16, 17, 18, 30, 45, 96, 110, 113, 117, 120, 128, 133, 136, 152, 157, 186, 187, 189, 191, 192, 197, 198, 201, 202, 205, 206, 208, 211, 213, 215, 217, 219, 220, 226, 228, 230, 231, 233, 245, 249, 263, 264, 266, 267, 268, 269, 270, 288]:
                self.enterOuterAlt(localctx, 1)
                self.state = 417
                self.expressie()
                pass
            elif token in [290]:
                self.enterOuterAlt(localctx, 2)
                self.state = 418
                self.match(RegelSpraakParser.NVT)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BeslistabelColumnTextContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PIPE(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.PIPE)
            else:
                return self.getToken(RegelSpraakParser.PIPE, i)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_beslistabelColumnText

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBeslistabelColumnText" ):
                listener.enterBeslistabelColumnText(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBeslistabelColumnText" ):
                listener.exitBeslistabelColumnText(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBeslistabelColumnText" ):
                return visitor.visitBeslistabelColumnText(self)
            else:
                return visitor.visitChildren(self)




    def beslistabelColumnText(self):

        localctx = RegelSpraakParser.BeslistabelColumnTextContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_beslistabelColumnText)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 422 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 421
                    _la = self._input.LA(1)
                    if _la <= 0 or _la==289:
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()

                else:
                    raise NoViableAltException(self)
                self.state = 424 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,16,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IdentifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(RegelSpraakParser.IDENTIFIER, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_identifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIdentifier" ):
                listener.enterIdentifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIdentifier" ):
                listener.exitIdentifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIdentifier" ):
                return visitor.visitIdentifier(self)
            else:
                return visitor.visitChildren(self)




    def identifier(self):

        localctx = RegelSpraakParser.IdentifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_identifier)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 426
            self.match(RegelSpraakParser.IDENTIFIER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IdentifierOrKeywordContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(RegelSpraakParser.IDENTIFIER, 0)

        def DAG(self):
            return self.getToken(RegelSpraakParser.DAG, 0)

        def DAGEN(self):
            return self.getToken(RegelSpraakParser.DAGEN, 0)

        def MAAND(self):
            return self.getToken(RegelSpraakParser.MAAND, 0)

        def JAAR(self):
            return self.getToken(RegelSpraakParser.JAAR, 0)

        def AANTAL(self):
            return self.getToken(RegelSpraakParser.AANTAL, 0)

        def PERIODE(self):
            return self.getToken(RegelSpraakParser.PERIODE, 0)

        def REGEL(self):
            return self.getToken(RegelSpraakParser.REGEL, 0)

        def VOORWAARDE(self):
            return self.getToken(RegelSpraakParser.VOORWAARDE, 0)

        def HEEFT(self):
            return self.getToken(RegelSpraakParser.HEEFT, 0)

        def ALLE(self):
            return self.getToken(RegelSpraakParser.ALLE, 0)

        def INCONSISTENT(self):
            return self.getToken(RegelSpraakParser.INCONSISTENT, 0)

        def IS(self):
            return self.getToken(RegelSpraakParser.IS, 0)

        def KWARTAAL(self):
            return self.getToken(RegelSpraakParser.KWARTAAL, 0)

        def METER(self):
            return self.getToken(RegelSpraakParser.METER, 0)

        def EEN_TELWOORD(self):
            return self.getToken(RegelSpraakParser.EEN_TELWOORD, 0)

        def TWEE_TELWOORD(self):
            return self.getToken(RegelSpraakParser.TWEE_TELWOORD, 0)

        def DRIE_TELWOORD(self):
            return self.getToken(RegelSpraakParser.DRIE_TELWOORD, 0)

        def VIER_TELWOORD(self):
            return self.getToken(RegelSpraakParser.VIER_TELWOORD, 0)

        def OUDER(self):
            return self.getToken(RegelSpraakParser.OUDER, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_identifierOrKeyword

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIdentifierOrKeyword" ):
                listener.enterIdentifierOrKeyword(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIdentifierOrKeyword" ):
                listener.exitIdentifierOrKeyword(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIdentifierOrKeyword" ):
                return visitor.visitIdentifierOrKeyword(self)
            else:
                return visitor.visitChildren(self)




    def identifierOrKeyword(self):

        localctx = RegelSpraakParser.IdentifierOrKeywordContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_identifierOrKeyword)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 428
            _la = self._input.LA(1)
            if not(((((_la - 96)) & ~0x3f) == 0 and ((1 << (_la - 96)) & 2305843013525585921) != 0) or ((((_la - 186)) & ~0x3f) == 0 and ((1 << (_la - 186)) & -9223350018703255551) != 0) or _la==263):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IdentifierOrKeywordNoIsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(RegelSpraakParser.IDENTIFIER, 0)

        def DAG(self):
            return self.getToken(RegelSpraakParser.DAG, 0)

        def DAGEN(self):
            return self.getToken(RegelSpraakParser.DAGEN, 0)

        def MAAND(self):
            return self.getToken(RegelSpraakParser.MAAND, 0)

        def JAAR(self):
            return self.getToken(RegelSpraakParser.JAAR, 0)

        def AANTAL(self):
            return self.getToken(RegelSpraakParser.AANTAL, 0)

        def PERIODE(self):
            return self.getToken(RegelSpraakParser.PERIODE, 0)

        def REGEL(self):
            return self.getToken(RegelSpraakParser.REGEL, 0)

        def VOORWAARDE(self):
            return self.getToken(RegelSpraakParser.VOORWAARDE, 0)

        def HEEFT(self):
            return self.getToken(RegelSpraakParser.HEEFT, 0)

        def ALLE(self):
            return self.getToken(RegelSpraakParser.ALLE, 0)

        def INCONSISTENT(self):
            return self.getToken(RegelSpraakParser.INCONSISTENT, 0)

        def KWARTAAL(self):
            return self.getToken(RegelSpraakParser.KWARTAAL, 0)

        def METER(self):
            return self.getToken(RegelSpraakParser.METER, 0)

        def EEN_TELWOORD(self):
            return self.getToken(RegelSpraakParser.EEN_TELWOORD, 0)

        def TWEE_TELWOORD(self):
            return self.getToken(RegelSpraakParser.TWEE_TELWOORD, 0)

        def DRIE_TELWOORD(self):
            return self.getToken(RegelSpraakParser.DRIE_TELWOORD, 0)

        def VIER_TELWOORD(self):
            return self.getToken(RegelSpraakParser.VIER_TELWOORD, 0)

        def OUDER(self):
            return self.getToken(RegelSpraakParser.OUDER, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_identifierOrKeywordNoIs

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIdentifierOrKeywordNoIs" ):
                listener.enterIdentifierOrKeywordNoIs(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIdentifierOrKeywordNoIs" ):
                listener.exitIdentifierOrKeywordNoIs(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIdentifierOrKeywordNoIs" ):
                return visitor.visitIdentifierOrKeywordNoIs(self)
            else:
                return visitor.visitChildren(self)




    def identifierOrKeywordNoIs(self):

        localctx = RegelSpraakParser.IdentifierOrKeywordNoIsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_identifierOrKeywordNoIs)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 430
            _la = self._input.LA(1)
            if not(((((_la - 96)) & ~0x3f) == 0 and ((1 << (_la - 96)) & 2305843013525454849) != 0) or ((((_la - 186)) & ~0x3f) == 0 and ((1 << (_la - 186)) & -9223350018703255551) != 0) or _la==263):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NaamPhraseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifierOrKeyword(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.IdentifierOrKeywordContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.IdentifierOrKeywordContext,i)


        def DE(self):
            return self.getToken(RegelSpraakParser.DE, 0)

        def HET(self):
            return self.getToken(RegelSpraakParser.HET, 0)

        def EEN(self):
            return self.getToken(RegelSpraakParser.EEN, 0)

        def ZIJN(self):
            return self.getToken(RegelSpraakParser.ZIJN, 0)

        def NIEUWE(self):
            return self.getToken(RegelSpraakParser.NIEUWE, 0)

        def MET(self):
            return self.getToken(RegelSpraakParser.MET, 0)

        def NIET(self):
            return self.getToken(RegelSpraakParser.NIET, 0)

        def AANTAL(self):
            return self.getToken(RegelSpraakParser.AANTAL, 0)

        def DAGEN(self):
            return self.getToken(RegelSpraakParser.DAGEN, 0)

        def IN(self):
            return self.getToken(RegelSpraakParser.IN, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_naamPhrase

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNaamPhrase" ):
                listener.enterNaamPhrase(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNaamPhrase" ):
                listener.exitNaamPhrase(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNaamPhrase" ):
                return visitor.visitNaamPhrase(self)
            else:
                return visitor.visitChildren(self)




    def naamPhrase(self):

        localctx = RegelSpraakParser.NaamPhraseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_naamPhrase)
        self._la = 0 # Token type
        try:
            self.state = 489
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,27,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 433
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==117 or ((((_la - 208)) & ~0x3f) == 0 and ((1 << (_la - 208)) & 41) != 0):
                    self.state = 432
                    _la = self._input.LA(1)
                    if not(_la==117 or ((((_la - 208)) & ~0x3f) == 0 and ((1 << (_la - 208)) & 41) != 0)):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                self.state = 436 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 435
                        self.identifierOrKeyword()

                    else:
                        raise NoViableAltException(self)
                    self.state = 438 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,18,self._ctx)

                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 441 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 440
                        self.identifierOrKeyword()

                    else:
                        raise NoViableAltException(self)
                    self.state = 443 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,19,self._ctx)

                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 445
                self.match(RegelSpraakParser.NIEUWE)
                self.state = 447 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 446
                        self.identifierOrKeyword()

                    else:
                        raise NoViableAltException(self)
                    self.state = 449 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,20,self._ctx)

                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 451
                self.match(RegelSpraakParser.NIEUWE)
                self.state = 453 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 452
                    self.identifierOrKeyword()
                    self.state = 455 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (((((_la - 96)) & ~0x3f) == 0 and ((1 << (_la - 96)) & 2305843013525585921) != 0) or ((((_la - 186)) & ~0x3f) == 0 and ((1 << (_la - 186)) & -9223350018703255551) != 0) or _la==263):
                        break

                self.state = 457
                self.match(RegelSpraakParser.MET)
                self.state = 459 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 458
                        self.identifierOrKeyword()

                    else:
                        raise NoViableAltException(self)
                    self.state = 461 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,22,self._ctx)

                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 464 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 463
                    self.identifierOrKeyword()
                    self.state = 466 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (((((_la - 96)) & ~0x3f) == 0 and ((1 << (_la - 96)) & 2305843013525585921) != 0) or ((((_la - 186)) & ~0x3f) == 0 and ((1 << (_la - 186)) & -9223350018703255551) != 0) or _la==263):
                        break

                self.state = 468
                self.match(RegelSpraakParser.MET)
                self.state = 470 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 469
                        self.identifierOrKeyword()

                    else:
                        raise NoViableAltException(self)
                    self.state = 472 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,24,self._ctx)

                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 474
                self.match(RegelSpraakParser.NIET)
                self.state = 476 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 475
                        self.identifierOrKeyword()

                    else:
                        raise NoViableAltException(self)
                    self.state = 478 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,25,self._ctx)

                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 480
                self.match(RegelSpraakParser.HET)
                self.state = 481
                self.match(RegelSpraakParser.AANTAL)
                self.state = 482
                self.match(RegelSpraakParser.DAGEN)
                self.state = 483
                self.match(RegelSpraakParser.IN)
                self.state = 485 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 484
                        self.identifierOrKeyword()

                    else:
                        raise NoViableAltException(self)
                    self.state = 487 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,26,self._ctx)

                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NaamPhraseWithNumbersContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifierOrKeywordWithNumbers(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.IdentifierOrKeywordWithNumbersContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.IdentifierOrKeywordWithNumbersContext,i)


        def DE(self):
            return self.getToken(RegelSpraakParser.DE, 0)

        def HET(self):
            return self.getToken(RegelSpraakParser.HET, 0)

        def EEN(self):
            return self.getToken(RegelSpraakParser.EEN, 0)

        def ZIJN(self):
            return self.getToken(RegelSpraakParser.ZIJN, 0)

        def NIEUWE(self):
            return self.getToken(RegelSpraakParser.NIEUWE, 0)

        def MET(self):
            return self.getToken(RegelSpraakParser.MET, 0)

        def NIET(self):
            return self.getToken(RegelSpraakParser.NIET, 0)

        def AANTAL(self):
            return self.getToken(RegelSpraakParser.AANTAL, 0)

        def DAGEN(self):
            return self.getToken(RegelSpraakParser.DAGEN, 0)

        def IN(self):
            return self.getToken(RegelSpraakParser.IN, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_naamPhraseWithNumbers

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNaamPhraseWithNumbers" ):
                listener.enterNaamPhraseWithNumbers(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNaamPhraseWithNumbers" ):
                listener.exitNaamPhraseWithNumbers(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNaamPhraseWithNumbers" ):
                return visitor.visitNaamPhraseWithNumbers(self)
            else:
                return visitor.visitChildren(self)




    def naamPhraseWithNumbers(self):

        localctx = RegelSpraakParser.NaamPhraseWithNumbersContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_naamPhraseWithNumbers)
        self._la = 0 # Token type
        try:
            self.state = 548
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,38,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 492
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==117 or ((((_la - 208)) & ~0x3f) == 0 and ((1 << (_la - 208)) & 41) != 0):
                    self.state = 491
                    _la = self._input.LA(1)
                    if not(_la==117 or ((((_la - 208)) & ~0x3f) == 0 and ((1 << (_la - 208)) & 41) != 0)):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                self.state = 495 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 494
                        self.identifierOrKeywordWithNumbers()

                    else:
                        raise NoViableAltException(self)
                    self.state = 497 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,29,self._ctx)

                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 500 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 499
                        self.identifierOrKeywordWithNumbers()

                    else:
                        raise NoViableAltException(self)
                    self.state = 502 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,30,self._ctx)

                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 504
                self.match(RegelSpraakParser.NIEUWE)
                self.state = 506 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 505
                        self.identifierOrKeywordWithNumbers()

                    else:
                        raise NoViableAltException(self)
                    self.state = 508 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,31,self._ctx)

                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 510
                self.match(RegelSpraakParser.NIEUWE)
                self.state = 512 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 511
                    self.identifierOrKeywordWithNumbers()
                    self.state = 514 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (((((_la - 96)) & ~0x3f) == 0 and ((1 << (_la - 96)) & 2305843013525585921) != 0) or ((((_la - 186)) & ~0x3f) == 0 and ((1 << (_la - 186)) & -9223350018703255551) != 0) or _la==263 or _la==264):
                        break

                self.state = 516
                self.match(RegelSpraakParser.MET)
                self.state = 518 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 517
                        self.identifierOrKeywordWithNumbers()

                    else:
                        raise NoViableAltException(self)
                    self.state = 520 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,33,self._ctx)

                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 523 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 522
                    self.identifierOrKeywordWithNumbers()
                    self.state = 525 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (((((_la - 96)) & ~0x3f) == 0 and ((1 << (_la - 96)) & 2305843013525585921) != 0) or ((((_la - 186)) & ~0x3f) == 0 and ((1 << (_la - 186)) & -9223350018703255551) != 0) or _la==263 or _la==264):
                        break

                self.state = 527
                self.match(RegelSpraakParser.MET)
                self.state = 529 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 528
                        self.identifierOrKeywordWithNumbers()

                    else:
                        raise NoViableAltException(self)
                    self.state = 531 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,35,self._ctx)

                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 533
                self.match(RegelSpraakParser.NIET)
                self.state = 535 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 534
                        self.identifierOrKeywordWithNumbers()

                    else:
                        raise NoViableAltException(self)
                    self.state = 537 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,36,self._ctx)

                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 539
                self.match(RegelSpraakParser.HET)
                self.state = 540
                self.match(RegelSpraakParser.AANTAL)
                self.state = 541
                self.match(RegelSpraakParser.DAGEN)
                self.state = 542
                self.match(RegelSpraakParser.IN)
                self.state = 544 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 543
                        self.identifierOrKeywordWithNumbers()

                    else:
                        raise NoViableAltException(self)
                    self.state = 546 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,37,self._ctx)

                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IdentifierOrKeywordWithNumbersContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifierOrKeyword(self):
            return self.getTypedRuleContext(RegelSpraakParser.IdentifierOrKeywordContext,0)


        def NUMBER(self):
            return self.getToken(RegelSpraakParser.NUMBER, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_identifierOrKeywordWithNumbers

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIdentifierOrKeywordWithNumbers" ):
                listener.enterIdentifierOrKeywordWithNumbers(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIdentifierOrKeywordWithNumbers" ):
                listener.exitIdentifierOrKeywordWithNumbers(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIdentifierOrKeywordWithNumbers" ):
                return visitor.visitIdentifierOrKeywordWithNumbers(self)
            else:
                return visitor.visitChildren(self)




    def identifierOrKeywordWithNumbers(self):

        localctx = RegelSpraakParser.IdentifierOrKeywordWithNumbersContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_identifierOrKeywordWithNumbers)
        try:
            self.state = 552
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [96, 110, 113, 120, 128, 157, 186, 197, 198, 201, 202, 205, 206, 217, 219, 220, 228, 230, 249, 263]:
                self.enterOuterAlt(localctx, 1)
                self.state = 550
                self.identifierOrKeyword()
                pass
            elif token in [264]:
                self.enterOuterAlt(localctx, 2)
                self.state = 551
                self.match(RegelSpraakParser.NUMBER)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NaamPhraseNoIsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifierOrKeywordNoIs(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.IdentifierOrKeywordNoIsContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.IdentifierOrKeywordNoIsContext,i)


        def DE(self):
            return self.getToken(RegelSpraakParser.DE, 0)

        def HET(self):
            return self.getToken(RegelSpraakParser.HET, 0)

        def EEN(self):
            return self.getToken(RegelSpraakParser.EEN, 0)

        def ZIJN(self):
            return self.getToken(RegelSpraakParser.ZIJN, 0)

        def NIEUWE(self):
            return self.getToken(RegelSpraakParser.NIEUWE, 0)

        def MET(self):
            return self.getToken(RegelSpraakParser.MET, 0)

        def NIET(self):
            return self.getToken(RegelSpraakParser.NIET, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_naamPhraseNoIs

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNaamPhraseNoIs" ):
                listener.enterNaamPhraseNoIs(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNaamPhraseNoIs" ):
                listener.exitNaamPhraseNoIs(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNaamPhraseNoIs" ):
                return visitor.visitNaamPhraseNoIs(self)
            else:
                return visitor.visitChildren(self)




    def naamPhraseNoIs(self):

        localctx = RegelSpraakParser.NaamPhraseNoIsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_naamPhraseNoIs)
        self._la = 0 # Token type
        try:
            self.state = 602
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,49,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 555
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==117 or ((((_la - 208)) & ~0x3f) == 0 and ((1 << (_la - 208)) & 41) != 0):
                    self.state = 554
                    _la = self._input.LA(1)
                    if not(_la==117 or ((((_la - 208)) & ~0x3f) == 0 and ((1 << (_la - 208)) & 41) != 0)):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                self.state = 558 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 557
                        self.identifierOrKeywordNoIs()

                    else:
                        raise NoViableAltException(self)
                    self.state = 560 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,41,self._ctx)

                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 563 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 562
                        self.identifierOrKeywordNoIs()

                    else:
                        raise NoViableAltException(self)
                    self.state = 565 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,42,self._ctx)

                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 567
                self.match(RegelSpraakParser.NIEUWE)
                self.state = 569 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 568
                        self.identifierOrKeywordNoIs()

                    else:
                        raise NoViableAltException(self)
                    self.state = 571 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,43,self._ctx)

                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 573
                self.match(RegelSpraakParser.NIEUWE)
                self.state = 575 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 574
                    self.identifierOrKeywordNoIs()
                    self.state = 577 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (((((_la - 96)) & ~0x3f) == 0 and ((1 << (_la - 96)) & 2305843013525454849) != 0) or ((((_la - 186)) & ~0x3f) == 0 and ((1 << (_la - 186)) & -9223350018703255551) != 0) or _la==263):
                        break

                self.state = 579
                self.match(RegelSpraakParser.MET)
                self.state = 581 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 580
                        self.identifierOrKeywordNoIs()

                    else:
                        raise NoViableAltException(self)
                    self.state = 583 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,45,self._ctx)

                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 586 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 585
                    self.identifierOrKeywordNoIs()
                    self.state = 588 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (((((_la - 96)) & ~0x3f) == 0 and ((1 << (_la - 96)) & 2305843013525454849) != 0) or ((((_la - 186)) & ~0x3f) == 0 and ((1 << (_la - 186)) & -9223350018703255551) != 0) or _la==263):
                        break

                self.state = 590
                self.match(RegelSpraakParser.MET)
                self.state = 592 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 591
                        self.identifierOrKeywordNoIs()

                    else:
                        raise NoViableAltException(self)
                    self.state = 594 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,47,self._ctx)

                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 596
                self.match(RegelSpraakParser.NIET)
                self.state = 598 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 597
                        self.identifierOrKeywordNoIs()

                    else:
                        raise NoViableAltException(self)
                    self.state = 600 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,48,self._ctx)

                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NaamwoordContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def naamPhrase(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.NaamPhraseContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.NaamPhraseContext,i)


        def voorzetsel(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.VoorzetselContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.VoorzetselContext,i)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_naamwoord

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNaamwoord" ):
                listener.enterNaamwoord(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNaamwoord" ):
                listener.exitNaamwoord(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNaamwoord" ):
                return visitor.visitNaamwoord(self)
            else:
                return visitor.visitChildren(self)




    def naamwoord(self):

        localctx = RegelSpraakParser.NaamwoordContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_naamwoord)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 604
            self.naamPhrase()
            self.state = 610
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,50,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 605
                    self.voorzetsel()
                    self.state = 606
                    self.naamPhrase() 
                self.state = 612
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,50,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NaamwoordWithNumbersContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def naamPhraseWithNumbers(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.NaamPhraseWithNumbersContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.NaamPhraseWithNumbersContext,i)


        def voorzetsel(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.VoorzetselContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.VoorzetselContext,i)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_naamwoordWithNumbers

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNaamwoordWithNumbers" ):
                listener.enterNaamwoordWithNumbers(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNaamwoordWithNumbers" ):
                listener.exitNaamwoordWithNumbers(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNaamwoordWithNumbers" ):
                return visitor.visitNaamwoordWithNumbers(self)
            else:
                return visitor.visitChildren(self)




    def naamwoordWithNumbers(self):

        localctx = RegelSpraakParser.NaamwoordWithNumbersContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_naamwoordWithNumbers)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 613
            self.naamPhraseWithNumbers()
            self.state = 619
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,51,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 614
                    self.voorzetsel()
                    self.state = 615
                    self.naamPhraseWithNumbers() 
                self.state = 621
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,51,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NaamwoordNoIsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def naamPhraseNoIs(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.NaamPhraseNoIsContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.NaamPhraseNoIsContext,i)


        def voorzetsel(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.VoorzetselContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.VoorzetselContext,i)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_naamwoordNoIs

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNaamwoordNoIs" ):
                listener.enterNaamwoordNoIs(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNaamwoordNoIs" ):
                listener.exitNaamwoordNoIs(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNaamwoordNoIs" ):
                return visitor.visitNaamwoordNoIs(self)
            else:
                return visitor.visitChildren(self)




    def naamwoordNoIs(self):

        localctx = RegelSpraakParser.NaamwoordNoIsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_naamwoordNoIs)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 622
            self.naamPhraseNoIs()
            self.state = 628
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,52,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 623
                    self.voorzetsel()
                    self.state = 624
                    self.naamPhraseNoIs() 
                self.state = 630
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,52,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VoorzetselContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def VAN(self):
            return self.getToken(RegelSpraakParser.VAN, 0)

        def IN(self):
            return self.getToken(RegelSpraakParser.IN, 0)

        def VOOR(self):
            return self.getToken(RegelSpraakParser.VOOR, 0)

        def OVER(self):
            return self.getToken(RegelSpraakParser.OVER, 0)

        def OP(self):
            return self.getToken(RegelSpraakParser.OP, 0)

        def BIJ(self):
            return self.getToken(RegelSpraakParser.BIJ, 0)

        def UIT(self):
            return self.getToken(RegelSpraakParser.UIT, 0)

        def TOT(self):
            return self.getToken(RegelSpraakParser.TOT, 0)

        def EN(self):
            return self.getToken(RegelSpraakParser.EN, 0)

        def MET(self):
            return self.getToken(RegelSpraakParser.MET, 0)

        def OF(self):
            return self.getToken(RegelSpraakParser.OF, 0)

        def TOT_EN_MET(self):
            return self.getToken(RegelSpraakParser.TOT_EN_MET, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_voorzetsel

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVoorzetsel" ):
                listener.enterVoorzetsel(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVoorzetsel" ):
                listener.exitVoorzetsel(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVoorzetsel" ):
                return visitor.visitVoorzetsel(self)
            else:
                return visitor.visitChildren(self)




    def voorzetsel(self):

        localctx = RegelSpraakParser.VoorzetselContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_voorzetsel)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 631
            _la = self._input.LA(1)
            if not(((((_la - 142)) & ~0x3f) == 0 and ((1 << (_la - 142)) & 4611686019501129733) != 0) or ((((_la - 212)) & ~0x3f) == 0 and ((1 << (_la - 212)) & 4597129233) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DatumLiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DATE_TIME_LITERAL(self):
            return self.getToken(RegelSpraakParser.DATE_TIME_LITERAL, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_datumLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDatumLiteral" ):
                listener.enterDatumLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDatumLiteral" ):
                listener.exitDatumLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDatumLiteral" ):
                return visitor.visitDatumLiteral(self)
            else:
                return visitor.visitChildren(self)




    def datumLiteral(self):

        localctx = RegelSpraakParser.DatumLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_datumLiteral)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 633
            self.match(RegelSpraakParser.DATE_TIME_LITERAL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UnitContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(RegelSpraakParser.IDENTIFIER, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_unit

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnit" ):
                listener.enterUnit(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnit" ):
                listener.exitUnit(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnit" ):
                return visitor.visitUnit(self)
            else:
                return visitor.visitChildren(self)




    def unit(self):

        localctx = RegelSpraakParser.UnitContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_unit)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 635
            self.match(RegelSpraakParser.IDENTIFIER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TimeUnitContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DAG(self):
            return self.getToken(RegelSpraakParser.DAG, 0)

        def DAGEN(self):
            return self.getToken(RegelSpraakParser.DAGEN, 0)

        def MAAND(self):
            return self.getToken(RegelSpraakParser.MAAND, 0)

        def MAANDEN(self):
            return self.getToken(RegelSpraakParser.MAANDEN, 0)

        def JAAR(self):
            return self.getToken(RegelSpraakParser.JAAR, 0)

        def JAREN(self):
            return self.getToken(RegelSpraakParser.JAREN, 0)

        def WEEK(self):
            return self.getToken(RegelSpraakParser.WEEK, 0)

        def WEKEN(self):
            return self.getToken(RegelSpraakParser.WEKEN, 0)

        def UUR(self):
            return self.getToken(RegelSpraakParser.UUR, 0)

        def UREN(self):
            return self.getToken(RegelSpraakParser.UREN, 0)

        def MINUUT(self):
            return self.getToken(RegelSpraakParser.MINUUT, 0)

        def MINUTEN(self):
            return self.getToken(RegelSpraakParser.MINUTEN, 0)

        def SECONDE(self):
            return self.getToken(RegelSpraakParser.SECONDE, 0)

        def SECONDEN(self):
            return self.getToken(RegelSpraakParser.SECONDEN, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_timeUnit

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTimeUnit" ):
                listener.enterTimeUnit(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTimeUnit" ):
                listener.exitTimeUnit(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTimeUnit" ):
                return visitor.visitTimeUnit(self)
            else:
                return visitor.visitChildren(self)




    def timeUnit(self):

        localctx = RegelSpraakParser.TimeUnitContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_timeUnit)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 637
            _la = self._input.LA(1)
            if not(((((_la - 205)) & ~0x3f) == 0 and ((1 << (_la - 205)) & 6624451080195) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ObjectTypeDefinitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self._IDENTIFIER = None # Token
            self.plural = list() # of Tokens

        def OBJECTTYPE(self):
            return self.getToken(RegelSpraakParser.OBJECTTYPE, 0)

        def naamwoordNoIs(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordNoIsContext,0)


        def MV_START(self):
            return self.getToken(RegelSpraakParser.MV_START, 0)

        def RPAREN(self):
            return self.getToken(RegelSpraakParser.RPAREN, 0)

        def BEZIELD(self):
            return self.getToken(RegelSpraakParser.BEZIELD, 0)

        def objectTypeMember(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.ObjectTypeMemberContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.ObjectTypeMemberContext,i)


        def IDENTIFIER(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.IDENTIFIER)
            else:
                return self.getToken(RegelSpraakParser.IDENTIFIER, i)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_objectTypeDefinition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterObjectTypeDefinition" ):
                listener.enterObjectTypeDefinition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitObjectTypeDefinition" ):
                listener.exitObjectTypeDefinition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitObjectTypeDefinition" ):
                return visitor.visitObjectTypeDefinition(self)
            else:
                return visitor.visitChildren(self)




    def objectTypeDefinition(self):

        localctx = RegelSpraakParser.ObjectTypeDefinitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_objectTypeDefinition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 639
            self.match(RegelSpraakParser.OBJECTTYPE)
            self.state = 640
            self.naamwoordNoIs()
            self.state = 648
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==174:
                self.state = 641
                self.match(RegelSpraakParser.MV_START)
                self.state = 643 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 642
                    localctx._IDENTIFIER = self.match(RegelSpraakParser.IDENTIFIER)
                    localctx.plural.append(localctx._IDENTIFIER)
                    self.state = 645 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==263):
                        break

                self.state = 647
                self.match(RegelSpraakParser.RPAREN)


            self.state = 651
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==161:
                self.state = 650
                self.match(RegelSpraakParser.BEZIELD)


            self.state = 656
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,56,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 653
                    self.objectTypeMember() 
                self.state = 658
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,56,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ObjectTypeMemberContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SEMICOLON(self):
            return self.getToken(RegelSpraakParser.SEMICOLON, 0)

        def kenmerkSpecificatie(self):
            return self.getTypedRuleContext(RegelSpraakParser.KenmerkSpecificatieContext,0)


        def attribuutSpecificatie(self):
            return self.getTypedRuleContext(RegelSpraakParser.AttribuutSpecificatieContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_objectTypeMember

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterObjectTypeMember" ):
                listener.enterObjectTypeMember(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitObjectTypeMember" ):
                listener.exitObjectTypeMember(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitObjectTypeMember" ):
                return visitor.visitObjectTypeMember(self)
            else:
                return visitor.visitChildren(self)




    def objectTypeMember(self):

        localctx = RegelSpraakParser.ObjectTypeMemberContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_objectTypeMember)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 661
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,57,self._ctx)
            if la_ == 1:
                self.state = 659
                self.kenmerkSpecificatie()
                pass

            elif la_ == 2:
                self.state = 660
                self.attribuutSpecificatie()
                pass


            self.state = 663
            self.match(RegelSpraakParser.SEMICOLON)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class KenmerkSpecificatieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KENMERK(self):
            return self.getToken(RegelSpraakParser.KENMERK, 0)

        def identifier(self):
            return self.getTypedRuleContext(RegelSpraakParser.IdentifierContext,0)


        def naamwoordWithNumbers(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordWithNumbersContext,0)


        def tijdlijn(self):
            return self.getTypedRuleContext(RegelSpraakParser.TijdlijnContext,0)


        def BIJVOEGLIJK(self):
            return self.getToken(RegelSpraakParser.BIJVOEGLIJK, 0)

        def BEZITTELIJK(self):
            return self.getToken(RegelSpraakParser.BEZITTELIJK, 0)

        def IS(self):
            return self.getToken(RegelSpraakParser.IS, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_kenmerkSpecificatie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterKenmerkSpecificatie" ):
                listener.enterKenmerkSpecificatie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitKenmerkSpecificatie" ):
                listener.exitKenmerkSpecificatie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitKenmerkSpecificatie" ):
                return visitor.visitKenmerkSpecificatie(self)
            else:
                return visitor.visitChildren(self)




    def kenmerkSpecificatie(self):

        localctx = RegelSpraakParser.KenmerkSpecificatieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_kenmerkSpecificatie)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 670
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,59,self._ctx)
            if la_ == 1:
                self.state = 666
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==113:
                    self.state = 665
                    self.match(RegelSpraakParser.IS)


                self.state = 668
                self.identifier()
                pass

            elif la_ == 2:
                self.state = 669
                self.naamwoordWithNumbers()
                pass


            self.state = 672
            self.match(RegelSpraakParser.KENMERK)
            self.state = 674
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==159 or _la==160:
                self.state = 673
                _la = self._input.LA(1)
                if not(_la==159 or _la==160):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


            self.state = 677
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 183)) & ~0x3f) == 0 and ((1 << (_la - 183)) & 7) != 0):
                self.state = 676
                self.tijdlijn()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AttribuutSpecificatieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def naamwoordWithNumbers(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordWithNumbersContext,0)


        def datatype(self):
            return self.getTypedRuleContext(RegelSpraakParser.DatatypeContext,0)


        def domeinRef(self):
            return self.getTypedRuleContext(RegelSpraakParser.DomeinRefContext,0)


        def objectTypeRef(self):
            return self.getTypedRuleContext(RegelSpraakParser.ObjectTypeRefContext,0)


        def MET_EENHEID(self):
            return self.getToken(RegelSpraakParser.MET_EENHEID, 0)

        def unitIdentifier(self):
            return self.getTypedRuleContext(RegelSpraakParser.UnitIdentifierContext,0)


        def GEDIMENSIONEERD_MET(self):
            return self.getToken(RegelSpraakParser.GEDIMENSIONEERD_MET, 0)

        def dimensieRef(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.DimensieRefContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.DimensieRefContext,i)


        def tijdlijn(self):
            return self.getTypedRuleContext(RegelSpraakParser.TijdlijnContext,0)


        def EN(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.EN)
            else:
                return self.getToken(RegelSpraakParser.EN, i)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_attribuutSpecificatie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAttribuutSpecificatie" ):
                listener.enterAttribuutSpecificatie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAttribuutSpecificatie" ):
                listener.exitAttribuutSpecificatie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAttribuutSpecificatie" ):
                return visitor.visitAttribuutSpecificatie(self)
            else:
                return visitor.visitChildren(self)




    def attribuutSpecificatie(self):

        localctx = RegelSpraakParser.AttribuutSpecificatieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_attribuutSpecificatie)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 679
            self.naamwoordWithNumbers()
            self.state = 683
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,62,self._ctx)
            if la_ == 1:
                self.state = 680
                self.datatype()
                pass

            elif la_ == 2:
                self.state = 681
                self.domeinRef()
                pass

            elif la_ == 3:
                self.state = 682
                self.objectTypeRef()
                pass


            self.state = 687
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==173:
                self.state = 685
                self.match(RegelSpraakParser.MET_EENHEID)
                self.state = 686
                self.unitIdentifier()


            self.state = 698
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==167:
                self.state = 689
                self.match(RegelSpraakParser.GEDIMENSIONEERD_MET)
                self.state = 690
                self.dimensieRef()
                self.state = 695
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==212:
                    self.state = 691
                    self.match(RegelSpraakParser.EN)
                    self.state = 692
                    self.dimensieRef()
                    self.state = 697
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)



            self.state = 701
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 183)) & ~0x3f) == 0 and ((1 << (_la - 183)) & 7) != 0):
                self.state = 700
                self.tijdlijn()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DatatypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def numeriekDatatype(self):
            return self.getTypedRuleContext(RegelSpraakParser.NumeriekDatatypeContext,0)


        def tekstDatatype(self):
            return self.getTypedRuleContext(RegelSpraakParser.TekstDatatypeContext,0)


        def booleanDatatype(self):
            return self.getTypedRuleContext(RegelSpraakParser.BooleanDatatypeContext,0)


        def datumTijdDatatype(self):
            return self.getTypedRuleContext(RegelSpraakParser.DatumTijdDatatypeContext,0)


        def lijstDatatype(self):
            return self.getTypedRuleContext(RegelSpraakParser.LijstDatatypeContext,0)


        def percentageDatatype(self):
            return self.getTypedRuleContext(RegelSpraakParser.PercentageDatatypeContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_datatype

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDatatype" ):
                listener.enterDatatype(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDatatype" ):
                listener.exitDatatype(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDatatype" ):
                return visitor.visitDatatype(self)
            else:
                return visitor.visitChildren(self)




    def datatype(self):

        localctx = RegelSpraakParser.DatatypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_datatype)
        try:
            self.state = 709
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [177]:
                self.enterOuterAlt(localctx, 1)
                self.state = 703
                self.numeriekDatatype()
                pass
            elif token in [182]:
                self.enterOuterAlt(localctx, 2)
                self.state = 704
                self.tekstDatatype()
                pass
            elif token in [162]:
                self.enterOuterAlt(localctx, 3)
                self.state = 705
                self.booleanDatatype()
                pass
            elif token in [3, 164]:
                self.enterOuterAlt(localctx, 4)
                self.state = 706
                self.datumTijdDatatype()
                pass
            elif token in [101]:
                self.enterOuterAlt(localctx, 5)
                self.state = 707
                self.lijstDatatype()
                pass
            elif token in [178]:
                self.enterOuterAlt(localctx, 6)
                self.state = 708
                self.percentageDatatype()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LijstDatatypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LIJST(self):
            return self.getToken(RegelSpraakParser.LIJST, 0)

        def VAN(self):
            return self.getToken(RegelSpraakParser.VAN, 0)

        def datatype(self):
            return self.getTypedRuleContext(RegelSpraakParser.DatatypeContext,0)


        def domeinRef(self):
            return self.getTypedRuleContext(RegelSpraakParser.DomeinRefContext,0)


        def objectTypeRef(self):
            return self.getTypedRuleContext(RegelSpraakParser.ObjectTypeRefContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_lijstDatatype

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLijstDatatype" ):
                listener.enterLijstDatatype(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLijstDatatype" ):
                listener.exitLijstDatatype(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLijstDatatype" ):
                return visitor.visitLijstDatatype(self)
            else:
                return visitor.visitChildren(self)




    def lijstDatatype(self):

        localctx = RegelSpraakParser.LijstDatatypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_lijstDatatype)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 711
            self.match(RegelSpraakParser.LIJST)
            self.state = 712
            self.match(RegelSpraakParser.VAN)
            self.state = 716
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,68,self._ctx)
            if la_ == 1:
                self.state = 713
                self.datatype()
                pass

            elif la_ == 2:
                self.state = 714
                self.domeinRef()
                pass

            elif la_ == 3:
                self.state = 715
                self.objectTypeRef()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NumeriekDatatypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NUMERIEK(self):
            return self.getToken(RegelSpraakParser.NUMERIEK, 0)

        def LPAREN(self):
            return self.getToken(RegelSpraakParser.LPAREN, 0)

        def getalSpecificatie(self):
            return self.getTypedRuleContext(RegelSpraakParser.GetalSpecificatieContext,0)


        def RPAREN(self):
            return self.getToken(RegelSpraakParser.RPAREN, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_numeriekDatatype

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumeriekDatatype" ):
                listener.enterNumeriekDatatype(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumeriekDatatype" ):
                listener.exitNumeriekDatatype(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNumeriekDatatype" ):
                return visitor.visitNumeriekDatatype(self)
            else:
                return visitor.visitChildren(self)




    def numeriekDatatype(self):

        localctx = RegelSpraakParser.NumeriekDatatypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_numeriekDatatype)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 718
            self.match(RegelSpraakParser.NUMERIEK)
            self.state = 723
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==270:
                self.state = 719
                self.match(RegelSpraakParser.LPAREN)
                self.state = 720
                self.getalSpecificatie()
                self.state = 721
                self.match(RegelSpraakParser.RPAREN)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TekstDatatypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TEKST(self):
            return self.getToken(RegelSpraakParser.TEKST, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_tekstDatatype

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTekstDatatype" ):
                listener.enterTekstDatatype(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTekstDatatype" ):
                listener.exitTekstDatatype(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTekstDatatype" ):
                return visitor.visitTekstDatatype(self)
            else:
                return visitor.visitChildren(self)




    def tekstDatatype(self):

        localctx = RegelSpraakParser.TekstDatatypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_tekstDatatype)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 725
            self.match(RegelSpraakParser.TEKST)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PercentageDatatypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PERCENTAGE(self):
            return self.getToken(RegelSpraakParser.PERCENTAGE, 0)

        def LPAREN(self):
            return self.getToken(RegelSpraakParser.LPAREN, 0)

        def getalSpecificatie(self):
            return self.getTypedRuleContext(RegelSpraakParser.GetalSpecificatieContext,0)


        def RPAREN(self):
            return self.getToken(RegelSpraakParser.RPAREN, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_percentageDatatype

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPercentageDatatype" ):
                listener.enterPercentageDatatype(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPercentageDatatype" ):
                listener.exitPercentageDatatype(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPercentageDatatype" ):
                return visitor.visitPercentageDatatype(self)
            else:
                return visitor.visitChildren(self)




    def percentageDatatype(self):

        localctx = RegelSpraakParser.PercentageDatatypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_percentageDatatype)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 727
            self.match(RegelSpraakParser.PERCENTAGE)
            self.state = 732
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==270:
                self.state = 728
                self.match(RegelSpraakParser.LPAREN)
                self.state = 729
                self.getalSpecificatie()
                self.state = 730
                self.match(RegelSpraakParser.RPAREN)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BooleanDatatypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BOOLEAN(self):
            return self.getToken(RegelSpraakParser.BOOLEAN, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_booleanDatatype

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBooleanDatatype" ):
                listener.enterBooleanDatatype(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBooleanDatatype" ):
                listener.exitBooleanDatatype(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBooleanDatatype" ):
                return visitor.visitBooleanDatatype(self)
            else:
                return visitor.visitChildren(self)




    def booleanDatatype(self):

        localctx = RegelSpraakParser.BooleanDatatypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_booleanDatatype)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 734
            self.match(RegelSpraakParser.BOOLEAN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DatumTijdDatatypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DATUM_IN_DAGEN(self):
            return self.getToken(RegelSpraakParser.DATUM_IN_DAGEN, 0)

        def DATUM_TIJD_MILLIS(self):
            return self.getToken(RegelSpraakParser.DATUM_TIJD_MILLIS, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_datumTijdDatatype

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDatumTijdDatatype" ):
                listener.enterDatumTijdDatatype(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDatumTijdDatatype" ):
                listener.exitDatumTijdDatatype(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDatumTijdDatatype" ):
                return visitor.visitDatumTijdDatatype(self)
            else:
                return visitor.visitChildren(self)




    def datumTijdDatatype(self):

        localctx = RegelSpraakParser.DatumTijdDatatypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_datumTijdDatatype)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 736
            _la = self._input.LA(1)
            if not(_la==3 or _la==164):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GetalSpecificatieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GEHEEL_GETAL(self):
            return self.getToken(RegelSpraakParser.GEHEEL_GETAL, 0)

        def GETAL(self):
            return self.getToken(RegelSpraakParser.GETAL, 0)

        def NEGATIEF(self):
            return self.getToken(RegelSpraakParser.NEGATIEF, 0)

        def NIET_NEGATIEF(self):
            return self.getToken(RegelSpraakParser.NIET_NEGATIEF, 0)

        def POSITIEF(self):
            return self.getToken(RegelSpraakParser.POSITIEF, 0)

        def MET(self):
            return self.getToken(RegelSpraakParser.MET, 0)

        def NUMBER(self):
            return self.getToken(RegelSpraakParser.NUMBER, 0)

        def DECIMALEN(self):
            return self.getToken(RegelSpraakParser.DECIMALEN, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_getalSpecificatie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGetalSpecificatie" ):
                listener.enterGetalSpecificatie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGetalSpecificatie" ):
                listener.exitGetalSpecificatie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGetalSpecificatie" ):
                return visitor.visitGetalSpecificatie(self)
            else:
                return visitor.visitChildren(self)




    def getalSpecificatie(self):

        localctx = RegelSpraakParser.GetalSpecificatieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_getalSpecificatie)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 739
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 175)) & ~0x3f) == 0 and ((1 << (_la - 175)) & 19) != 0):
                self.state = 738
                _la = self._input.LA(1)
                if not(((((_la - 175)) & ~0x3f) == 0 and ((1 << (_la - 175)) & 19) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


            self.state = 747
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,72,self._ctx)
            if la_ == 1:
                self.state = 741
                self.match(RegelSpraakParser.GEHEEL_GETAL)
                pass

            elif la_ == 2:
                self.state = 742
                self.match(RegelSpraakParser.GETAL)
                self.state = 743
                self.match(RegelSpraakParser.MET)
                self.state = 744
                self.match(RegelSpraakParser.NUMBER)
                self.state = 745
                self.match(RegelSpraakParser.DECIMALEN)
                pass

            elif la_ == 3:
                self.state = 746
                self.match(RegelSpraakParser.GETAL)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DomeinDefinitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.name = None # Token

        def DOMEIN(self):
            return self.getToken(RegelSpraakParser.DOMEIN, 0)

        def IS_VAN_HET_TYPE(self):
            return self.getToken(RegelSpraakParser.IS_VAN_HET_TYPE, 0)

        def domeinType(self):
            return self.getTypedRuleContext(RegelSpraakParser.DomeinTypeContext,0)


        def IDENTIFIER(self):
            return self.getToken(RegelSpraakParser.IDENTIFIER, 0)

        def MET_EENHEID(self):
            return self.getToken(RegelSpraakParser.MET_EENHEID, 0)

        def eenheidExpressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.EenheidExpressieContext,0)


        def SEMICOLON(self):
            return self.getToken(RegelSpraakParser.SEMICOLON, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_domeinDefinition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDomeinDefinition" ):
                listener.enterDomeinDefinition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDomeinDefinition" ):
                listener.exitDomeinDefinition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDomeinDefinition" ):
                return visitor.visitDomeinDefinition(self)
            else:
                return visitor.visitChildren(self)




    def domeinDefinition(self):

        localctx = RegelSpraakParser.DomeinDefinitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_domeinDefinition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 749
            self.match(RegelSpraakParser.DOMEIN)
            self.state = 750
            localctx.name = self.match(RegelSpraakParser.IDENTIFIER)
            self.state = 751
            self.match(RegelSpraakParser.IS_VAN_HET_TYPE)
            self.state = 752
            self.domeinType()
            self.state = 755
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==173:
                self.state = 753
                self.match(RegelSpraakParser.MET_EENHEID)
                self.state = 754
                self.eenheidExpressie()


            self.state = 758
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==277:
                self.state = 757
                self.match(RegelSpraakParser.SEMICOLON)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DomeinTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def enumeratieSpecificatie(self):
            return self.getTypedRuleContext(RegelSpraakParser.EnumeratieSpecificatieContext,0)


        def numeriekDatatype(self):
            return self.getTypedRuleContext(RegelSpraakParser.NumeriekDatatypeContext,0)


        def tekstDatatype(self):
            return self.getTypedRuleContext(RegelSpraakParser.TekstDatatypeContext,0)


        def booleanDatatype(self):
            return self.getTypedRuleContext(RegelSpraakParser.BooleanDatatypeContext,0)


        def datumTijdDatatype(self):
            return self.getTypedRuleContext(RegelSpraakParser.DatumTijdDatatypeContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_domeinType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDomeinType" ):
                listener.enterDomeinType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDomeinType" ):
                listener.exitDomeinType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDomeinType" ):
                return visitor.visitDomeinType(self)
            else:
                return visitor.visitChildren(self)




    def domeinType(self):

        localctx = RegelSpraakParser.DomeinTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_domeinType)
        try:
            self.state = 765
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [166]:
                self.enterOuterAlt(localctx, 1)
                self.state = 760
                self.enumeratieSpecificatie()
                pass
            elif token in [177]:
                self.enterOuterAlt(localctx, 2)
                self.state = 761
                self.numeriekDatatype()
                pass
            elif token in [182]:
                self.enterOuterAlt(localctx, 3)
                self.state = 762
                self.tekstDatatype()
                pass
            elif token in [162]:
                self.enterOuterAlt(localctx, 4)
                self.state = 763
                self.booleanDatatype()
                pass
            elif token in [3, 164]:
                self.enterOuterAlt(localctx, 5)
                self.state = 764
                self.datumTijdDatatype()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EnumeratieSpecificatieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ENUMERATIE(self):
            return self.getToken(RegelSpraakParser.ENUMERATIE, 0)

        def ENUM_LITERAL(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.ENUM_LITERAL)
            else:
                return self.getToken(RegelSpraakParser.ENUM_LITERAL, i)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_enumeratieSpecificatie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEnumeratieSpecificatie" ):
                listener.enterEnumeratieSpecificatie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEnumeratieSpecificatie" ):
                listener.exitEnumeratieSpecificatie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEnumeratieSpecificatie" ):
                return visitor.visitEnumeratieSpecificatie(self)
            else:
                return visitor.visitChildren(self)




    def enumeratieSpecificatie(self):

        localctx = RegelSpraakParser.EnumeratieSpecificatieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 74, self.RULE_enumeratieSpecificatie)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 767
            self.match(RegelSpraakParser.ENUMERATIE)
            self.state = 769 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 768
                self.match(RegelSpraakParser.ENUM_LITERAL)
                self.state = 771 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==269):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DomeinRefContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.name = None # Token

        def IDENTIFIER(self):
            return self.getToken(RegelSpraakParser.IDENTIFIER, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_domeinRef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDomeinRef" ):
                listener.enterDomeinRef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDomeinRef" ):
                listener.exitDomeinRef(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDomeinRef" ):
                return visitor.visitDomeinRef(self)
            else:
                return visitor.visitChildren(self)




    def domeinRef(self):

        localctx = RegelSpraakParser.DomeinRefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 76, self.RULE_domeinRef)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 773
            localctx.name = self.match(RegelSpraakParser.IDENTIFIER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ObjectTypeRefContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(RegelSpraakParser.IDENTIFIER, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_objectTypeRef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterObjectTypeRef" ):
                listener.enterObjectTypeRef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitObjectTypeRef" ):
                listener.exitObjectTypeRef(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitObjectTypeRef" ):
                return visitor.visitObjectTypeRef(self)
            else:
                return visitor.visitChildren(self)




    def objectTypeRef(self):

        localctx = RegelSpraakParser.ObjectTypeRefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 78, self.RULE_objectTypeRef)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 775
            self.match(RegelSpraakParser.IDENTIFIER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EenheidsysteemDefinitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.name = None # IdentifierContext

        def EENHEIDSYSTEEM(self):
            return self.getToken(RegelSpraakParser.EENHEIDSYSTEEM, 0)

        def identifier(self):
            return self.getTypedRuleContext(RegelSpraakParser.IdentifierContext,0)


        def eenheidEntry(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.EenheidEntryContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.EenheidEntryContext,i)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_eenheidsysteemDefinition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEenheidsysteemDefinition" ):
                listener.enterEenheidsysteemDefinition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEenheidsysteemDefinition" ):
                listener.exitEenheidsysteemDefinition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEenheidsysteemDefinition" ):
                return visitor.visitEenheidsysteemDefinition(self)
            else:
                return visitor.visitChildren(self)




    def eenheidsysteemDefinition(self):

        localctx = RegelSpraakParser.EenheidsysteemDefinitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 80, self.RULE_eenheidsysteemDefinition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 777
            self.match(RegelSpraakParser.EENHEIDSYSTEEM)
            self.state = 778
            localctx.name = self.identifier()
            self.state = 782
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==208 or _la==213:
                self.state = 779
                self.eenheidEntry()
                self.state = 784
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EenheidEntryContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.unitName = None # UnitIdentifierContext
            self.pluralName = None # UnitIdentifierContext
            self.abbrev = None # UnitIdentifierContext
            self.symbol = None # UnitIdentifierContext
            self.value = None # Token
            self.targetUnit = None # UnitIdentifierContext

        def DE(self):
            return self.getToken(RegelSpraakParser.DE, 0)

        def HET(self):
            return self.getToken(RegelSpraakParser.HET, 0)

        def unitIdentifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.UnitIdentifierContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.UnitIdentifierContext,i)


        def MV_START(self):
            return self.getToken(RegelSpraakParser.MV_START, 0)

        def RPAREN(self):
            return self.getToken(RegelSpraakParser.RPAREN, 0)

        def EQUALS(self):
            return self.getToken(RegelSpraakParser.EQUALS, 0)

        def NUMBER(self):
            return self.getToken(RegelSpraakParser.NUMBER, 0)

        def SLASH(self):
            return self.getToken(RegelSpraakParser.SLASH, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_eenheidEntry

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEenheidEntry" ):
                listener.enterEenheidEntry(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEenheidEntry" ):
                listener.exitEenheidEntry(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEenheidEntry" ):
                return visitor.visitEenheidEntry(self)
            else:
                return visitor.visitChildren(self)




    def eenheidEntry(self):

        localctx = RegelSpraakParser.EenheidEntryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 82, self.RULE_eenheidEntry)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 785
            _la = self._input.LA(1)
            if not(_la==208 or _la==213):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 786
            localctx.unitName = self.unitIdentifier()
            self.state = 791
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==174:
                self.state = 787
                self.match(RegelSpraakParser.MV_START)
                self.state = 788
                localctx.pluralName = self.unitIdentifier()
                self.state = 789
                self.match(RegelSpraakParser.RPAREN)


            self.state = 793
            localctx.abbrev = self.unitIdentifier()
            self.state = 795
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==133 or ((((_la - 205)) & ~0x3f) == 0 and ((1 << (_la - 205)) & 576449784568606723) != 0):
                self.state = 794
                localctx.symbol = self.unitIdentifier()


            self.state = 803
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==265:
                self.state = 797
                self.match(RegelSpraakParser.EQUALS)
                self.state = 799
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==278:
                    self.state = 798
                    self.match(RegelSpraakParser.SLASH)


                self.state = 801
                localctx.value = self.match(RegelSpraakParser.NUMBER)
                self.state = 802
                localctx.targetUnit = self.unitIdentifier()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UnitIdentifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(RegelSpraakParser.IDENTIFIER, 0)

        def METER(self):
            return self.getToken(RegelSpraakParser.METER, 0)

        def KILOGRAM(self):
            return self.getToken(RegelSpraakParser.KILOGRAM, 0)

        def MILLISECONDE(self):
            return self.getToken(RegelSpraakParser.MILLISECONDE, 0)

        def SECONDE(self):
            return self.getToken(RegelSpraakParser.SECONDE, 0)

        def MINUUT(self):
            return self.getToken(RegelSpraakParser.MINUUT, 0)

        def MINUTEN(self):
            return self.getToken(RegelSpraakParser.MINUTEN, 0)

        def UUR(self):
            return self.getToken(RegelSpraakParser.UUR, 0)

        def UREN(self):
            return self.getToken(RegelSpraakParser.UREN, 0)

        def VOET(self):
            return self.getToken(RegelSpraakParser.VOET, 0)

        def POND(self):
            return self.getToken(RegelSpraakParser.POND, 0)

        def MIJL(self):
            return self.getToken(RegelSpraakParser.MIJL, 0)

        def M(self):
            return self.getToken(RegelSpraakParser.M, 0)

        def KG(self):
            return self.getToken(RegelSpraakParser.KG, 0)

        def S(self):
            return self.getToken(RegelSpraakParser.S, 0)

        def FT(self):
            return self.getToken(RegelSpraakParser.FT, 0)

        def LB(self):
            return self.getToken(RegelSpraakParser.LB, 0)

        def MIN(self):
            return self.getToken(RegelSpraakParser.MIN, 0)

        def MI(self):
            return self.getToken(RegelSpraakParser.MI, 0)

        def EURO_SYMBOL(self):
            return self.getToken(RegelSpraakParser.EURO_SYMBOL, 0)

        def DOLLAR_SYMBOL(self):
            return self.getToken(RegelSpraakParser.DOLLAR_SYMBOL, 0)

        def DEGREE_SYMBOL(self):
            return self.getToken(RegelSpraakParser.DEGREE_SYMBOL, 0)

        def DAG(self):
            return self.getToken(RegelSpraakParser.DAG, 0)

        def DAGEN(self):
            return self.getToken(RegelSpraakParser.DAGEN, 0)

        def MAAND(self):
            return self.getToken(RegelSpraakParser.MAAND, 0)

        def MAANDEN(self):
            return self.getToken(RegelSpraakParser.MAANDEN, 0)

        def JAAR(self):
            return self.getToken(RegelSpraakParser.JAAR, 0)

        def JAREN(self):
            return self.getToken(RegelSpraakParser.JAREN, 0)

        def WEEK(self):
            return self.getToken(RegelSpraakParser.WEEK, 0)

        def WEKEN(self):
            return self.getToken(RegelSpraakParser.WEKEN, 0)

        def KWARTAAL(self):
            return self.getToken(RegelSpraakParser.KWARTAAL, 0)

        def SECONDEN(self):
            return self.getToken(RegelSpraakParser.SECONDEN, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_unitIdentifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnitIdentifier" ):
                listener.enterUnitIdentifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnitIdentifier" ):
                listener.exitUnitIdentifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnitIdentifier" ):
                return visitor.visitUnitIdentifier(self)
            else:
                return visitor.visitChildren(self)




    def unitIdentifier(self):

        localctx = RegelSpraakParser.UnitIdentifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 84, self.RULE_unitIdentifier)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 805
            _la = self._input.LA(1)
            if not(_la==133 or ((((_la - 205)) & ~0x3f) == 0 and ((1 << (_la - 205)) & 576449784568606723) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EenheidExpressieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def eenheidMacht(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.EenheidMachtContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.EenheidMachtContext,i)


        def SLASH(self):
            return self.getToken(RegelSpraakParser.SLASH, 0)

        def NUMBER(self):
            return self.getToken(RegelSpraakParser.NUMBER, 0)

        def PERCENT_SIGN(self):
            return self.getToken(RegelSpraakParser.PERCENT_SIGN, 0)

        def EURO_SYMBOL(self):
            return self.getToken(RegelSpraakParser.EURO_SYMBOL, 0)

        def DOLLAR_SYMBOL(self):
            return self.getToken(RegelSpraakParser.DOLLAR_SYMBOL, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_eenheidExpressie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEenheidExpressie" ):
                listener.enterEenheidExpressie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEenheidExpressie" ):
                listener.exitEenheidExpressie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEenheidExpressie" ):
                return visitor.visitEenheidExpressie(self)
            else:
                return visitor.visitChildren(self)




    def eenheidExpressie(self):

        localctx = RegelSpraakParser.EenheidExpressieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 86, self.RULE_eenheidExpressie)
        self._la = 0 # Token type
        try:
            self.state = 816
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,83,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 807
                self.eenheidMacht()
                self.state = 810
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==278:
                    self.state = 808
                    self.match(RegelSpraakParser.SLASH)
                    self.state = 809
                    self.eenheidMacht()


                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 812
                self.match(RegelSpraakParser.NUMBER)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 813
                self.match(RegelSpraakParser.PERCENT_SIGN)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 814
                self.match(RegelSpraakParser.EURO_SYMBOL)
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 815
                self.match(RegelSpraakParser.DOLLAR_SYMBOL)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EenheidMachtContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def unitIdentifier(self):
            return self.getTypedRuleContext(RegelSpraakParser.UnitIdentifierContext,0)


        def CARET(self):
            return self.getToken(RegelSpraakParser.CARET, 0)

        def NUMBER(self):
            return self.getToken(RegelSpraakParser.NUMBER, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_eenheidMacht

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEenheidMacht" ):
                listener.enterEenheidMacht(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEenheidMacht" ):
                listener.exitEenheidMacht(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEenheidMacht" ):
                return visitor.visitEenheidMacht(self)
            else:
                return visitor.visitChildren(self)




    def eenheidMacht(self):

        localctx = RegelSpraakParser.EenheidMachtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 88, self.RULE_eenheidMacht)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 818
            self.unitIdentifier()
            self.state = 821
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==284:
                self.state = 819
                self.match(RegelSpraakParser.CARET)
                self.state = 820
                self.match(RegelSpraakParser.NUMBER)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DimensieDefinitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.dimensieNaamMeervoud = None # NaamwoordContext

        def DIMENSIE(self):
            return self.getToken(RegelSpraakParser.DIMENSIE, 0)

        def naamwoord(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.NaamwoordContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,i)


        def BESTAANDE_UIT(self):
            return self.getToken(RegelSpraakParser.BESTAANDE_UIT, 0)

        def voorzetselSpecificatie(self):
            return self.getTypedRuleContext(RegelSpraakParser.VoorzetselSpecificatieContext,0)


        def COMMA(self):
            return self.getToken(RegelSpraakParser.COMMA, 0)

        def labelWaardeSpecificatie(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.LabelWaardeSpecificatieContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.LabelWaardeSpecificatieContext,i)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_dimensieDefinition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDimensieDefinition" ):
                listener.enterDimensieDefinition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDimensieDefinition" ):
                listener.exitDimensieDefinition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDimensieDefinition" ):
                return visitor.visitDimensieDefinition(self)
            else:
                return visitor.visitChildren(self)




    def dimensieDefinition(self):

        localctx = RegelSpraakParser.DimensieDefinitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 90, self.RULE_dimensieDefinition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 823
            self.match(RegelSpraakParser.DIMENSIE)
            self.state = 824
            self.naamwoord()
            self.state = 826
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==274:
                self.state = 825
                self.match(RegelSpraakParser.COMMA)


            self.state = 828
            self.match(RegelSpraakParser.BESTAANDE_UIT)
            self.state = 829
            localctx.dimensieNaamMeervoud = self.naamwoord()
            self.state = 830
            self.voorzetselSpecificatie()
            self.state = 832 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 831
                self.labelWaardeSpecificatie()
                self.state = 834 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==264):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VoorzetselSpecificatieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.vz = None # VoorzetselContext

        def NA_HET_ATTRIBUUT_MET_VOORZETSEL(self):
            return self.getToken(RegelSpraakParser.NA_HET_ATTRIBUUT_MET_VOORZETSEL, 0)

        def RPAREN(self):
            return self.getToken(RegelSpraakParser.RPAREN, 0)

        def voorzetsel(self):
            return self.getTypedRuleContext(RegelSpraakParser.VoorzetselContext,0)


        def COLON(self):
            return self.getToken(RegelSpraakParser.COLON, 0)

        def VOOR_HET_ATTRIBUUT_ZONDER_VOORZETSEL(self):
            return self.getToken(RegelSpraakParser.VOOR_HET_ATTRIBUUT_ZONDER_VOORZETSEL, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_voorzetselSpecificatie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVoorzetselSpecificatie" ):
                listener.enterVoorzetselSpecificatie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVoorzetselSpecificatie" ):
                listener.exitVoorzetselSpecificatie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVoorzetselSpecificatie" ):
                return visitor.visitVoorzetselSpecificatie(self)
            else:
                return visitor.visitChildren(self)




    def voorzetselSpecificatie(self):

        localctx = RegelSpraakParser.VoorzetselSpecificatieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 92, self.RULE_voorzetselSpecificatie)
        self._la = 0 # Token type
        try:
            self.state = 843
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [2]:
                self.enterOuterAlt(localctx, 1)
                self.state = 836
                self.match(RegelSpraakParser.NA_HET_ATTRIBUUT_MET_VOORZETSEL)
                self.state = 837
                localctx.vz = self.voorzetsel()
                self.state = 838
                self.match(RegelSpraakParser.RPAREN)
                self.state = 840
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==276:
                    self.state = 839
                    self.match(RegelSpraakParser.COLON)


                pass
            elif token in [1]:
                self.enterOuterAlt(localctx, 2)
                self.state = 842
                self.match(RegelSpraakParser.VOOR_HET_ATTRIBUUT_ZONDER_VOORZETSEL)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LabelWaardeSpecificatieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.dimWaarde = None # NaamwoordContext

        def NUMBER(self):
            return self.getToken(RegelSpraakParser.NUMBER, 0)

        def DOT(self):
            return self.getToken(RegelSpraakParser.DOT, 0)

        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_labelWaardeSpecificatie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLabelWaardeSpecificatie" ):
                listener.enterLabelWaardeSpecificatie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLabelWaardeSpecificatie" ):
                listener.exitLabelWaardeSpecificatie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLabelWaardeSpecificatie" ):
                return visitor.visitLabelWaardeSpecificatie(self)
            else:
                return visitor.visitChildren(self)




    def labelWaardeSpecificatie(self):

        localctx = RegelSpraakParser.LabelWaardeSpecificatieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 94, self.RULE_labelWaardeSpecificatie)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 845
            self.match(RegelSpraakParser.NUMBER)
            self.state = 846
            self.match(RegelSpraakParser.DOT)
            self.state = 847
            localctx.dimWaarde = self.naamwoord()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TijdlijnContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def VOOR_ELKE_DAG(self):
            return self.getToken(RegelSpraakParser.VOOR_ELKE_DAG, 0)

        def VOOR_ELKE_MAAND(self):
            return self.getToken(RegelSpraakParser.VOOR_ELKE_MAAND, 0)

        def VOOR_ELK_JAAR(self):
            return self.getToken(RegelSpraakParser.VOOR_ELK_JAAR, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_tijdlijn

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTijdlijn" ):
                listener.enterTijdlijn(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTijdlijn" ):
                listener.exitTijdlijn(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTijdlijn" ):
                return visitor.visitTijdlijn(self)
            else:
                return visitor.visitChildren(self)




    def tijdlijn(self):

        localctx = RegelSpraakParser.TijdlijnContext(self, self._ctx, self.state)
        self.enterRule(localctx, 96, self.RULE_tijdlijn)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 849
            _la = self._input.LA(1)
            if not(((((_la - 183)) & ~0x3f) == 0 and ((1 << (_la - 183)) & 7) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DimensieRefContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.name = None # Token

        def IDENTIFIER(self):
            return self.getToken(RegelSpraakParser.IDENTIFIER, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_dimensieRef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDimensieRef" ):
                listener.enterDimensieRef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDimensieRef" ):
                listener.exitDimensieRef(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDimensieRef" ):
                return visitor.visitDimensieRef(self)
            else:
                return visitor.visitChildren(self)




    def dimensieRef(self):

        localctx = RegelSpraakParser.DimensieRefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 98, self.RULE_dimensieRef)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 851
            localctx.name = self.match(RegelSpraakParser.IDENTIFIER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParameterDefinitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PARAMETER(self):
            return self.getToken(RegelSpraakParser.PARAMETER, 0)

        def parameterNamePhrase(self):
            return self.getTypedRuleContext(RegelSpraakParser.ParameterNamePhraseContext,0)


        def COLON(self):
            return self.getToken(RegelSpraakParser.COLON, 0)

        def datatype(self):
            return self.getTypedRuleContext(RegelSpraakParser.DatatypeContext,0)


        def domeinRef(self):
            return self.getTypedRuleContext(RegelSpraakParser.DomeinRefContext,0)


        def MET_EENHEID(self):
            return self.getToken(RegelSpraakParser.MET_EENHEID, 0)

        def eenheidExpressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.EenheidExpressieContext,0)


        def IS(self):
            return self.getToken(RegelSpraakParser.IS, 0)

        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)


        def tijdlijn(self):
            return self.getTypedRuleContext(RegelSpraakParser.TijdlijnContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_parameterDefinition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParameterDefinition" ):
                listener.enterParameterDefinition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParameterDefinition" ):
                listener.exitParameterDefinition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParameterDefinition" ):
                return visitor.visitParameterDefinition(self)
            else:
                return visitor.visitChildren(self)




    def parameterDefinition(self):

        localctx = RegelSpraakParser.ParameterDefinitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 100, self.RULE_parameterDefinition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 853
            self.match(RegelSpraakParser.PARAMETER)
            self.state = 854
            self.parameterNamePhrase()
            self.state = 855
            self.match(RegelSpraakParser.COLON)
            self.state = 858
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [3, 101, 162, 164, 177, 178, 182]:
                self.state = 856
                self.datatype()
                pass
            elif token in [263]:
                self.state = 857
                self.domeinRef()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 862
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==173:
                self.state = 860
                self.match(RegelSpraakParser.MET_EENHEID)
                self.state = 861
                self.eenheidExpressie()


            self.state = 866
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==113:
                self.state = 864
                self.match(RegelSpraakParser.IS)
                self.state = 865
                self.expressie()


            self.state = 869
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 183)) & ~0x3f) == 0 and ((1 << (_la - 183)) & 7) != 0):
                self.state = 868
                self.tijdlijn()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParameterNamePhraseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def parameterNamePart(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.ParameterNamePartContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.ParameterNamePartContext,i)


        def voorzetsel(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.VoorzetselContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.VoorzetselContext,i)


        def DE(self):
            return self.getToken(RegelSpraakParser.DE, 0)

        def HET(self):
            return self.getToken(RegelSpraakParser.HET, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_parameterNamePhrase

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParameterNamePhrase" ):
                listener.enterParameterNamePhrase(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParameterNamePhrase" ):
                listener.exitParameterNamePhrase(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParameterNamePhrase" ):
                return visitor.visitParameterNamePhrase(self)
            else:
                return visitor.visitChildren(self)




    def parameterNamePhrase(self):

        localctx = RegelSpraakParser.ParameterNamePhraseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 102, self.RULE_parameterNamePhrase)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 872
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==208 or _la==213:
                self.state = 871
                _la = self._input.LA(1)
                if not(_la==208 or _la==213):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


            self.state = 874
            self.parameterNamePart()
            self.state = 880
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((((_la - 142)) & ~0x3f) == 0 and ((1 << (_la - 142)) & 4611686019501129733) != 0) or ((((_la - 212)) & ~0x3f) == 0 and ((1 << (_la - 212)) & 4597129233) != 0):
                self.state = 875
                self.voorzetsel()
                self.state = 876
                self.parameterNamePart()
                self.state = 882
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParameterNamePartContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.IDENTIFIER)
            else:
                return self.getToken(RegelSpraakParser.IDENTIFIER, i)

        def AANTAL(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.AANTAL)
            else:
                return self.getToken(RegelSpraakParser.AANTAL, i)

        def NUMBER(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.NUMBER)
            else:
                return self.getToken(RegelSpraakParser.NUMBER, i)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_parameterNamePart

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParameterNamePart" ):
                listener.enterParameterNamePart(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParameterNamePart" ):
                listener.exitParameterNamePart(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParameterNamePart" ):
                return visitor.visitParameterNamePart(self)
            else:
                return visitor.visitChildren(self)




    def parameterNamePart(self):

        localctx = RegelSpraakParser.ParameterNamePartContext(self, self._ctx, self.state)
        self.enterRule(localctx, 104, self.RULE_parameterNamePart)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 884 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 883
                    _la = self._input.LA(1)
                    if not(_la==186 or _la==263 or _la==264):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()

                else:
                    raise NoViableAltException(self)
                self.state = 886 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,95,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParameterMetLidwoordContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def parameterNamePart(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.ParameterNamePartContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.ParameterNamePartContext,i)


        def voorzetsel(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.VoorzetselContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.VoorzetselContext,i)


        def DE(self):
            return self.getToken(RegelSpraakParser.DE, 0)

        def HET(self):
            return self.getToken(RegelSpraakParser.HET, 0)

        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_parameterMetLidwoord

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParameterMetLidwoord" ):
                listener.enterParameterMetLidwoord(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParameterMetLidwoord" ):
                listener.exitParameterMetLidwoord(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParameterMetLidwoord" ):
                return visitor.visitParameterMetLidwoord(self)
            else:
                return visitor.visitChildren(self)




    def parameterMetLidwoord(self):

        localctx = RegelSpraakParser.ParameterMetLidwoordContext(self, self._ctx, self.state)
        self.enterRule(localctx, 106, self.RULE_parameterMetLidwoord)
        self._la = 0 # Token type
        try:
            self.state = 901
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,98,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 889
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==208 or _la==213:
                    self.state = 888
                    _la = self._input.LA(1)
                    if not(_la==208 or _la==213):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                self.state = 891
                self.parameterNamePart()
                self.state = 897
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,97,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 892
                        self.voorzetsel()
                        self.state = 893
                        self.parameterNamePart() 
                    self.state = 899
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,97,self._ctx)

                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 900
                self.naamwoord()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FeitTypeDefinitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.feittypenaam = None # NaamwoordContext

        def FEITTYPE(self):
            return self.getToken(RegelSpraakParser.FEITTYPE, 0)

        def rolDefinition(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.RolDefinitionContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.RolDefinitionContext,i)


        def cardinalityLine(self):
            return self.getTypedRuleContext(RegelSpraakParser.CardinalityLineContext,0)


        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def WEDERKERIG_FEITTYPE(self):
            return self.getToken(RegelSpraakParser.WEDERKERIG_FEITTYPE, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_feitTypeDefinition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFeitTypeDefinition" ):
                listener.enterFeitTypeDefinition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFeitTypeDefinition" ):
                listener.exitFeitTypeDefinition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFeitTypeDefinition" ):
                return visitor.visitFeitTypeDefinition(self)
            else:
                return visitor.visitChildren(self)




    def feitTypeDefinition(self):

        localctx = RegelSpraakParser.FeitTypeDefinitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 108, self.RULE_feitTypeDefinition)
        try:
            self.state = 918
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [105]:
                self.enterOuterAlt(localctx, 1)
                self.state = 903
                self.match(RegelSpraakParser.FEITTYPE)
                self.state = 904
                localctx.feittypenaam = self.naamwoord()
                self.state = 905
                self.rolDefinition()
                self.state = 907 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 906
                        self.rolDefinition()

                    else:
                        raise NoViableAltException(self)
                    self.state = 909 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,99,self._ctx)

                self.state = 911
                self.cardinalityLine()
                pass
            elif token in [28]:
                self.enterOuterAlt(localctx, 2)
                self.state = 913
                self.match(RegelSpraakParser.WEDERKERIG_FEITTYPE)
                self.state = 914
                localctx.feittypenaam = self.naamwoord()
                self.state = 915
                self.rolDefinition()
                self.state = 916
                self.cardinalityLine()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RolDefinitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.article = None # Token
            self.content = None # RolContentWordsContext
            self.meervoud = None # NaamwoordContext
            self.objecttype = None # RolObjectTypeContext

        def rolContentWords(self):
            return self.getTypedRuleContext(RegelSpraakParser.RolContentWordsContext,0)


        def DE(self):
            return self.getToken(RegelSpraakParser.DE, 0)

        def HET(self):
            return self.getToken(RegelSpraakParser.HET, 0)

        def MV_START(self):
            return self.getToken(RegelSpraakParser.MV_START, 0)

        def RPAREN(self):
            return self.getToken(RegelSpraakParser.RPAREN, 0)

        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def rolObjectType(self):
            return self.getTypedRuleContext(RegelSpraakParser.RolObjectTypeContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_rolDefinition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRolDefinition" ):
                listener.enterRolDefinition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRolDefinition" ):
                listener.exitRolDefinition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRolDefinition" ):
                return visitor.visitRolDefinition(self)
            else:
                return visitor.visitChildren(self)




    def rolDefinition(self):

        localctx = RegelSpraakParser.RolDefinitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 110, self.RULE_rolDefinition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 920
            localctx.article = self._input.LT(1)
            _la = self._input.LA(1)
            if not(_la==208 or _la==213):
                localctx.article = self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 921
            localctx.content = self.rolContentWords()
            self.state = 926
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,101,self._ctx)
            if la_ == 1:
                self.state = 922
                self.match(RegelSpraakParser.MV_START)
                self.state = 923
                localctx.meervoud = self.naamwoord()
                self.state = 924
                self.match(RegelSpraakParser.RPAREN)


            self.state = 929
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,102,self._ctx)
            if la_ == 1:
                self.state = 928
                localctx.objecttype = self.rolObjectType()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RolObjectTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifierOrKeyword(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.IdentifierOrKeywordContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.IdentifierOrKeywordContext,i)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_rolObjectType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRolObjectType" ):
                listener.enterRolObjectType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRolObjectType" ):
                listener.exitRolObjectType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRolObjectType" ):
                return visitor.visitRolObjectType(self)
            else:
                return visitor.visitChildren(self)




    def rolObjectType(self):

        localctx = RegelSpraakParser.RolObjectTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 112, self.RULE_rolObjectType)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 932 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 931
                    self.identifierOrKeyword()

                else:
                    raise NoViableAltException(self)
                self.state = 934 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,103,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RolContentWordsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifierOrKeyword(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.IdentifierOrKeywordContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.IdentifierOrKeywordContext,i)


        def voorzetsel(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.VoorzetselContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.VoorzetselContext,i)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_rolContentWords

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRolContentWords" ):
                listener.enterRolContentWords(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRolContentWords" ):
                listener.exitRolContentWords(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRolContentWords" ):
                return visitor.visitRolContentWords(self)
            else:
                return visitor.visitChildren(self)




    def rolContentWords(self):

        localctx = RegelSpraakParser.RolContentWordsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 114, self.RULE_rolContentWords)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 938 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 938
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [96, 110, 113, 120, 128, 157, 186, 197, 198, 201, 202, 205, 206, 217, 219, 220, 228, 230, 249, 263]:
                        self.state = 936
                        self.identifierOrKeyword()
                        pass
                    elif token in [142, 144, 172, 204, 212, 216, 225, 227, 229, 237, 240, 244]:
                        self.state = 937
                        self.voorzetsel()
                        pass
                    else:
                        raise NoViableAltException(self)


                else:
                    raise NoViableAltException(self)
                self.state = 940 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,105,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CardinalityLineContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def cardinalityWord(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.CardinalityWordContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.CardinalityWordContext,i)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_cardinalityLine

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCardinalityLine" ):
                listener.enterCardinalityLine(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCardinalityLine" ):
                listener.exitCardinalityLine(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCardinalityLine" ):
                return visitor.visitCardinalityLine(self)
            else:
                return visitor.visitChildren(self)




    def cardinalityLine(self):

        localctx = RegelSpraakParser.CardinalityLineContext(self, self._ctx, self.state)
        self.enterRule(localctx, 116, self.RULE_cardinalityLine)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 943 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 942
                    self.cardinalityWord()

                else:
                    raise NoViableAltException(self)
                self.state = 945 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,106,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CardinalityWordContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OBJECTTYPE(self):
            return self.getToken(RegelSpraakParser.OBJECTTYPE, 0)

        def PARAMETER(self):
            return self.getToken(RegelSpraakParser.PARAMETER, 0)

        def REGEL(self):
            return self.getToken(RegelSpraakParser.REGEL, 0)

        def FEITTYPE(self):
            return self.getToken(RegelSpraakParser.FEITTYPE, 0)

        def WEDERKERIG_FEITTYPE(self):
            return self.getToken(RegelSpraakParser.WEDERKERIG_FEITTYPE, 0)

        def DIMENSIE(self):
            return self.getToken(RegelSpraakParser.DIMENSIE, 0)

        def DOMEIN(self):
            return self.getToken(RegelSpraakParser.DOMEIN, 0)

        def BESLISTABEL(self):
            return self.getToken(RegelSpraakParser.BESLISTABEL, 0)

        def CONSISTENTIEREGEL(self):
            return self.getToken(RegelSpraakParser.CONSISTENTIEREGEL, 0)

        def EENHEIDSYSTEEM(self):
            return self.getToken(RegelSpraakParser.EENHEIDSYSTEEM, 0)

        def DAGSOORT(self):
            return self.getToken(RegelSpraakParser.DAGSOORT, 0)

        def SEMICOLON(self):
            return self.getToken(RegelSpraakParser.SEMICOLON, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_cardinalityWord

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCardinalityWord" ):
                listener.enterCardinalityWord(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCardinalityWord" ):
                listener.exitCardinalityWord(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCardinalityWord" ):
                return visitor.visitCardinalityWord(self)
            else:
                return visitor.visitChildren(self)




    def cardinalityWord(self):

        localctx = RegelSpraakParser.CardinalityWordContext(self, self._ctx, self.state)
        self.enterRule(localctx, 118, self.RULE_cardinalityWord)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 947
            _la = self._input.LA(1)
            if _la <= 0 or _la==28 or ((((_la - 95)) & ~0x3f) == 0 and ((1 << (_la - 95)) & 4027) != 0) or _la==277:
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RegelContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def REGEL(self):
            return self.getToken(RegelSpraakParser.REGEL, 0)

        def regelName(self):
            return self.getTypedRuleContext(RegelSpraakParser.RegelNameContext,0)


        def regelVersie(self):
            return self.getTypedRuleContext(RegelSpraakParser.RegelVersieContext,0)


        def resultaatDeel(self):
            return self.getTypedRuleContext(RegelSpraakParser.ResultaatDeelContext,0)


        def NUMBER(self):
            return self.getToken(RegelSpraakParser.NUMBER, 0)

        def voorwaardeDeel(self):
            return self.getTypedRuleContext(RegelSpraakParser.VoorwaardeDeelContext,0)


        def DOT(self):
            return self.getToken(RegelSpraakParser.DOT, 0)

        def variabeleDeel(self):
            return self.getTypedRuleContext(RegelSpraakParser.VariabeleDeelContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_regel

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRegel" ):
                listener.enterRegel(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRegel" ):
                listener.exitRegel(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRegel" ):
                return visitor.visitRegel(self)
            else:
                return visitor.visitChildren(self)




    def regel(self):

        localctx = RegelSpraakParser.RegelContext(self, self._ctx, self.state)
        self.enterRule(localctx, 120, self.RULE_regel)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 949
            self.match(RegelSpraakParser.REGEL)
            self.state = 950
            self.regelName()
            self.state = 952
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==264:
                self.state = 951
                self.match(RegelSpraakParser.NUMBER)


            self.state = 954
            self.regelVersie()
            self.state = 955
            self.resultaatDeel()
            self.state = 961
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [111]:
                self.state = 956
                self.voorwaardeDeel()
                self.state = 958
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==275:
                    self.state = 957
                    self.match(RegelSpraakParser.DOT)


                pass
            elif token in [275]:
                self.state = 960
                self.match(RegelSpraakParser.DOT)
                pass
            elif token in [-1, 28, 95, 96, 97, 98, 99, 100, 102, 103, 104, 105, 106, 107]:
                pass
            else:
                pass
            self.state = 964
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==107:
                self.state = 963
                self.variabeleDeel()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RegelGroepContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.isRecursive = None # Token

        def REGELGROEP(self):
            return self.getToken(RegelSpraakParser.REGELGROEP, 0)

        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def regel(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.RegelContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.RegelContext,i)


        def consistentieregel(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.ConsistentieregelContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.ConsistentieregelContext,i)


        def IS_RECURSIEF(self):
            return self.getToken(RegelSpraakParser.IS_RECURSIEF, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_regelGroep

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRegelGroep" ):
                listener.enterRegelGroep(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRegelGroep" ):
                listener.exitRegelGroep(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRegelGroep" ):
                return visitor.visitRegelGroep(self)
            else:
                return visitor.visitChildren(self)




    def regelGroep(self):

        localctx = RegelSpraakParser.RegelGroepContext(self, self._ctx, self.state)
        self.enterRule(localctx, 122, self.RULE_regelGroep)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 966
            self.match(RegelSpraakParser.REGELGROEP)
            self.state = 967
            self.naamwoord()
            self.state = 969
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==112:
                self.state = 968
                localctx.isRecursive = self.match(RegelSpraakParser.IS_RECURSIEF)


            self.state = 973 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 973
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [96]:
                        self.state = 971
                        self.regel()
                        pass
                    elif token in [95]:
                        self.state = 972
                        self.consistentieregel()
                        pass
                    else:
                        raise NoViableAltException(self)


                else:
                    raise NoViableAltException(self)
                self.state = 975 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,113,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RegelNameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def naamwoordWithNumbers(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordWithNumbersContext,0)


        def regelNameExtension(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.RegelNameExtensionContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.RegelNameExtensionContext,i)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_regelName

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRegelName" ):
                listener.enterRegelName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRegelName" ):
                listener.exitRegelName(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRegelName" ):
                return visitor.visitRegelName(self)
            else:
                return visitor.visitChildren(self)




    def regelName(self):

        localctx = RegelSpraakParser.RegelNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 124, self.RULE_regelName)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 977
            self.naamwoordWithNumbers()
            self.state = 981
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==113 or ((((_la - 194)) & ~0x3f) == 0 and ((1 << (_la - 194)) & 262209) != 0) or _la==274:
                self.state = 978
                self.regelNameExtension()
                self.state = 983
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RegelNameExtensionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IN_GELIJKE_DELEN(self):
            return self.getToken(RegelSpraakParser.IN_GELIJKE_DELEN, 0)

        def COMMA(self):
            return self.getToken(RegelSpraakParser.COMMA, 0)

        def naamwoordWithNumbers(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordWithNumbersContext,0)


        def MET(self):
            return self.getToken(RegelSpraakParser.MET, 0)

        def EN(self):
            return self.getToken(RegelSpraakParser.EN, 0)

        def IS(self):
            return self.getToken(RegelSpraakParser.IS, 0)

        def GEEN(self):
            return self.getToken(RegelSpraakParser.GEEN, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_regelNameExtension

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRegelNameExtension" ):
                listener.enterRegelNameExtension(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRegelNameExtension" ):
                listener.exitRegelNameExtension(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRegelNameExtension" ):
                return visitor.visitRegelNameExtension(self)
            else:
                return visitor.visitChildren(self)




    def regelNameExtension(self):

        localctx = RegelSpraakParser.RegelNameExtensionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 126, self.RULE_regelNameExtension)
        try:
            self.state = 998
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,115,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 984
                self.match(RegelSpraakParser.IN_GELIJKE_DELEN)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 985
                self.match(RegelSpraakParser.COMMA)
                self.state = 986
                self.naamwoordWithNumbers()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 987
                self.match(RegelSpraakParser.COMMA)
                self.state = 988
                self.match(RegelSpraakParser.MET)
                self.state = 989
                self.naamwoordWithNumbers()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 990
                self.match(RegelSpraakParser.EN)
                self.state = 991
                self.naamwoordWithNumbers()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 992
                self.match(RegelSpraakParser.IS)
                self.state = 993
                self.naamwoordWithNumbers()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 994
                self.match(RegelSpraakParser.GEEN)
                self.state = 995
                self.naamwoordWithNumbers()
                self.state = 996
                self.match(RegelSpraakParser.IS)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RegelVersieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GELDIG(self):
            return self.getToken(RegelSpraakParser.GELDIG, 0)

        def versieGeldigheid(self):
            return self.getTypedRuleContext(RegelSpraakParser.VersieGeldigheidContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_regelVersie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRegelVersie" ):
                listener.enterRegelVersie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRegelVersie" ):
                listener.exitRegelVersie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRegelVersie" ):
                return visitor.visitRegelVersie(self)
            else:
                return visitor.visitChildren(self)




    def regelVersie(self):

        localctx = RegelSpraakParser.RegelVersieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 128, self.RULE_regelVersie)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1000
            self.match(RegelSpraakParser.GELDIG)
            self.state = 1001
            self.versieGeldigheid()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VersieGeldigheidContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ALTIJD(self):
            return self.getToken(RegelSpraakParser.ALTIJD, 0)

        def VANAF(self):
            return self.getToken(RegelSpraakParser.VANAF, 0)

        def datumLiteral(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.DatumLiteralContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.DatumLiteralContext,i)


        def TM(self):
            return self.getToken(RegelSpraakParser.TM, 0)

        def TOT_EN_MET(self):
            return self.getToken(RegelSpraakParser.TOT_EN_MET, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_versieGeldigheid

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVersieGeldigheid" ):
                listener.enterVersieGeldigheid(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVersieGeldigheid" ):
                listener.exitVersieGeldigheid(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVersieGeldigheid" ):
                return visitor.visitVersieGeldigheid(self)
            else:
                return visitor.visitChildren(self)




    def versieGeldigheid(self):

        localctx = RegelSpraakParser.VersieGeldigheidContext(self, self._ctx, self.state)
        self.enterRule(localctx, 130, self.RULE_versieGeldigheid)
        self._la = 0 # Token type
        try:
            self.state = 1010
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [203]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1003
                self.match(RegelSpraakParser.ALTIJD)
                pass
            elif token in [146]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1004
                self.match(RegelSpraakParser.VANAF)
                self.state = 1005
                self.datumLiteral()
                self.state = 1008
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==144 or _la==236:
                    self.state = 1006
                    _la = self._input.LA(1)
                    if not(_la==144 or _la==236):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()
                    self.state = 1007
                    self.datumLiteral()


                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ResultaatDeelContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_resultaatDeel

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class GelijkstellingResultaatContext(ResultaatDeelContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.ResultaatDeelContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def attribuutReferentie(self):
            return self.getTypedRuleContext(RegelSpraakParser.AttribuutReferentieContext,0)

        def WORDT_BEREKEND_ALS(self):
            return self.getToken(RegelSpraakParser.WORDT_BEREKEND_ALS, 0)
        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)

        def WORDT_GESTELD_OP(self):
            return self.getToken(RegelSpraakParser.WORDT_GESTELD_OP, 0)
        def WORDT_GEINITIALISEERD_OP(self):
            return self.getToken(RegelSpraakParser.WORDT_GEINITIALISEERD_OP, 0)
        def periodeDefinitie(self):
            return self.getTypedRuleContext(RegelSpraakParser.PeriodeDefinitieContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGelijkstellingResultaat" ):
                listener.enterGelijkstellingResultaat(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGelijkstellingResultaat" ):
                listener.exitGelijkstellingResultaat(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGelijkstellingResultaat" ):
                return visitor.visitGelijkstellingResultaat(self)
            else:
                return visitor.visitChildren(self)


    class RelationshipWithAttributeResultaatContext(ResultaatDeelContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.ResultaatDeelContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def onderwerpReferentie(self):
            return self.getTypedRuleContext(RegelSpraakParser.OnderwerpReferentieContext,0)

        def HEEFT(self):
            return self.getToken(RegelSpraakParser.HEEFT, 0)
        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)

        def MET(self):
            return self.getToken(RegelSpraakParser.MET, 0)
        def attribuutMetLidwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.AttribuutMetLidwoordContext,0)

        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)

        def DE(self):
            return self.getToken(RegelSpraakParser.DE, 0)
        def HET(self):
            return self.getToken(RegelSpraakParser.HET, 0)
        def GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.GELIJK_AAN, 0)
        def IS_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.IS_GELIJK_AAN, 0)
        def GELIJK_IS_AAN(self):
            return self.getToken(RegelSpraakParser.GELIJK_IS_AAN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRelationshipWithAttributeResultaat" ):
                listener.enterRelationshipWithAttributeResultaat(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRelationshipWithAttributeResultaat" ):
                listener.exitRelationshipWithAttributeResultaat(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRelationshipWithAttributeResultaat" ):
                return visitor.visitRelationshipWithAttributeResultaat(self)
            else:
                return visitor.visitChildren(self)


    class ConsistencyCheckResultaatContext(ResultaatDeelContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.ResultaatDeelContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def attribuutReferentie(self):
            return self.getTypedRuleContext(RegelSpraakParser.AttribuutReferentieContext,0)

        def MOET(self):
            return self.getToken(RegelSpraakParser.MOET, 0)
        def consistencyOperator(self):
            return self.getTypedRuleContext(RegelSpraakParser.ConsistencyOperatorContext,0)

        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConsistencyCheckResultaat" ):
                listener.enterConsistencyCheckResultaat(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConsistencyCheckResultaat" ):
                listener.exitConsistencyCheckResultaat(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConsistencyCheckResultaat" ):
                return visitor.visitConsistencyCheckResultaat(self)
            else:
                return visitor.visitChildren(self)


    class VerdelingContext(ResultaatDeelContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.ResultaatDeelContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def verdelingResultaat(self):
            return self.getTypedRuleContext(RegelSpraakParser.VerdelingResultaatContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVerdeling" ):
                listener.enterVerdeling(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVerdeling" ):
                listener.exitVerdeling(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVerdeling" ):
                return visitor.visitVerdeling(self)
            else:
                return visitor.visitChildren(self)


    class ObjectCreatieResultaatContext(ResultaatDeelContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.ResultaatDeelContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def objectCreatie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ObjectCreatieContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterObjectCreatieResultaat" ):
                listener.enterObjectCreatieResultaat(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitObjectCreatieResultaat" ):
                listener.exitObjectCreatieResultaat(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitObjectCreatieResultaat" ):
                return visitor.visitObjectCreatieResultaat(self)
            else:
                return visitor.visitChildren(self)


    class DagsoortdefinitieResultaatContext(ResultaatDeelContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.ResultaatDeelContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def EEN(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.EEN)
            else:
                return self.getToken(RegelSpraakParser.EEN, i)
        def DAG(self):
            return self.getToken(RegelSpraakParser.DAG, 0)
        def IS(self):
            return self.getToken(RegelSpraakParser.IS, 0)
        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDagsoortdefinitieResultaat" ):
                listener.enterDagsoortdefinitieResultaat(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDagsoortdefinitieResultaat" ):
                listener.exitDagsoortdefinitieResultaat(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDagsoortdefinitieResultaat" ):
                return visitor.visitDagsoortdefinitieResultaat(self)
            else:
                return visitor.visitChildren(self)


    class KenmerkFeitResultaatContext(ResultaatDeelContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.ResultaatDeelContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def onderwerpReferentie(self):
            return self.getTypedRuleContext(RegelSpraakParser.OnderwerpReferentieContext,0)

        def kenmerkNaam(self):
            return self.getTypedRuleContext(RegelSpraakParser.KenmerkNaamContext,0)

        def IS(self):
            return self.getToken(RegelSpraakParser.IS, 0)
        def HEEFT(self):
            return self.getToken(RegelSpraakParser.HEEFT, 0)
        def periodeDefinitie(self):
            return self.getTypedRuleContext(RegelSpraakParser.PeriodeDefinitieContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterKenmerkFeitResultaat" ):
                listener.enterKenmerkFeitResultaat(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitKenmerkFeitResultaat" ):
                listener.exitKenmerkFeitResultaat(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitKenmerkFeitResultaat" ):
                return visitor.visitKenmerkFeitResultaat(self)
            else:
                return visitor.visitChildren(self)


    class FeitCreatieResultaatContext(ResultaatDeelContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.ResultaatDeelContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def feitCreatiePattern(self):
            return self.getTypedRuleContext(RegelSpraakParser.FeitCreatiePatternContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFeitCreatieResultaat" ):
                listener.enterFeitCreatieResultaat(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFeitCreatieResultaat" ):
                listener.exitFeitCreatieResultaat(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFeitCreatieResultaat" ):
                return visitor.visitFeitCreatieResultaat(self)
            else:
                return visitor.visitChildren(self)



    def resultaatDeel(self):

        localctx = RegelSpraakParser.ResultaatDeelContext(self, self._ctx, self.state)
        self.enterRule(localctx, 132, self.RULE_resultaatDeel)
        self._la = 0 # Token type
        try:
            self.state = 1052
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,121,self._ctx)
            if la_ == 1:
                localctx = RegelSpraakParser.DagsoortdefinitieResultaatContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1012
                self.match(RegelSpraakParser.EEN)
                self.state = 1013
                self.match(RegelSpraakParser.DAG)
                self.state = 1014
                self.match(RegelSpraakParser.IS)
                self.state = 1015
                self.match(RegelSpraakParser.EEN)
                self.state = 1016
                self.naamwoord()
                pass

            elif la_ == 2:
                localctx = RegelSpraakParser.GelijkstellingResultaatContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1017
                self.attribuutReferentie()
                self.state = 1024
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [8]:
                    self.state = 1018
                    self.match(RegelSpraakParser.WORDT_BEREKEND_ALS)
                    self.state = 1019
                    self.expressie()
                    pass
                elif token in [9]:
                    self.state = 1020
                    self.match(RegelSpraakParser.WORDT_GESTELD_OP)
                    self.state = 1021
                    self.expressie()
                    pass
                elif token in [10]:
                    self.state = 1022
                    self.match(RegelSpraakParser.WORDT_GEINITIALISEERD_OP)
                    self.state = 1023
                    self.expressie()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 1027
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if ((((_la - 142)) & ~0x3f) == 0 and ((1 << (_la - 142)) & 21) != 0) or _la==240:
                    self.state = 1026
                    self.periodeDefinitie()


                pass

            elif la_ == 3:
                localctx = RegelSpraakParser.ConsistencyCheckResultaatContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 1029
                self.attribuutReferentie()
                self.state = 1030
                self.match(RegelSpraakParser.MOET)
                self.state = 1031
                self.consistencyOperator()
                self.state = 1032
                self.expressie()
                pass

            elif la_ == 4:
                localctx = RegelSpraakParser.FeitCreatieResultaatContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 1034
                self.feitCreatiePattern()
                pass

            elif la_ == 5:
                localctx = RegelSpraakParser.KenmerkFeitResultaatContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 1035
                self.onderwerpReferentie()
                self.state = 1036
                _la = self._input.LA(1)
                if not(_la==110 or _la==113):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1037
                self.kenmerkNaam()
                self.state = 1039
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if ((((_la - 142)) & ~0x3f) == 0 and ((1 << (_la - 142)) & 21) != 0) or _la==240:
                    self.state = 1038
                    self.periodeDefinitie()


                pass

            elif la_ == 6:
                localctx = RegelSpraakParser.RelationshipWithAttributeResultaatContext(self, localctx)
                self.enterOuterAlt(localctx, 6)
                self.state = 1041
                self.onderwerpReferentie()
                self.state = 1042
                self.match(RegelSpraakParser.HEEFT)
                self.state = 1043
                _la = self._input.LA(1)
                if not(_la==208 or _la==213):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1044
                self.naamwoord()
                self.state = 1045
                self.match(RegelSpraakParser.MET)
                self.state = 1046
                self.attribuutMetLidwoord()
                self.state = 1047
                _la = self._input.LA(1)
                if not(_la==47 or _la==48 or _la==124):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1048
                self.expressie()
                pass

            elif la_ == 7:
                localctx = RegelSpraakParser.ObjectCreatieResultaatContext(self, localctx)
                self.enterOuterAlt(localctx, 7)
                self.state = 1050
                self.objectCreatie()
                pass

            elif la_ == 8:
                localctx = RegelSpraakParser.VerdelingContext(self, localctx)
                self.enterOuterAlt(localctx, 8)
                self.state = 1051
                self.verdelingResultaat()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConsistencyOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ONGELIJK_ZIJN_AAN(self):
            return self.getToken(RegelSpraakParser.ONGELIJK_ZIJN_AAN, 0)

        def ONGELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.ONGELIJK_AAN, 0)

        def IS_ONGELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.IS_ONGELIJK_AAN, 0)

        def GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.GELIJK_AAN, 0)

        def IS_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.IS_GELIJK_AAN, 0)

        def GROTER_DAN(self):
            return self.getToken(RegelSpraakParser.GROTER_DAN, 0)

        def IS_GROTER_DAN(self):
            return self.getToken(RegelSpraakParser.IS_GROTER_DAN, 0)

        def KLEINER_DAN(self):
            return self.getToken(RegelSpraakParser.KLEINER_DAN, 0)

        def IS_KLEINER_DAN(self):
            return self.getToken(RegelSpraakParser.IS_KLEINER_DAN, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_consistencyOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConsistencyOperator" ):
                listener.enterConsistencyOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConsistencyOperator" ):
                listener.exitConsistencyOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConsistencyOperator" ):
                return visitor.visitConsistencyOperator(self)
            else:
                return visitor.visitChildren(self)




    def consistencyOperator(self):

        localctx = RegelSpraakParser.ConsistencyOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 134, self.RULE_consistencyOperator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1054
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 6473924464345088) != 0) or ((((_la - 124)) & ~0x3f) == 0 and ((1 << (_la - 124)) & 24617) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FeitCreatiePatternContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.role1 = None # FeitCreatieRolPhraseContext
            self.subject1 = None # FeitCreatieSubjectPhraseContext
            self.article2 = None # Token
            self.role2 = None # FeitCreatieRolPhraseContext
            self.article3 = None # Token
            self.subject2 = None # FeitCreatieSubjectPhraseContext

        def EEN(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.EEN)
            else:
                return self.getToken(RegelSpraakParser.EEN, i)

        def VAN(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.VAN)
            else:
                return self.getToken(RegelSpraakParser.VAN, i)

        def IS(self):
            return self.getToken(RegelSpraakParser.IS, 0)

        def feitCreatieRolPhrase(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.FeitCreatieRolPhraseContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.FeitCreatieRolPhraseContext,i)


        def feitCreatieSubjectPhrase(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.FeitCreatieSubjectPhraseContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.FeitCreatieSubjectPhraseContext,i)


        def DE(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.DE)
            else:
                return self.getToken(RegelSpraakParser.DE, i)

        def HET(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.HET)
            else:
                return self.getToken(RegelSpraakParser.HET, i)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_feitCreatiePattern

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFeitCreatiePattern" ):
                listener.enterFeitCreatiePattern(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFeitCreatiePattern" ):
                listener.exitFeitCreatiePattern(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFeitCreatiePattern" ):
                return visitor.visitFeitCreatiePattern(self)
            else:
                return visitor.visitChildren(self)




    def feitCreatiePattern(self):

        localctx = RegelSpraakParser.FeitCreatiePatternContext(self, self._ctx, self.state)
        self.enterRule(localctx, 136, self.RULE_feitCreatiePattern)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1056
            self.match(RegelSpraakParser.EEN)
            self.state = 1057
            localctx.role1 = self.feitCreatieRolPhrase()
            self.state = 1058
            self.match(RegelSpraakParser.VAN)
            self.state = 1059
            self.match(RegelSpraakParser.EEN)
            self.state = 1060
            localctx.subject1 = self.feitCreatieSubjectPhrase()
            self.state = 1061
            self.match(RegelSpraakParser.IS)
            self.state = 1062
            localctx.article2 = self._input.LT(1)
            _la = self._input.LA(1)
            if not(((((_la - 208)) & ~0x3f) == 0 and ((1 << (_la - 208)) & 41) != 0)):
                localctx.article2 = self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 1063
            localctx.role2 = self.feitCreatieRolPhrase()
            self.state = 1064
            self.match(RegelSpraakParser.VAN)
            self.state = 1065
            localctx.article3 = self._input.LT(1)
            _la = self._input.LA(1)
            if not(((((_la - 208)) & ~0x3f) == 0 and ((1 << (_la - 208)) & 41) != 0)):
                localctx.article3 = self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 1066
            localctx.subject2 = self.feitCreatieSubjectPhrase()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FeitCreatieRolPhraseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def feitCreatieWord(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.FeitCreatieWordContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.FeitCreatieWordContext,i)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_feitCreatieRolPhrase

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFeitCreatieRolPhrase" ):
                listener.enterFeitCreatieRolPhrase(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFeitCreatieRolPhrase" ):
                listener.exitFeitCreatieRolPhrase(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFeitCreatieRolPhrase" ):
                return visitor.visitFeitCreatieRolPhrase(self)
            else:
                return visitor.visitChildren(self)




    def feitCreatieRolPhrase(self):

        localctx = RegelSpraakParser.FeitCreatieRolPhraseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 138, self.RULE_feitCreatieRolPhrase)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1069 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 1068
                self.feitCreatieWord()
                self.state = 1071 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (((((_la - 96)) & ~0x3f) == 0 and ((1 << (_la - 96)) & 2305913382269763585) != 0) or ((((_la - 172)) & ~0x3f) == 0 and ((1 << (_la - 172)) & 540908075595350017) != 0) or ((((_la - 237)) & ~0x3f) == 0 and ((1 << (_la - 237)) & 67113089) != 0)):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FeitCreatieSubjectPhraseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def feitCreatieSubjectWord(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.FeitCreatieSubjectWordContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.FeitCreatieSubjectWordContext,i)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_feitCreatieSubjectPhrase

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFeitCreatieSubjectPhrase" ):
                listener.enterFeitCreatieSubjectPhrase(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFeitCreatieSubjectPhrase" ):
                listener.exitFeitCreatieSubjectPhrase(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFeitCreatieSubjectPhrase" ):
                return visitor.visitFeitCreatieSubjectPhrase(self)
            else:
                return visitor.visitChildren(self)




    def feitCreatieSubjectPhrase(self):

        localctx = RegelSpraakParser.FeitCreatieSubjectPhraseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 140, self.RULE_feitCreatieSubjectPhrase)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1074 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 1073
                    self.feitCreatieSubjectWord()

                else:
                    raise NoViableAltException(self)
                self.state = 1076 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,123,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FeitCreatieSubjectWordContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifierOrKeyword(self):
            return self.getTypedRuleContext(RegelSpraakParser.IdentifierOrKeywordContext,0)


        def voorzetsel(self):
            return self.getTypedRuleContext(RegelSpraakParser.VoorzetselContext,0)


        def DE(self):
            return self.getToken(RegelSpraakParser.DE, 0)

        def HET(self):
            return self.getToken(RegelSpraakParser.HET, 0)

        def EEN(self):
            return self.getToken(RegelSpraakParser.EEN, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_feitCreatieSubjectWord

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFeitCreatieSubjectWord" ):
                listener.enterFeitCreatieSubjectWord(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFeitCreatieSubjectWord" ):
                listener.exitFeitCreatieSubjectWord(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFeitCreatieSubjectWord" ):
                return visitor.visitFeitCreatieSubjectWord(self)
            else:
                return visitor.visitChildren(self)




    def feitCreatieSubjectWord(self):

        localctx = RegelSpraakParser.FeitCreatieSubjectWordContext(self, self._ctx, self.state)
        self.enterRule(localctx, 142, self.RULE_feitCreatieSubjectWord)
        try:
            self.state = 1083
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [96, 110, 113, 120, 128, 157, 186, 197, 198, 201, 202, 205, 206, 217, 219, 220, 228, 230, 249, 263]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1078
                self.identifierOrKeyword()
                pass
            elif token in [142, 144, 172, 204, 212, 216, 225, 227, 229, 237, 240, 244]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1079
                self.voorzetsel()
                pass
            elif token in [208]:
                self.enterOuterAlt(localctx, 3)
                self.state = 1080
                self.match(RegelSpraakParser.DE)
                pass
            elif token in [213]:
                self.enterOuterAlt(localctx, 4)
                self.state = 1081
                self.match(RegelSpraakParser.HET)
                pass
            elif token in [211]:
                self.enterOuterAlt(localctx, 5)
                self.state = 1082
                self.match(RegelSpraakParser.EEN)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FeitCreatieWordContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifierOrKeyword(self):
            return self.getTypedRuleContext(RegelSpraakParser.IdentifierOrKeywordContext,0)


        def voorzetselNietVan(self):
            return self.getTypedRuleContext(RegelSpraakParser.VoorzetselNietVanContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_feitCreatieWord

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFeitCreatieWord" ):
                listener.enterFeitCreatieWord(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFeitCreatieWord" ):
                listener.exitFeitCreatieWord(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFeitCreatieWord" ):
                return visitor.visitFeitCreatieWord(self)
            else:
                return visitor.visitChildren(self)




    def feitCreatieWord(self):

        localctx = RegelSpraakParser.FeitCreatieWordContext(self, self._ctx, self.state)
        self.enterRule(localctx, 144, self.RULE_feitCreatieWord)
        try:
            self.state = 1087
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [96, 110, 113, 120, 128, 157, 186, 197, 198, 201, 202, 205, 206, 217, 219, 220, 228, 230, 249, 263]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1085
                self.identifierOrKeyword()
                pass
            elif token in [142, 172, 204, 212, 216, 227, 229, 237, 244]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1086
                self.voorzetselNietVan()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VoorzetselNietVanContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IN(self):
            return self.getToken(RegelSpraakParser.IN, 0)

        def VOOR(self):
            return self.getToken(RegelSpraakParser.VOOR, 0)

        def OVER(self):
            return self.getToken(RegelSpraakParser.OVER, 0)

        def OP(self):
            return self.getToken(RegelSpraakParser.OP, 0)

        def BIJ(self):
            return self.getToken(RegelSpraakParser.BIJ, 0)

        def UIT(self):
            return self.getToken(RegelSpraakParser.UIT, 0)

        def TOT(self):
            return self.getToken(RegelSpraakParser.TOT, 0)

        def EN(self):
            return self.getToken(RegelSpraakParser.EN, 0)

        def MET(self):
            return self.getToken(RegelSpraakParser.MET, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_voorzetselNietVan

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVoorzetselNietVan" ):
                listener.enterVoorzetselNietVan(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVoorzetselNietVan" ):
                listener.exitVoorzetselNietVan(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVoorzetselNietVan" ):
                return visitor.visitVoorzetselNietVan(self)
            else:
                return visitor.visitChildren(self)




    def voorzetselNietVan(self):

        localctx = RegelSpraakParser.VoorzetselNietVanContext(self, self._ctx, self.state)
        self.enterRule(localctx, 146, self.RULE_voorzetselNietVan)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1089
            _la = self._input.LA(1)
            if not(((((_la - 142)) & ~0x3f) == 0 and ((1 << (_la - 142)) & 4611686019501129729) != 0) or ((((_la - 212)) & ~0x3f) == 0 and ((1 << (_la - 212)) & 4328685585) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ObjectCreatieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.objectType = None # NaamwoordContext

        def ER_WORDT_EEN_NIEUW(self):
            return self.getToken(RegelSpraakParser.ER_WORDT_EEN_NIEUW, 0)

        def AANGEMAAKT(self):
            return self.getToken(RegelSpraakParser.AANGEMAAKT, 0)

        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def objectAttributeInit(self):
            return self.getTypedRuleContext(RegelSpraakParser.ObjectAttributeInitContext,0)


        def DOT(self):
            return self.getToken(RegelSpraakParser.DOT, 0)

        def CREEER(self):
            return self.getToken(RegelSpraakParser.CREEER, 0)

        def EEN(self):
            return self.getToken(RegelSpraakParser.EEN, 0)

        def NIEUWE(self):
            return self.getToken(RegelSpraakParser.NIEUWE, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_objectCreatie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterObjectCreatie" ):
                listener.enterObjectCreatie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitObjectCreatie" ):
                listener.exitObjectCreatie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitObjectCreatie" ):
                return visitor.visitObjectCreatie(self)
            else:
                return visitor.visitChildren(self)




    def objectCreatie(self):

        localctx = RegelSpraakParser.ObjectCreatieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 148, self.RULE_objectCreatie)
        self._la = 0 # Token type
        try:
            self.state = 1110
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [41]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1091
                self.match(RegelSpraakParser.ER_WORDT_EEN_NIEUW)
                self.state = 1092
                localctx.objectType = self.naamwoord()
                self.state = 1093
                self.match(RegelSpraakParser.AANGEMAAKT)
                self.state = 1095
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==172:
                    self.state = 1094
                    self.objectAttributeInit()


                self.state = 1098
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,127,self._ctx)
                if la_ == 1:
                    self.state = 1097
                    self.match(RegelSpraakParser.DOT)


                pass
            elif token in [44]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1100
                self.match(RegelSpraakParser.CREEER)
                self.state = 1101
                self.match(RegelSpraakParser.EEN)
                self.state = 1102
                self.match(RegelSpraakParser.NIEUWE)
                self.state = 1103
                localctx.objectType = self.naamwoord()
                self.state = 1105
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==172:
                    self.state = 1104
                    self.objectAttributeInit()


                self.state = 1108
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,129,self._ctx)
                if la_ == 1:
                    self.state = 1107
                    self.match(RegelSpraakParser.DOT)


                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ObjectAttributeInitContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.attribuut = None # SimpleNaamwoordContext
            self.waarde = None # SimpleExpressieContext

        def MET(self):
            return self.getToken(RegelSpraakParser.MET, 0)

        def GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.GELIJK_AAN, 0)

        def simpleNaamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.SimpleNaamwoordContext,0)


        def simpleExpressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.SimpleExpressieContext,0)


        def attributeInitVervolg(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.AttributeInitVervolgContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.AttributeInitVervolgContext,i)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_objectAttributeInit

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterObjectAttributeInit" ):
                listener.enterObjectAttributeInit(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitObjectAttributeInit" ):
                listener.exitObjectAttributeInit(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitObjectAttributeInit" ):
                return visitor.visitObjectAttributeInit(self)
            else:
                return visitor.visitChildren(self)




    def objectAttributeInit(self):

        localctx = RegelSpraakParser.ObjectAttributeInitContext(self, self._ctx, self.state)
        self.enterRule(localctx, 150, self.RULE_objectAttributeInit)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1112
            self.match(RegelSpraakParser.MET)
            self.state = 1113
            localctx.attribuut = self.simpleNaamwoord()
            self.state = 1114
            self.match(RegelSpraakParser.GELIJK_AAN)
            self.state = 1115
            localctx.waarde = self.simpleExpressie()
            self.state = 1119
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==212:
                self.state = 1116
                self.attributeInitVervolg()
                self.state = 1121
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AttributeInitVervolgContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.attribuut = None # SimpleNaamwoordContext
            self.waarde = None # SimpleExpressieContext

        def EN(self):
            return self.getToken(RegelSpraakParser.EN, 0)

        def GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.GELIJK_AAN, 0)

        def simpleNaamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.SimpleNaamwoordContext,0)


        def simpleExpressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.SimpleExpressieContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_attributeInitVervolg

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAttributeInitVervolg" ):
                listener.enterAttributeInitVervolg(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAttributeInitVervolg" ):
                listener.exitAttributeInitVervolg(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAttributeInitVervolg" ):
                return visitor.visitAttributeInitVervolg(self)
            else:
                return visitor.visitChildren(self)




    def attributeInitVervolg(self):

        localctx = RegelSpraakParser.AttributeInitVervolgContext(self, self._ctx, self.state)
        self.enterRule(localctx, 152, self.RULE_attributeInitVervolg)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1122
            self.match(RegelSpraakParser.EN)
            self.state = 1123
            localctx.attribuut = self.simpleNaamwoord()
            self.state = 1124
            self.match(RegelSpraakParser.GELIJK_AAN)
            self.state = 1125
            localctx.waarde = self.simpleExpressie()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SimpleNaamwoordContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def naamPhrase(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamPhraseContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_simpleNaamwoord

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSimpleNaamwoord" ):
                listener.enterSimpleNaamwoord(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSimpleNaamwoord" ):
                listener.exitSimpleNaamwoord(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSimpleNaamwoord" ):
                return visitor.visitSimpleNaamwoord(self)
            else:
                return visitor.visitChildren(self)




    def simpleNaamwoord(self):

        localctx = RegelSpraakParser.SimpleNaamwoordContext(self, self._ctx, self.state)
        self.enterRule(localctx, 154, self.RULE_simpleNaamwoord)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1127
            self.naamPhrase()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConsistentieregelContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CONSISTENTIEREGEL(self):
            return self.getToken(RegelSpraakParser.CONSISTENTIEREGEL, 0)

        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def uniekzijnResultaat(self):
            return self.getTypedRuleContext(RegelSpraakParser.UniekzijnResultaatContext,0)


        def inconsistentResultaat(self):
            return self.getTypedRuleContext(RegelSpraakParser.InconsistentResultaatContext,0)


        def voorwaardeDeel(self):
            return self.getTypedRuleContext(RegelSpraakParser.VoorwaardeDeelContext,0)


        def DOT(self):
            return self.getToken(RegelSpraakParser.DOT, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_consistentieregel

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConsistentieregel" ):
                listener.enterConsistentieregel(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConsistentieregel" ):
                listener.exitConsistentieregel(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConsistentieregel" ):
                return visitor.visitConsistentieregel(self)
            else:
                return visitor.visitChildren(self)




    def consistentieregel(self):

        localctx = RegelSpraakParser.ConsistentieregelContext(self, self._ctx, self.state)
        self.enterRule(localctx, 156, self.RULE_consistentieregel)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1129
            self.match(RegelSpraakParser.CONSISTENTIEREGEL)
            self.state = 1130
            self.naamwoord()
            self.state = 1140
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,134,self._ctx)
            if la_ == 1:
                self.state = 1131
                self.uniekzijnResultaat()
                pass

            elif la_ == 2:
                self.state = 1132
                self.inconsistentResultaat()
                self.state = 1138
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [111]:
                    self.state = 1133
                    self.voorwaardeDeel()
                    self.state = 1135
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==275:
                        self.state = 1134
                        self.match(RegelSpraakParser.DOT)


                    pass
                elif token in [275]:
                    self.state = 1137
                    self.match(RegelSpraakParser.DOT)
                    pass
                elif token in [-1, 28, 95, 96, 97, 98, 99, 100, 102, 103, 104, 105, 106]:
                    pass
                else:
                    pass
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UniekzijnResultaatContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def alleAttributenVanObjecttype(self):
            return self.getTypedRuleContext(RegelSpraakParser.AlleAttributenVanObjecttypeContext,0)


        def MOETEN_UNIEK_ZIJN(self):
            return self.getToken(RegelSpraakParser.MOETEN_UNIEK_ZIJN, 0)

        def DOT(self):
            return self.getToken(RegelSpraakParser.DOT, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_uniekzijnResultaat

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUniekzijnResultaat" ):
                listener.enterUniekzijnResultaat(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUniekzijnResultaat" ):
                listener.exitUniekzijnResultaat(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUniekzijnResultaat" ):
                return visitor.visitUniekzijnResultaat(self)
            else:
                return visitor.visitChildren(self)




    def uniekzijnResultaat(self):

        localctx = RegelSpraakParser.UniekzijnResultaatContext(self, self._ctx, self.state)
        self.enterRule(localctx, 158, self.RULE_uniekzijnResultaat)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1142
            self.alleAttributenVanObjecttype()
            self.state = 1143
            self.match(RegelSpraakParser.MOETEN_UNIEK_ZIJN)
            self.state = 1145
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==275:
                self.state = 1144
                self.match(RegelSpraakParser.DOT)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AlleAttributenVanObjecttypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DE(self):
            return self.getToken(RegelSpraakParser.DE, 0)

        def naamwoord(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.NaamwoordContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,i)


        def VAN(self):
            return self.getToken(RegelSpraakParser.VAN, 0)

        def ALLE(self):
            return self.getToken(RegelSpraakParser.ALLE, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_alleAttributenVanObjecttype

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAlleAttributenVanObjecttype" ):
                listener.enterAlleAttributenVanObjecttype(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAlleAttributenVanObjecttype" ):
                listener.exitAlleAttributenVanObjecttype(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAlleAttributenVanObjecttype" ):
                return visitor.visitAlleAttributenVanObjecttype(self)
            else:
                return visitor.visitChildren(self)




    def alleAttributenVanObjecttype(self):

        localctx = RegelSpraakParser.AlleAttributenVanObjecttypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 160, self.RULE_alleAttributenVanObjecttype)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1147
            self.match(RegelSpraakParser.DE)
            self.state = 1148
            self.naamwoord()
            self.state = 1149
            self.match(RegelSpraakParser.VAN)
            self.state = 1150
            self.match(RegelSpraakParser.ALLE)
            self.state = 1151
            self.naamwoord()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InconsistentResultaatContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def IS_INCONSISTENT(self):
            return self.getToken(RegelSpraakParser.IS_INCONSISTENT, 0)

        def DE(self):
            return self.getToken(RegelSpraakParser.DE, 0)

        def HET(self):
            return self.getToken(RegelSpraakParser.HET, 0)

        def ER(self):
            return self.getToken(RegelSpraakParser.ER, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_inconsistentResultaat

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInconsistentResultaat" ):
                listener.enterInconsistentResultaat(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInconsistentResultaat" ):
                listener.exitInconsistentResultaat(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInconsistentResultaat" ):
                return visitor.visitInconsistentResultaat(self)
            else:
                return visitor.visitChildren(self)




    def inconsistentResultaat(self):

        localctx = RegelSpraakParser.InconsistentResultaatContext(self, self._ctx, self.state)
        self.enterRule(localctx, 162, self.RULE_inconsistentResultaat)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1154
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,136,self._ctx)
            if la_ == 1:
                self.state = 1153
                _la = self._input.LA(1)
                if not(((((_la - 208)) & ~0x3f) == 0 and ((1 << (_la - 208)) & 1099511627809) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


            self.state = 1156
            self.naamwoord()
            self.state = 1157
            self.match(RegelSpraakParser.IS_INCONSISTENT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VoorwaardeDeelContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INDIEN(self):
            return self.getToken(RegelSpraakParser.INDIEN, 0)

        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)


        def toplevelSamengesteldeVoorwaarde(self):
            return self.getTypedRuleContext(RegelSpraakParser.ToplevelSamengesteldeVoorwaardeContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_voorwaardeDeel

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVoorwaardeDeel" ):
                listener.enterVoorwaardeDeel(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVoorwaardeDeel" ):
                listener.exitVoorwaardeDeel(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVoorwaardeDeel" ):
                return visitor.visitVoorwaardeDeel(self)
            else:
                return visitor.visitChildren(self)




    def voorwaardeDeel(self):

        localctx = RegelSpraakParser.VoorwaardeDeelContext(self, self._ctx, self.state)
        self.enterRule(localctx, 164, self.RULE_voorwaardeDeel)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1159
            self.match(RegelSpraakParser.INDIEN)
            self.state = 1162
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,137,self._ctx)
            if la_ == 1:
                self.state = 1160
                self.expressie()
                pass

            elif la_ == 2:
                self.state = 1161
                self.toplevelSamengesteldeVoorwaarde()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ToplevelSamengesteldeVoorwaardeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ER_AAN(self):
            return self.getToken(RegelSpraakParser.ER_AAN, 0)

        def voorwaardeKwantificatie(self):
            return self.getTypedRuleContext(RegelSpraakParser.VoorwaardeKwantificatieContext,0)


        def WORDT_VOLDAAN(self):
            return self.getToken(RegelSpraakParser.WORDT_VOLDAAN, 0)

        def COLON(self):
            return self.getToken(RegelSpraakParser.COLON, 0)

        def VOLGENDE_VOORWAARDEN(self):
            return self.getToken(RegelSpraakParser.VOLGENDE_VOORWAARDEN, 0)

        def VOLGENDE_VOORWAARDE(self):
            return self.getToken(RegelSpraakParser.VOLGENDE_VOORWAARDE, 0)

        def samengesteldeVoorwaardeOnderdeel(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.SamengesteldeVoorwaardeOnderdeelContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.SamengesteldeVoorwaardeOnderdeelContext,i)


        def AAN(self):
            return self.getToken(RegelSpraakParser.AAN, 0)

        def VOLDOET(self):
            return self.getToken(RegelSpraakParser.VOLDOET, 0)

        def onderwerpReferentie(self):
            return self.getTypedRuleContext(RegelSpraakParser.OnderwerpReferentieContext,0)


        def HIJ(self):
            return self.getToken(RegelSpraakParser.HIJ, 0)

        def HET(self):
            return self.getToken(RegelSpraakParser.HET, 0)

        def ER(self):
            return self.getToken(RegelSpraakParser.ER, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_toplevelSamengesteldeVoorwaarde

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterToplevelSamengesteldeVoorwaarde" ):
                listener.enterToplevelSamengesteldeVoorwaarde(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitToplevelSamengesteldeVoorwaarde" ):
                listener.exitToplevelSamengesteldeVoorwaarde(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitToplevelSamengesteldeVoorwaarde" ):
                return visitor.visitToplevelSamengesteldeVoorwaarde(self)
            else:
                return visitor.visitChildren(self)




    def toplevelSamengesteldeVoorwaarde(self):

        localctx = RegelSpraakParser.ToplevelSamengesteldeVoorwaardeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 166, self.RULE_toplevelSamengesteldeVoorwaarde)
        self._la = 0 # Token type
        try:
            self.state = 1206
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,143,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1164
                self.match(RegelSpraakParser.ER_AAN)
                self.state = 1165
                self.voorwaardeKwantificatie()
                self.state = 1166
                _la = self._input.LA(1)
                if not(_la==241 or _la==242):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1167
                self.match(RegelSpraakParser.WORDT_VOLDAAN)
                self.state = 1168
                self.match(RegelSpraakParser.COLON)
                self.state = 1170 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 1169
                    self.samengesteldeVoorwaardeOnderdeel()
                    self.state = 1172 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (((((_la - 280)) & ~0x3f) == 0 and ((1 << (_la - 280)) & 291) != 0)):
                        break

                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1178
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,139,self._ctx)
                if la_ == 1:
                    self.state = 1174
                    self.onderwerpReferentie()
                    pass

                elif la_ == 2:
                    self.state = 1175
                    self.match(RegelSpraakParser.HIJ)
                    pass

                elif la_ == 3:
                    self.state = 1176
                    self.match(RegelSpraakParser.HET)
                    pass

                elif la_ == 4:
                    self.state = 1177
                    self.match(RegelSpraakParser.ER)
                    pass


                self.state = 1180
                self.match(RegelSpraakParser.AAN)
                self.state = 1181
                self.voorwaardeKwantificatie()
                self.state = 1182
                _la = self._input.LA(1)
                if not(_la==241 or _la==242):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1183
                self.match(RegelSpraakParser.VOLDOET)
                self.state = 1184
                self.match(RegelSpraakParser.COLON)
                self.state = 1186 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 1185
                    self.samengesteldeVoorwaardeOnderdeel()
                    self.state = 1188 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (((((_la - 280)) & ~0x3f) == 0 and ((1 << (_la - 280)) & 291) != 0)):
                        break

                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1194
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,141,self._ctx)
                if la_ == 1:
                    self.state = 1190
                    self.onderwerpReferentie()
                    pass

                elif la_ == 2:
                    self.state = 1191
                    self.match(RegelSpraakParser.HIJ)
                    pass

                elif la_ == 3:
                    self.state = 1192
                    self.match(RegelSpraakParser.HET)
                    pass

                elif la_ == 4:
                    self.state = 1193
                    self.match(RegelSpraakParser.ER)
                    pass


                self.state = 1196
                self.match(RegelSpraakParser.VOLDOET)
                self.state = 1197
                self.match(RegelSpraakParser.AAN)
                self.state = 1198
                self.voorwaardeKwantificatie()
                self.state = 1199
                _la = self._input.LA(1)
                if not(_la==241 or _la==242):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1200
                self.match(RegelSpraakParser.COLON)
                self.state = 1202 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 1201
                    self.samengesteldeVoorwaardeOnderdeel()
                    self.state = 1204 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (((((_la - 280)) & ~0x3f) == 0 and ((1 << (_la - 280)) & 291) != 0)):
                        break

                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VoorwaardeKwantificatieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ALLE(self):
            return self.getToken(RegelSpraakParser.ALLE, 0)

        def GEEN_VAN_DE(self):
            return self.getToken(RegelSpraakParser.GEEN_VAN_DE, 0)

        def VAN(self):
            return self.getToken(RegelSpraakParser.VAN, 0)

        def DE(self):
            return self.getToken(RegelSpraakParser.DE, 0)

        def TEN_MINSTE(self):
            return self.getToken(RegelSpraakParser.TEN_MINSTE, 0)

        def TENMINSTE(self):
            return self.getToken(RegelSpraakParser.TENMINSTE, 0)

        def NUMBER(self):
            return self.getToken(RegelSpraakParser.NUMBER, 0)

        def EEN(self):
            return self.getToken(RegelSpraakParser.EEN, 0)

        def EEN_TELWOORD(self):
            return self.getToken(RegelSpraakParser.EEN_TELWOORD, 0)

        def TWEE_TELWOORD(self):
            return self.getToken(RegelSpraakParser.TWEE_TELWOORD, 0)

        def DRIE_TELWOORD(self):
            return self.getToken(RegelSpraakParser.DRIE_TELWOORD, 0)

        def VIER_TELWOORD(self):
            return self.getToken(RegelSpraakParser.VIER_TELWOORD, 0)

        def TEN_HOOGSTE(self):
            return self.getToken(RegelSpraakParser.TEN_HOOGSTE, 0)

        def PRECIES(self):
            return self.getToken(RegelSpraakParser.PRECIES, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_voorwaardeKwantificatie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVoorwaardeKwantificatie" ):
                listener.enterVoorwaardeKwantificatie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVoorwaardeKwantificatie" ):
                listener.exitVoorwaardeKwantificatie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVoorwaardeKwantificatie" ):
                return visitor.visitVoorwaardeKwantificatie(self)
            else:
                return visitor.visitChildren(self)




    def voorwaardeKwantificatie(self):

        localctx = RegelSpraakParser.VoorwaardeKwantificatieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 168, self.RULE_voorwaardeKwantificatie)
        self._la = 0 # Token type
        try:
            self.state = 1222
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [120]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1208
                self.match(RegelSpraakParser.ALLE)
                pass
            elif token in [199]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1209
                self.match(RegelSpraakParser.GEEN_VAN_DE)
                pass
            elif token in [153, 154]:
                self.enterOuterAlt(localctx, 3)
                self.state = 1210
                _la = self._input.LA(1)
                if not(_la==153 or _la==154):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1211
                _la = self._input.LA(1)
                if not(((((_la - 197)) & ~0x3f) == 0 and ((1 << (_la - 197)) & 16435) != 0) or _la==264):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1212
                self.match(RegelSpraakParser.VAN)
                self.state = 1213
                self.match(RegelSpraakParser.DE)
                pass
            elif token in [155]:
                self.enterOuterAlt(localctx, 4)
                self.state = 1214
                self.match(RegelSpraakParser.TEN_HOOGSTE)
                self.state = 1215
                _la = self._input.LA(1)
                if not(((((_la - 197)) & ~0x3f) == 0 and ((1 << (_la - 197)) & 16435) != 0) or _la==264):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1216
                self.match(RegelSpraakParser.VAN)
                self.state = 1217
                self.match(RegelSpraakParser.DE)
                pass
            elif token in [156]:
                self.enterOuterAlt(localctx, 5)
                self.state = 1218
                self.match(RegelSpraakParser.PRECIES)
                self.state = 1219
                _la = self._input.LA(1)
                if not(((((_la - 197)) & ~0x3f) == 0 and ((1 << (_la - 197)) & 16435) != 0) or _la==264):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1220
                self.match(RegelSpraakParser.VAN)
                self.state = 1221
                self.match(RegelSpraakParser.DE)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SamengesteldeVoorwaardeOnderdeelContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def bulletPrefix(self):
            return self.getTypedRuleContext(RegelSpraakParser.BulletPrefixContext,0)


        def elementaireVoorwaarde(self):
            return self.getTypedRuleContext(RegelSpraakParser.ElementaireVoorwaardeContext,0)


        def genesteSamengesteldeVoorwaarde(self):
            return self.getTypedRuleContext(RegelSpraakParser.GenesteSamengesteldeVoorwaardeContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_samengesteldeVoorwaardeOnderdeel

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSamengesteldeVoorwaardeOnderdeel" ):
                listener.enterSamengesteldeVoorwaardeOnderdeel(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSamengesteldeVoorwaardeOnderdeel" ):
                listener.exitSamengesteldeVoorwaardeOnderdeel(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSamengesteldeVoorwaardeOnderdeel" ):
                return visitor.visitSamengesteldeVoorwaardeOnderdeel(self)
            else:
                return visitor.visitChildren(self)




    def samengesteldeVoorwaardeOnderdeel(self):

        localctx = RegelSpraakParser.SamengesteldeVoorwaardeOnderdeelContext(self, self._ctx, self.state)
        self.enterRule(localctx, 170, self.RULE_samengesteldeVoorwaardeOnderdeel)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1224
            self.bulletPrefix()
            self.state = 1227
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,145,self._ctx)
            if la_ == 1:
                self.state = 1225
                self.elementaireVoorwaarde()
                pass

            elif la_ == 2:
                self.state = 1226
                self.genesteSamengesteldeVoorwaarde()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BulletPrefixContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MINUS(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.MINUS)
            else:
                return self.getToken(RegelSpraakParser.MINUS, i)

        def DOUBLE_DOT(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.DOUBLE_DOT)
            else:
                return self.getToken(RegelSpraakParser.DOUBLE_DOT, i)

        def BULLET(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.BULLET)
            else:
                return self.getToken(RegelSpraakParser.BULLET, i)

        def ASTERISK(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.ASTERISK)
            else:
                return self.getToken(RegelSpraakParser.ASTERISK, i)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_bulletPrefix

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBulletPrefix" ):
                listener.enterBulletPrefix(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBulletPrefix" ):
                listener.exitBulletPrefix(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBulletPrefix" ):
                return visitor.visitBulletPrefix(self)
            else:
                return visitor.visitChildren(self)




    def bulletPrefix(self):

        localctx = RegelSpraakParser.BulletPrefixContext(self, self._ctx, self.state)
        self.enterRule(localctx, 172, self.RULE_bulletPrefix)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1230 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 1229
                    _la = self._input.LA(1)
                    if not(((((_la - 280)) & ~0x3f) == 0 and ((1 << (_la - 280)) & 291) != 0)):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()

                else:
                    raise NoViableAltException(self)
                self.state = 1232 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,146,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ElementaireVoorwaardeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_elementaireVoorwaarde

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterElementaireVoorwaarde" ):
                listener.enterElementaireVoorwaarde(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitElementaireVoorwaarde" ):
                listener.exitElementaireVoorwaarde(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitElementaireVoorwaarde" ):
                return visitor.visitElementaireVoorwaarde(self)
            else:
                return visitor.visitChildren(self)




    def elementaireVoorwaarde(self):

        localctx = RegelSpraakParser.ElementaireVoorwaardeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 174, self.RULE_elementaireVoorwaarde)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1234
            self.expressie()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GenesteSamengesteldeVoorwaardeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def VOLDOET(self):
            return self.getToken(RegelSpraakParser.VOLDOET, 0)

        def AAN(self):
            return self.getToken(RegelSpraakParser.AAN, 0)

        def voorwaardeKwantificatie(self):
            return self.getTypedRuleContext(RegelSpraakParser.VoorwaardeKwantificatieContext,0)


        def COLON(self):
            return self.getToken(RegelSpraakParser.COLON, 0)

        def VOLGENDE_VOORWAARDEN(self):
            return self.getToken(RegelSpraakParser.VOLGENDE_VOORWAARDEN, 0)

        def VOLGENDE_VOORWAARDE(self):
            return self.getToken(RegelSpraakParser.VOLGENDE_VOORWAARDE, 0)

        def onderwerpReferentie(self):
            return self.getTypedRuleContext(RegelSpraakParser.OnderwerpReferentieContext,0)


        def HIJ(self):
            return self.getToken(RegelSpraakParser.HIJ, 0)

        def ER(self):
            return self.getToken(RegelSpraakParser.ER, 0)

        def samengesteldeVoorwaardeOnderdeel(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.SamengesteldeVoorwaardeOnderdeelContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.SamengesteldeVoorwaardeOnderdeelContext,i)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_genesteSamengesteldeVoorwaarde

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGenesteSamengesteldeVoorwaarde" ):
                listener.enterGenesteSamengesteldeVoorwaarde(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGenesteSamengesteldeVoorwaarde" ):
                listener.exitGenesteSamengesteldeVoorwaarde(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGenesteSamengesteldeVoorwaarde" ):
                return visitor.visitGenesteSamengesteldeVoorwaarde(self)
            else:
                return visitor.visitChildren(self)




    def genesteSamengesteldeVoorwaarde(self):

        localctx = RegelSpraakParser.GenesteSamengesteldeVoorwaardeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 176, self.RULE_genesteSamengesteldeVoorwaarde)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1239
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,147,self._ctx)
            if la_ == 1:
                self.state = 1236
                self.onderwerpReferentie()
                pass

            elif la_ == 2:
                self.state = 1237
                self.match(RegelSpraakParser.HIJ)
                pass

            elif la_ == 3:
                self.state = 1238
                self.match(RegelSpraakParser.ER)
                pass


            self.state = 1241
            self.match(RegelSpraakParser.VOLDOET)
            self.state = 1242
            self.match(RegelSpraakParser.AAN)
            self.state = 1243
            self.voorwaardeKwantificatie()
            self.state = 1244
            _la = self._input.LA(1)
            if not(_la==241 or _la==242):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 1245
            self.match(RegelSpraakParser.COLON)
            self.state = 1247 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 1246
                    self.samengesteldeVoorwaardeOnderdeel()

                else:
                    raise NoViableAltException(self)
                self.state = 1249 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,148,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OnderwerpReferentieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def onderwerpBasis(self):
            return self.getTypedRuleContext(RegelSpraakParser.OnderwerpBasisContext,0)


        def predicaat(self):
            return self.getTypedRuleContext(RegelSpraakParser.PredicaatContext,0)


        def DIE(self):
            return self.getToken(RegelSpraakParser.DIE, 0)

        def DAT(self):
            return self.getToken(RegelSpraakParser.DAT, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_onderwerpReferentie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOnderwerpReferentie" ):
                listener.enterOnderwerpReferentie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOnderwerpReferentie" ):
                listener.exitOnderwerpReferentie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOnderwerpReferentie" ):
                return visitor.visitOnderwerpReferentie(self)
            else:
                return visitor.visitChildren(self)




    def onderwerpReferentie(self):

        localctx = RegelSpraakParser.OnderwerpReferentieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 178, self.RULE_onderwerpReferentie)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1251
            self.onderwerpBasis()
            self.state = 1254
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,149,self._ctx)
            if la_ == 1:
                self.state = 1252
                _la = self._input.LA(1)
                if not(_la==207 or _la==210):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1253
                self.predicaat()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OnderwerpReferentieWithNumbersContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def onderwerpBasisWithNumbers(self):
            return self.getTypedRuleContext(RegelSpraakParser.OnderwerpBasisWithNumbersContext,0)


        def predicaat(self):
            return self.getTypedRuleContext(RegelSpraakParser.PredicaatContext,0)


        def DIE(self):
            return self.getToken(RegelSpraakParser.DIE, 0)

        def DAT(self):
            return self.getToken(RegelSpraakParser.DAT, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_onderwerpReferentieWithNumbers

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOnderwerpReferentieWithNumbers" ):
                listener.enterOnderwerpReferentieWithNumbers(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOnderwerpReferentieWithNumbers" ):
                listener.exitOnderwerpReferentieWithNumbers(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOnderwerpReferentieWithNumbers" ):
                return visitor.visitOnderwerpReferentieWithNumbers(self)
            else:
                return visitor.visitChildren(self)




    def onderwerpReferentieWithNumbers(self):

        localctx = RegelSpraakParser.OnderwerpReferentieWithNumbersContext(self, self._ctx, self.state)
        self.enterRule(localctx, 180, self.RULE_onderwerpReferentieWithNumbers)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1256
            self.onderwerpBasisWithNumbers()
            self.state = 1259
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==207 or _la==210:
                self.state = 1257
                _la = self._input.LA(1)
                if not(_la==207 or _la==210):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1258
                self.predicaat()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OnderwerpBasisContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def basisOnderwerp(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.BasisOnderwerpContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.BasisOnderwerpContext,i)


        def voorzetsel(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.VoorzetselContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.VoorzetselContext,i)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_onderwerpBasis

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOnderwerpBasis" ):
                listener.enterOnderwerpBasis(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOnderwerpBasis" ):
                listener.exitOnderwerpBasis(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOnderwerpBasis" ):
                return visitor.visitOnderwerpBasis(self)
            else:
                return visitor.visitChildren(self)




    def onderwerpBasis(self):

        localctx = RegelSpraakParser.OnderwerpBasisContext(self, self._ctx, self.state)
        self.enterRule(localctx, 182, self.RULE_onderwerpBasis)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1261
            self.basisOnderwerp()
            self.state = 1267
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,151,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 1262
                    self.voorzetsel()
                    self.state = 1263
                    self.basisOnderwerp() 
                self.state = 1269
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,151,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OnderwerpBasisWithNumbersContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def basisOnderwerpWithNumbers(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.BasisOnderwerpWithNumbersContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.BasisOnderwerpWithNumbersContext,i)


        def voorzetsel(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.VoorzetselContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.VoorzetselContext,i)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_onderwerpBasisWithNumbers

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOnderwerpBasisWithNumbers" ):
                listener.enterOnderwerpBasisWithNumbers(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOnderwerpBasisWithNumbers" ):
                listener.exitOnderwerpBasisWithNumbers(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOnderwerpBasisWithNumbers" ):
                return visitor.visitOnderwerpBasisWithNumbers(self)
            else:
                return visitor.visitChildren(self)




    def onderwerpBasisWithNumbers(self):

        localctx = RegelSpraakParser.OnderwerpBasisWithNumbersContext(self, self._ctx, self.state)
        self.enterRule(localctx, 184, self.RULE_onderwerpBasisWithNumbers)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1270
            self.basisOnderwerpWithNumbers()
            self.state = 1276
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((((_la - 142)) & ~0x3f) == 0 and ((1 << (_la - 142)) & 4611686019501129733) != 0) or ((((_la - 212)) & ~0x3f) == 0 and ((1 << (_la - 212)) & 4597129233) != 0):
                self.state = 1271
                self.voorzetsel()
                self.state = 1272
                self.basisOnderwerpWithNumbers()
                self.state = 1278
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BasisOnderwerpContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DE(self):
            return self.getToken(RegelSpraakParser.DE, 0)

        def HET(self):
            return self.getToken(RegelSpraakParser.HET, 0)

        def EEN(self):
            return self.getToken(RegelSpraakParser.EEN, 0)

        def ZIJN(self):
            return self.getToken(RegelSpraakParser.ZIJN, 0)

        def identifierOrKeyword(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.IdentifierOrKeywordContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.IdentifierOrKeywordContext,i)


        def HIJ(self):
            return self.getToken(RegelSpraakParser.HIJ, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_basisOnderwerp

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBasisOnderwerp" ):
                listener.enterBasisOnderwerp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBasisOnderwerp" ):
                listener.exitBasisOnderwerp(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBasisOnderwerp" ):
                return visitor.visitBasisOnderwerp(self)
            else:
                return visitor.visitChildren(self)




    def basisOnderwerp(self):

        localctx = RegelSpraakParser.BasisOnderwerpContext(self, self._ctx, self.state)
        self.enterRule(localctx, 186, self.RULE_basisOnderwerp)
        self._la = 0 # Token type
        try:
            self.state = 1286
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [117, 208, 211, 213]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1279
                _la = self._input.LA(1)
                if not(_la==117 or ((((_la - 208)) & ~0x3f) == 0 and ((1 << (_la - 208)) & 41) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1281 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 1280
                        self.identifierOrKeyword()

                    else:
                        raise NoViableAltException(self)
                    self.state = 1283 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,153,self._ctx)

                pass
            elif token in [215]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1285
                self.match(RegelSpraakParser.HIJ)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BasisOnderwerpWithNumbersContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DE(self):
            return self.getToken(RegelSpraakParser.DE, 0)

        def HET(self):
            return self.getToken(RegelSpraakParser.HET, 0)

        def EEN(self):
            return self.getToken(RegelSpraakParser.EEN, 0)

        def ZIJN(self):
            return self.getToken(RegelSpraakParser.ZIJN, 0)

        def identifierOrKeywordWithNumbers(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.IdentifierOrKeywordWithNumbersContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.IdentifierOrKeywordWithNumbersContext,i)


        def HIJ(self):
            return self.getToken(RegelSpraakParser.HIJ, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_basisOnderwerpWithNumbers

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBasisOnderwerpWithNumbers" ):
                listener.enterBasisOnderwerpWithNumbers(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBasisOnderwerpWithNumbers" ):
                listener.exitBasisOnderwerpWithNumbers(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBasisOnderwerpWithNumbers" ):
                return visitor.visitBasisOnderwerpWithNumbers(self)
            else:
                return visitor.visitChildren(self)




    def basisOnderwerpWithNumbers(self):

        localctx = RegelSpraakParser.BasisOnderwerpWithNumbersContext(self, self._ctx, self.state)
        self.enterRule(localctx, 188, self.RULE_basisOnderwerpWithNumbers)
        self._la = 0 # Token type
        try:
            self.state = 1295
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [117, 208, 211, 213]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1288
                _la = self._input.LA(1)
                if not(_la==117 or ((((_la - 208)) & ~0x3f) == 0 and ((1 << (_la - 208)) & 41) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1290 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 1289
                    self.identifierOrKeywordWithNumbers()
                    self.state = 1292 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (((((_la - 96)) & ~0x3f) == 0 and ((1 << (_la - 96)) & 2305843013525585921) != 0) or ((((_la - 186)) & ~0x3f) == 0 and ((1 << (_la - 186)) & -9223350018703255551) != 0) or _la==263 or _la==264):
                        break

                pass
            elif token in [215]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1294
                self.match(RegelSpraakParser.HIJ)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AttribuutReferentieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def attribuutMetLidwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.AttribuutMetLidwoordContext,0)


        def VAN(self):
            return self.getToken(RegelSpraakParser.VAN, 0)

        def onderwerpReferentie(self):
            return self.getTypedRuleContext(RegelSpraakParser.OnderwerpReferentieContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_attribuutReferentie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAttribuutReferentie" ):
                listener.enterAttribuutReferentie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAttribuutReferentie" ):
                listener.exitAttribuutReferentie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAttribuutReferentie" ):
                return visitor.visitAttribuutReferentie(self)
            else:
                return visitor.visitChildren(self)




    def attribuutReferentie(self):

        localctx = RegelSpraakParser.AttribuutReferentieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 190, self.RULE_attribuutReferentie)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1297
            self.attribuutMetLidwoord()
            self.state = 1298
            self.match(RegelSpraakParser.VAN)
            self.state = 1299
            self.onderwerpReferentie()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AttribuutMetLidwoordContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def naamwoordNoIs(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordNoIsContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_attribuutMetLidwoord

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAttribuutMetLidwoord" ):
                listener.enterAttribuutMetLidwoord(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAttribuutMetLidwoord" ):
                listener.exitAttribuutMetLidwoord(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAttribuutMetLidwoord" ):
                return visitor.visitAttribuutMetLidwoord(self)
            else:
                return visitor.visitChildren(self)




    def attribuutMetLidwoord(self):

        localctx = RegelSpraakParser.AttribuutMetLidwoordContext(self, self._ctx, self.state)
        self.enterRule(localctx, 192, self.RULE_attribuutMetLidwoord)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1301
            self.naamwoordNoIs()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class KenmerkNaamContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def naamwoordWithNumbers(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordWithNumbersContext,0)


        def voorzetsel(self):
            return self.getTypedRuleContext(RegelSpraakParser.VoorzetselContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_kenmerkNaam

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterKenmerkNaam" ):
                listener.enterKenmerkNaam(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitKenmerkNaam" ):
                listener.exitKenmerkNaam(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitKenmerkNaam" ):
                return visitor.visitKenmerkNaam(self)
            else:
                return visitor.visitChildren(self)




    def kenmerkNaam(self):

        localctx = RegelSpraakParser.KenmerkNaamContext(self, self._ctx, self.state)
        self.enterRule(localctx, 194, self.RULE_kenmerkNaam)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1304
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 142)) & ~0x3f) == 0 and ((1 << (_la - 142)) & 4611686019501129733) != 0) or ((((_la - 212)) & ~0x3f) == 0 and ((1 << (_la - 212)) & 4597129233) != 0):
                self.state = 1303
                self.voorzetsel()


            self.state = 1306
            self.naamwoordWithNumbers()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class KenmerkPhraseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def voorzetsel(self):
            return self.getTypedRuleContext(RegelSpraakParser.VoorzetselContext,0)


        def identifierOrKeywordWithNumbers(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.IdentifierOrKeywordWithNumbersContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.IdentifierOrKeywordWithNumbersContext,i)


        def DE(self):
            return self.getToken(RegelSpraakParser.DE, 0)

        def HET(self):
            return self.getToken(RegelSpraakParser.HET, 0)

        def EEN(self):
            return self.getToken(RegelSpraakParser.EEN, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_kenmerkPhrase

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterKenmerkPhrase" ):
                listener.enterKenmerkPhrase(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitKenmerkPhrase" ):
                listener.exitKenmerkPhrase(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitKenmerkPhrase" ):
                return visitor.visitKenmerkPhrase(self)
            else:
                return visitor.visitChildren(self)




    def kenmerkPhrase(self):

        localctx = RegelSpraakParser.KenmerkPhraseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 196, self.RULE_kenmerkPhrase)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1309
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 142)) & ~0x3f) == 0 and ((1 << (_la - 142)) & 4611686019501129733) != 0) or ((((_la - 212)) & ~0x3f) == 0 and ((1 << (_la - 212)) & 4597129233) != 0):
                self.state = 1308
                self.voorzetsel()


            self.state = 1312
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 208)) & ~0x3f) == 0 and ((1 << (_la - 208)) & 41) != 0):
                self.state = 1311
                _la = self._input.LA(1)
                if not(((((_la - 208)) & ~0x3f) == 0 and ((1 << (_la - 208)) & 41) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


            self.state = 1315 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 1314
                self.identifierOrKeywordWithNumbers()
                self.state = 1317 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (((((_la - 96)) & ~0x3f) == 0 and ((1 << (_la - 96)) & 2305843013525585921) != 0) or ((((_la - 186)) & ~0x3f) == 0 and ((1 << (_la - 186)) & -9223350018703255551) != 0) or _la==263 or _la==264):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BezieldeReferentieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ZIJN(self):
            return self.getToken(RegelSpraakParser.ZIJN, 0)

        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_bezieldeReferentie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBezieldeReferentie" ):
                listener.enterBezieldeReferentie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBezieldeReferentie" ):
                listener.exitBezieldeReferentie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBezieldeReferentie" ):
                return visitor.visitBezieldeReferentie(self)
            else:
                return visitor.visitChildren(self)




    def bezieldeReferentie(self):

        localctx = RegelSpraakParser.BezieldeReferentieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 198, self.RULE_bezieldeReferentie)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1319
            self.match(RegelSpraakParser.ZIJN)
            self.state = 1320
            self.naamwoord()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PredicaatContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def elementairPredicaat(self):
            return self.getTypedRuleContext(RegelSpraakParser.ElementairPredicaatContext,0)


        def samengesteldPredicaat(self):
            return self.getTypedRuleContext(RegelSpraakParser.SamengesteldPredicaatContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_predicaat

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPredicaat" ):
                listener.enterPredicaat(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPredicaat" ):
                listener.exitPredicaat(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPredicaat" ):
                return visitor.visitPredicaat(self)
            else:
                return visitor.visitChildren(self)




    def predicaat(self):

        localctx = RegelSpraakParser.PredicaatContext(self, self._ctx, self.state)
        self.enterRule(localctx, 200, self.RULE_predicaat)
        try:
            self.state = 1324
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [45, 54, 55, 56, 57, 58, 59, 64, 65, 66, 67, 96, 110, 113, 117, 120, 128, 136, 142, 144, 157, 172, 186, 197, 198, 201, 202, 204, 205, 206, 208, 211, 212, 213, 216, 217, 219, 220, 225, 227, 228, 229, 230, 237, 240, 244, 249, 263, 264]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1322
                self.elementairPredicaat()
                pass
            elif token in [118]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1323
                self.samengesteldPredicaat()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ElementairPredicaatContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def attribuutVergelijkingsPredicaat(self):
            return self.getTypedRuleContext(RegelSpraakParser.AttribuutVergelijkingsPredicaatContext,0)


        def objectPredicaat(self):
            return self.getTypedRuleContext(RegelSpraakParser.ObjectPredicaatContext,0)


        def getalPredicaat(self):
            return self.getTypedRuleContext(RegelSpraakParser.GetalPredicaatContext,0)


        def tekstPredicaat(self):
            return self.getTypedRuleContext(RegelSpraakParser.TekstPredicaatContext,0)


        def datumPredicaat(self):
            return self.getTypedRuleContext(RegelSpraakParser.DatumPredicaatContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_elementairPredicaat

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterElementairPredicaat" ):
                listener.enterElementairPredicaat(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitElementairPredicaat" ):
                listener.exitElementairPredicaat(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitElementairPredicaat" ):
                return visitor.visitElementairPredicaat(self)
            else:
                return visitor.visitChildren(self)




    def elementairPredicaat(self):

        localctx = RegelSpraakParser.ElementairPredicaatContext(self, self._ctx, self.state)
        self.enterRule(localctx, 202, self.RULE_elementairPredicaat)
        try:
            self.state = 1331
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,162,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1326
                self.attribuutVergelijkingsPredicaat()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1327
                self.objectPredicaat()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1328
                self.getalPredicaat()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 1329
                self.tekstPredicaat()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 1330
                self.datumPredicaat()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ObjectPredicaatContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def eenzijdigeObjectVergelijking(self):
            return self.getTypedRuleContext(RegelSpraakParser.EenzijdigeObjectVergelijkingContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_objectPredicaat

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterObjectPredicaat" ):
                listener.enterObjectPredicaat(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitObjectPredicaat" ):
                listener.exitObjectPredicaat(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitObjectPredicaat" ):
                return visitor.visitObjectPredicaat(self)
            else:
                return visitor.visitChildren(self)




    def objectPredicaat(self):

        localctx = RegelSpraakParser.ObjectPredicaatContext(self, self._ctx, self.state)
        self.enterRule(localctx, 204, self.RULE_objectPredicaat)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1333
            self.eenzijdigeObjectVergelijking()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EenzijdigeObjectVergelijkingContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ZIJN(self):
            return self.getToken(RegelSpraakParser.ZIJN, 0)

        def HEBBEN(self):
            return self.getToken(RegelSpraakParser.HEBBEN, 0)

        def kenmerkNaam(self):
            return self.getTypedRuleContext(RegelSpraakParser.KenmerkNaamContext,0)


        def rolNaam(self):
            return self.getTypedRuleContext(RegelSpraakParser.RolNaamContext,0)


        def EEN(self):
            return self.getToken(RegelSpraakParser.EEN, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_eenzijdigeObjectVergelijking

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEenzijdigeObjectVergelijking" ):
                listener.enterEenzijdigeObjectVergelijking(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEenzijdigeObjectVergelijking" ):
                listener.exitEenzijdigeObjectVergelijking(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEenzijdigeObjectVergelijking" ):
                return visitor.visitEenzijdigeObjectVergelijking(self)
            else:
                return visitor.visitChildren(self)




    def eenzijdigeObjectVergelijking(self):

        localctx = RegelSpraakParser.EenzijdigeObjectVergelijkingContext(self, self._ctx, self.state)
        self.enterRule(localctx, 206, self.RULE_eenzijdigeObjectVergelijking)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1336
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,163,self._ctx)
            if la_ == 1:
                self.state = 1335
                self.match(RegelSpraakParser.EEN)


            self.state = 1340
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,164,self._ctx)
            if la_ == 1:
                self.state = 1338
                self.kenmerkNaam()
                pass

            elif la_ == 2:
                self.state = 1339
                self.rolNaam()
                pass


            self.state = 1342
            _la = self._input.LA(1)
            if not(_la==109 or _la==117):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RolNaamContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_rolNaam

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRolNaam" ):
                listener.enterRolNaam(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRolNaam" ):
                listener.exitRolNaam(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRolNaam" ):
                return visitor.visitRolNaam(self)
            else:
                return visitor.visitChildren(self)




    def rolNaam(self):

        localctx = RegelSpraakParser.RolNaamContext(self, self._ctx, self.state)
        self.enterRule(localctx, 208, self.RULE_rolNaam)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1344
            self.naamwoord()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AttribuutVergelijkingsPredicaatContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.attribuutNaam = None # NaamwoordContext

        def HEBBEN(self):
            return self.getToken(RegelSpraakParser.HEBBEN, 0)

        def comparisonOperator(self):
            return self.getTypedRuleContext(RegelSpraakParser.ComparisonOperatorContext,0)


        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)


        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def EEN(self):
            return self.getToken(RegelSpraakParser.EEN, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_attribuutVergelijkingsPredicaat

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAttribuutVergelijkingsPredicaat" ):
                listener.enterAttribuutVergelijkingsPredicaat(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAttribuutVergelijkingsPredicaat" ):
                listener.exitAttribuutVergelijkingsPredicaat(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAttribuutVergelijkingsPredicaat" ):
                return visitor.visitAttribuutVergelijkingsPredicaat(self)
            else:
                return visitor.visitChildren(self)




    def attribuutVergelijkingsPredicaat(self):

        localctx = RegelSpraakParser.AttribuutVergelijkingsPredicaatContext(self, self._ctx, self.state)
        self.enterRule(localctx, 210, self.RULE_attribuutVergelijkingsPredicaat)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1347
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,165,self._ctx)
            if la_ == 1:
                self.state = 1346
                self.match(RegelSpraakParser.EEN)


            self.state = 1349
            localctx.attribuutNaam = self.naamwoord()
            self.state = 1350
            self.match(RegelSpraakParser.HEBBEN)
            self.state = 1351
            self.comparisonOperator()
            self.state = 1352
            self.expressie()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GetalPredicaatContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def getalVergelijkingsOperatorMeervoud(self):
            return self.getTypedRuleContext(RegelSpraakParser.GetalVergelijkingsOperatorMeervoudContext,0)


        def getalExpressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.GetalExpressieContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_getalPredicaat

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGetalPredicaat" ):
                listener.enterGetalPredicaat(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGetalPredicaat" ):
                listener.exitGetalPredicaat(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGetalPredicaat" ):
                return visitor.visitGetalPredicaat(self)
            else:
                return visitor.visitChildren(self)




    def getalPredicaat(self):

        localctx = RegelSpraakParser.GetalPredicaatContext(self, self._ctx, self.state)
        self.enterRule(localctx, 212, self.RULE_getalPredicaat)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1354
            self.getalVergelijkingsOperatorMeervoud()
            self.state = 1355
            self.getalExpressie()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TekstPredicaatContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def tekstVergelijkingsOperatorMeervoud(self):
            return self.getTypedRuleContext(RegelSpraakParser.TekstVergelijkingsOperatorMeervoudContext,0)


        def tekstExpressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.TekstExpressieContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_tekstPredicaat

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTekstPredicaat" ):
                listener.enterTekstPredicaat(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTekstPredicaat" ):
                listener.exitTekstPredicaat(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTekstPredicaat" ):
                return visitor.visitTekstPredicaat(self)
            else:
                return visitor.visitChildren(self)




    def tekstPredicaat(self):

        localctx = RegelSpraakParser.TekstPredicaatContext(self, self._ctx, self.state)
        self.enterRule(localctx, 214, self.RULE_tekstPredicaat)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1357
            self.tekstVergelijkingsOperatorMeervoud()
            self.state = 1358
            self.tekstExpressie()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DatumPredicaatContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def datumVergelijkingsOperatorMeervoud(self):
            return self.getTypedRuleContext(RegelSpraakParser.DatumVergelijkingsOperatorMeervoudContext,0)


        def datumExpressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.DatumExpressieContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_datumPredicaat

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDatumPredicaat" ):
                listener.enterDatumPredicaat(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDatumPredicaat" ):
                listener.exitDatumPredicaat(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDatumPredicaat" ):
                return visitor.visitDatumPredicaat(self)
            else:
                return visitor.visitChildren(self)




    def datumPredicaat(self):

        localctx = RegelSpraakParser.DatumPredicaatContext(self, self._ctx, self.state)
        self.enterRule(localctx, 216, self.RULE_datumPredicaat)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1360
            self.datumVergelijkingsOperatorMeervoud()
            self.state = 1361
            self.datumExpressie()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SamengesteldPredicaatContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def AAN(self):
            return self.getToken(RegelSpraakParser.AAN, 0)

        def voorwaardeKwantificatie(self):
            return self.getTypedRuleContext(RegelSpraakParser.VoorwaardeKwantificatieContext,0)


        def VOLGENDE(self):
            return self.getToken(RegelSpraakParser.VOLGENDE, 0)

        def COLON(self):
            return self.getToken(RegelSpraakParser.COLON, 0)

        def VOORWAARDE(self):
            return self.getToken(RegelSpraakParser.VOORWAARDE, 0)

        def VOORWAARDEN(self):
            return self.getToken(RegelSpraakParser.VOORWAARDEN, 0)

        def VOLDOET(self):
            return self.getToken(RegelSpraakParser.VOLDOET, 0)

        def VOLDOEN(self):
            return self.getToken(RegelSpraakParser.VOLDOEN, 0)

        def samengesteldeVoorwaardeOnderdeelInPredicaat(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.SamengesteldeVoorwaardeOnderdeelInPredicaatContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.SamengesteldeVoorwaardeOnderdeelInPredicaatContext,i)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_samengesteldPredicaat

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSamengesteldPredicaat" ):
                listener.enterSamengesteldPredicaat(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSamengesteldPredicaat" ):
                listener.exitSamengesteldPredicaat(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSamengesteldPredicaat" ):
                return visitor.visitSamengesteldPredicaat(self)
            else:
                return visitor.visitChildren(self)




    def samengesteldPredicaat(self):

        localctx = RegelSpraakParser.SamengesteldPredicaatContext(self, self._ctx, self.state)
        self.enterRule(localctx, 218, self.RULE_samengesteldPredicaat)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1363
            self.match(RegelSpraakParser.AAN)
            self.state = 1364
            self.voorwaardeKwantificatie()
            self.state = 1365
            self.match(RegelSpraakParser.VOLGENDE)
            self.state = 1366
            _la = self._input.LA(1)
            if not(_la==157 or _la==158):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 1367
            _la = self._input.LA(1)
            if not(_la==149 or _la==150):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 1368
            self.match(RegelSpraakParser.COLON)
            self.state = 1370 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 1369
                    self.samengesteldeVoorwaardeOnderdeelInPredicaat()

                else:
                    raise NoViableAltException(self)
                self.state = 1372 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,166,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SamengesteldeVoorwaardeOnderdeelInPredicaatContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def bulletPrefix(self):
            return self.getTypedRuleContext(RegelSpraakParser.BulletPrefixContext,0)


        def elementaireVoorwaardeInPredicaat(self):
            return self.getTypedRuleContext(RegelSpraakParser.ElementaireVoorwaardeInPredicaatContext,0)


        def genesteSamengesteldeVoorwaardeInPredicaat(self):
            return self.getTypedRuleContext(RegelSpraakParser.GenesteSamengesteldeVoorwaardeInPredicaatContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_samengesteldeVoorwaardeOnderdeelInPredicaat

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSamengesteldeVoorwaardeOnderdeelInPredicaat" ):
                listener.enterSamengesteldeVoorwaardeOnderdeelInPredicaat(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSamengesteldeVoorwaardeOnderdeelInPredicaat" ):
                listener.exitSamengesteldeVoorwaardeOnderdeelInPredicaat(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSamengesteldeVoorwaardeOnderdeelInPredicaat" ):
                return visitor.visitSamengesteldeVoorwaardeOnderdeelInPredicaat(self)
            else:
                return visitor.visitChildren(self)




    def samengesteldeVoorwaardeOnderdeelInPredicaat(self):

        localctx = RegelSpraakParser.SamengesteldeVoorwaardeOnderdeelInPredicaatContext(self, self._ctx, self.state)
        self.enterRule(localctx, 220, self.RULE_samengesteldeVoorwaardeOnderdeelInPredicaat)
        try:
            self.state = 1380
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,167,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1374
                self.bulletPrefix()
                self.state = 1375
                self.elementaireVoorwaardeInPredicaat()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1377
                self.bulletPrefix()
                self.state = 1378
                self.genesteSamengesteldeVoorwaardeInPredicaat()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ElementaireVoorwaardeInPredicaatContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def vergelijkingInPredicaat(self):
            return self.getTypedRuleContext(RegelSpraakParser.VergelijkingInPredicaatContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_elementaireVoorwaardeInPredicaat

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterElementaireVoorwaardeInPredicaat" ):
                listener.enterElementaireVoorwaardeInPredicaat(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitElementaireVoorwaardeInPredicaat" ):
                listener.exitElementaireVoorwaardeInPredicaat(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitElementaireVoorwaardeInPredicaat" ):
                return visitor.visitElementaireVoorwaardeInPredicaat(self)
            else:
                return visitor.visitChildren(self)




    def elementaireVoorwaardeInPredicaat(self):

        localctx = RegelSpraakParser.ElementaireVoorwaardeInPredicaatContext(self, self._ctx, self.state)
        self.enterRule(localctx, 222, self.RULE_elementaireVoorwaardeInPredicaat)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1382
            self.vergelijkingInPredicaat()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VergelijkingInPredicaatContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def attribuutReferentie(self):
            return self.getTypedRuleContext(RegelSpraakParser.AttribuutReferentieContext,0)


        def comparisonOperator(self):
            return self.getTypedRuleContext(RegelSpraakParser.ComparisonOperatorContext,0)


        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)


        def onderwerpReferentie(self):
            return self.getTypedRuleContext(RegelSpraakParser.OnderwerpReferentieContext,0)


        def eenzijdigeObjectVergelijking(self):
            return self.getTypedRuleContext(RegelSpraakParser.EenzijdigeObjectVergelijkingContext,0)


        def kenmerkNaam(self):
            return self.getTypedRuleContext(RegelSpraakParser.KenmerkNaamContext,0)


        def IS(self):
            return self.getToken(RegelSpraakParser.IS, 0)

        def ZIJN(self):
            return self.getToken(RegelSpraakParser.ZIJN, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_vergelijkingInPredicaat

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVergelijkingInPredicaat" ):
                listener.enterVergelijkingInPredicaat(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVergelijkingInPredicaat" ):
                listener.exitVergelijkingInPredicaat(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVergelijkingInPredicaat" ):
                return visitor.visitVergelijkingInPredicaat(self)
            else:
                return visitor.visitChildren(self)




    def vergelijkingInPredicaat(self):

        localctx = RegelSpraakParser.VergelijkingInPredicaatContext(self, self._ctx, self.state)
        self.enterRule(localctx, 224, self.RULE_vergelijkingInPredicaat)
        self._la = 0 # Token type
        try:
            self.state = 1395
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,168,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1384
                self.attribuutReferentie()
                self.state = 1385
                self.comparisonOperator()
                self.state = 1386
                self.expressie()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1388
                self.onderwerpReferentie()
                self.state = 1389
                self.eenzijdigeObjectVergelijking()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1391
                self.attribuutReferentie()
                self.state = 1392
                _la = self._input.LA(1)
                if not(_la==113 or _la==117):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1393
                self.kenmerkNaam()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GenesteSamengesteldeVoorwaardeInPredicaatContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def AAN(self):
            return self.getToken(RegelSpraakParser.AAN, 0)

        def voorwaardeKwantificatie(self):
            return self.getTypedRuleContext(RegelSpraakParser.VoorwaardeKwantificatieContext,0)


        def VOLGENDE(self):
            return self.getToken(RegelSpraakParser.VOLGENDE, 0)

        def COLON(self):
            return self.getToken(RegelSpraakParser.COLON, 0)

        def VOORWAARDE(self):
            return self.getToken(RegelSpraakParser.VOORWAARDE, 0)

        def VOORWAARDEN(self):
            return self.getToken(RegelSpraakParser.VOORWAARDEN, 0)

        def VOLDOET(self):
            return self.getToken(RegelSpraakParser.VOLDOET, 0)

        def VOLDOEN(self):
            return self.getToken(RegelSpraakParser.VOLDOEN, 0)

        def WORDT(self):
            return self.getToken(RegelSpraakParser.WORDT, 0)

        def VOLDAAN(self):
            return self.getToken(RegelSpraakParser.VOLDAAN, 0)

        def samengesteldeVoorwaardeOnderdeelInPredicaat(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.SamengesteldeVoorwaardeOnderdeelInPredicaatContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.SamengesteldeVoorwaardeOnderdeelInPredicaatContext,i)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_genesteSamengesteldeVoorwaardeInPredicaat

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGenesteSamengesteldeVoorwaardeInPredicaat" ):
                listener.enterGenesteSamengesteldeVoorwaardeInPredicaat(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGenesteSamengesteldeVoorwaardeInPredicaat" ):
                listener.exitGenesteSamengesteldeVoorwaardeInPredicaat(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGenesteSamengesteldeVoorwaardeInPredicaat" ):
                return visitor.visitGenesteSamengesteldeVoorwaardeInPredicaat(self)
            else:
                return visitor.visitChildren(self)




    def genesteSamengesteldeVoorwaardeInPredicaat(self):

        localctx = RegelSpraakParser.GenesteSamengesteldeVoorwaardeInPredicaatContext(self, self._ctx, self.state)
        self.enterRule(localctx, 226, self.RULE_genesteSamengesteldeVoorwaardeInPredicaat)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1401
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [150]:
                self.state = 1397
                self.match(RegelSpraakParser.VOLDOET)
                pass
            elif token in [149]:
                self.state = 1398
                self.match(RegelSpraakParser.VOLDOEN)
                pass
            elif token in [291]:
                self.state = 1399
                self.match(RegelSpraakParser.WORDT)
                self.state = 1400
                self.match(RegelSpraakParser.VOLDAAN)
                pass
            else:
                raise NoViableAltException(self)

            self.state = 1403
            self.match(RegelSpraakParser.AAN)
            self.state = 1404
            self.voorwaardeKwantificatie()
            self.state = 1405
            self.match(RegelSpraakParser.VOLGENDE)
            self.state = 1406
            _la = self._input.LA(1)
            if not(_la==157 or _la==158):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 1407
            self.match(RegelSpraakParser.COLON)
            self.state = 1409 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 1408
                    self.samengesteldeVoorwaardeOnderdeelInPredicaat()

                else:
                    raise NoViableAltException(self)
                self.state = 1411 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,170,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GetalVergelijkingsOperatorMeervoudContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ZIJN_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.ZIJN_GELIJK_AAN, 0)

        def ZIJN_ONGELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.ZIJN_ONGELIJK_AAN, 0)

        def ZIJN_GROTER_DAN(self):
            return self.getToken(RegelSpraakParser.ZIJN_GROTER_DAN, 0)

        def ZIJN_GROTER_OF_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.ZIJN_GROTER_OF_GELIJK_AAN, 0)

        def ZIJN_KLEINER_DAN(self):
            return self.getToken(RegelSpraakParser.ZIJN_KLEINER_DAN, 0)

        def ZIJN_KLEINER_OF_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.ZIJN_KLEINER_OF_GELIJK_AAN, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_getalVergelijkingsOperatorMeervoud

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGetalVergelijkingsOperatorMeervoud" ):
                listener.enterGetalVergelijkingsOperatorMeervoud(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGetalVergelijkingsOperatorMeervoud" ):
                listener.exitGetalVergelijkingsOperatorMeervoud(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGetalVergelijkingsOperatorMeervoud" ):
                return visitor.visitGetalVergelijkingsOperatorMeervoud(self)
            else:
                return visitor.visitChildren(self)




    def getalVergelijkingsOperatorMeervoud(self):

        localctx = RegelSpraakParser.GetalVergelijkingsOperatorMeervoudContext(self, self._ctx, self.state)
        self.enterRule(localctx, 228, self.RULE_getalVergelijkingsOperatorMeervoud)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1413
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 1134907106097364992) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TekstVergelijkingsOperatorMeervoudContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ZIJN_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.ZIJN_GELIJK_AAN, 0)

        def ZIJN_ONGELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.ZIJN_ONGELIJK_AAN, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_tekstVergelijkingsOperatorMeervoud

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTekstVergelijkingsOperatorMeervoud" ):
                listener.enterTekstVergelijkingsOperatorMeervoud(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTekstVergelijkingsOperatorMeervoud" ):
                listener.exitTekstVergelijkingsOperatorMeervoud(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTekstVergelijkingsOperatorMeervoud" ):
                return visitor.visitTekstVergelijkingsOperatorMeervoud(self)
            else:
                return visitor.visitChildren(self)




    def tekstVergelijkingsOperatorMeervoud(self):

        localctx = RegelSpraakParser.TekstVergelijkingsOperatorMeervoudContext(self, self._ctx, self.state)
        self.enterRule(localctx, 230, self.RULE_tekstVergelijkingsOperatorMeervoud)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1415
            _la = self._input.LA(1)
            if not(_la==54 or _la==55):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DatumVergelijkingsOperatorMeervoudContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ZIJN_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.ZIJN_GELIJK_AAN, 0)

        def ZIJN_ONGELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.ZIJN_ONGELIJK_AAN, 0)

        def ZIJN_LATER_DAN(self):
            return self.getToken(RegelSpraakParser.ZIJN_LATER_DAN, 0)

        def ZIJN_LATER_OF_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.ZIJN_LATER_OF_GELIJK_AAN, 0)

        def ZIJN_EERDER_DAN(self):
            return self.getToken(RegelSpraakParser.ZIJN_EERDER_DAN, 0)

        def ZIJN_EERDER_OF_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.ZIJN_EERDER_OF_GELIJK_AAN, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_datumVergelijkingsOperatorMeervoud

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDatumVergelijkingsOperatorMeervoud" ):
                listener.enterDatumVergelijkingsOperatorMeervoud(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDatumVergelijkingsOperatorMeervoud" ):
                listener.exitDatumVergelijkingsOperatorMeervoud(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDatumVergelijkingsOperatorMeervoud" ):
                return visitor.visitDatumVergelijkingsOperatorMeervoud(self)
            else:
                return visitor.visitChildren(self)




    def datumVergelijkingsOperatorMeervoud(self):

        localctx = RegelSpraakParser.DatumVergelijkingsOperatorMeervoudContext(self, self._ctx, self.state)
        self.enterRule(localctx, 232, self.RULE_datumVergelijkingsOperatorMeervoud)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1417
            _la = self._input.LA(1)
            if not(((((_la - 54)) & ~0x3f) == 0 and ((1 << (_la - 54)) & 15363) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GetalExpressieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_getalExpressie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGetalExpressie" ):
                listener.enterGetalExpressie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGetalExpressie" ):
                listener.exitGetalExpressie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGetalExpressie" ):
                return visitor.visitGetalExpressie(self)
            else:
                return visitor.visitChildren(self)




    def getalExpressie(self):

        localctx = RegelSpraakParser.GetalExpressieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 234, self.RULE_getalExpressie)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1419
            self.expressie()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TekstExpressieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_tekstExpressie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTekstExpressie" ):
                listener.enterTekstExpressie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTekstExpressie" ):
                listener.exitTekstExpressie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTekstExpressie" ):
                return visitor.visitTekstExpressie(self)
            else:
                return visitor.visitChildren(self)




    def tekstExpressie(self):

        localctx = RegelSpraakParser.TekstExpressieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 236, self.RULE_tekstExpressie)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1421
            self.expressie()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DatumExpressieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_datumExpressie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDatumExpressie" ):
                listener.enterDatumExpressie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDatumExpressie" ):
                listener.exitDatumExpressie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDatumExpressie" ):
                return visitor.visitDatumExpressie(self)
            else:
                return visitor.visitChildren(self)




    def datumExpressie(self):

        localctx = RegelSpraakParser.DatumExpressieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 238, self.RULE_datumExpressie)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1423
            self.expressie()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VariabeleDeelContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DAARBIJ_GELDT(self):
            return self.getToken(RegelSpraakParser.DAARBIJ_GELDT, 0)

        def DOT(self):
            return self.getToken(RegelSpraakParser.DOT, 0)

        def variabeleToekenning(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.VariabeleToekenningContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.VariabeleToekenningContext,i)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_variabeleDeel

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVariabeleDeel" ):
                listener.enterVariabeleDeel(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVariabeleDeel" ):
                listener.exitVariabeleDeel(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVariabeleDeel" ):
                return visitor.visitVariabeleDeel(self)
            else:
                return visitor.visitChildren(self)




    def variabeleDeel(self):

        localctx = RegelSpraakParser.VariabeleDeelContext(self, self._ctx, self.state)
        self.enterRule(localctx, 240, self.RULE_variabeleDeel)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1425
            self.match(RegelSpraakParser.DAARBIJ_GELDT)
            self.state = 1429
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((((_la - 208)) & ~0x3f) == 0 and ((1 << (_la - 208)) & 36028797018964001) != 0):
                self.state = 1426
                self.variabeleToekenning()
                self.state = 1431
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1432
            self.match(RegelSpraakParser.DOT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VariabeleToekenningContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.article = None # Token
            self.varName = None # Token
            self.varExpr = None # VariabeleExpressieContext

        def IS(self):
            return self.getToken(RegelSpraakParser.IS, 0)

        def IDENTIFIER(self):
            return self.getToken(RegelSpraakParser.IDENTIFIER, 0)

        def variabeleExpressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.VariabeleExpressieContext,0)


        def DE(self):
            return self.getToken(RegelSpraakParser.DE, 0)

        def HET(self):
            return self.getToken(RegelSpraakParser.HET, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_variabeleToekenning

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVariabeleToekenning" ):
                listener.enterVariabeleToekenning(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVariabeleToekenning" ):
                listener.exitVariabeleToekenning(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVariabeleToekenning" ):
                return visitor.visitVariabeleToekenning(self)
            else:
                return visitor.visitChildren(self)




    def variabeleToekenning(self):

        localctx = RegelSpraakParser.VariabeleToekenningContext(self, self._ctx, self.state)
        self.enterRule(localctx, 242, self.RULE_variabeleToekenning)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1435
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==208 or _la==213:
                self.state = 1434
                localctx.article = self._input.LT(1)
                _la = self._input.LA(1)
                if not(_la==208 or _la==213):
                    localctx.article = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


            self.state = 1437
            localctx.varName = self.match(RegelSpraakParser.IDENTIFIER)
            self.state = 1438
            self.match(RegelSpraakParser.IS)
            self.state = 1439
            localctx.varExpr = self.variabeleExpressie()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VariabeleExpressieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def primaryExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.PrimaryExpressionContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,i)


        def additiveOperator(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.AdditiveOperatorContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.AdditiveOperatorContext,i)


        def multiplicativeOperator(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.MultiplicativeOperatorContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.MultiplicativeOperatorContext,i)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_variabeleExpressie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVariabeleExpressie" ):
                listener.enterVariabeleExpressie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVariabeleExpressie" ):
                listener.exitVariabeleExpressie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVariabeleExpressie" ):
                return visitor.visitVariabeleExpressie(self)
            else:
                return visitor.visitChildren(self)




    def variabeleExpressie(self):

        localctx = RegelSpraakParser.VariabeleExpressieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 244, self.RULE_variabeleExpressie)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1441
            self.primaryExpression(0)
            self.state = 1450
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((((_la - 122)) & ~0x3f) == 0 and ((1 << (_la - 122)) & 67243011) != 0):
                self.state = 1444
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [133, 139, 148]:
                    self.state = 1442
                    self.additiveOperator()
                    pass
                elif token in [122, 123, 132]:
                    self.state = 1443
                    self.multiplicativeOperator()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 1446
                self.primaryExpression(0)
                self.state = 1452
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExpressieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_expressie

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class SimpleExprContext(ExpressieContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.ExpressieContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def logicalExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.LogicalExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSimpleExpr" ):
                listener.enterSimpleExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSimpleExpr" ):
                listener.exitSimpleExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSimpleExpr" ):
                return visitor.visitSimpleExpr(self)
            else:
                return visitor.visitChildren(self)


    class ExprBegrenzingAfrondingContext(ExpressieContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.ExpressieContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def logicalExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.LogicalExpressionContext,0)

        def COMMA(self):
            return self.getToken(RegelSpraakParser.COMMA, 0)
        def begrenzing(self):
            return self.getTypedRuleContext(RegelSpraakParser.BegrenzingContext,0)

        def afronding(self):
            return self.getTypedRuleContext(RegelSpraakParser.AfrondingContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExprBegrenzingAfronding" ):
                listener.enterExprBegrenzingAfronding(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExprBegrenzingAfronding" ):
                listener.exitExprBegrenzingAfronding(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExprBegrenzingAfronding" ):
                return visitor.visitExprBegrenzingAfronding(self)
            else:
                return visitor.visitChildren(self)


    class ExprBegrenzingContext(ExpressieContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.ExpressieContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def logicalExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.LogicalExpressionContext,0)

        def COMMA(self):
            return self.getToken(RegelSpraakParser.COMMA, 0)
        def begrenzing(self):
            return self.getTypedRuleContext(RegelSpraakParser.BegrenzingContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExprBegrenzing" ):
                listener.enterExprBegrenzing(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExprBegrenzing" ):
                listener.exitExprBegrenzing(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExprBegrenzing" ):
                return visitor.visitExprBegrenzing(self)
            else:
                return visitor.visitChildren(self)


    class ExprAfrondingContext(ExpressieContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.ExpressieContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def logicalExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.LogicalExpressionContext,0)

        def afronding(self):
            return self.getTypedRuleContext(RegelSpraakParser.AfrondingContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExprAfronding" ):
                listener.enterExprAfronding(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExprAfronding" ):
                listener.exitExprAfronding(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExprAfronding" ):
                return visitor.visitExprAfronding(self)
            else:
                return visitor.visitChildren(self)



    def expressie(self):

        localctx = RegelSpraakParser.ExpressieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 246, self.RULE_expressie)
        try:
            self.state = 1466
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,175,self._ctx)
            if la_ == 1:
                localctx = RegelSpraakParser.ExprBegrenzingAfrondingContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1453
                self.logicalExpression()
                self.state = 1454
                self.match(RegelSpraakParser.COMMA)
                self.state = 1455
                self.begrenzing()
                self.state = 1456
                self.afronding()
                pass

            elif la_ == 2:
                localctx = RegelSpraakParser.ExprBegrenzingContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1458
                self.logicalExpression()
                self.state = 1459
                self.match(RegelSpraakParser.COMMA)
                self.state = 1460
                self.begrenzing()
                pass

            elif la_ == 3:
                localctx = RegelSpraakParser.ExprAfrondingContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 1462
                self.logicalExpression()
                self.state = 1463
                self.afronding()
                pass

            elif la_ == 4:
                localctx = RegelSpraakParser.SimpleExprContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 1465
                self.logicalExpression()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SimpleExpressieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_simpleExpressie

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class SimpleExprBegrenzingContext(SimpleExpressieContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.SimpleExpressieContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def comparisonExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.ComparisonExpressionContext,0)

        def COMMA(self):
            return self.getToken(RegelSpraakParser.COMMA, 0)
        def begrenzing(self):
            return self.getTypedRuleContext(RegelSpraakParser.BegrenzingContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSimpleExprBegrenzing" ):
                listener.enterSimpleExprBegrenzing(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSimpleExprBegrenzing" ):
                listener.exitSimpleExprBegrenzing(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSimpleExprBegrenzing" ):
                return visitor.visitSimpleExprBegrenzing(self)
            else:
                return visitor.visitChildren(self)


    class SimpleExprAfrondingContext(SimpleExpressieContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.SimpleExpressieContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def comparisonExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.ComparisonExpressionContext,0)

        def afronding(self):
            return self.getTypedRuleContext(RegelSpraakParser.AfrondingContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSimpleExprAfronding" ):
                listener.enterSimpleExprAfronding(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSimpleExprAfronding" ):
                listener.exitSimpleExprAfronding(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSimpleExprAfronding" ):
                return visitor.visitSimpleExprAfronding(self)
            else:
                return visitor.visitChildren(self)


    class SimpleExprBegrenzingAfrondingContext(SimpleExpressieContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.SimpleExpressieContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def comparisonExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.ComparisonExpressionContext,0)

        def COMMA(self):
            return self.getToken(RegelSpraakParser.COMMA, 0)
        def begrenzing(self):
            return self.getTypedRuleContext(RegelSpraakParser.BegrenzingContext,0)

        def afronding(self):
            return self.getTypedRuleContext(RegelSpraakParser.AfrondingContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSimpleExprBegrenzingAfronding" ):
                listener.enterSimpleExprBegrenzingAfronding(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSimpleExprBegrenzingAfronding" ):
                listener.exitSimpleExprBegrenzingAfronding(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSimpleExprBegrenzingAfronding" ):
                return visitor.visitSimpleExprBegrenzingAfronding(self)
            else:
                return visitor.visitChildren(self)


    class SimpleExprBaseContext(SimpleExpressieContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.SimpleExpressieContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def comparisonExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.ComparisonExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSimpleExprBase" ):
                listener.enterSimpleExprBase(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSimpleExprBase" ):
                listener.exitSimpleExprBase(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSimpleExprBase" ):
                return visitor.visitSimpleExprBase(self)
            else:
                return visitor.visitChildren(self)



    def simpleExpressie(self):

        localctx = RegelSpraakParser.SimpleExpressieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 248, self.RULE_simpleExpressie)
        try:
            self.state = 1481
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,176,self._ctx)
            if la_ == 1:
                localctx = RegelSpraakParser.SimpleExprBegrenzingAfrondingContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1468
                self.comparisonExpression()
                self.state = 1469
                self.match(RegelSpraakParser.COMMA)
                self.state = 1470
                self.begrenzing()
                self.state = 1471
                self.afronding()
                pass

            elif la_ == 2:
                localctx = RegelSpraakParser.SimpleExprBegrenzingContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1473
                self.comparisonExpression()
                self.state = 1474
                self.match(RegelSpraakParser.COMMA)
                self.state = 1475
                self.begrenzing()
                pass

            elif la_ == 3:
                localctx = RegelSpraakParser.SimpleExprAfrondingContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 1477
                self.comparisonExpression()
                self.state = 1478
                self.afronding()
                pass

            elif la_ == 4:
                localctx = RegelSpraakParser.SimpleExprBaseContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 1480
                self.comparisonExpression()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LogicalExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_logicalExpression

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class LogicalExprContext(LogicalExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.LogicalExpressionContext
            super().__init__(parser)
            self.left = None # ComparisonExpressionContext
            self.op = None # Token
            self.right = None # LogicalExpressionContext
            self.copyFrom(ctx)

        def comparisonExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.ComparisonExpressionContext,0)

        def logicalExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.LogicalExpressionContext,0)

        def EN(self):
            return self.getToken(RegelSpraakParser.EN, 0)
        def OF(self):
            return self.getToken(RegelSpraakParser.OF, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLogicalExpr" ):
                listener.enterLogicalExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLogicalExpr" ):
                listener.exitLogicalExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLogicalExpr" ):
                return visitor.visitLogicalExpr(self)
            else:
                return visitor.visitChildren(self)



    def logicalExpression(self):

        localctx = RegelSpraakParser.LogicalExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 250, self.RULE_logicalExpression)
        self._la = 0 # Token type
        try:
            localctx = RegelSpraakParser.LogicalExprContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 1483
            localctx.left = self.comparisonExpression()
            self.state = 1486
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,177,self._ctx)
            if la_ == 1:
                self.state = 1484
                localctx.op = self._input.LT(1)
                _la = self._input.LA(1)
                if not(_la==212 or _la==225):
                    localctx.op = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1485
                localctx.right = self.logicalExpression()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ComparisonExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_comparisonExpression

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class GelijkIsAanOfExprContext(ComparisonExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.ComparisonExpressionContext
            super().__init__(parser)
            self.left = None # AdditiveExpressionContext
            self.op = None # GelijkIsAanOperatorContext
            self.firstValue = None # LiteralValueContext
            self._literalValue = None # LiteralValueContext
            self.middleValues = list() # of LiteralValueContexts
            self.lastValue = None # LiteralValueContext
            self.copyFrom(ctx)

        def OF(self):
            return self.getToken(RegelSpraakParser.OF, 0)
        def additiveExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.AdditiveExpressionContext,0)

        def gelijkIsAanOperator(self):
            return self.getTypedRuleContext(RegelSpraakParser.GelijkIsAanOperatorContext,0)

        def literalValue(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.LiteralValueContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.LiteralValueContext,i)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.COMMA)
            else:
                return self.getToken(RegelSpraakParser.COMMA, i)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGelijkIsAanOfExpr" ):
                listener.enterGelijkIsAanOfExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGelijkIsAanOfExpr" ):
                listener.exitGelijkIsAanOfExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGelijkIsAanOfExpr" ):
                return visitor.visitGelijkIsAanOfExpr(self)
            else:
                return visitor.visitChildren(self)


    class SubordinateClauseExprContext(ComparisonExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.ComparisonExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def subordinateClauseExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.SubordinateClauseExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSubordinateClauseExpr" ):
                listener.enterSubordinateClauseExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSubordinateClauseExpr" ):
                listener.exitSubordinateClauseExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSubordinateClauseExpr" ):
                return visitor.visitSubordinateClauseExpr(self)
            else:
                return visitor.visitChildren(self)


    class PeriodeCheckExprContext(ComparisonExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.ComparisonExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def periodevergelijkingElementair(self):
            return self.getTypedRuleContext(RegelSpraakParser.PeriodevergelijkingElementairContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPeriodeCheckExpr" ):
                listener.enterPeriodeCheckExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPeriodeCheckExpr" ):
                listener.exitPeriodeCheckExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPeriodeCheckExpr" ):
                return visitor.visitPeriodeCheckExpr(self)
            else:
                return visitor.visitChildren(self)


    class BinaryComparisonExprContext(ComparisonExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.ComparisonExpressionContext
            super().__init__(parser)
            self.left = None # AdditiveExpressionContext
            self.right = None # AdditiveExpressionContext
            self.copyFrom(ctx)

        def additiveExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.AdditiveExpressionContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.AdditiveExpressionContext,i)

        def comparisonOperator(self):
            return self.getTypedRuleContext(RegelSpraakParser.ComparisonOperatorContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBinaryComparisonExpr" ):
                listener.enterBinaryComparisonExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBinaryComparisonExpr" ):
                listener.exitBinaryComparisonExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBinaryComparisonExpr" ):
                return visitor.visitBinaryComparisonExpr(self)
            else:
                return visitor.visitChildren(self)


    class UnaryConditionExprContext(ComparisonExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.ComparisonExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def unaryCondition(self):
            return self.getTypedRuleContext(RegelSpraakParser.UnaryConditionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnaryConditionExpr" ):
                listener.enterUnaryConditionExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnaryConditionExpr" ):
                listener.exitUnaryConditionExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnaryConditionExpr" ):
                return visitor.visitUnaryConditionExpr(self)
            else:
                return visitor.visitChildren(self)


    class HeeftKenmerkExprContext(ComparisonExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.ComparisonExpressionContext
            super().__init__(parser)
            self.left = None # AdditiveExpressionContext
            self.copyFrom(ctx)

        def HEEFT(self):
            return self.getToken(RegelSpraakParser.HEEFT, 0)
        def naamwoordWithNumbers(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordWithNumbersContext,0)

        def additiveExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.AdditiveExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterHeeftKenmerkExpr" ):
                listener.enterHeeftKenmerkExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitHeeftKenmerkExpr" ):
                listener.exitHeeftKenmerkExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitHeeftKenmerkExpr" ):
                return visitor.visitHeeftKenmerkExpr(self)
            else:
                return visitor.visitChildren(self)


    class IsKenmerkExprContext(ComparisonExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.ComparisonExpressionContext
            super().__init__(parser)
            self.left = None # AdditiveExpressionContext
            self.copyFrom(ctx)

        def IS(self):
            return self.getToken(RegelSpraakParser.IS, 0)
        def naamwoordWithNumbers(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordWithNumbersContext,0)

        def additiveExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.AdditiveExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIsKenmerkExpr" ):
                listener.enterIsKenmerkExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIsKenmerkExpr" ):
                listener.exitIsKenmerkExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIsKenmerkExpr" ):
                return visitor.visitIsKenmerkExpr(self)
            else:
                return visitor.visitChildren(self)


    class RegelStatusConditionExprContext(ComparisonExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.ComparisonExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def regelStatusCondition(self):
            return self.getTypedRuleContext(RegelSpraakParser.RegelStatusConditionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRegelStatusConditionExpr" ):
                listener.enterRegelStatusConditionExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRegelStatusConditionExpr" ):
                listener.exitRegelStatusConditionExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRegelStatusConditionExpr" ):
                return visitor.visitRegelStatusConditionExpr(self)
            else:
                return visitor.visitChildren(self)



    def comparisonExpression(self):

        localctx = RegelSpraakParser.ComparisonExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 252, self.RULE_comparisonExpression)
        self._la = 0 # Token type
        try:
            self.state = 1519
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,180,self._ctx)
            if la_ == 1:
                localctx = RegelSpraakParser.SubordinateClauseExprContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1488
                self.subordinateClauseExpression()
                pass

            elif la_ == 2:
                localctx = RegelSpraakParser.PeriodeCheckExprContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1489
                self.periodevergelijkingElementair()
                pass

            elif la_ == 3:
                localctx = RegelSpraakParser.IsKenmerkExprContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 1490
                localctx.left = self.additiveExpression()
                self.state = 1491
                self.match(RegelSpraakParser.IS)
                self.state = 1492
                self.naamwoordWithNumbers()
                pass

            elif la_ == 4:
                localctx = RegelSpraakParser.HeeftKenmerkExprContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 1494
                localctx.left = self.additiveExpression()
                self.state = 1495
                self.match(RegelSpraakParser.HEEFT)
                self.state = 1496
                self.naamwoordWithNumbers()
                pass

            elif la_ == 5:
                localctx = RegelSpraakParser.GelijkIsAanOfExprContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 1498
                localctx.left = self.additiveExpression()
                self.state = 1499
                localctx.op = self.gelijkIsAanOperator()
                self.state = 1500
                localctx.firstValue = self.literalValue()
                self.state = 1505
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==274:
                    self.state = 1501
                    self.match(RegelSpraakParser.COMMA)
                    self.state = 1502
                    localctx._literalValue = self.literalValue()
                    localctx.middleValues.append(localctx._literalValue)
                    self.state = 1507
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 1508
                self.match(RegelSpraakParser.OF)
                self.state = 1509
                localctx.lastValue = self.literalValue()
                pass

            elif la_ == 6:
                localctx = RegelSpraakParser.BinaryComparisonExprContext(self, localctx)
                self.enterOuterAlt(localctx, 6)
                self.state = 1511
                localctx.left = self.additiveExpression()
                self.state = 1515
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,179,self._ctx)
                if la_ == 1:
                    self.state = 1512
                    self.comparisonOperator()
                    self.state = 1513
                    localctx.right = self.additiveExpression()


                pass

            elif la_ == 7:
                localctx = RegelSpraakParser.UnaryConditionExprContext(self, localctx)
                self.enterOuterAlt(localctx, 7)
                self.state = 1517
                self.unaryCondition()
                pass

            elif la_ == 8:
                localctx = RegelSpraakParser.RegelStatusConditionExprContext(self, localctx)
                self.enterOuterAlt(localctx, 8)
                self.state = 1518
                self.regelStatusCondition()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LiteralValueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ENUM_LITERAL(self):
            return self.getToken(RegelSpraakParser.ENUM_LITERAL, 0)

        def STRING_LITERAL(self):
            return self.getToken(RegelSpraakParser.STRING_LITERAL, 0)

        def NUMBER(self):
            return self.getToken(RegelSpraakParser.NUMBER, 0)

        def unitIdentifier(self):
            return self.getTypedRuleContext(RegelSpraakParser.UnitIdentifierContext,0)


        def PERCENTAGE_LITERAL(self):
            return self.getToken(RegelSpraakParser.PERCENTAGE_LITERAL, 0)

        def datumLiteral(self):
            return self.getTypedRuleContext(RegelSpraakParser.DatumLiteralContext,0)


        def identifier(self):
            return self.getTypedRuleContext(RegelSpraakParser.IdentifierContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_literalValue

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLiteralValue" ):
                listener.enterLiteralValue(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLiteralValue" ):
                listener.exitLiteralValue(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLiteralValue" ):
                return visitor.visitLiteralValue(self)
            else:
                return visitor.visitChildren(self)




    def literalValue(self):

        localctx = RegelSpraakParser.LiteralValueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 254, self.RULE_literalValue)
        try:
            self.state = 1530
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [269]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1521
                self.match(RegelSpraakParser.ENUM_LITERAL)
                pass
            elif token in [268]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1522
                self.match(RegelSpraakParser.STRING_LITERAL)
                pass
            elif token in [264]:
                self.enterOuterAlt(localctx, 3)
                self.state = 1523
                self.match(RegelSpraakParser.NUMBER)
                self.state = 1525
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,181,self._ctx)
                if la_ == 1:
                    self.state = 1524
                    self.unitIdentifier()


                pass
            elif token in [267]:
                self.enterOuterAlt(localctx, 4)
                self.state = 1527
                self.match(RegelSpraakParser.PERCENTAGE_LITERAL)
                pass
            elif token in [266]:
                self.enterOuterAlt(localctx, 5)
                self.state = 1528
                self.datumLiteral()
                pass
            elif token in [263]:
                self.enterOuterAlt(localctx, 6)
                self.state = 1529
                self.identifier()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GelijkIsAanOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GELIJK_IS_AAN(self):
            return self.getToken(RegelSpraakParser.GELIJK_IS_AAN, 0)

        def IS_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.IS_GELIJK_AAN, 0)

        def GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.GELIJK_AAN, 0)

        def ZIJN_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.ZIJN_GELIJK_AAN, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_gelijkIsAanOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGelijkIsAanOperator" ):
                listener.enterGelijkIsAanOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGelijkIsAanOperator" ):
                listener.exitGelijkIsAanOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGelijkIsAanOperator" ):
                return visitor.visitGelijkIsAanOperator(self)
            else:
                return visitor.visitChildren(self)




    def gelijkIsAanOperator(self):

        localctx = RegelSpraakParser.GelijkIsAanOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 256, self.RULE_gelijkIsAanOperator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1532
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 18436610974547968) != 0) or _la==124):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ComparisonOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.GELIJK_AAN, 0)

        def ONGELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.ONGELIJK_AAN, 0)

        def GELIJK_IS_AAN(self):
            return self.getToken(RegelSpraakParser.GELIJK_IS_AAN, 0)

        def GROTER_DAN(self):
            return self.getToken(RegelSpraakParser.GROTER_DAN, 0)

        def GROTER_OF_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.GROTER_OF_GELIJK_AAN, 0)

        def KLEINER_DAN(self):
            return self.getToken(RegelSpraakParser.KLEINER_DAN, 0)

        def KLEINER_OF_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.KLEINER_OF_GELIJK_AAN, 0)

        def KLEINER_IS_DAN(self):
            return self.getToken(RegelSpraakParser.KLEINER_IS_DAN, 0)

        def GROTER_IS_DAN(self):
            return self.getToken(RegelSpraakParser.GROTER_IS_DAN, 0)

        def IS(self):
            return self.getToken(RegelSpraakParser.IS, 0)

        def IN(self):
            return self.getToken(RegelSpraakParser.IN, 0)

        def LATER_DAN(self):
            return self.getToken(RegelSpraakParser.LATER_DAN, 0)

        def LATER_OF_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.LATER_OF_GELIJK_AAN, 0)

        def EERDER_DAN(self):
            return self.getToken(RegelSpraakParser.EERDER_DAN, 0)

        def EERDER_OF_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.EERDER_OF_GELIJK_AAN, 0)

        def NIET(self):
            return self.getToken(RegelSpraakParser.NIET, 0)

        def IS_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.IS_GELIJK_AAN, 0)

        def IS_ONGELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.IS_ONGELIJK_AAN, 0)

        def IS_KLEINER_DAN(self):
            return self.getToken(RegelSpraakParser.IS_KLEINER_DAN, 0)

        def IS_KLEINER_OF_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.IS_KLEINER_OF_GELIJK_AAN, 0)

        def IS_GROTER_DAN(self):
            return self.getToken(RegelSpraakParser.IS_GROTER_DAN, 0)

        def IS_GROTER_OF_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.IS_GROTER_OF_GELIJK_AAN, 0)

        def ZIJN_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.ZIJN_GELIJK_AAN, 0)

        def ZIJN_ONGELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.ZIJN_ONGELIJK_AAN, 0)

        def ZIJN_KLEINER_DAN(self):
            return self.getToken(RegelSpraakParser.ZIJN_KLEINER_DAN, 0)

        def ZIJN_KLEINER_OF_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.ZIJN_KLEINER_OF_GELIJK_AAN, 0)

        def ZIJN_GROTER_DAN(self):
            return self.getToken(RegelSpraakParser.ZIJN_GROTER_DAN, 0)

        def ZIJN_GROTER_OF_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.ZIJN_GROTER_OF_GELIJK_AAN, 0)

        def IS_LATER_DAN(self):
            return self.getToken(RegelSpraakParser.IS_LATER_DAN, 0)

        def IS_LATER_OF_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.IS_LATER_OF_GELIJK_AAN, 0)

        def IS_EERDER_DAN(self):
            return self.getToken(RegelSpraakParser.IS_EERDER_DAN, 0)

        def IS_EERDER_OF_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.IS_EERDER_OF_GELIJK_AAN, 0)

        def ZIJN_LATER_DAN(self):
            return self.getToken(RegelSpraakParser.ZIJN_LATER_DAN, 0)

        def ZIJN_LATER_OF_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.ZIJN_LATER_OF_GELIJK_AAN, 0)

        def ZIJN_EERDER_DAN(self):
            return self.getToken(RegelSpraakParser.ZIJN_EERDER_DAN, 0)

        def ZIJN_EERDER_OF_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.ZIJN_EERDER_OF_GELIJK_AAN, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_comparisonOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterComparisonOperator" ):
                listener.enterComparisonOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitComparisonOperator" ):
                listener.exitComparisonOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitComparisonOperator" ):
                return visitor.visitComparisonOperator(self)
            else:
                return visitor.visitChildren(self)




    def comparisonOperator(self):

        localctx = RegelSpraakParser.ComparisonOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 258, self.RULE_comparisonOperator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1534
            _la = self._input.LA(1)
            if not(((((_la - 22)) & ~0x3f) == 0 and ((1 << (_la - 22)) & 70368710819855) != 0) or ((((_la - 113)) & ~0x3f) == 0 and ((1 << (_la - 113)) & 42158337) != 0) or _la==216):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AdditiveExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.left = None # MultiplicativeExpressionContext
            self.right = None # MultiplicativeExpressionContext

        def multiplicativeExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.MultiplicativeExpressionContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.MultiplicativeExpressionContext,i)


        def additiveOperator(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.AdditiveOperatorContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.AdditiveOperatorContext,i)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_additiveExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAdditiveExpression" ):
                listener.enterAdditiveExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAdditiveExpression" ):
                listener.exitAdditiveExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAdditiveExpression" ):
                return visitor.visitAdditiveExpression(self)
            else:
                return visitor.visitChildren(self)




    def additiveExpression(self):

        localctx = RegelSpraakParser.AdditiveExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 260, self.RULE_additiveExpression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1536
            localctx.left = self.multiplicativeExpression()
            self.state = 1542
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,183,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 1537
                    self.additiveOperator()
                    self.state = 1538
                    localctx.right = self.multiplicativeExpression() 
                self.state = 1544
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,183,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AdditiveOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PLUS(self):
            return self.getToken(RegelSpraakParser.PLUS, 0)

        def MIN(self):
            return self.getToken(RegelSpraakParser.MIN, 0)

        def VERMINDERD_MET(self):
            return self.getToken(RegelSpraakParser.VERMINDERD_MET, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_additiveOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAdditiveOperator" ):
                listener.enterAdditiveOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAdditiveOperator" ):
                listener.exitAdditiveOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAdditiveOperator" ):
                return visitor.visitAdditiveOperator(self)
            else:
                return visitor.visitChildren(self)




    def additiveOperator(self):

        localctx = RegelSpraakParser.AdditiveOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 262, self.RULE_additiveOperator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1545
            _la = self._input.LA(1)
            if not(((((_la - 133)) & ~0x3f) == 0 and ((1 << (_la - 133)) & 32833) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MultiplicativeExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.left = None # PowerExpressionContext
            self.right = None # PowerExpressionContext

        def powerExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.PowerExpressionContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.PowerExpressionContext,i)


        def multiplicativeOperator(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.MultiplicativeOperatorContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.MultiplicativeOperatorContext,i)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_multiplicativeExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMultiplicativeExpression" ):
                listener.enterMultiplicativeExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMultiplicativeExpression" ):
                listener.exitMultiplicativeExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMultiplicativeExpression" ):
                return visitor.visitMultiplicativeExpression(self)
            else:
                return visitor.visitChildren(self)




    def multiplicativeExpression(self):

        localctx = RegelSpraakParser.MultiplicativeExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 264, self.RULE_multiplicativeExpression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1547
            localctx.left = self.powerExpression()
            self.state = 1553
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,184,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 1548
                    self.multiplicativeOperator()
                    self.state = 1549
                    localctx.right = self.powerExpression() 
                self.state = 1555
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,184,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MultiplicativeOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MAAL(self):
            return self.getToken(RegelSpraakParser.MAAL, 0)

        def GEDEELD_DOOR(self):
            return self.getToken(RegelSpraakParser.GEDEELD_DOOR, 0)

        def GEDEELD_DOOR_ABS(self):
            return self.getToken(RegelSpraakParser.GEDEELD_DOOR_ABS, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_multiplicativeOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMultiplicativeOperator" ):
                listener.enterMultiplicativeOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMultiplicativeOperator" ):
                listener.exitMultiplicativeOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMultiplicativeOperator" ):
                return visitor.visitMultiplicativeOperator(self)
            else:
                return visitor.visitChildren(self)




    def multiplicativeOperator(self):

        localctx = RegelSpraakParser.MultiplicativeOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 266, self.RULE_multiplicativeOperator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1556
            _la = self._input.LA(1)
            if not(((((_la - 122)) & ~0x3f) == 0 and ((1 << (_la - 122)) & 1027) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PowerExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.left = None # PrimaryExpressionContext
            self.right = None # PrimaryExpressionContext

        def primaryExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.PrimaryExpressionContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,i)


        def powerOperator(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.PowerOperatorContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.PowerOperatorContext,i)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_powerExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPowerExpression" ):
                listener.enterPowerExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPowerExpression" ):
                listener.exitPowerExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPowerExpression" ):
                return visitor.visitPowerExpression(self)
            else:
                return visitor.visitChildren(self)




    def powerExpression(self):

        localctx = RegelSpraakParser.PowerExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 268, self.RULE_powerExpression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1558
            localctx.left = self.primaryExpression(0)
            self.state = 1564
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,185,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 1559
                    self.powerOperator()
                    self.state = 1560
                    localctx.right = self.primaryExpression(0) 
                self.state = 1566
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,185,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PowerOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TOT_DE_MACHT(self):
            return self.getToken(RegelSpraakParser.TOT_DE_MACHT, 0)

        def CARET(self):
            return self.getToken(RegelSpraakParser.CARET, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_powerOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPowerOperator" ):
                listener.enterPowerOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPowerOperator" ):
                listener.exitPowerOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPowerOperator" ):
                return visitor.visitPowerOperator(self)
            else:
                return visitor.visitChildren(self)




    def powerOperator(self):

        localctx = RegelSpraakParser.PowerOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 270, self.RULE_powerOperator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1567
            _la = self._input.LA(1)
            if not(_la==143 or _la==284):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PrimaryExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_primaryExpression

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)


    class WortelFuncExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def DE_WORTEL_VAN(self):
            return self.getToken(RegelSpraakParser.DE_WORTEL_VAN, 0)
        def primaryExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWortelFuncExpr" ):
                listener.enterWortelFuncExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWortelFuncExpr" ):
                listener.exitWortelFuncExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitWortelFuncExpr" ):
                return visitor.visitWortelFuncExpr(self)
            else:
                return visitor.visitChildren(self)


    class BooleanTrueLiteralExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def WAAR(self):
            return self.getToken(RegelSpraakParser.WAAR, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBooleanTrueLiteralExpr" ):
                listener.enterBooleanTrueLiteralExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBooleanTrueLiteralExpr" ):
                listener.exitBooleanTrueLiteralExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBooleanTrueLiteralExpr" ):
                return visitor.visitBooleanTrueLiteralExpr(self)
            else:
                return visitor.visitChildren(self)


    class AbsValFuncExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def DE_ABSOLUTE_WAARDE_VAN(self):
            return self.getToken(RegelSpraakParser.DE_ABSOLUTE_WAARDE_VAN, 0)
        def LPAREN(self):
            return self.getToken(RegelSpraakParser.LPAREN, 0)
        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)

        def RPAREN(self):
            return self.getToken(RegelSpraakParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAbsValFuncExpr" ):
                listener.enterAbsValFuncExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAbsValFuncExpr" ):
                listener.exitAbsValFuncExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAbsValFuncExpr" ):
                return visitor.visitAbsValFuncExpr(self)
            else:
                return visitor.visitChildren(self)


    class MaxValFuncExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def DE_MAXIMALE_WAARDE_VAN(self):
            return self.getToken(RegelSpraakParser.DE_MAXIMALE_WAARDE_VAN, 0)
        def primaryExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.PrimaryExpressionContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,i)

        def EN(self):
            return self.getToken(RegelSpraakParser.EN, 0)
        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.COMMA)
            else:
                return self.getToken(RegelSpraakParser.COMMA, i)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMaxValFuncExpr" ):
                listener.enterMaxValFuncExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMaxValFuncExpr" ):
                listener.exitMaxValFuncExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMaxValFuncExpr" ):
                return visitor.visitMaxValFuncExpr(self)
            else:
                return visitor.visitChildren(self)


    class RekendatumKeywordExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def REKENDATUM(self):
            return self.getToken(RegelSpraakParser.REKENDATUM, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRekendatumKeywordExpr" ):
                listener.enterRekendatumKeywordExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRekendatumKeywordExpr" ):
                listener.exitRekendatumKeywordExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRekendatumKeywordExpr" ):
                return visitor.visitRekendatumKeywordExpr(self)
            else:
                return visitor.visitChildren(self)


    class EnumLiteralExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ENUM_LITERAL(self):
            return self.getToken(RegelSpraakParser.ENUM_LITERAL, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEnumLiteralExpr" ):
                listener.enterEnumLiteralExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEnumLiteralExpr" ):
                listener.exitEnumLiteralExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEnumLiteralExpr" ):
                return visitor.visitEnumLiteralExpr(self)
            else:
                return visitor.visitChildren(self)


    class NumberLiteralExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def NUMBER(self):
            return self.getToken(RegelSpraakParser.NUMBER, 0)
        def unitIdentifier(self):
            return self.getTypedRuleContext(RegelSpraakParser.UnitIdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumberLiteralExpr" ):
                listener.enterNumberLiteralExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumberLiteralExpr" ):
                listener.exitNumberLiteralExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNumberLiteralExpr" ):
                return visitor.visitNumberLiteralExpr(self)
            else:
                return visitor.visitChildren(self)


    class DatumLiteralExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def datumLiteral(self):
            return self.getTypedRuleContext(RegelSpraakParser.DatumLiteralContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDatumLiteralExpr" ):
                listener.enterDatumLiteralExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDatumLiteralExpr" ):
                listener.exitDatumLiteralExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDatumLiteralExpr" ):
                return visitor.visitDatumLiteralExpr(self)
            else:
                return visitor.visitChildren(self)


    class AantalFuncExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def HET(self):
            return self.getToken(RegelSpraakParser.HET, 0)
        def AANTAL(self):
            return self.getToken(RegelSpraakParser.AANTAL, 0)
        def ALLE(self):
            return self.getToken(RegelSpraakParser.ALLE, 0)
        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)

        def onderwerpReferentie(self):
            return self.getTypedRuleContext(RegelSpraakParser.OnderwerpReferentieContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAantalFuncExpr" ):
                listener.enterAantalFuncExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAantalFuncExpr" ):
                listener.exitAantalFuncExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAantalFuncExpr" ):
                return visitor.visitAantalFuncExpr(self)
            else:
                return visitor.visitChildren(self)


    class UnaryNietExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def NIET(self):
            return self.getToken(RegelSpraakParser.NIET, 0)
        def primaryExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnaryNietExpr" ):
                listener.enterUnaryNietExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnaryNietExpr" ):
                listener.exitUnaryNietExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnaryNietExpr" ):
                return visitor.visitUnaryNietExpr(self)
            else:
                return visitor.visitChildren(self)


    class ConcatenatieExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def CONCATENATIE_VAN(self):
            return self.getToken(RegelSpraakParser.CONCATENATIE_VAN, 0)
        def primaryExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.PrimaryExpressionContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,i)

        def EN(self):
            return self.getToken(RegelSpraakParser.EN, 0)
        def OF(self):
            return self.getToken(RegelSpraakParser.OF, 0)
        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.COMMA)
            else:
                return self.getToken(RegelSpraakParser.COMMA, i)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConcatenatieExpr" ):
                listener.enterConcatenatieExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConcatenatieExpr" ):
                listener.exitConcatenatieExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConcatenatieExpr" ):
                return visitor.visitConcatenatieExpr(self)
            else:
                return visitor.visitChildren(self)


    class SomAlleAttribuutExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def SOM_VAN(self):
            return self.getToken(RegelSpraakParser.SOM_VAN, 0)
        def ALLE(self):
            return self.getToken(RegelSpraakParser.ALLE, 0)
        def attribuutReferentie(self):
            return self.getTypedRuleContext(RegelSpraakParser.AttribuutReferentieContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSomAlleAttribuutExpr" ):
                listener.enterSomAlleAttribuutExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSomAlleAttribuutExpr" ):
                listener.exitSomAlleAttribuutExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSomAlleAttribuutExpr" ):
                return visitor.visitSomAlleAttribuutExpr(self)
            else:
                return visitor.visitChildren(self)


    class AttrRefExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def attribuutReferentie(self):
            return self.getTypedRuleContext(RegelSpraakParser.AttribuutReferentieContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAttrRefExpr" ):
                listener.enterAttrRefExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAttrRefExpr" ):
                listener.exitAttrRefExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAttrRefExpr" ):
                return visitor.visitAttrRefExpr(self)
            else:
                return visitor.visitChildren(self)


    class DagUitFuncExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def DE(self):
            return self.getToken(RegelSpraakParser.DE, 0)
        def DAG(self):
            return self.getToken(RegelSpraakParser.DAG, 0)
        def UIT(self):
            return self.getToken(RegelSpraakParser.UIT, 0)
        def primaryExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDagUitFuncExpr" ):
                listener.enterDagUitFuncExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDagUitFuncExpr" ):
                listener.exitDagUitFuncExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDagUitFuncExpr" ):
                return visitor.visitDagUitFuncExpr(self)
            else:
                return visitor.visitChildren(self)


    class BegrenzingExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def primaryExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,0)

        def COMMA(self):
            return self.getToken(RegelSpraakParser.COMMA, 0)
        def begrenzing(self):
            return self.getTypedRuleContext(RegelSpraakParser.BegrenzingContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBegrenzingExpr" ):
                listener.enterBegrenzingExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBegrenzingExpr" ):
                listener.exitBegrenzingExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBegrenzingExpr" ):
                return visitor.visitBegrenzingExpr(self)
            else:
                return visitor.visitChildren(self)


    class NaamwoordExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNaamwoordExpr" ):
                listener.enterNaamwoordExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNaamwoordExpr" ):
                listener.exitNaamwoordExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNaamwoordExpr" ):
                return visitor.visitNaamwoordExpr(self)
            else:
                return visitor.visitChildren(self)


    class BooleanFalseLiteralExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ONWAAR(self):
            return self.getToken(RegelSpraakParser.ONWAAR, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBooleanFalseLiteralExpr" ):
                listener.enterBooleanFalseLiteralExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBooleanFalseLiteralExpr" ):
                listener.exitBooleanFalseLiteralExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBooleanFalseLiteralExpr" ):
                return visitor.visitBooleanFalseLiteralExpr(self)
            else:
                return visitor.visitChildren(self)


    class JaarUitFuncExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def HET(self):
            return self.getToken(RegelSpraakParser.HET, 0)
        def JAAR(self):
            return self.getToken(RegelSpraakParser.JAAR, 0)
        def UIT(self):
            return self.getToken(RegelSpraakParser.UIT, 0)
        def primaryExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterJaarUitFuncExpr" ):
                listener.enterJaarUitFuncExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitJaarUitFuncExpr" ):
                listener.exitJaarUitFuncExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitJaarUitFuncExpr" ):
                return visitor.visitJaarUitFuncExpr(self)
            else:
                return visitor.visitChildren(self)


    class TotaalVanExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def HET_TOTAAL_VAN(self):
            return self.getToken(RegelSpraakParser.HET_TOTAAL_VAN, 0)
        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)

        def conditieBijExpressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ConditieBijExpressieContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTotaalVanExpr" ):
                listener.enterTotaalVanExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTotaalVanExpr" ):
                listener.exitTotaalVanExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTotaalVanExpr" ):
                return visitor.visitTotaalVanExpr(self)
            else:
                return visitor.visitChildren(self)


    class TijdsevenredigDeelExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def HET_TIJDSEVENREDIG_DEEL_PER(self):
            return self.getToken(RegelSpraakParser.HET_TIJDSEVENREDIG_DEEL_PER, 0)
        def VAN(self):
            return self.getToken(RegelSpraakParser.VAN, 0)
        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)

        def MAAND(self):
            return self.getToken(RegelSpraakParser.MAAND, 0)
        def JAAR(self):
            return self.getToken(RegelSpraakParser.JAAR, 0)
        def conditieBijExpressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ConditieBijExpressieContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTijdsevenredigDeelExpr" ):
                listener.enterTijdsevenredigDeelExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTijdsevenredigDeelExpr" ):
                listener.exitTijdsevenredigDeelExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTijdsevenredigDeelExpr" ):
                return visitor.visitTijdsevenredigDeelExpr(self)
            else:
                return visitor.visitChildren(self)


    class CapitalizedTijdsevenredigDeelExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def HET_TIJDSEVENREDIG_DEEL_PER(self):
            return self.getToken(RegelSpraakParser.HET_TIJDSEVENREDIG_DEEL_PER, 0)
        def VAN(self):
            return self.getToken(RegelSpraakParser.VAN, 0)
        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)

        def MAAND(self):
            return self.getToken(RegelSpraakParser.MAAND, 0)
        def JAAR(self):
            return self.getToken(RegelSpraakParser.JAAR, 0)
        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.IdentifierContext,i)

        def conditieBijExpressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ConditieBijExpressieContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCapitalizedTijdsevenredigDeelExpr" ):
                listener.enterCapitalizedTijdsevenredigDeelExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCapitalizedTijdsevenredigDeelExpr" ):
                listener.exitCapitalizedTijdsevenredigDeelExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCapitalizedTijdsevenredigDeelExpr" ):
                return visitor.visitCapitalizedTijdsevenredigDeelExpr(self)
            else:
                return visitor.visitChildren(self)


    class AantalAttribuutExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def HET(self):
            return self.getToken(RegelSpraakParser.HET, 0)
        def AANTAL(self):
            return self.getToken(RegelSpraakParser.AANTAL, 0)
        def attribuutReferentie(self):
            return self.getTypedRuleContext(RegelSpraakParser.AttribuutReferentieContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAantalAttribuutExpr" ):
                listener.enterAantalAttribuutExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAantalAttribuutExpr" ):
                listener.exitAantalAttribuutExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAantalAttribuutExpr" ):
                return visitor.visitAantalAttribuutExpr(self)
            else:
                return visitor.visitChildren(self)


    class ParenExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(RegelSpraakParser.LPAREN, 0)
        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)

        def RPAREN(self):
            return self.getToken(RegelSpraakParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParenExpr" ):
                listener.enterParenExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParenExpr" ):
                listener.exitParenExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParenExpr" ):
                return visitor.visitParenExpr(self)
            else:
                return visitor.visitChildren(self)


    class DimensieRangeAggExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def VANAF(self):
            return self.getToken(RegelSpraakParser.VANAF, 0)
        def naamwoord(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.NaamwoordContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,i)

        def TM(self):
            return self.getToken(RegelSpraakParser.TM, 0)
        def getalAggregatieFunctie(self):
            return self.getTypedRuleContext(RegelSpraakParser.GetalAggregatieFunctieContext,0)

        def datumAggregatieFunctie(self):
            return self.getTypedRuleContext(RegelSpraakParser.DatumAggregatieFunctieContext,0)

        def bezieldeReferentie(self):
            return self.getTypedRuleContext(RegelSpraakParser.BezieldeReferentieContext,0)

        def attribuutReferentie(self):
            return self.getTypedRuleContext(RegelSpraakParser.AttribuutReferentieContext,0)

        def DOT(self):
            return self.getToken(RegelSpraakParser.DOT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDimensieRangeAggExpr" ):
                listener.enterDimensieRangeAggExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDimensieRangeAggExpr" ):
                listener.exitDimensieRangeAggExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDimensieRangeAggExpr" ):
                return visitor.visitDimensieRangeAggExpr(self)
            else:
                return visitor.visitChildren(self)


    class DatumMetFuncExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def DE_DATUM_MET(self):
            return self.getToken(RegelSpraakParser.DE_DATUM_MET, 0)
        def LPAREN(self):
            return self.getToken(RegelSpraakParser.LPAREN, 0)
        def primaryExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.PrimaryExpressionContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,i)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.COMMA)
            else:
                return self.getToken(RegelSpraakParser.COMMA, i)
        def RPAREN(self):
            return self.getToken(RegelSpraakParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDatumMetFuncExpr" ):
                listener.enterDatumMetFuncExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDatumMetFuncExpr" ):
                listener.exitDatumMetFuncExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDatumMetFuncExpr" ):
                return visitor.visitDatumMetFuncExpr(self)
            else:
                return visitor.visitChildren(self)


    class PercentageLiteralExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def PERCENTAGE_LITERAL(self):
            return self.getToken(RegelSpraakParser.PERCENTAGE_LITERAL, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPercentageLiteralExpr" ):
                listener.enterPercentageLiteralExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPercentageLiteralExpr" ):
                listener.exitPercentageLiteralExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPercentageLiteralExpr" ):
                return visitor.visitPercentageLiteralExpr(self)
            else:
                return visitor.visitChildren(self)


    class StringLiteralExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def STRING_LITERAL(self):
            return self.getToken(RegelSpraakParser.STRING_LITERAL, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStringLiteralExpr" ):
                listener.enterStringLiteralExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStringLiteralExpr" ):
                listener.exitStringLiteralExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStringLiteralExpr" ):
                return visitor.visitStringLiteralExpr(self)
            else:
                return visitor.visitChildren(self)


    class PercentageFuncExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.p = None # Token
            self.copyFrom(ctx)

        def VAN(self):
            return self.getToken(RegelSpraakParser.VAN, 0)
        def primaryExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,0)

        def NUMBER(self):
            return self.getToken(RegelSpraakParser.NUMBER, 0)
        def PERCENTAGE_LITERAL(self):
            return self.getToken(RegelSpraakParser.PERCENTAGE_LITERAL, 0)
        def PERCENT_SIGN(self):
            return self.getToken(RegelSpraakParser.PERCENT_SIGN, 0)
        def IDENTIFIER(self):
            return self.getToken(RegelSpraakParser.IDENTIFIER, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPercentageFuncExpr" ):
                listener.enterPercentageFuncExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPercentageFuncExpr" ):
                listener.exitPercentageFuncExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPercentageFuncExpr" ):
                return visitor.visitPercentageFuncExpr(self)
            else:
                return visitor.visitChildren(self)


    class EersteDatumFuncExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def EERSTE_VAN(self):
            return self.getToken(RegelSpraakParser.EERSTE_VAN, 0)
        def primaryExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.PrimaryExpressionContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,i)

        def EN(self):
            return self.getToken(RegelSpraakParser.EN, 0)
        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.COMMA)
            else:
                return self.getToken(RegelSpraakParser.COMMA, i)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEersteDatumFuncExpr" ):
                listener.enterEersteDatumFuncExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEersteDatumFuncExpr" ):
                listener.exitEersteDatumFuncExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEersteDatumFuncExpr" ):
                return visitor.visitEersteDatumFuncExpr(self)
            else:
                return visitor.visitChildren(self)


    class PasenFuncExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def DE_EERSTE_PAASDAG_VAN(self):
            return self.getToken(RegelSpraakParser.DE_EERSTE_PAASDAG_VAN, 0)
        def LPAREN(self):
            return self.getToken(RegelSpraakParser.LPAREN, 0)
        def primaryExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,0)

        def RPAREN(self):
            return self.getToken(RegelSpraakParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPasenFuncExpr" ):
                listener.enterPasenFuncExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPasenFuncExpr" ):
                listener.exitPasenFuncExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPasenFuncExpr" ):
                return visitor.visitPasenFuncExpr(self)
            else:
                return visitor.visitChildren(self)


    class AbsTijdsduurFuncExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def DE_ABSOLUTE_TIJDSDUUR_VAN(self):
            return self.getToken(RegelSpraakParser.DE_ABSOLUTE_TIJDSDUUR_VAN, 0)
        def primaryExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.PrimaryExpressionContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,i)

        def TOT(self):
            return self.getToken(RegelSpraakParser.TOT, 0)
        def IN_HELE(self):
            return self.getToken(RegelSpraakParser.IN_HELE, 0)
        def unitIdentifier(self):
            return self.getTypedRuleContext(RegelSpraakParser.UnitIdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAbsTijdsduurFuncExpr" ):
                listener.enterAbsTijdsduurFuncExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAbsTijdsduurFuncExpr" ):
                listener.exitAbsTijdsduurFuncExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAbsTijdsduurFuncExpr" ):
                return visitor.visitAbsTijdsduurFuncExpr(self)
            else:
                return visitor.visitChildren(self)


    class MaandUitFuncExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def DE(self):
            return self.getToken(RegelSpraakParser.DE, 0)
        def MAAND(self):
            return self.getToken(RegelSpraakParser.MAAND, 0)
        def UIT(self):
            return self.getToken(RegelSpraakParser.UIT, 0)
        def primaryExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMaandUitFuncExpr" ):
                listener.enterMaandUitFuncExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMaandUitFuncExpr" ):
                listener.exitMaandUitFuncExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMaandUitFuncExpr" ):
                return visitor.visitMaandUitFuncExpr(self)
            else:
                return visitor.visitChildren(self)


    class CapitalizedTotaalVanExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def HET_TOTAAL_VAN(self):
            return self.getToken(RegelSpraakParser.HET_TOTAAL_VAN, 0)
        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)

        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.IdentifierContext,i)

        def conditieBijExpressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ConditieBijExpressieContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCapitalizedTotaalVanExpr" ):
                listener.enterCapitalizedTotaalVanExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCapitalizedTotaalVanExpr" ):
                listener.exitCapitalizedTotaalVanExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCapitalizedTotaalVanExpr" ):
                return visitor.visitCapitalizedTotaalVanExpr(self)
            else:
                return visitor.visitChildren(self)


    class IdentifierExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(RegelSpraakParser.IdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIdentifierExpr" ):
                listener.enterIdentifierExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIdentifierExpr" ):
                listener.exitIdentifierExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIdentifierExpr" ):
                return visitor.visitIdentifierExpr(self)
            else:
                return visitor.visitChildren(self)


    class DimensieAggExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def attribuutMetLidwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.AttribuutMetLidwoordContext,0)

        def dimensieSelectie(self):
            return self.getTypedRuleContext(RegelSpraakParser.DimensieSelectieContext,0)

        def getalAggregatieFunctie(self):
            return self.getTypedRuleContext(RegelSpraakParser.GetalAggregatieFunctieContext,0)

        def datumAggregatieFunctie(self):
            return self.getTypedRuleContext(RegelSpraakParser.DatumAggregatieFunctieContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDimensieAggExpr" ):
                listener.enterDimensieAggExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDimensieAggExpr" ):
                listener.exitDimensieAggExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDimensieAggExpr" ):
                return visitor.visitDimensieAggExpr(self)
            else:
                return visitor.visitChildren(self)


    class TijdsduurFuncExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def TIJDSDUUR_VAN(self):
            return self.getToken(RegelSpraakParser.TIJDSDUUR_VAN, 0)
        def primaryExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.PrimaryExpressionContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,i)

        def TOT(self):
            return self.getToken(RegelSpraakParser.TOT, 0)
        def IN_HELE(self):
            return self.getToken(RegelSpraakParser.IN_HELE, 0)
        def unitIdentifier(self):
            return self.getTypedRuleContext(RegelSpraakParser.UnitIdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTijdsduurFuncExpr" ):
                listener.enterTijdsduurFuncExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTijdsduurFuncExpr" ):
                listener.exitTijdsduurFuncExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTijdsduurFuncExpr" ):
                return visitor.visitTijdsduurFuncExpr(self)
            else:
                return visitor.visitChildren(self)


    class OnderwerpRefExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def onderwerpReferentie(self):
            return self.getTypedRuleContext(RegelSpraakParser.OnderwerpReferentieContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOnderwerpRefExpr" ):
                listener.enterOnderwerpRefExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOnderwerpRefExpr" ):
                listener.exitOnderwerpRefExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOnderwerpRefExpr" ):
                return visitor.visitOnderwerpRefExpr(self)
            else:
                return visitor.visitChildren(self)


    class SomFuncExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def SOM_VAN(self):
            return self.getToken(RegelSpraakParser.SOM_VAN, 0)
        def primaryExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.PrimaryExpressionContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,i)

        def EN(self):
            return self.getToken(RegelSpraakParser.EN, 0)
        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.COMMA)
            else:
                return self.getToken(RegelSpraakParser.COMMA, i)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSomFuncExpr" ):
                listener.enterSomFuncExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSomFuncExpr" ):
                listener.exitSomFuncExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSomFuncExpr" ):
                return visitor.visitSomFuncExpr(self)
            else:
                return visitor.visitChildren(self)


    class SomAlleExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def SOM_VAN(self):
            return self.getToken(RegelSpraakParser.SOM_VAN, 0)
        def ALLE(self):
            return self.getToken(RegelSpraakParser.ALLE, 0)
        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSomAlleExpr" ):
                listener.enterSomAlleExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSomAlleExpr" ):
                listener.exitSomAlleExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSomAlleExpr" ):
                return visitor.visitSomAlleExpr(self)
            else:
                return visitor.visitChildren(self)


    class SimpleConcatenatieExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def primaryExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.PrimaryExpressionContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,i)

        def EN(self):
            return self.getToken(RegelSpraakParser.EN, 0)
        def OF(self):
            return self.getToken(RegelSpraakParser.OF, 0)
        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.COMMA)
            else:
                return self.getToken(RegelSpraakParser.COMMA, i)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSimpleConcatenatieExpr" ):
                listener.enterSimpleConcatenatieExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSimpleConcatenatieExpr" ):
                listener.exitSimpleConcatenatieExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSimpleConcatenatieExpr" ):
                return visitor.visitSimpleConcatenatieExpr(self)
            else:
                return visitor.visitChildren(self)


    class BegrenzingAfrondingExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def primaryExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,0)

        def COMMA(self):
            return self.getToken(RegelSpraakParser.COMMA, 0)
        def begrenzing(self):
            return self.getTypedRuleContext(RegelSpraakParser.BegrenzingContext,0)

        def afronding(self):
            return self.getTypedRuleContext(RegelSpraakParser.AfrondingContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBegrenzingAfrondingExpr" ):
                listener.enterBegrenzingAfrondingExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBegrenzingAfrondingExpr" ):
                listener.exitBegrenzingAfrondingExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBegrenzingAfrondingExpr" ):
                return visitor.visitBegrenzingAfrondingExpr(self)
            else:
                return visitor.visitChildren(self)


    class PercentageOfExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def PERCENTAGE_LITERAL(self):
            return self.getToken(RegelSpraakParser.PERCENTAGE_LITERAL, 0)
        def VAN(self):
            return self.getToken(RegelSpraakParser.VAN, 0)
        def primaryExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPercentageOfExpr" ):
                listener.enterPercentageOfExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPercentageOfExpr" ):
                listener.exitPercentageOfExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPercentageOfExpr" ):
                return visitor.visitPercentageOfExpr(self)
            else:
                return visitor.visitChildren(self)


    class MinValFuncExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def DE_MINIMALE_WAARDE_VAN(self):
            return self.getToken(RegelSpraakParser.DE_MINIMALE_WAARDE_VAN, 0)
        def primaryExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.PrimaryExpressionContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,i)

        def EN(self):
            return self.getToken(RegelSpraakParser.EN, 0)
        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.COMMA)
            else:
                return self.getToken(RegelSpraakParser.COMMA, i)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMinValFuncExpr" ):
                listener.enterMinValFuncExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMinValFuncExpr" ):
                listener.exitMinValFuncExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMinValFuncExpr" ):
                return visitor.visitMinValFuncExpr(self)
            else:
                return visitor.visitChildren(self)


    class MaxAlleAttribuutExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def DE_MAXIMALE_WAARDE_VAN(self):
            return self.getToken(RegelSpraakParser.DE_MAXIMALE_WAARDE_VAN, 0)
        def ALLE(self):
            return self.getToken(RegelSpraakParser.ALLE, 0)
        def attribuutReferentie(self):
            return self.getTypedRuleContext(RegelSpraakParser.AttribuutReferentieContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMaxAlleAttribuutExpr" ):
                listener.enterMaxAlleAttribuutExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMaxAlleAttribuutExpr" ):
                listener.exitMaxAlleAttribuutExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMaxAlleAttribuutExpr" ):
                return visitor.visitMaxAlleAttribuutExpr(self)
            else:
                return visitor.visitChildren(self)


    class BezieldeRefExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def bezieldeReferentie(self):
            return self.getTypedRuleContext(RegelSpraakParser.BezieldeReferentieContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBezieldeRefExpr" ):
                listener.enterBezieldeRefExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBezieldeRefExpr" ):
                listener.exitBezieldeRefExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBezieldeRefExpr" ):
                return visitor.visitBezieldeRefExpr(self)
            else:
                return visitor.visitChildren(self)


    class DateCalcExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def primaryExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.PrimaryExpressionContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,i)

        def timeUnit(self):
            return self.getTypedRuleContext(RegelSpraakParser.TimeUnitContext,0)

        def PLUS(self):
            return self.getToken(RegelSpraakParser.PLUS, 0)
        def MIN(self):
            return self.getToken(RegelSpraakParser.MIN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDateCalcExpr" ):
                listener.enterDateCalcExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDateCalcExpr" ):
                listener.exitDateCalcExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDateCalcExpr" ):
                return visitor.visitDateCalcExpr(self)
            else:
                return visitor.visitChildren(self)


    class MinAlleAttribuutExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def DE_MINIMALE_WAARDE_VAN(self):
            return self.getToken(RegelSpraakParser.DE_MINIMALE_WAARDE_VAN, 0)
        def ALLE(self):
            return self.getToken(RegelSpraakParser.ALLE, 0)
        def attribuutReferentie(self):
            return self.getTypedRuleContext(RegelSpraakParser.AttribuutReferentieContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMinAlleAttribuutExpr" ):
                listener.enterMinAlleAttribuutExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMinAlleAttribuutExpr" ):
                listener.exitMinAlleAttribuutExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMinAlleAttribuutExpr" ):
                return visitor.visitMinAlleAttribuutExpr(self)
            else:
                return visitor.visitChildren(self)


    class AfrondingExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def primaryExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,0)

        def afronding(self):
            return self.getTypedRuleContext(RegelSpraakParser.AfrondingContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAfrondingExpr" ):
                listener.enterAfrondingExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAfrondingExpr" ):
                listener.exitAfrondingExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAfrondingExpr" ):
                return visitor.visitAfrondingExpr(self)
            else:
                return visitor.visitChildren(self)


    class LaatsteDatumFuncExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LAATSTE_VAN(self):
            return self.getToken(RegelSpraakParser.LAATSTE_VAN, 0)
        def primaryExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.PrimaryExpressionContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,i)

        def EN(self):
            return self.getToken(RegelSpraakParser.EN, 0)
        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.COMMA)
            else:
                return self.getToken(RegelSpraakParser.COMMA, i)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLaatsteDatumFuncExpr" ):
                listener.enterLaatsteDatumFuncExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLaatsteDatumFuncExpr" ):
                listener.exitLaatsteDatumFuncExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLaatsteDatumFuncExpr" ):
                return visitor.visitLaatsteDatumFuncExpr(self)
            else:
                return visitor.visitChildren(self)


    class HetAantalDagenInExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def HET(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.HET)
            else:
                return self.getToken(RegelSpraakParser.HET, i)
        def AANTAL(self):
            return self.getToken(RegelSpraakParser.AANTAL, 0)
        def DAGEN(self):
            return self.getToken(RegelSpraakParser.DAGEN, 0)
        def IN(self):
            return self.getToken(RegelSpraakParser.IN, 0)
        def DAT(self):
            return self.getToken(RegelSpraakParser.DAT, 0)
        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)

        def MAAND(self):
            return self.getToken(RegelSpraakParser.MAAND, 0)
        def JAAR(self):
            return self.getToken(RegelSpraakParser.JAAR, 0)
        def DE(self):
            return self.getToken(RegelSpraakParser.DE, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterHetAantalDagenInExpr" ):
                listener.enterHetAantalDagenInExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitHetAantalDagenInExpr" ):
                listener.exitHetAantalDagenInExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitHetAantalDagenInExpr" ):
                return visitor.visitHetAantalDagenInExpr(self)
            else:
                return visitor.visitChildren(self)


    class UnaryMinusExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def MIN(self):
            return self.getToken(RegelSpraakParser.MIN, 0)
        def primaryExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,0)

        def MINUS(self):
            return self.getToken(RegelSpraakParser.MINUS, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnaryMinusExpr" ):
                listener.enterUnaryMinusExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnaryMinusExpr" ):
                listener.exitUnaryMinusExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnaryMinusExpr" ):
                return visitor.visitUnaryMinusExpr(self)
            else:
                return visitor.visitChildren(self)


    class ParamRefExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def parameterMetLidwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.ParameterMetLidwoordContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParamRefExpr" ):
                listener.enterParamRefExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParamRefExpr" ):
                listener.exitParamRefExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParamRefExpr" ):
                return visitor.visitParamRefExpr(self)
            else:
                return visitor.visitChildren(self)


    class PronounExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def HIJ(self):
            return self.getToken(RegelSpraakParser.HIJ, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPronounExpr" ):
                listener.enterPronounExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPronounExpr" ):
                listener.exitPronounExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPronounExpr" ):
                return visitor.visitPronounExpr(self)
            else:
                return visitor.visitChildren(self)



    def primaryExpression(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = RegelSpraakParser.PrimaryExpressionContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 272
        self.enterRecursionRule(localctx, 272, self.RULE_primaryExpression, _p)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1833
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,210,self._ctx)
            if la_ == 1:
                localctx = RegelSpraakParser.UnaryMinusExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx

                self.state = 1570
                self.match(RegelSpraakParser.MIN)
                self.state = 1571
                self.primaryExpression(58)
                pass

            elif la_ == 2:
                localctx = RegelSpraakParser.UnaryMinusExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1572
                self.match(RegelSpraakParser.MINUS)
                self.state = 1573
                self.primaryExpression(57)
                pass

            elif la_ == 3:
                localctx = RegelSpraakParser.UnaryNietExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1574
                self.match(RegelSpraakParser.NIET)
                self.state = 1575
                self.primaryExpression(56)
                pass

            elif la_ == 4:
                localctx = RegelSpraakParser.AbsTijdsduurFuncExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1576
                self.match(RegelSpraakParser.DE_ABSOLUTE_TIJDSDUUR_VAN)
                self.state = 1577
                self.primaryExpression(0)
                self.state = 1578
                self.match(RegelSpraakParser.TOT)
                self.state = 1579
                self.primaryExpression(0)
                self.state = 1582
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,186,self._ctx)
                if la_ == 1:
                    self.state = 1580
                    self.match(RegelSpraakParser.IN_HELE)
                    self.state = 1581
                    self.unitIdentifier()


                pass

            elif la_ == 5:
                localctx = RegelSpraakParser.TijdsduurFuncExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1584
                self.match(RegelSpraakParser.TIJDSDUUR_VAN)
                self.state = 1585
                self.primaryExpression(0)
                self.state = 1586
                self.match(RegelSpraakParser.TOT)
                self.state = 1587
                self.primaryExpression(0)
                self.state = 1590
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,187,self._ctx)
                if la_ == 1:
                    self.state = 1588
                    self.match(RegelSpraakParser.IN_HELE)
                    self.state = 1589
                    self.unitIdentifier()


                pass

            elif la_ == 6:
                localctx = RegelSpraakParser.SomFuncExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1592
                self.match(RegelSpraakParser.SOM_VAN)
                self.state = 1593
                self.primaryExpression(0)
                self.state = 1598
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==274:
                    self.state = 1594
                    self.match(RegelSpraakParser.COMMA)
                    self.state = 1595
                    self.primaryExpression(0)
                    self.state = 1600
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 1601
                self.match(RegelSpraakParser.EN)
                self.state = 1602
                self.primaryExpression(53)
                pass

            elif la_ == 7:
                localctx = RegelSpraakParser.SomAlleExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1604
                self.match(RegelSpraakParser.SOM_VAN)
                self.state = 1605
                self.match(RegelSpraakParser.ALLE)
                self.state = 1606
                self.naamwoord()
                pass

            elif la_ == 8:
                localctx = RegelSpraakParser.SomAlleAttribuutExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1607
                self.match(RegelSpraakParser.SOM_VAN)
                self.state = 1608
                self.match(RegelSpraakParser.ALLE)
                self.state = 1609
                self.attribuutReferentie()
                pass

            elif la_ == 9:
                localctx = RegelSpraakParser.AantalFuncExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1610
                self.match(RegelSpraakParser.HET)
                self.state = 1611
                self.match(RegelSpraakParser.AANTAL)
                self.state = 1612
                self.match(RegelSpraakParser.ALLE)
                self.state = 1613
                self.naamwoord()
                pass

            elif la_ == 10:
                localctx = RegelSpraakParser.AantalFuncExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1614
                self.match(RegelSpraakParser.HET)
                self.state = 1615
                self.match(RegelSpraakParser.AANTAL)
                self.state = 1616
                self.onderwerpReferentie()
                pass

            elif la_ == 11:
                localctx = RegelSpraakParser.AantalFuncExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1617
                self.match(RegelSpraakParser.AANTAL)
                self.state = 1618
                self.match(RegelSpraakParser.ALLE)
                self.state = 1619
                self.naamwoord()
                pass

            elif la_ == 12:
                localctx = RegelSpraakParser.AantalFuncExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1620
                self.match(RegelSpraakParser.AANTAL)
                self.state = 1621
                self.onderwerpReferentie()
                pass

            elif la_ == 13:
                localctx = RegelSpraakParser.AantalAttribuutExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1622
                self.match(RegelSpraakParser.HET)
                self.state = 1623
                self.match(RegelSpraakParser.AANTAL)
                self.state = 1624
                self.attribuutReferentie()
                pass

            elif la_ == 14:
                localctx = RegelSpraakParser.AantalAttribuutExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1625
                self.match(RegelSpraakParser.AANTAL)
                self.state = 1626
                self.attribuutReferentie()
                pass

            elif la_ == 15:
                localctx = RegelSpraakParser.PercentageFuncExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1633
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [264]:
                    self.state = 1627
                    self.match(RegelSpraakParser.NUMBER)
                    self.state = 1630
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [279]:
                        self.state = 1628
                        self.match(RegelSpraakParser.PERCENT_SIGN)
                        pass
                    elif token in [263]:
                        self.state = 1629
                        localctx.p = self.match(RegelSpraakParser.IDENTIFIER)
                        pass
                    else:
                        raise NoViableAltException(self)

                    pass
                elif token in [267]:
                    self.state = 1632
                    self.match(RegelSpraakParser.PERCENTAGE_LITERAL)
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 1635
                self.match(RegelSpraakParser.VAN)
                self.state = 1636
                self.primaryExpression(44)
                pass

            elif la_ == 16:
                localctx = RegelSpraakParser.PercentageOfExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1637
                self.match(RegelSpraakParser.PERCENTAGE_LITERAL)
                self.state = 1638
                self.match(RegelSpraakParser.VAN)
                self.state = 1639
                self.primaryExpression(43)
                pass

            elif la_ == 17:
                localctx = RegelSpraakParser.ConcatenatieExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1640
                self.match(RegelSpraakParser.CONCATENATIE_VAN)
                self.state = 1641
                self.primaryExpression(0)
                self.state = 1646
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==274:
                    self.state = 1642
                    self.match(RegelSpraakParser.COMMA)
                    self.state = 1643
                    self.primaryExpression(0)
                    self.state = 1648
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 1649
                _la = self._input.LA(1)
                if not(_la==212 or _la==225):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1650
                self.primaryExpression(39)
                pass

            elif la_ == 18:
                localctx = RegelSpraakParser.WortelFuncExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1652
                self.match(RegelSpraakParser.DE_WORTEL_VAN)
                self.state = 1653
                self.primaryExpression(37)
                pass

            elif la_ == 19:
                localctx = RegelSpraakParser.AbsValFuncExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1654
                self.match(RegelSpraakParser.DE_ABSOLUTE_WAARDE_VAN)
                self.state = 1655
                self.match(RegelSpraakParser.LPAREN)
                self.state = 1656
                self.expressie()
                self.state = 1657
                self.match(RegelSpraakParser.RPAREN)
                pass

            elif la_ == 20:
                localctx = RegelSpraakParser.MinValFuncExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1659
                self.match(RegelSpraakParser.DE_MINIMALE_WAARDE_VAN)
                self.state = 1660
                self.primaryExpression(0)
                self.state = 1665
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==274:
                    self.state = 1661
                    self.match(RegelSpraakParser.COMMA)
                    self.state = 1662
                    self.primaryExpression(0)
                    self.state = 1667
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 1668
                self.match(RegelSpraakParser.EN)
                self.state = 1669
                self.primaryExpression(35)
                pass

            elif la_ == 21:
                localctx = RegelSpraakParser.MinAlleAttribuutExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1671
                self.match(RegelSpraakParser.DE_MINIMALE_WAARDE_VAN)
                self.state = 1672
                self.match(RegelSpraakParser.ALLE)
                self.state = 1673
                self.attribuutReferentie()
                pass

            elif la_ == 22:
                localctx = RegelSpraakParser.MaxValFuncExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1674
                self.match(RegelSpraakParser.DE_MAXIMALE_WAARDE_VAN)
                self.state = 1675
                self.primaryExpression(0)
                self.state = 1680
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==274:
                    self.state = 1676
                    self.match(RegelSpraakParser.COMMA)
                    self.state = 1677
                    self.primaryExpression(0)
                    self.state = 1682
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 1683
                self.match(RegelSpraakParser.EN)
                self.state = 1684
                self.primaryExpression(33)
                pass

            elif la_ == 23:
                localctx = RegelSpraakParser.MaxAlleAttribuutExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1686
                self.match(RegelSpraakParser.DE_MAXIMALE_WAARDE_VAN)
                self.state = 1687
                self.match(RegelSpraakParser.ALLE)
                self.state = 1688
                self.attribuutReferentie()
                pass

            elif la_ == 24:
                localctx = RegelSpraakParser.JaarUitFuncExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1689
                self.match(RegelSpraakParser.HET)
                self.state = 1690
                self.match(RegelSpraakParser.JAAR)
                self.state = 1691
                self.match(RegelSpraakParser.UIT)
                self.state = 1692
                self.primaryExpression(31)
                pass

            elif la_ == 25:
                localctx = RegelSpraakParser.MaandUitFuncExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1693
                self.match(RegelSpraakParser.DE)
                self.state = 1694
                self.match(RegelSpraakParser.MAAND)
                self.state = 1695
                self.match(RegelSpraakParser.UIT)
                self.state = 1696
                self.primaryExpression(30)
                pass

            elif la_ == 26:
                localctx = RegelSpraakParser.DagUitFuncExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1697
                self.match(RegelSpraakParser.DE)
                self.state = 1698
                self.match(RegelSpraakParser.DAG)
                self.state = 1699
                self.match(RegelSpraakParser.UIT)
                self.state = 1700
                self.primaryExpression(29)
                pass

            elif la_ == 27:
                localctx = RegelSpraakParser.DatumMetFuncExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1701
                self.match(RegelSpraakParser.DE_DATUM_MET)
                self.state = 1702
                self.match(RegelSpraakParser.LPAREN)
                self.state = 1703
                self.primaryExpression(0)
                self.state = 1704
                self.match(RegelSpraakParser.COMMA)
                self.state = 1705
                self.primaryExpression(0)
                self.state = 1706
                self.match(RegelSpraakParser.COMMA)
                self.state = 1707
                self.primaryExpression(0)
                self.state = 1708
                self.match(RegelSpraakParser.RPAREN)
                pass

            elif la_ == 28:
                localctx = RegelSpraakParser.PasenFuncExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1710
                self.match(RegelSpraakParser.DE_EERSTE_PAASDAG_VAN)
                self.state = 1711
                self.match(RegelSpraakParser.LPAREN)
                self.state = 1712
                self.primaryExpression(0)
                self.state = 1713
                self.match(RegelSpraakParser.RPAREN)
                pass

            elif la_ == 29:
                localctx = RegelSpraakParser.EersteDatumFuncExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1715
                self.match(RegelSpraakParser.EERSTE_VAN)
                self.state = 1716
                self.primaryExpression(0)
                self.state = 1721
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==274:
                    self.state = 1717
                    self.match(RegelSpraakParser.COMMA)
                    self.state = 1718
                    self.primaryExpression(0)
                    self.state = 1723
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 1724
                self.match(RegelSpraakParser.EN)
                self.state = 1725
                self.primaryExpression(25)
                pass

            elif la_ == 30:
                localctx = RegelSpraakParser.LaatsteDatumFuncExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1727
                self.match(RegelSpraakParser.LAATSTE_VAN)
                self.state = 1728
                self.primaryExpression(0)
                self.state = 1733
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==274:
                    self.state = 1729
                    self.match(RegelSpraakParser.COMMA)
                    self.state = 1730
                    self.primaryExpression(0)
                    self.state = 1735
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 1736
                self.match(RegelSpraakParser.EN)
                self.state = 1737
                self.primaryExpression(24)
                pass

            elif la_ == 31:
                localctx = RegelSpraakParser.TotaalVanExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1739
                self.match(RegelSpraakParser.HET_TOTAAL_VAN)
                self.state = 1740
                self.expressie()
                self.state = 1742
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,196,self._ctx)
                if la_ == 1:
                    self.state = 1741
                    self.conditieBijExpressie()


                pass

            elif la_ == 32:
                localctx = RegelSpraakParser.HetAantalDagenInExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1744
                self.match(RegelSpraakParser.HET)
                self.state = 1745
                self.match(RegelSpraakParser.AANTAL)
                self.state = 1746
                self.match(RegelSpraakParser.DAGEN)
                self.state = 1747
                self.match(RegelSpraakParser.IN)
                self.state = 1756
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [208, 220]:
                    self.state = 1749
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==208:
                        self.state = 1748
                        self.match(RegelSpraakParser.DE)


                    self.state = 1751
                    self.match(RegelSpraakParser.MAAND)
                    pass
                elif token in [213, 217]:
                    self.state = 1753
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==213:
                        self.state = 1752
                        self.match(RegelSpraakParser.HET)


                    self.state = 1755
                    self.match(RegelSpraakParser.JAAR)
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 1758
                self.match(RegelSpraakParser.DAT)
                self.state = 1759
                self.expressie()
                pass

            elif la_ == 33:
                localctx = RegelSpraakParser.CapitalizedTotaalVanExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1761 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 1760
                    self.identifier()
                    self.state = 1763 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==263):
                        break

                self.state = 1765
                self.match(RegelSpraakParser.HET_TOTAAL_VAN)
                self.state = 1766
                self.expressie()
                self.state = 1768
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,201,self._ctx)
                if la_ == 1:
                    self.state = 1767
                    self.conditieBijExpressie()


                pass

            elif la_ == 34:
                localctx = RegelSpraakParser.TijdsevenredigDeelExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1770
                self.match(RegelSpraakParser.HET_TIJDSEVENREDIG_DEEL_PER)
                self.state = 1771
                _la = self._input.LA(1)
                if not(_la==217 or _la==220):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1772
                self.match(RegelSpraakParser.VAN)
                self.state = 1773
                self.expressie()
                self.state = 1775
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,202,self._ctx)
                if la_ == 1:
                    self.state = 1774
                    self.conditieBijExpressie()


                pass

            elif la_ == 35:
                localctx = RegelSpraakParser.CapitalizedTijdsevenredigDeelExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1778 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 1777
                    self.identifier()
                    self.state = 1780 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==263):
                        break

                self.state = 1782
                self.match(RegelSpraakParser.HET_TIJDSEVENREDIG_DEEL_PER)
                self.state = 1783
                _la = self._input.LA(1)
                if not(_la==217 or _la==220):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1784
                self.match(RegelSpraakParser.VAN)
                self.state = 1785
                self.expressie()
                self.state = 1787
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,204,self._ctx)
                if la_ == 1:
                    self.state = 1786
                    self.conditieBijExpressie()


                pass

            elif la_ == 36:
                localctx = RegelSpraakParser.DimensieAggExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1791
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [13, 14, 186, 191, 213]:
                    self.state = 1789
                    self.getalAggregatieFunctie()
                    pass
                elif token in [187, 189]:
                    self.state = 1790
                    self.datumAggregatieFunctie()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 1793
                self.attribuutMetLidwoord()
                self.state = 1794
                self.dimensieSelectie()
                pass

            elif la_ == 37:
                localctx = RegelSpraakParser.DimensieRangeAggExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1798
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [13, 14, 186, 191, 213]:
                    self.state = 1796
                    self.getalAggregatieFunctie()
                    pass
                elif token in [187, 189]:
                    self.state = 1797
                    self.datumAggregatieFunctie()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 1802
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,207,self._ctx)
                if la_ == 1:
                    self.state = 1800
                    self.bezieldeReferentie()
                    pass

                elif la_ == 2:
                    self.state = 1801
                    self.attribuutReferentie()
                    pass


                self.state = 1804
                self.match(RegelSpraakParser.VANAF)
                self.state = 1805
                self.naamwoord()
                self.state = 1806
                self.match(RegelSpraakParser.TM)
                self.state = 1807
                self.naamwoord()
                self.state = 1809
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,208,self._ctx)
                if la_ == 1:
                    self.state = 1808
                    self.match(RegelSpraakParser.DOT)


                pass

            elif la_ == 38:
                localctx = RegelSpraakParser.NumberLiteralExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1811
                self.match(RegelSpraakParser.NUMBER)
                self.state = 1813
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,209,self._ctx)
                if la_ == 1:
                    self.state = 1812
                    self.unitIdentifier()


                pass

            elif la_ == 39:
                localctx = RegelSpraakParser.RekendatumKeywordExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1815
                self.match(RegelSpraakParser.REKENDATUM)
                pass

            elif la_ == 40:
                localctx = RegelSpraakParser.IdentifierExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1816
                self.identifier()
                pass

            elif la_ == 41:
                localctx = RegelSpraakParser.BezieldeRefExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1817
                self.bezieldeReferentie()
                pass

            elif la_ == 42:
                localctx = RegelSpraakParser.AttrRefExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1818
                self.attribuutReferentie()
                pass

            elif la_ == 43:
                localctx = RegelSpraakParser.OnderwerpRefExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1819
                self.onderwerpReferentie()
                pass

            elif la_ == 44:
                localctx = RegelSpraakParser.NaamwoordExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1820
                self.naamwoord()
                pass

            elif la_ == 45:
                localctx = RegelSpraakParser.ParamRefExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1821
                self.parameterMetLidwoord()
                pass

            elif la_ == 46:
                localctx = RegelSpraakParser.PercentageLiteralExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1822
                self.match(RegelSpraakParser.PERCENTAGE_LITERAL)
                pass

            elif la_ == 47:
                localctx = RegelSpraakParser.StringLiteralExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1823
                self.match(RegelSpraakParser.STRING_LITERAL)
                pass

            elif la_ == 48:
                localctx = RegelSpraakParser.EnumLiteralExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1824
                self.match(RegelSpraakParser.ENUM_LITERAL)
                pass

            elif la_ == 49:
                localctx = RegelSpraakParser.DatumLiteralExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1825
                self.datumLiteral()
                pass

            elif la_ == 50:
                localctx = RegelSpraakParser.BooleanTrueLiteralExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1826
                self.match(RegelSpraakParser.WAAR)
                pass

            elif la_ == 51:
                localctx = RegelSpraakParser.BooleanFalseLiteralExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1827
                self.match(RegelSpraakParser.ONWAAR)
                pass

            elif la_ == 52:
                localctx = RegelSpraakParser.PronounExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1828
                self.match(RegelSpraakParser.HIJ)
                pass

            elif la_ == 53:
                localctx = RegelSpraakParser.ParenExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1829
                self.match(RegelSpraakParser.LPAREN)
                self.state = 1830
                self.expressie()
                self.state = 1831
                self.match(RegelSpraakParser.RPAREN)
                pass


            self._ctx.stop = self._input.LT(-1)
            self.state = 1862
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,213,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    self.state = 1860
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,212,self._ctx)
                    if la_ == 1:
                        localctx = RegelSpraakParser.SimpleConcatenatieExprContext(self, RegelSpraakParser.PrimaryExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_primaryExpression)
                        self.state = 1835
                        if not self.precpred(self._ctx, 38):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 38)")
                        self.state = 1838 
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        while True:
                            self.state = 1836
                            self.match(RegelSpraakParser.COMMA)
                            self.state = 1837
                            self.primaryExpression(0)
                            self.state = 1840 
                            self._errHandler.sync(self)
                            _la = self._input.LA(1)
                            if not (_la==274):
                                break

                        self.state = 1842
                        _la = self._input.LA(1)
                        if not(_la==212 or _la==225):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 1843
                        self.primaryExpression(39)
                        pass

                    elif la_ == 2:
                        localctx = RegelSpraakParser.AfrondingExprContext(self, RegelSpraakParser.PrimaryExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_primaryExpression)
                        self.state = 1845
                        if not self.precpred(self._ctx, 42):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 42)")
                        self.state = 1846
                        self.afronding()
                        pass

                    elif la_ == 3:
                        localctx = RegelSpraakParser.BegrenzingAfrondingExprContext(self, RegelSpraakParser.PrimaryExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_primaryExpression)
                        self.state = 1847
                        if not self.precpred(self._ctx, 41):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 41)")
                        self.state = 1848
                        self.match(RegelSpraakParser.COMMA)
                        self.state = 1849
                        self.begrenzing()
                        self.state = 1850
                        self.afronding()
                        pass

                    elif la_ == 4:
                        localctx = RegelSpraakParser.BegrenzingExprContext(self, RegelSpraakParser.PrimaryExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_primaryExpression)
                        self.state = 1852
                        if not self.precpred(self._ctx, 40):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 40)")
                        self.state = 1853
                        self.match(RegelSpraakParser.COMMA)
                        self.state = 1854
                        self.begrenzing()
                        pass

                    elif la_ == 5:
                        localctx = RegelSpraakParser.DateCalcExprContext(self, RegelSpraakParser.PrimaryExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_primaryExpression)
                        self.state = 1855
                        if not self.precpred(self._ctx, 26):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 26)")
                        self.state = 1856
                        _la = self._input.LA(1)
                        if not(_la==133 or _la==139):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 1857
                        self.primaryExpression(0)
                        self.state = 1858
                        self.timeUnit()
                        pass

             
                self.state = 1864
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,213,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class AfrondingContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def AFGEROND_OP(self):
            return self.getToken(RegelSpraakParser.AFGEROND_OP, 0)

        def NUMBER(self):
            return self.getToken(RegelSpraakParser.NUMBER, 0)

        def DECIMALEN(self):
            return self.getToken(RegelSpraakParser.DECIMALEN, 0)

        def NAAR_BENEDEN(self):
            return self.getToken(RegelSpraakParser.NAAR_BENEDEN, 0)

        def NAAR_BOVEN(self):
            return self.getToken(RegelSpraakParser.NAAR_BOVEN, 0)

        def REKENKUNDIG(self):
            return self.getToken(RegelSpraakParser.REKENKUNDIG, 0)

        def RICHTING_NUL(self):
            return self.getToken(RegelSpraakParser.RICHTING_NUL, 0)

        def WEG_VAN_NUL(self):
            return self.getToken(RegelSpraakParser.WEG_VAN_NUL, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_afronding

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAfronding" ):
                listener.enterAfronding(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAfronding" ):
                listener.exitAfronding(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAfronding" ):
                return visitor.visitAfronding(self)
            else:
                return visitor.visitChildren(self)




    def afronding(self):

        localctx = RegelSpraakParser.AfrondingContext(self, self._ctx, self.state)
        self.enterRule(localctx, 274, self.RULE_afronding)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1865
            _la = self._input.LA(1)
            if not(((((_la - 134)) & ~0x3f) == 0 and ((1 << (_la - 134)) & 131267) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 1866
            self.match(RegelSpraakParser.AFGEROND_OP)
            self.state = 1867
            self.match(RegelSpraakParser.NUMBER)
            self.state = 1868
            self.match(RegelSpraakParser.DECIMALEN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BegrenzingContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def begrenzingMinimum(self):
            return self.getTypedRuleContext(RegelSpraakParser.BegrenzingMinimumContext,0)


        def begrenzingMaximum(self):
            return self.getTypedRuleContext(RegelSpraakParser.BegrenzingMaximumContext,0)


        def EN(self):
            return self.getToken(RegelSpraakParser.EN, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_begrenzing

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBegrenzing" ):
                listener.enterBegrenzing(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBegrenzing" ):
                listener.exitBegrenzing(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBegrenzing" ):
                return visitor.visitBegrenzing(self)
            else:
                return visitor.visitChildren(self)




    def begrenzing(self):

        localctx = RegelSpraakParser.BegrenzingContext(self, self._ctx, self.state)
        self.enterRule(localctx, 276, self.RULE_begrenzing)
        try:
            self.state = 1876
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,214,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1870
                self.begrenzingMinimum()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1871
                self.begrenzingMaximum()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1872
                self.begrenzingMinimum()
                self.state = 1873
                self.match(RegelSpraakParser.EN)
                self.state = 1874
                self.begrenzingMaximum()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BegrenzingMinimumContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MET_EEN_MINIMUM_VAN(self):
            return self.getToken(RegelSpraakParser.MET_EEN_MINIMUM_VAN, 0)

        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_begrenzingMinimum

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBegrenzingMinimum" ):
                listener.enterBegrenzingMinimum(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBegrenzingMinimum" ):
                listener.exitBegrenzingMinimum(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBegrenzingMinimum" ):
                return visitor.visitBegrenzingMinimum(self)
            else:
                return visitor.visitChildren(self)




    def begrenzingMinimum(self):

        localctx = RegelSpraakParser.BegrenzingMinimumContext(self, self._ctx, self.state)
        self.enterRule(localctx, 278, self.RULE_begrenzingMinimum)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1878
            self.match(RegelSpraakParser.MET_EEN_MINIMUM_VAN)
            self.state = 1879
            self.expressie()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BegrenzingMaximumContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MET_EEN_MAXIMUM_VAN(self):
            return self.getToken(RegelSpraakParser.MET_EEN_MAXIMUM_VAN, 0)

        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_begrenzingMaximum

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBegrenzingMaximum" ):
                listener.enterBegrenzingMaximum(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBegrenzingMaximum" ):
                listener.exitBegrenzingMaximum(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBegrenzingMaximum" ):
                return visitor.visitBegrenzingMaximum(self)
            else:
                return visitor.visitChildren(self)




    def begrenzingMaximum(self):

        localctx = RegelSpraakParser.BegrenzingMaximumContext(self, self._ctx, self.state)
        self.enterRule(localctx, 280, self.RULE_begrenzingMaximum)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1881
            self.match(RegelSpraakParser.MET_EEN_MAXIMUM_VAN)
            self.state = 1882
            self.expressie()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConditieBijExpressieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.condition = None # ExpressieContext

        def GEDURENDE_DE_TIJD_DAT(self):
            return self.getToken(RegelSpraakParser.GEDURENDE_DE_TIJD_DAT, 0)

        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)


        def periodevergelijkingEnkelvoudig(self):
            return self.getTypedRuleContext(RegelSpraakParser.PeriodevergelijkingEnkelvoudigContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_conditieBijExpressie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConditieBijExpressie" ):
                listener.enterConditieBijExpressie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConditieBijExpressie" ):
                listener.exitConditieBijExpressie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConditieBijExpressie" ):
                return visitor.visitConditieBijExpressie(self)
            else:
                return visitor.visitChildren(self)




    def conditieBijExpressie(self):

        localctx = RegelSpraakParser.ConditieBijExpressieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 282, self.RULE_conditieBijExpressie)
        try:
            self.state = 1887
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [4]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1884
                self.match(RegelSpraakParser.GEDURENDE_DE_TIJD_DAT)
                self.state = 1885
                localctx.condition = self.expressie()
                pass
            elif token in [142, 144, 146, 240]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1886
                self.periodevergelijkingEnkelvoudig()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PeriodevergelijkingElementairContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def HET_IS_DE_PERIODE(self):
            return self.getToken(RegelSpraakParser.HET_IS_DE_PERIODE, 0)

        def periodevergelijkingEnkelvoudig(self):
            return self.getTypedRuleContext(RegelSpraakParser.PeriodevergelijkingEnkelvoudigContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_periodevergelijkingElementair

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPeriodevergelijkingElementair" ):
                listener.enterPeriodevergelijkingElementair(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPeriodevergelijkingElementair" ):
                listener.exitPeriodevergelijkingElementair(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPeriodevergelijkingElementair" ):
                return visitor.visitPeriodevergelijkingElementair(self)
            else:
                return visitor.visitChildren(self)




    def periodevergelijkingElementair(self):

        localctx = RegelSpraakParser.PeriodevergelijkingElementairContext(self, self._ctx, self.state)
        self.enterRule(localctx, 284, self.RULE_periodevergelijkingElementair)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1889
            self.match(RegelSpraakParser.HET_IS_DE_PERIODE)
            self.state = 1890
            self.periodevergelijkingEnkelvoudig()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PeriodevergelijkingEnkelvoudigContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def VANAF(self):
            return self.getToken(RegelSpraakParser.VANAF, 0)

        def datumExpressie(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.DatumExpressieContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.DatumExpressieContext,i)


        def VAN(self):
            return self.getToken(RegelSpraakParser.VAN, 0)

        def TOT(self):
            return self.getToken(RegelSpraakParser.TOT, 0)

        def TOT_EN_MET(self):
            return self.getToken(RegelSpraakParser.TOT_EN_MET, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_periodevergelijkingEnkelvoudig

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPeriodevergelijkingEnkelvoudig" ):
                listener.enterPeriodevergelijkingEnkelvoudig(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPeriodevergelijkingEnkelvoudig" ):
                listener.exitPeriodevergelijkingEnkelvoudig(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPeriodevergelijkingEnkelvoudig" ):
                return visitor.visitPeriodevergelijkingEnkelvoudig(self)
            else:
                return visitor.visitChildren(self)




    def periodevergelijkingEnkelvoudig(self):

        localctx = RegelSpraakParser.PeriodevergelijkingEnkelvoudigContext(self, self._ctx, self.state)
        self.enterRule(localctx, 286, self.RULE_periodevergelijkingEnkelvoudig)
        try:
            self.state = 1908
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,216,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1892
                self.match(RegelSpraakParser.VANAF)
                self.state = 1893
                self.datumExpressie()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1894
                self.match(RegelSpraakParser.VAN)
                self.state = 1895
                self.datumExpressie()
                self.state = 1896
                self.match(RegelSpraakParser.TOT)
                self.state = 1897
                self.datumExpressie()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1899
                self.match(RegelSpraakParser.VAN)
                self.state = 1900
                self.datumExpressie()
                self.state = 1901
                self.match(RegelSpraakParser.TOT_EN_MET)
                self.state = 1902
                self.datumExpressie()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 1904
                self.match(RegelSpraakParser.TOT)
                self.state = 1905
                self.datumExpressie()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 1906
                self.match(RegelSpraakParser.TOT_EN_MET)
                self.state = 1907
                self.datumExpressie()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PeriodeDefinitieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_periodeDefinitie

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class VanafPeriodeContext(PeriodeDefinitieContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PeriodeDefinitieContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def VANAF(self):
            return self.getToken(RegelSpraakParser.VANAF, 0)
        def dateExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.DateExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVanafPeriode" ):
                listener.enterVanafPeriode(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVanafPeriode" ):
                listener.exitVanafPeriode(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVanafPeriode" ):
                return visitor.visitVanafPeriode(self)
            else:
                return visitor.visitChildren(self)


    class VanTotPeriodeContext(PeriodeDefinitieContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PeriodeDefinitieContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def VAN(self):
            return self.getToken(RegelSpraakParser.VAN, 0)
        def dateExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.DateExpressionContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.DateExpressionContext,i)

        def TOT(self):
            return self.getToken(RegelSpraakParser.TOT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVanTotPeriode" ):
                listener.enterVanTotPeriode(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVanTotPeriode" ):
                listener.exitVanTotPeriode(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVanTotPeriode" ):
                return visitor.visitVanTotPeriode(self)
            else:
                return visitor.visitChildren(self)


    class VanTotEnMetPeriodeContext(PeriodeDefinitieContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PeriodeDefinitieContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def VAN(self):
            return self.getToken(RegelSpraakParser.VAN, 0)
        def dateExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.DateExpressionContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.DateExpressionContext,i)

        def TOT_EN_MET(self):
            return self.getToken(RegelSpraakParser.TOT_EN_MET, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVanTotEnMetPeriode" ):
                listener.enterVanTotEnMetPeriode(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVanTotEnMetPeriode" ):
                listener.exitVanTotEnMetPeriode(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVanTotEnMetPeriode" ):
                return visitor.visitVanTotEnMetPeriode(self)
            else:
                return visitor.visitChildren(self)


    class TotPeriodeContext(PeriodeDefinitieContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PeriodeDefinitieContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def TOT(self):
            return self.getToken(RegelSpraakParser.TOT, 0)
        def dateExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.DateExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTotPeriode" ):
                listener.enterTotPeriode(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTotPeriode" ):
                listener.exitTotPeriode(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTotPeriode" ):
                return visitor.visitTotPeriode(self)
            else:
                return visitor.visitChildren(self)


    class TotEnMetPeriodeContext(PeriodeDefinitieContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PeriodeDefinitieContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def TOT_EN_MET(self):
            return self.getToken(RegelSpraakParser.TOT_EN_MET, 0)
        def dateExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.DateExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTotEnMetPeriode" ):
                listener.enterTotEnMetPeriode(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTotEnMetPeriode" ):
                listener.exitTotEnMetPeriode(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTotEnMetPeriode" ):
                return visitor.visitTotEnMetPeriode(self)
            else:
                return visitor.visitChildren(self)



    def periodeDefinitie(self):

        localctx = RegelSpraakParser.PeriodeDefinitieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 288, self.RULE_periodeDefinitie)
        try:
            self.state = 1926
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,217,self._ctx)
            if la_ == 1:
                localctx = RegelSpraakParser.VanafPeriodeContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1910
                self.match(RegelSpraakParser.VANAF)
                self.state = 1911
                self.dateExpression()
                pass

            elif la_ == 2:
                localctx = RegelSpraakParser.TotPeriodeContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1912
                self.match(RegelSpraakParser.TOT)
                self.state = 1913
                self.dateExpression()
                pass

            elif la_ == 3:
                localctx = RegelSpraakParser.TotEnMetPeriodeContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 1914
                self.match(RegelSpraakParser.TOT_EN_MET)
                self.state = 1915
                self.dateExpression()
                pass

            elif la_ == 4:
                localctx = RegelSpraakParser.VanTotPeriodeContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 1916
                self.match(RegelSpraakParser.VAN)
                self.state = 1917
                self.dateExpression()
                self.state = 1918
                self.match(RegelSpraakParser.TOT)
                self.state = 1919
                self.dateExpression()
                pass

            elif la_ == 5:
                localctx = RegelSpraakParser.VanTotEnMetPeriodeContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 1921
                self.match(RegelSpraakParser.VAN)
                self.state = 1922
                self.dateExpression()
                self.state = 1923
                self.match(RegelSpraakParser.TOT_EN_MET)
                self.state = 1924
                self.dateExpression()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DateExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def datumLiteral(self):
            return self.getTypedRuleContext(RegelSpraakParser.DatumLiteralContext,0)


        def REKENDATUM(self):
            return self.getToken(RegelSpraakParser.REKENDATUM, 0)

        def REKENJAAR(self):
            return self.getToken(RegelSpraakParser.REKENJAAR, 0)

        def attribuutReferentie(self):
            return self.getTypedRuleContext(RegelSpraakParser.AttribuutReferentieContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_dateExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDateExpression" ):
                listener.enterDateExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDateExpression" ):
                listener.exitDateExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDateExpression" ):
                return visitor.visitDateExpression(self)
            else:
                return visitor.visitChildren(self)




    def dateExpression(self):

        localctx = RegelSpraakParser.DateExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 290, self.RULE_dateExpression)
        try:
            self.state = 1932
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [266]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1928
                self.datumLiteral()
                pass
            elif token in [231]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1929
                self.match(RegelSpraakParser.REKENDATUM)
                pass
            elif token in [232]:
                self.enterOuterAlt(localctx, 3)
                self.state = 1930
                self.match(RegelSpraakParser.REKENJAAR)
                pass
            elif token in [45, 96, 110, 117, 120, 128, 136, 157, 186, 197, 198, 201, 202, 205, 206, 208, 211, 213, 217, 219, 220, 228, 230, 249, 263]:
                self.enterOuterAlt(localctx, 4)
                self.state = 1931
                self.attribuutReferentie()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GetalAggregatieFunctieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def HET(self):
            return self.getToken(RegelSpraakParser.HET, 0)

        def AANTAL(self):
            return self.getToken(RegelSpraakParser.AANTAL, 0)

        def DE_MAXIMALE_WAARDE_VAN(self):
            return self.getToken(RegelSpraakParser.DE_MAXIMALE_WAARDE_VAN, 0)

        def DE_MINIMALE_WAARDE_VAN(self):
            return self.getToken(RegelSpraakParser.DE_MINIMALE_WAARDE_VAN, 0)

        def SOM_VAN(self):
            return self.getToken(RegelSpraakParser.SOM_VAN, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_getalAggregatieFunctie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGetalAggregatieFunctie" ):
                listener.enterGetalAggregatieFunctie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGetalAggregatieFunctie" ):
                listener.exitGetalAggregatieFunctie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGetalAggregatieFunctie" ):
                return visitor.visitGetalAggregatieFunctie(self)
            else:
                return visitor.visitChildren(self)




    def getalAggregatieFunctie(self):

        localctx = RegelSpraakParser.GetalAggregatieFunctieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 292, self.RULE_getalAggregatieFunctie)
        try:
            self.state = 1940
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [213]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1934
                self.match(RegelSpraakParser.HET)
                self.state = 1935
                self.match(RegelSpraakParser.AANTAL)
                pass
            elif token in [186]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1936
                self.match(RegelSpraakParser.AANTAL)
                pass
            elif token in [13]:
                self.enterOuterAlt(localctx, 3)
                self.state = 1937
                self.match(RegelSpraakParser.DE_MAXIMALE_WAARDE_VAN)
                pass
            elif token in [14]:
                self.enterOuterAlt(localctx, 4)
                self.state = 1938
                self.match(RegelSpraakParser.DE_MINIMALE_WAARDE_VAN)
                pass
            elif token in [191]:
                self.enterOuterAlt(localctx, 5)
                self.state = 1939
                self.match(RegelSpraakParser.SOM_VAN)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DatumAggregatieFunctieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EERSTE_VAN(self):
            return self.getToken(RegelSpraakParser.EERSTE_VAN, 0)

        def LAATSTE_VAN(self):
            return self.getToken(RegelSpraakParser.LAATSTE_VAN, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_datumAggregatieFunctie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDatumAggregatieFunctie" ):
                listener.enterDatumAggregatieFunctie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDatumAggregatieFunctie" ):
                listener.exitDatumAggregatieFunctie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDatumAggregatieFunctie" ):
                return visitor.visitDatumAggregatieFunctie(self)
            else:
                return visitor.visitChildren(self)




    def datumAggregatieFunctie(self):

        localctx = RegelSpraakParser.DatumAggregatieFunctieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 294, self.RULE_datumAggregatieFunctie)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1942
            _la = self._input.LA(1)
            if not(_la==187 or _la==189):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DimensieSelectieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OVER(self):
            return self.getToken(RegelSpraakParser.OVER, 0)

        def DOT(self):
            return self.getToken(RegelSpraakParser.DOT, 0)

        def aggregerenOverAlleDimensies(self):
            return self.getTypedRuleContext(RegelSpraakParser.AggregerenOverAlleDimensiesContext,0)


        def aggregerenOverVerzameling(self):
            return self.getTypedRuleContext(RegelSpraakParser.AggregerenOverVerzamelingContext,0)


        def aggregerenOverBereik(self):
            return self.getTypedRuleContext(RegelSpraakParser.AggregerenOverBereikContext,0)


        def VAN(self):
            return self.getToken(RegelSpraakParser.VAN, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_dimensieSelectie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDimensieSelectie" ):
                listener.enterDimensieSelectie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDimensieSelectie" ):
                listener.exitDimensieSelectie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDimensieSelectie" ):
                return visitor.visitDimensieSelectie(self)
            else:
                return visitor.visitChildren(self)




    def dimensieSelectie(self):

        localctx = RegelSpraakParser.DimensieSelectieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 296, self.RULE_dimensieSelectie)
        try:
            self.state = 1954
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [229]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1944
                self.match(RegelSpraakParser.OVER)
                self.state = 1948
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,220,self._ctx)
                if la_ == 1:
                    self.state = 1945
                    self.aggregerenOverAlleDimensies()
                    pass

                elif la_ == 2:
                    self.state = 1946
                    self.aggregerenOverVerzameling()
                    pass

                elif la_ == 3:
                    self.state = 1947
                    self.aggregerenOverBereik()
                    pass


                self.state = 1950
                self.match(RegelSpraakParser.DOT)
                pass
            elif token in [240]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1952
                self.match(RegelSpraakParser.VAN)
                self.state = 1953
                self.aggregerenOverAlleDimensies()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AggregerenOverAlleDimensiesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ALLE(self):
            return self.getToken(RegelSpraakParser.ALLE, 0)

        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def predicaat(self):
            return self.getTypedRuleContext(RegelSpraakParser.PredicaatContext,0)


        def DIE(self):
            return self.getToken(RegelSpraakParser.DIE, 0)

        def DAT(self):
            return self.getToken(RegelSpraakParser.DAT, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_aggregerenOverAlleDimensies

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAggregerenOverAlleDimensies" ):
                listener.enterAggregerenOverAlleDimensies(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAggregerenOverAlleDimensies" ):
                listener.exitAggregerenOverAlleDimensies(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAggregerenOverAlleDimensies" ):
                return visitor.visitAggregerenOverAlleDimensies(self)
            else:
                return visitor.visitChildren(self)




    def aggregerenOverAlleDimensies(self):

        localctx = RegelSpraakParser.AggregerenOverAlleDimensiesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 298, self.RULE_aggregerenOverAlleDimensies)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1956
            self.match(RegelSpraakParser.ALLE)
            self.state = 1957
            self.naamwoord()
            self.state = 1960
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,222,self._ctx)
            if la_ == 1:
                self.state = 1958
                _la = self._input.LA(1)
                if not(_la==207 or _la==210):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1959
                self.predicaat()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AggregerenOverVerzamelingContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DE(self):
            return self.getToken(RegelSpraakParser.DE, 0)

        def naamwoord(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.NaamwoordContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,i)


        def VANAF(self):
            return self.getToken(RegelSpraakParser.VANAF, 0)

        def TM(self):
            return self.getToken(RegelSpraakParser.TM, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_aggregerenOverVerzameling

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAggregerenOverVerzameling" ):
                listener.enterAggregerenOverVerzameling(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAggregerenOverVerzameling" ):
                listener.exitAggregerenOverVerzameling(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAggregerenOverVerzameling" ):
                return visitor.visitAggregerenOverVerzameling(self)
            else:
                return visitor.visitChildren(self)




    def aggregerenOverVerzameling(self):

        localctx = RegelSpraakParser.AggregerenOverVerzamelingContext(self, self._ctx, self.state)
        self.enterRule(localctx, 300, self.RULE_aggregerenOverVerzameling)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1962
            self.match(RegelSpraakParser.DE)
            self.state = 1963
            self.naamwoord()
            self.state = 1964
            self.match(RegelSpraakParser.VANAF)
            self.state = 1965
            self.naamwoord()
            self.state = 1966
            self.match(RegelSpraakParser.TM)
            self.state = 1967
            self.naamwoord()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AggregerenOverBereikContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DE(self):
            return self.getToken(RegelSpraakParser.DE, 0)

        def naamwoord(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.NaamwoordContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,i)


        def IN(self):
            return self.getToken(RegelSpraakParser.IN, 0)

        def LBRACE(self):
            return self.getToken(RegelSpraakParser.LBRACE, 0)

        def EN(self):
            return self.getToken(RegelSpraakParser.EN, 0)

        def RBRACE(self):
            return self.getToken(RegelSpraakParser.RBRACE, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.COMMA)
            else:
                return self.getToken(RegelSpraakParser.COMMA, i)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_aggregerenOverBereik

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAggregerenOverBereik" ):
                listener.enterAggregerenOverBereik(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAggregerenOverBereik" ):
                listener.exitAggregerenOverBereik(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAggregerenOverBereik" ):
                return visitor.visitAggregerenOverBereik(self)
            else:
                return visitor.visitChildren(self)




    def aggregerenOverBereik(self):

        localctx = RegelSpraakParser.AggregerenOverBereikContext(self, self._ctx, self.state)
        self.enterRule(localctx, 302, self.RULE_aggregerenOverBereik)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1969
            self.match(RegelSpraakParser.DE)
            self.state = 1970
            self.naamwoord()
            self.state = 1971
            self.match(RegelSpraakParser.IN)
            self.state = 1972
            self.match(RegelSpraakParser.LBRACE)
            self.state = 1973
            self.naamwoord()
            self.state = 1978
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==274:
                self.state = 1974
                self.match(RegelSpraakParser.COMMA)
                self.state = 1975
                self.naamwoord()
                self.state = 1980
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1981
            self.match(RegelSpraakParser.EN)
            self.state = 1982
            self.naamwoord()
            self.state = 1983
            self.match(RegelSpraakParser.RBRACE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UnaryConditionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_unaryCondition

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class UnaryCheckConditionContext(UnaryConditionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.UnaryConditionContext
            super().__init__(parser)
            self.expr = None # PrimaryExpressionContext
            self.op = None # Token
            self.copyFrom(ctx)

        def primaryExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,0)

        def IS_LEEG(self):
            return self.getToken(RegelSpraakParser.IS_LEEG, 0)
        def IS_GEVULD(self):
            return self.getToken(RegelSpraakParser.IS_GEVULD, 0)
        def VOLDOET_AAN_DE_ELFPROEF(self):
            return self.getToken(RegelSpraakParser.VOLDOET_AAN_DE_ELFPROEF, 0)
        def VOLDOET_NIET_AAN_DE_ELFPROEF(self):
            return self.getToken(RegelSpraakParser.VOLDOET_NIET_AAN_DE_ELFPROEF, 0)
        def ZIJN_LEEG(self):
            return self.getToken(RegelSpraakParser.ZIJN_LEEG, 0)
        def ZIJN_GEVULD(self):
            return self.getToken(RegelSpraakParser.ZIJN_GEVULD, 0)
        def VOLDOEN_AAN_DE_ELFPROEF(self):
            return self.getToken(RegelSpraakParser.VOLDOEN_AAN_DE_ELFPROEF, 0)
        def VOLDOEN_NIET_AAN_DE_ELFPROEF(self):
            return self.getToken(RegelSpraakParser.VOLDOEN_NIET_AAN_DE_ELFPROEF, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnaryCheckCondition" ):
                listener.enterUnaryCheckCondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnaryCheckCondition" ):
                listener.exitUnaryCheckCondition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnaryCheckCondition" ):
                return visitor.visitUnaryCheckCondition(self)
            else:
                return visitor.visitChildren(self)


    class UnaryKenmerkConditionContext(UnaryConditionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.UnaryConditionContext
            super().__init__(parser)
            self.expr = None # PrimaryExpressionContext
            self.op = None # Token
            self.kenmerk = None # IdentifierContext
            self.copyFrom(ctx)

        def primaryExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,0)

        def identifier(self):
            return self.getTypedRuleContext(RegelSpraakParser.IdentifierContext,0)

        def IS_KENMERK(self):
            return self.getToken(RegelSpraakParser.IS_KENMERK, 0)
        def ZIJN_KENMERK(self):
            return self.getToken(RegelSpraakParser.ZIJN_KENMERK, 0)
        def IS_NIET_KENMERK(self):
            return self.getToken(RegelSpraakParser.IS_NIET_KENMERK, 0)
        def ZIJN_NIET_KENMERK(self):
            return self.getToken(RegelSpraakParser.ZIJN_NIET_KENMERK, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnaryKenmerkCondition" ):
                listener.enterUnaryKenmerkCondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnaryKenmerkCondition" ):
                listener.exitUnaryKenmerkCondition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnaryKenmerkCondition" ):
                return visitor.visitUnaryKenmerkCondition(self)
            else:
                return visitor.visitChildren(self)


    class UnaryNumeriekExactConditionContext(UnaryConditionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.UnaryConditionContext
            super().__init__(parser)
            self.expr = None # PrimaryExpressionContext
            self.op = None # Token
            self.copyFrom(ctx)

        def NUMBER(self):
            return self.getToken(RegelSpraakParser.NUMBER, 0)
        def CIJFERS(self):
            return self.getToken(RegelSpraakParser.CIJFERS, 0)
        def primaryExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,0)

        def IS_NUMERIEK_MET_EXACT(self):
            return self.getToken(RegelSpraakParser.IS_NUMERIEK_MET_EXACT, 0)
        def IS_NIET_NUMERIEK_MET_EXACT(self):
            return self.getToken(RegelSpraakParser.IS_NIET_NUMERIEK_MET_EXACT, 0)
        def ZIJN_NUMERIEK_MET_EXACT(self):
            return self.getToken(RegelSpraakParser.ZIJN_NUMERIEK_MET_EXACT, 0)
        def ZIJN_NIET_NUMERIEK_MET_EXACT(self):
            return self.getToken(RegelSpraakParser.ZIJN_NIET_NUMERIEK_MET_EXACT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnaryNumeriekExactCondition" ):
                listener.enterUnaryNumeriekExactCondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnaryNumeriekExactCondition" ):
                listener.exitUnaryNumeriekExactCondition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnaryNumeriekExactCondition" ):
                return visitor.visitUnaryNumeriekExactCondition(self)
            else:
                return visitor.visitChildren(self)


    class UnaryRolConditionContext(UnaryConditionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.UnaryConditionContext
            super().__init__(parser)
            self.expr = None # PrimaryExpressionContext
            self.op = None # Token
            self.rol = None # IdentifierContext
            self.copyFrom(ctx)

        def primaryExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,0)

        def identifier(self):
            return self.getTypedRuleContext(RegelSpraakParser.IdentifierContext,0)

        def IS_ROL(self):
            return self.getToken(RegelSpraakParser.IS_ROL, 0)
        def ZIJN_ROL(self):
            return self.getToken(RegelSpraakParser.ZIJN_ROL, 0)
        def IS_NIET_ROL(self):
            return self.getToken(RegelSpraakParser.IS_NIET_ROL, 0)
        def ZIJN_NIET_ROL(self):
            return self.getToken(RegelSpraakParser.ZIJN_NIET_ROL, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnaryRolCondition" ):
                listener.enterUnaryRolCondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnaryRolCondition" ):
                listener.exitUnaryRolCondition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnaryRolCondition" ):
                return visitor.visitUnaryRolCondition(self)
            else:
                return visitor.visitChildren(self)


    class UnaryDagsoortConditionContext(UnaryConditionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.UnaryConditionContext
            super().__init__(parser)
            self.expr = None # PrimaryExpressionContext
            self.op = None # Token
            self.dagsoort = None # IdentifierContext
            self.copyFrom(ctx)

        def primaryExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,0)

        def identifier(self):
            return self.getTypedRuleContext(RegelSpraakParser.IdentifierContext,0)

        def IS_EEN_DAGSOORT(self):
            return self.getToken(RegelSpraakParser.IS_EEN_DAGSOORT, 0)
        def ZIJN_EEN_DAGSOORT(self):
            return self.getToken(RegelSpraakParser.ZIJN_EEN_DAGSOORT, 0)
        def IS_GEEN_DAGSOORT(self):
            return self.getToken(RegelSpraakParser.IS_GEEN_DAGSOORT, 0)
        def ZIJN_GEEN_DAGSOORT(self):
            return self.getToken(RegelSpraakParser.ZIJN_GEEN_DAGSOORT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnaryDagsoortCondition" ):
                listener.enterUnaryDagsoortCondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnaryDagsoortCondition" ):
                listener.exitUnaryDagsoortCondition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnaryDagsoortCondition" ):
                return visitor.visitUnaryDagsoortCondition(self)
            else:
                return visitor.visitChildren(self)


    class UnaryInconsistentDataConditionContext(UnaryConditionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.UnaryConditionContext
            super().__init__(parser)
            self.expr = None # PrimaryExpressionContext
            self.copyFrom(ctx)

        def IS_INCONSISTENT(self):
            return self.getToken(RegelSpraakParser.IS_INCONSISTENT, 0)
        def primaryExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnaryInconsistentDataCondition" ):
                listener.enterUnaryInconsistentDataCondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnaryInconsistentDataCondition" ):
                listener.exitUnaryInconsistentDataCondition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnaryInconsistentDataCondition" ):
                return visitor.visitUnaryInconsistentDataCondition(self)
            else:
                return visitor.visitChildren(self)


    class UnaryUniekConditionContext(UnaryConditionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.UnaryConditionContext
            super().__init__(parser)
            self.ref = None # OnderwerpReferentieContext
            self.copyFrom(ctx)

        def MOETEN_UNIEK_ZIJN(self):
            return self.getToken(RegelSpraakParser.MOETEN_UNIEK_ZIJN, 0)
        def onderwerpReferentie(self):
            return self.getTypedRuleContext(RegelSpraakParser.OnderwerpReferentieContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnaryUniekCondition" ):
                listener.enterUnaryUniekCondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnaryUniekCondition" ):
                listener.exitUnaryUniekCondition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnaryUniekCondition" ):
                return visitor.visitUnaryUniekCondition(self)
            else:
                return visitor.visitChildren(self)



    def unaryCondition(self):

        localctx = RegelSpraakParser.UnaryConditionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 304, self.RULE_unaryCondition)
        self._la = 0 # Token type
        try:
            self.state = 2011
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,224,self._ctx)
            if la_ == 1:
                localctx = RegelSpraakParser.UnaryCheckConditionContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1985
                localctx.expr = self.primaryExpression(0)
                self.state = 1986
                localctx.op = self._input.LT(1)
                _la = self._input.LA(1)
                if not(((((_la - 68)) & ~0x3f) == 0 and ((1 << (_la - 68)) & 61455) != 0)):
                    localctx.op = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass

            elif la_ == 2:
                localctx = RegelSpraakParser.UnaryNumeriekExactConditionContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1988
                localctx.expr = self.primaryExpression(0)
                self.state = 1989
                localctx.op = self._input.LT(1)
                _la = self._input.LA(1)
                if not(((((_la - 84)) & ~0x3f) == 0 and ((1 << (_la - 84)) & 15) != 0)):
                    localctx.op = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1990
                self.match(RegelSpraakParser.NUMBER)
                self.state = 1991
                self.match(RegelSpraakParser.CIJFERS)
                pass

            elif la_ == 3:
                localctx = RegelSpraakParser.UnaryDagsoortConditionContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 1993
                localctx.expr = self.primaryExpression(0)
                self.state = 1994
                localctx.op = self._input.LT(1)
                _la = self._input.LA(1)
                if not(((((_la - 88)) & ~0x3f) == 0 and ((1 << (_la - 88)) & 15) != 0)):
                    localctx.op = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1995
                localctx.dagsoort = self.identifier()
                pass

            elif la_ == 4:
                localctx = RegelSpraakParser.UnaryKenmerkConditionContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 1997
                localctx.expr = self.primaryExpression(0)
                self.state = 1998
                localctx.op = self._input.LT(1)
                _la = self._input.LA(1)
                if not(((((_la - 72)) & ~0x3f) == 0 and ((1 << (_la - 72)) & 85) != 0)):
                    localctx.op = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1999
                localctx.kenmerk = self.identifier()
                pass

            elif la_ == 5:
                localctx = RegelSpraakParser.UnaryRolConditionContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 2001
                localctx.expr = self.primaryExpression(0)
                self.state = 2002
                localctx.op = self._input.LT(1)
                _la = self._input.LA(1)
                if not(((((_la - 73)) & ~0x3f) == 0 and ((1 << (_la - 73)) & 85) != 0)):
                    localctx.op = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 2003
                localctx.rol = self.identifier()
                pass

            elif la_ == 6:
                localctx = RegelSpraakParser.UnaryUniekConditionContext(self, localctx)
                self.enterOuterAlt(localctx, 6)
                self.state = 2005
                localctx.ref = self.onderwerpReferentie()
                self.state = 2006
                self.match(RegelSpraakParser.MOETEN_UNIEK_ZIJN)
                pass

            elif la_ == 7:
                localctx = RegelSpraakParser.UnaryInconsistentDataConditionContext(self, localctx)
                self.enterOuterAlt(localctx, 7)
                self.state = 2008
                localctx.expr = self.primaryExpression(0)
                self.state = 2009
                self.match(RegelSpraakParser.IS_INCONSISTENT)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RegelStatusConditionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_regelStatusCondition

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class RegelStatusInconsistentCheckContext(RegelStatusConditionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.RegelStatusConditionContext
            super().__init__(parser)
            self.name = None # NaamwoordContext
            self.copyFrom(ctx)

        def REGELVERSIE(self):
            return self.getToken(RegelSpraakParser.REGELVERSIE, 0)
        def IS_INCONSISTENT(self):
            return self.getToken(RegelSpraakParser.IS_INCONSISTENT, 0)
        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRegelStatusInconsistentCheck" ):
                listener.enterRegelStatusInconsistentCheck(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRegelStatusInconsistentCheck" ):
                listener.exitRegelStatusInconsistentCheck(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRegelStatusInconsistentCheck" ):
                return visitor.visitRegelStatusInconsistentCheck(self)
            else:
                return visitor.visitChildren(self)


    class RegelStatusGevuurdCheckContext(RegelStatusConditionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.RegelStatusConditionContext
            super().__init__(parser)
            self.name = None # NaamwoordContext
            self.copyFrom(ctx)

        def REGELVERSIE(self):
            return self.getToken(RegelSpraakParser.REGELVERSIE, 0)
        def IS_GEVUURD(self):
            return self.getToken(RegelSpraakParser.IS_GEVUURD, 0)
        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRegelStatusGevuurdCheck" ):
                listener.enterRegelStatusGevuurdCheck(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRegelStatusGevuurdCheck" ):
                listener.exitRegelStatusGevuurdCheck(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRegelStatusGevuurdCheck" ):
                return visitor.visitRegelStatusGevuurdCheck(self)
            else:
                return visitor.visitChildren(self)



    def regelStatusCondition(self):

        localctx = RegelSpraakParser.RegelStatusConditionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 306, self.RULE_regelStatusCondition)
        try:
            self.state = 2021
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,225,self._ctx)
            if la_ == 1:
                localctx = RegelSpraakParser.RegelStatusGevuurdCheckContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 2013
                self.match(RegelSpraakParser.REGELVERSIE)
                self.state = 2014
                localctx.name = self.naamwoord()
                self.state = 2015
                self.match(RegelSpraakParser.IS_GEVUURD)
                pass

            elif la_ == 2:
                localctx = RegelSpraakParser.RegelStatusInconsistentCheckContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 2017
                self.match(RegelSpraakParser.REGELVERSIE)
                self.state = 2018
                localctx.name = self.naamwoord()
                self.state = 2019
                self.match(RegelSpraakParser.IS_INCONSISTENT)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SubordinateClauseExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_subordinateClauseExpression

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class SubordinateIsWithExprContext(SubordinateClauseExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.SubordinateClauseExpressionContext
            super().__init__(parser)
            self.subject = None # OnderwerpReferentieContext
            self.prepPhrase = None # NaamwoordWithNumbersContext
            self.verb = None # Token
            self.copyFrom(ctx)

        def onderwerpReferentie(self):
            return self.getTypedRuleContext(RegelSpraakParser.OnderwerpReferentieContext,0)

        def naamwoordWithNumbers(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordWithNumbersContext,0)

        def IS(self):
            return self.getToken(RegelSpraakParser.IS, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSubordinateIsWithExpr" ):
                listener.enterSubordinateIsWithExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSubordinateIsWithExpr" ):
                listener.exitSubordinateIsWithExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSubordinateIsWithExpr" ):
                return visitor.visitSubordinateIsWithExpr(self)
            else:
                return visitor.visitChildren(self)


    class SubordinateHasExprContext(SubordinateClauseExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.SubordinateClauseExpressionContext
            super().__init__(parser)
            self.subject = None # OnderwerpReferentieContext
            self.object_ = None # NaamwoordWithNumbersContext
            self.verb = None # Token
            self.copyFrom(ctx)

        def onderwerpReferentie(self):
            return self.getTypedRuleContext(RegelSpraakParser.OnderwerpReferentieContext,0)

        def naamwoordWithNumbers(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordWithNumbersContext,0)

        def HEEFT(self):
            return self.getToken(RegelSpraakParser.HEEFT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSubordinateHasExpr" ):
                listener.enterSubordinateHasExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSubordinateHasExpr" ):
                listener.exitSubordinateHasExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSubordinateHasExpr" ):
                return visitor.visitSubordinateHasExpr(self)
            else:
                return visitor.visitChildren(self)


    class SubordinateIsKenmerkExprContext(SubordinateClauseExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.SubordinateClauseExpressionContext
            super().__init__(parser)
            self.subject = None # OnderwerpReferentieContext
            self.verb = None # Token
            self.kenmerk = None # NaamwoordWithNumbersContext
            self.copyFrom(ctx)

        def onderwerpReferentie(self):
            return self.getTypedRuleContext(RegelSpraakParser.OnderwerpReferentieContext,0)

        def IS(self):
            return self.getToken(RegelSpraakParser.IS, 0)
        def naamwoordWithNumbers(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordWithNumbersContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSubordinateIsKenmerkExpr" ):
                listener.enterSubordinateIsKenmerkExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSubordinateIsKenmerkExpr" ):
                listener.exitSubordinateIsKenmerkExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSubordinateIsKenmerkExpr" ):
                return visitor.visitSubordinateIsKenmerkExpr(self)
            else:
                return visitor.visitChildren(self)



    def subordinateClauseExpression(self):

        localctx = RegelSpraakParser.SubordinateClauseExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 308, self.RULE_subordinateClauseExpression)
        try:
            self.state = 2035
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,226,self._ctx)
            if la_ == 1:
                localctx = RegelSpraakParser.SubordinateHasExprContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 2023
                localctx.subject = self.onderwerpReferentie()
                self.state = 2024
                localctx.object_ = self.naamwoordWithNumbers()
                self.state = 2025
                localctx.verb = self.match(RegelSpraakParser.HEEFT)
                pass

            elif la_ == 2:
                localctx = RegelSpraakParser.SubordinateIsWithExprContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 2027
                localctx.subject = self.onderwerpReferentie()
                self.state = 2028
                localctx.prepPhrase = self.naamwoordWithNumbers()
                self.state = 2029
                localctx.verb = self.match(RegelSpraakParser.IS)
                pass

            elif la_ == 3:
                localctx = RegelSpraakParser.SubordinateIsKenmerkExprContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 2031
                localctx.subject = self.onderwerpReferentie()
                self.state = 2032
                localctx.verb = self.match(RegelSpraakParser.IS)
                self.state = 2033
                localctx.kenmerk = self.naamwoordWithNumbers()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DagsoortDefinitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self._IDENTIFIER = None # Token
            self.plural = list() # of Tokens

        def DAGSOORT(self):
            return self.getToken(RegelSpraakParser.DAGSOORT, 0)

        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def MV_START(self):
            return self.getToken(RegelSpraakParser.MV_START, 0)

        def RPAREN(self):
            return self.getToken(RegelSpraakParser.RPAREN, 0)

        def SEMICOLON(self):
            return self.getToken(RegelSpraakParser.SEMICOLON, 0)

        def IDENTIFIER(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.IDENTIFIER)
            else:
                return self.getToken(RegelSpraakParser.IDENTIFIER, i)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_dagsoortDefinition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDagsoortDefinition" ):
                listener.enterDagsoortDefinition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDagsoortDefinition" ):
                listener.exitDagsoortDefinition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDagsoortDefinition" ):
                return visitor.visitDagsoortDefinition(self)
            else:
                return visitor.visitChildren(self)




    def dagsoortDefinition(self):

        localctx = RegelSpraakParser.DagsoortDefinitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 310, self.RULE_dagsoortDefinition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2037
            self.match(RegelSpraakParser.DAGSOORT)
            self.state = 2038
            self.naamwoord()
            self.state = 2046
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==174:
                self.state = 2039
                self.match(RegelSpraakParser.MV_START)
                self.state = 2041 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 2040
                    localctx._IDENTIFIER = self.match(RegelSpraakParser.IDENTIFIER)
                    localctx.plural.append(localctx._IDENTIFIER)
                    self.state = 2043 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==263):
                        break

                self.state = 2045
                self.match(RegelSpraakParser.RPAREN)


            self.state = 2049
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==277:
                self.state = 2048
                self.match(RegelSpraakParser.SEMICOLON)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TekstreeksExprContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STRING_LITERAL(self):
            return self.getToken(RegelSpraakParser.STRING_LITERAL, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_tekstreeksExpr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTekstreeksExpr" ):
                listener.enterTekstreeksExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTekstreeksExpr" ):
                listener.exitTekstreeksExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTekstreeksExpr" ):
                return visitor.visitTekstreeksExpr(self)
            else:
                return visitor.visitChildren(self)




    def tekstreeksExpr(self):

        localctx = RegelSpraakParser.TekstreeksExprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 312, self.RULE_tekstreeksExpr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2051
            self.match(RegelSpraakParser.STRING_LITERAL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VerdelingResultaatContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.sourceAmount = None # ExpressieContext
            self.targetCollection = None # ExpressieContext

        def WORDT_VERDEELD_OVER(self):
            return self.getToken(RegelSpraakParser.WORDT_VERDEELD_OVER, 0)

        def COMMA(self):
            return self.getToken(RegelSpraakParser.COMMA, 0)

        def WAARBIJ_WORDT_VERDEELD(self):
            return self.getToken(RegelSpraakParser.WAARBIJ_WORDT_VERDEELD, 0)

        def expressie(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.ExpressieContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,i)


        def verdelingMethodeSimple(self):
            return self.getTypedRuleContext(RegelSpraakParser.VerdelingMethodeSimpleContext,0)


        def verdelingMethodeMultiLine(self):
            return self.getTypedRuleContext(RegelSpraakParser.VerdelingMethodeMultiLineContext,0)


        def verdelingRest(self):
            return self.getTypedRuleContext(RegelSpraakParser.VerdelingRestContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_verdelingResultaat

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVerdelingResultaat" ):
                listener.enterVerdelingResultaat(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVerdelingResultaat" ):
                listener.exitVerdelingResultaat(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVerdelingResultaat" ):
                return visitor.visitVerdelingResultaat(self)
            else:
                return visitor.visitChildren(self)




    def verdelingResultaat(self):

        localctx = RegelSpraakParser.VerdelingResultaatContext(self, self._ctx, self.state)
        self.enterRule(localctx, 314, self.RULE_verdelingResultaat)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2053
            localctx.sourceAmount = self.expressie()
            self.state = 2054
            self.match(RegelSpraakParser.WORDT_VERDEELD_OVER)
            self.state = 2055
            localctx.targetCollection = self.expressie()
            self.state = 2056
            self.match(RegelSpraakParser.COMMA)
            self.state = 2057
            self.match(RegelSpraakParser.WAARBIJ_WORDT_VERDEELD)
            self.state = 2060
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [21, 33, 34, 35, 119, 194]:
                self.state = 2058
                self.verdelingMethodeSimple()
                pass
            elif token in [276]:
                self.state = 2059
                self.verdelingMethodeMultiLine()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 2063
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==19:
                self.state = 2062
                self.verdelingRest()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VerdelingMethodeSimpleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def verdelingMethode(self):
            return self.getTypedRuleContext(RegelSpraakParser.VerdelingMethodeContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_verdelingMethodeSimple

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVerdelingMethodeSimple" ):
                listener.enterVerdelingMethodeSimple(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVerdelingMethodeSimple" ):
                listener.exitVerdelingMethodeSimple(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVerdelingMethodeSimple" ):
                return visitor.visitVerdelingMethodeSimple(self)
            else:
                return visitor.visitChildren(self)




    def verdelingMethodeSimple(self):

        localctx = RegelSpraakParser.VerdelingMethodeSimpleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 316, self.RULE_verdelingMethodeSimple)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2065
            self.verdelingMethode()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VerdelingMethodeMultiLineContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def COLON(self):
            return self.getToken(RegelSpraakParser.COLON, 0)

        def verdelingMethodeBulletList(self):
            return self.getTypedRuleContext(RegelSpraakParser.VerdelingMethodeBulletListContext,0)


        def DOT(self):
            return self.getToken(RegelSpraakParser.DOT, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_verdelingMethodeMultiLine

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVerdelingMethodeMultiLine" ):
                listener.enterVerdelingMethodeMultiLine(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVerdelingMethodeMultiLine" ):
                listener.exitVerdelingMethodeMultiLine(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVerdelingMethodeMultiLine" ):
                return visitor.visitVerdelingMethodeMultiLine(self)
            else:
                return visitor.visitChildren(self)




    def verdelingMethodeMultiLine(self):

        localctx = RegelSpraakParser.VerdelingMethodeMultiLineContext(self, self._ctx, self.state)
        self.enterRule(localctx, 318, self.RULE_verdelingMethodeMultiLine)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2067
            self.match(RegelSpraakParser.COLON)
            self.state = 2068
            self.verdelingMethodeBulletList()
            self.state = 2070
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,232,self._ctx)
            if la_ == 1:
                self.state = 2069
                self.match(RegelSpraakParser.DOT)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VerdelingMethodeBulletListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def verdelingMethodeBullet(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.VerdelingMethodeBulletContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.VerdelingMethodeBulletContext,i)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_verdelingMethodeBulletList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVerdelingMethodeBulletList" ):
                listener.enterVerdelingMethodeBulletList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVerdelingMethodeBulletList" ):
                listener.exitVerdelingMethodeBulletList(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVerdelingMethodeBulletList" ):
                return visitor.visitVerdelingMethodeBulletList(self)
            else:
                return visitor.visitChildren(self)




    def verdelingMethodeBulletList(self):

        localctx = RegelSpraakParser.VerdelingMethodeBulletListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 320, self.RULE_verdelingMethodeBulletList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2072
            self.verdelingMethodeBullet()
            self.state = 2076
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==288:
                self.state = 2073
                self.verdelingMethodeBullet()
                self.state = 2078
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VerdelingMethodeBulletContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MINUS(self):
            return self.getToken(RegelSpraakParser.MINUS, 0)

        def verdelingMethode(self):
            return self.getTypedRuleContext(RegelSpraakParser.VerdelingMethodeContext,0)


        def COMMA(self):
            return self.getToken(RegelSpraakParser.COMMA, 0)

        def DOT(self):
            return self.getToken(RegelSpraakParser.DOT, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_verdelingMethodeBullet

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVerdelingMethodeBullet" ):
                listener.enterVerdelingMethodeBullet(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVerdelingMethodeBullet" ):
                listener.exitVerdelingMethodeBullet(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVerdelingMethodeBullet" ):
                return visitor.visitVerdelingMethodeBullet(self)
            else:
                return visitor.visitChildren(self)




    def verdelingMethodeBullet(self):

        localctx = RegelSpraakParser.VerdelingMethodeBulletContext(self, self._ctx, self.state)
        self.enterRule(localctx, 322, self.RULE_verdelingMethodeBullet)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2079
            self.match(RegelSpraakParser.MINUS)
            self.state = 2080
            self.verdelingMethode()
            self.state = 2082
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,234,self._ctx)
            if la_ == 1:
                self.state = 2081
                _la = self._input.LA(1)
                if not(_la==274 or _la==275):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VerdelingMethodeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_verdelingMethode

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class VerdelingNaarRatoContext(VerdelingMethodeContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.VerdelingMethodeContext
            super().__init__(parser)
            self.ratioExpression = None # ExpressieContext
            self.copyFrom(ctx)

        def NAAR_RATO_VAN(self):
            return self.getToken(RegelSpraakParser.NAAR_RATO_VAN, 0)
        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVerdelingNaarRato" ):
                listener.enterVerdelingNaarRato(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVerdelingNaarRato" ):
                listener.exitVerdelingNaarRato(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVerdelingNaarRato" ):
                return visitor.visitVerdelingNaarRato(self)
            else:
                return visitor.visitChildren(self)


    class VerdelingGelijkeDelenContext(VerdelingMethodeContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.VerdelingMethodeContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def IN_GELIJKE_DELEN(self):
            return self.getToken(RegelSpraakParser.IN_GELIJKE_DELEN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVerdelingGelijkeDelen" ):
                listener.enterVerdelingGelijkeDelen(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVerdelingGelijkeDelen" ):
                listener.exitVerdelingGelijkeDelen(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVerdelingGelijkeDelen" ):
                return visitor.visitVerdelingGelijkeDelen(self)
            else:
                return visitor.visitChildren(self)


    class VerdelingMaximumContext(VerdelingMethodeContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.VerdelingMethodeContext
            super().__init__(parser)
            self.maxExpression = None # ExpressieContext
            self.copyFrom(ctx)

        def MET_EEN_MAXIMUM_VAN(self):
            return self.getToken(RegelSpraakParser.MET_EEN_MAXIMUM_VAN, 0)
        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVerdelingMaximum" ):
                listener.enterVerdelingMaximum(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVerdelingMaximum" ):
                listener.exitVerdelingMaximum(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVerdelingMaximum" ):
                return visitor.visitVerdelingMaximum(self)
            else:
                return visitor.visitChildren(self)


    class VerdelingOpVolgordeContext(VerdelingMethodeContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.VerdelingMethodeContext
            super().__init__(parser)
            self.orderDirection = None # Token
            self.orderExpression = None # ExpressieContext
            self.copyFrom(ctx)

        def OP_VOLGORDE_VAN(self):
            return self.getToken(RegelSpraakParser.OP_VOLGORDE_VAN, 0)
        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)

        def TOENEMENDE(self):
            return self.getToken(RegelSpraakParser.TOENEMENDE, 0)
        def AFNEMENDE(self):
            return self.getToken(RegelSpraakParser.AFNEMENDE, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVerdelingOpVolgorde" ):
                listener.enterVerdelingOpVolgorde(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVerdelingOpVolgorde" ):
                listener.exitVerdelingOpVolgorde(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVerdelingOpVolgorde" ):
                return visitor.visitVerdelingOpVolgorde(self)
            else:
                return visitor.visitChildren(self)


    class VerdelingTieBreakContext(VerdelingMethodeContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.VerdelingMethodeContext
            super().__init__(parser)
            self.tieBreakMethod = None # VerdelingMethodeContext
            self.copyFrom(ctx)

        def BIJ_EVEN_GROOT_CRITERIUM(self):
            return self.getToken(RegelSpraakParser.BIJ_EVEN_GROOT_CRITERIUM, 0)
        def verdelingMethode(self):
            return self.getTypedRuleContext(RegelSpraakParser.VerdelingMethodeContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVerdelingTieBreak" ):
                listener.enterVerdelingTieBreak(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVerdelingTieBreak" ):
                listener.exitVerdelingTieBreak(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVerdelingTieBreak" ):
                return visitor.visitVerdelingTieBreak(self)
            else:
                return visitor.visitChildren(self)


    class VerdelingAfrondingContext(VerdelingMethodeContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.VerdelingMethodeContext
            super().__init__(parser)
            self.decimals = None # Token
            self.roundDirection = None # Token
            self.copyFrom(ctx)

        def AFGEROND_OP(self):
            return self.getToken(RegelSpraakParser.AFGEROND_OP, 0)
        def DECIMALEN(self):
            return self.getToken(RegelSpraakParser.DECIMALEN, 0)
        def NUMBER(self):
            return self.getToken(RegelSpraakParser.NUMBER, 0)
        def NAAR_BENEDEN(self):
            return self.getToken(RegelSpraakParser.NAAR_BENEDEN, 0)
        def NAAR_BOVEN(self):
            return self.getToken(RegelSpraakParser.NAAR_BOVEN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVerdelingAfronding" ):
                listener.enterVerdelingAfronding(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVerdelingAfronding" ):
                listener.exitVerdelingAfronding(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVerdelingAfronding" ):
                return visitor.visitVerdelingAfronding(self)
            else:
                return visitor.visitChildren(self)



    def verdelingMethode(self):

        localctx = RegelSpraakParser.VerdelingMethodeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 324, self.RULE_verdelingMethode)
        self._la = 0 # Token type
        try:
            self.state = 2098
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [194]:
                localctx = RegelSpraakParser.VerdelingGelijkeDelenContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 2084
                self.match(RegelSpraakParser.IN_GELIJKE_DELEN)
                pass
            elif token in [35]:
                localctx = RegelSpraakParser.VerdelingNaarRatoContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 2085
                self.match(RegelSpraakParser.NAAR_RATO_VAN)
                self.state = 2086
                localctx.ratioExpression = self.expressie()
                pass
            elif token in [34]:
                localctx = RegelSpraakParser.VerdelingOpVolgordeContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 2087
                self.match(RegelSpraakParser.OP_VOLGORDE_VAN)
                self.state = 2088
                localctx.orderDirection = self._input.LT(1)
                _la = self._input.LA(1)
                if not(_la==193 or _la==196):
                    localctx.orderDirection = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 2089
                localctx.orderExpression = self.expressie()
                pass
            elif token in [33]:
                localctx = RegelSpraakParser.VerdelingTieBreakContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 2090
                self.match(RegelSpraakParser.BIJ_EVEN_GROOT_CRITERIUM)
                self.state = 2091
                localctx.tieBreakMethod = self.verdelingMethode()
                pass
            elif token in [21]:
                localctx = RegelSpraakParser.VerdelingMaximumContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 2092
                self.match(RegelSpraakParser.MET_EEN_MAXIMUM_VAN)
                self.state = 2093
                localctx.maxExpression = self.expressie()
                pass
            elif token in [119]:
                localctx = RegelSpraakParser.VerdelingAfrondingContext(self, localctx)
                self.enterOuterAlt(localctx, 6)
                self.state = 2094
                self.match(RegelSpraakParser.AFGEROND_OP)
                self.state = 2095
                localctx.decimals = self.match(RegelSpraakParser.NUMBER)
                self.state = 2096
                self.match(RegelSpraakParser.DECIMALEN)
                self.state = 2097
                localctx.roundDirection = self._input.LT(1)
                _la = self._input.LA(1)
                if not(_la==134 or _la==135):
                    localctx.roundDirection = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VerdelingRestContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.remainderTarget = None # ExpressieContext

        def ALS_ONVERDEELDE_REST_BLIJFT(self):
            return self.getToken(RegelSpraakParser.ALS_ONVERDEELDE_REST_BLIJFT, 0)

        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)


        def OVER_VERDELING(self):
            return self.getToken(RegelSpraakParser.OVER_VERDELING, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_verdelingRest

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVerdelingRest" ):
                listener.enterVerdelingRest(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVerdelingRest" ):
                listener.exitVerdelingRest(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVerdelingRest" ):
                return visitor.visitVerdelingRest(self)
            else:
                return visitor.visitChildren(self)




    def verdelingRest(self):

        localctx = RegelSpraakParser.VerdelingRestContext(self, self._ctx, self.state)
        self.enterRule(localctx, 326, self.RULE_verdelingRest)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2100
            self.match(RegelSpraakParser.ALS_ONVERDEELDE_REST_BLIJFT)
            self.state = 2101
            localctx.remainderTarget = self.expressie()
            self.state = 2103
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==195:
                self.state = 2102
                self.match(RegelSpraakParser.OVER_VERDELING)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx



    def sempred(self, localctx:RuleContext, ruleIndex:int, predIndex:int):
        if self._predicates == None:
            self._predicates = dict()
        self._predicates[136] = self.primaryExpression_sempred
        pred = self._predicates.get(ruleIndex, None)
        if pred is None:
            raise Exception("No predicate with index:" + str(ruleIndex))
        else:
            return pred(localctx, predIndex)

    def primaryExpression_sempred(self, localctx:PrimaryExpressionContext, predIndex:int):
            if predIndex == 0:
                return self.precpred(self._ctx, 38)
         

            if predIndex == 1:
                return self.precpred(self._ctx, 42)
         

            if predIndex == 2:
                return self.precpred(self._ctx, 41)
         

            if predIndex == 3:
                return self.precpred(self._ctx, 40)
         

            if predIndex == 4:
                return self.precpred(self._ctx, 26)
         




