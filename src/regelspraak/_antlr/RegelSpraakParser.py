# Generated from RegelSpraak.g4 by ANTLR 4.13.1
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO

def serializedATN():
    return [
        4,1,272,1230,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,
        7,6,2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,
        13,2,14,7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,
        20,7,20,2,21,7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,
        26,2,27,7,27,2,28,7,28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,
        33,7,33,2,34,7,34,2,35,7,35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,
        39,2,40,7,40,2,41,7,41,2,42,7,42,2,43,7,43,2,44,7,44,2,45,7,45,2,
        46,7,46,2,47,7,47,2,48,7,48,2,49,7,49,2,50,7,50,2,51,7,51,2,52,7,
        52,2,53,7,53,2,54,7,54,2,55,7,55,2,56,7,56,2,57,7,57,2,58,7,58,2,
        59,7,59,2,60,7,60,2,61,7,61,2,62,7,62,2,63,7,63,2,64,7,64,2,65,7,
        65,2,66,7,66,2,67,7,67,2,68,7,68,2,69,7,69,2,70,7,70,2,71,7,71,2,
        72,7,72,2,73,7,73,2,74,7,74,2,75,7,75,2,76,7,76,2,77,7,77,2,78,7,
        78,2,79,7,79,2,80,7,80,2,81,7,81,2,82,7,82,2,83,7,83,2,84,7,84,2,
        85,7,85,2,86,7,86,2,87,7,87,1,0,1,0,1,0,1,0,1,0,5,0,182,8,0,10,0,
        12,0,185,9,0,1,0,1,0,1,1,1,1,1,1,1,1,1,1,1,1,3,1,195,8,1,1,2,1,2,
        1,2,3,2,200,8,2,1,3,1,3,1,4,3,4,205,8,4,1,4,4,4,208,8,4,11,4,12,
        4,209,1,4,4,4,213,8,4,11,4,12,4,214,1,4,1,4,4,4,219,8,4,11,4,12,
        4,220,1,4,1,4,4,4,225,8,4,11,4,12,4,226,1,4,1,4,4,4,231,8,4,11,4,
        12,4,232,1,4,4,4,236,8,4,11,4,12,4,237,1,4,1,4,4,4,242,8,4,11,4,
        12,4,243,1,4,1,4,4,4,248,8,4,11,4,12,4,249,3,4,252,8,4,1,5,1,5,1,
        5,1,5,5,5,258,8,5,10,5,12,5,261,9,5,1,6,1,6,1,7,1,7,1,8,1,8,1,9,
        1,9,1,9,1,9,4,9,273,8,9,11,9,12,9,274,1,9,3,9,278,8,9,1,9,3,9,281,
        8,9,1,9,5,9,284,8,9,10,9,12,9,287,9,9,1,10,1,10,3,10,291,8,10,1,
        10,1,10,1,11,3,11,296,8,11,1,11,1,11,3,11,300,8,11,1,11,1,11,3,11,
        304,8,11,1,12,1,12,1,12,3,12,309,8,12,1,12,1,12,1,12,1,12,1,12,3,
        12,316,8,12,3,12,318,8,12,1,12,1,12,1,12,1,12,5,12,324,8,12,10,12,
        12,12,327,9,12,3,12,329,8,12,1,12,3,12,332,8,12,1,13,1,13,1,13,1,
        13,1,13,3,13,339,8,13,1,14,1,14,1,14,1,14,1,15,1,15,1,15,1,15,1,
        15,3,15,350,8,15,1,16,1,16,1,17,1,17,1,18,1,18,1,19,3,19,359,8,19,
        1,19,1,19,1,19,1,19,1,19,1,19,3,19,367,8,19,1,20,1,20,4,20,371,8,
        20,11,20,12,20,372,1,20,1,20,1,20,1,20,3,20,379,8,20,1,20,3,20,382,
        8,20,1,21,1,21,1,21,1,21,1,21,3,21,389,8,21,1,22,1,22,4,22,393,8,
        22,11,22,12,22,394,1,23,1,23,1,23,1,24,1,24,1,24,5,24,403,8,24,10,
        24,12,24,406,9,24,1,25,1,25,1,25,1,25,1,25,1,25,3,25,414,8,25,1,
        26,1,26,1,27,1,27,1,27,3,27,421,8,27,1,27,1,27,1,27,1,27,3,27,427,
        8,27,1,28,1,28,1,28,3,28,432,8,28,1,29,1,29,1,29,3,29,437,8,29,1,
        29,1,29,1,29,1,29,4,29,443,8,29,11,29,12,29,444,1,30,1,30,1,30,1,
        30,3,30,451,8,30,1,30,3,30,454,8,30,1,31,1,31,1,31,1,31,1,32,1,32,
        1,33,1,33,1,34,1,34,1,34,1,34,1,34,3,34,469,8,34,1,34,1,34,3,34,
        473,8,34,1,34,3,34,476,8,34,1,34,1,34,1,35,3,35,481,8,35,1,35,4,
        35,484,8,35,11,35,12,35,485,1,36,1,36,1,37,1,37,1,37,1,37,1,37,1,
        37,3,37,496,8,37,1,37,1,37,4,37,500,8,37,11,37,12,37,501,1,38,1,
        38,1,38,1,39,1,39,1,39,3,39,510,8,39,1,39,1,39,1,39,1,39,3,39,516,
        8,39,1,39,3,39,519,8,39,1,39,3,39,522,8,39,1,40,4,40,525,8,40,11,
        40,12,40,526,1,40,1,40,4,40,531,8,40,11,40,12,40,532,1,40,1,40,4,
        40,537,8,40,11,40,12,40,538,1,40,1,40,4,40,543,8,40,11,40,12,40,
        544,1,40,1,40,1,40,4,40,550,8,40,11,40,12,40,551,1,40,1,40,1,40,
        4,40,557,8,40,11,40,12,40,558,1,40,1,40,4,40,563,8,40,11,40,12,40,
        564,1,40,4,40,568,8,40,11,40,12,40,569,1,40,1,40,4,40,574,8,40,11,
        40,12,40,575,3,40,578,8,40,1,41,1,41,1,41,1,42,1,42,1,42,1,42,1,
        42,3,42,588,8,42,3,42,590,8,42,1,43,1,43,3,43,594,8,43,1,43,1,43,
        1,43,1,43,1,43,1,43,3,43,602,8,43,1,43,1,43,1,43,1,43,1,43,1,43,
        1,43,1,43,1,43,1,43,1,43,4,43,615,8,43,11,43,12,43,616,1,43,1,43,
        1,43,1,43,1,43,1,43,3,43,625,8,43,1,43,1,43,5,43,629,8,43,10,43,
        12,43,632,9,43,1,43,1,43,1,43,1,43,1,43,1,43,3,43,640,8,43,1,43,
        1,43,1,43,1,43,1,43,3,43,647,8,43,1,43,3,43,650,8,43,1,43,1,43,1,
        43,1,43,1,43,1,43,1,43,1,43,3,43,660,8,43,1,43,3,43,663,8,43,1,44,
        1,44,1,44,1,44,3,44,669,8,44,1,44,3,44,672,8,44,1,44,1,44,1,44,1,
        44,1,44,3,44,679,8,44,1,44,3,44,682,8,44,3,44,684,8,44,1,45,1,45,
        1,45,1,45,5,45,690,8,45,10,45,12,45,693,9,45,1,46,1,46,1,46,1,46,
        1,47,1,47,1,47,1,47,1,47,1,47,3,47,705,8,47,1,47,3,47,708,8,47,3,
        47,710,8,47,1,48,1,48,1,48,3,48,715,8,48,1,49,3,49,718,8,49,1,49,
        1,49,1,49,1,50,1,50,1,50,3,50,726,8,50,1,51,1,51,1,51,1,51,5,51,
        732,8,51,10,51,12,51,735,9,51,1,52,3,52,738,8,52,1,52,4,52,741,8,
        52,11,52,12,52,742,1,52,3,52,746,8,52,1,53,1,53,1,53,1,53,1,54,1,
        54,1,55,1,55,1,55,1,56,1,56,1,56,3,56,760,8,56,1,56,1,56,1,56,1,
        56,1,56,1,56,1,56,1,56,1,56,1,56,1,56,1,56,1,56,1,56,3,56,776,8,
        56,1,57,1,57,1,57,1,57,1,57,3,57,783,8,57,1,58,1,58,1,58,1,58,5,
        58,789,8,58,10,58,12,58,792,9,58,1,59,1,59,1,60,1,60,5,60,798,8,
        60,10,60,12,60,801,9,60,1,60,1,60,1,61,1,61,1,61,1,61,3,61,809,8,
        61,1,62,1,62,1,63,1,63,1,63,3,63,816,8,63,1,64,1,64,1,64,1,64,1,
        64,1,64,1,64,1,64,1,64,1,64,1,64,1,64,3,64,830,8,64,1,64,1,64,3,
        64,834,8,64,1,65,1,65,1,66,1,66,1,66,1,66,5,66,842,8,66,10,66,12,
        66,845,9,66,1,67,1,67,1,68,1,68,1,68,1,68,5,68,853,8,68,10,68,12,
        68,856,9,68,1,69,1,69,1,70,1,70,1,70,1,70,5,70,864,8,70,10,70,12,
        70,867,9,70,1,71,1,71,1,72,1,72,1,72,1,72,1,72,1,72,1,72,1,72,1,
        72,1,72,1,72,1,72,1,72,3,72,884,8,72,1,72,1,72,1,72,1,72,1,72,1,
        72,3,72,892,8,72,1,72,1,72,1,72,3,72,897,8,72,1,72,1,72,3,72,901,
        8,72,1,72,1,72,1,72,1,72,3,72,907,8,72,1,72,1,72,1,72,1,72,1,72,
        1,72,5,72,915,8,72,10,72,12,72,918,9,72,1,72,1,72,1,72,1,72,1,72,
        1,72,1,72,1,72,1,72,1,72,1,72,1,72,1,72,1,72,5,72,934,8,72,10,72,
        12,72,937,9,72,1,72,1,72,1,72,1,72,1,72,1,72,1,72,5,72,946,8,72,
        10,72,12,72,949,9,72,1,72,1,72,1,72,1,72,1,72,1,72,1,72,1,72,1,72,
        1,72,1,72,1,72,1,72,1,72,1,72,1,72,1,72,1,72,1,72,1,72,1,72,1,72,
        1,72,1,72,1,72,1,72,1,72,1,72,1,72,1,72,1,72,1,72,1,72,5,72,984,
        8,72,10,72,12,72,987,9,72,1,72,1,72,1,72,1,72,1,72,1,72,1,72,5,72,
        996,8,72,10,72,12,72,999,9,72,1,72,1,72,1,72,1,72,1,72,1,72,1,72,
        3,72,1008,8,72,1,72,1,72,1,72,1,72,1,72,3,72,1015,8,72,1,72,1,72,
        1,72,4,72,1020,8,72,11,72,12,72,1021,1,72,1,72,1,72,1,72,3,72,1028,
        8,72,1,72,1,72,1,72,1,72,1,72,1,72,3,72,1036,8,72,1,72,4,72,1039,
        8,72,11,72,12,72,1040,1,72,1,72,1,72,1,72,1,72,1,72,3,72,1049,8,
        72,1,72,1,72,3,72,1053,8,72,1,72,1,72,1,72,1,72,1,72,1,72,1,72,1,
        72,1,72,1,72,1,72,1,72,3,72,1067,8,72,1,72,1,72,1,72,1,72,1,72,1,
        72,1,72,1,72,1,72,1,72,3,72,1079,8,72,1,72,1,72,1,72,4,72,1084,8,
        72,11,72,12,72,1085,1,72,1,72,1,72,1,72,1,72,1,72,1,72,1,72,1,72,
        1,72,1,72,1,72,1,72,5,72,1101,8,72,10,72,12,72,1104,9,72,1,73,1,
        73,1,73,1,73,1,73,1,74,1,74,1,74,1,74,1,74,1,74,3,74,1117,8,74,1,
        75,1,75,1,75,1,76,1,76,1,76,1,77,1,77,1,77,3,77,1128,8,77,1,78,1,
        78,1,78,1,78,1,78,1,78,1,78,1,78,1,78,1,78,1,78,1,78,1,78,1,78,1,
        78,1,78,3,78,1146,8,78,1,79,3,79,1149,8,79,1,79,1,79,1,79,1,79,3,
        79,1155,8,79,1,80,1,80,1,81,1,81,1,81,1,81,3,81,1163,8,81,1,81,1,
        81,1,82,1,82,1,82,1,83,1,83,1,83,1,83,1,83,1,83,1,83,1,84,1,84,1,
        84,1,84,1,84,1,84,1,84,5,84,1184,8,84,10,84,12,84,1187,9,84,1,84,
        1,84,1,84,1,84,1,85,1,85,1,85,1,85,1,85,1,85,1,85,1,85,1,85,1,85,
        1,85,1,85,1,85,1,85,1,85,1,85,1,85,1,85,1,85,1,85,1,85,1,85,1,85,
        1,85,1,85,1,85,3,85,1219,8,85,1,86,1,86,1,86,1,86,1,87,1,87,1,87,
        3,87,1228,8,87,1,87,0,1,144,88,0,2,4,6,8,10,12,14,16,18,20,22,24,
        26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,66,68,
        70,72,74,76,78,80,82,84,86,88,90,92,94,96,98,100,102,104,106,108,
        110,112,114,116,118,120,122,124,126,128,130,132,134,136,138,140,
        142,144,146,148,150,152,154,156,158,160,162,164,166,168,170,172,
        174,0,35,3,0,117,117,203,203,208,208,7,0,141,141,200,200,210,210,
        218,219,226,226,228,228,231,231,1,0,155,156,2,0,7,7,159,159,2,0,
        170,171,174,174,5,0,133,133,215,215,224,224,227,227,235,248,1,0,
        178,180,2,0,203,203,208,208,2,0,181,181,248,248,2,0,31,31,106,106,
        2,0,143,143,225,225,2,0,111,111,113,113,2,0,141,141,167,167,1,0,
        2,4,2,0,145,145,228,228,2,0,141,141,143,143,2,0,211,211,213,213,
        3,0,203,203,208,208,234,234,5,0,117,117,120,120,203,203,206,206,
        208,208,3,0,192,193,197,198,249,249,2,0,265,266,272,272,2,0,207,
        207,216,216,10,0,25,28,41,42,50,69,113,113,121,121,124,124,127,127,
        129,130,136,137,210,210,3,0,133,133,138,138,147,147,2,0,122,123,
        132,132,2,0,142,142,269,269,2,0,133,133,138,138,3,0,134,135,139,
        140,150,150,2,0,182,182,184,184,2,0,70,73,82,85,1,0,86,89,1,0,90,
        93,4,0,74,74,76,76,78,78,80,80,4,0,75,75,77,77,79,79,81,81,1,0,95,
        96,1378,0,183,1,0,0,0,2,194,1,0,0,0,4,196,1,0,0,0,6,201,1,0,0,0,
        8,251,1,0,0,0,10,253,1,0,0,0,12,262,1,0,0,0,14,264,1,0,0,0,16,266,
        1,0,0,0,18,268,1,0,0,0,20,290,1,0,0,0,22,299,1,0,0,0,24,305,1,0,
        0,0,26,338,1,0,0,0,28,340,1,0,0,0,30,344,1,0,0,0,32,351,1,0,0,0,
        34,353,1,0,0,0,36,355,1,0,0,0,38,358,1,0,0,0,40,368,1,0,0,0,42,388,
        1,0,0,0,44,390,1,0,0,0,46,396,1,0,0,0,48,399,1,0,0,0,50,407,1,0,
        0,0,52,415,1,0,0,0,54,426,1,0,0,0,56,428,1,0,0,0,58,433,1,0,0,0,
        60,453,1,0,0,0,62,455,1,0,0,0,64,459,1,0,0,0,66,461,1,0,0,0,68,463,
        1,0,0,0,70,480,1,0,0,0,72,487,1,0,0,0,74,489,1,0,0,0,76,503,1,0,
        0,0,78,506,1,0,0,0,80,577,1,0,0,0,82,579,1,0,0,0,84,589,1,0,0,0,
        86,662,1,0,0,0,88,683,1,0,0,0,90,685,1,0,0,0,92,694,1,0,0,0,94,698,
        1,0,0,0,96,711,1,0,0,0,98,717,1,0,0,0,100,722,1,0,0,0,102,727,1,
        0,0,0,104,745,1,0,0,0,106,747,1,0,0,0,108,751,1,0,0,0,110,753,1,
        0,0,0,112,775,1,0,0,0,114,782,1,0,0,0,116,784,1,0,0,0,118,793,1,
        0,0,0,120,795,1,0,0,0,122,804,1,0,0,0,124,810,1,0,0,0,126,812,1,
        0,0,0,128,833,1,0,0,0,130,835,1,0,0,0,132,837,1,0,0,0,134,846,1,
        0,0,0,136,848,1,0,0,0,138,857,1,0,0,0,140,859,1,0,0,0,142,868,1,
        0,0,0,144,1078,1,0,0,0,146,1105,1,0,0,0,148,1116,1,0,0,0,150,1118,
        1,0,0,0,152,1121,1,0,0,0,154,1127,1,0,0,0,156,1145,1,0,0,0,158,1154,
        1,0,0,0,160,1156,1,0,0,0,162,1158,1,0,0,0,164,1166,1,0,0,0,166,1169,
        1,0,0,0,168,1176,1,0,0,0,170,1218,1,0,0,0,172,1220,1,0,0,0,174,1224,
        1,0,0,0,176,182,3,2,1,0,177,182,3,78,39,0,178,182,3,4,2,0,179,182,
        3,94,47,0,180,182,3,48,24,0,181,176,1,0,0,0,181,177,1,0,0,0,181,
        178,1,0,0,0,181,179,1,0,0,0,181,180,1,0,0,0,182,185,1,0,0,0,183,
        181,1,0,0,0,183,184,1,0,0,0,184,186,1,0,0,0,185,183,1,0,0,0,186,
        187,5,0,0,1,187,1,1,0,0,0,188,195,3,18,9,0,189,195,3,40,20,0,190,
        195,3,68,34,0,191,195,3,58,29,0,192,195,3,74,37,0,193,195,3,174,
        87,0,194,188,1,0,0,0,194,189,1,0,0,0,194,190,1,0,0,0,194,191,1,0,
        0,0,194,192,1,0,0,0,194,193,1,0,0,0,195,3,1,0,0,0,196,197,5,99,0,
        0,197,199,3,10,5,0,198,200,3,82,41,0,199,198,1,0,0,0,199,200,1,0,
        0,0,200,5,1,0,0,0,201,202,5,248,0,0,202,7,1,0,0,0,203,205,7,0,0,
        0,204,203,1,0,0,0,204,205,1,0,0,0,205,207,1,0,0,0,206,208,5,248,
        0,0,207,206,1,0,0,0,208,209,1,0,0,0,209,207,1,0,0,0,209,210,1,0,
        0,0,210,252,1,0,0,0,211,213,3,6,3,0,212,211,1,0,0,0,213,214,1,0,
        0,0,214,212,1,0,0,0,214,215,1,0,0,0,215,252,1,0,0,0,216,218,5,48,
        0,0,217,219,5,248,0,0,218,217,1,0,0,0,219,220,1,0,0,0,220,218,1,
        0,0,0,220,221,1,0,0,0,221,252,1,0,0,0,222,224,5,48,0,0,223,225,5,
        248,0,0,224,223,1,0,0,0,225,226,1,0,0,0,226,224,1,0,0,0,226,227,
        1,0,0,0,227,228,1,0,0,0,228,230,5,167,0,0,229,231,5,248,0,0,230,
        229,1,0,0,0,231,232,1,0,0,0,232,230,1,0,0,0,232,233,1,0,0,0,233,
        252,1,0,0,0,234,236,3,6,3,0,235,234,1,0,0,0,236,237,1,0,0,0,237,
        235,1,0,0,0,237,238,1,0,0,0,238,239,1,0,0,0,239,241,5,167,0,0,240,
        242,3,6,3,0,241,240,1,0,0,0,242,243,1,0,0,0,243,241,1,0,0,0,243,
        244,1,0,0,0,244,252,1,0,0,0,245,247,5,136,0,0,246,248,5,248,0,0,
        247,246,1,0,0,0,248,249,1,0,0,0,249,247,1,0,0,0,249,250,1,0,0,0,
        250,252,1,0,0,0,251,204,1,0,0,0,251,212,1,0,0,0,251,216,1,0,0,0,
        251,222,1,0,0,0,251,235,1,0,0,0,251,245,1,0,0,0,252,9,1,0,0,0,253,
        259,3,8,4,0,254,255,3,12,6,0,255,256,3,8,4,0,256,258,1,0,0,0,257,
        254,1,0,0,0,258,261,1,0,0,0,259,257,1,0,0,0,259,260,1,0,0,0,260,
        11,1,0,0,0,261,259,1,0,0,0,262,263,7,1,0,0,263,13,1,0,0,0,264,265,
        5,251,0,0,265,15,1,0,0,0,266,267,5,248,0,0,267,17,1,0,0,0,268,269,
        5,100,0,0,269,277,3,10,5,0,270,272,5,169,0,0,271,273,5,248,0,0,272,
        271,1,0,0,0,273,274,1,0,0,0,274,272,1,0,0,0,274,275,1,0,0,0,275,
        276,1,0,0,0,276,278,5,256,0,0,277,270,1,0,0,0,277,278,1,0,0,0,278,
        280,1,0,0,0,279,281,5,154,0,0,280,279,1,0,0,0,280,281,1,0,0,0,281,
        285,1,0,0,0,282,284,3,20,10,0,283,282,1,0,0,0,284,287,1,0,0,0,285,
        283,1,0,0,0,285,286,1,0,0,0,286,19,1,0,0,0,287,285,1,0,0,0,288,291,
        3,22,11,0,289,291,3,24,12,0,290,288,1,0,0,0,290,289,1,0,0,0,291,
        292,1,0,0,0,292,293,5,262,0,0,293,21,1,0,0,0,294,296,5,113,0,0,295,
        294,1,0,0,0,295,296,1,0,0,0,296,297,1,0,0,0,297,300,3,6,3,0,298,
        300,3,10,5,0,299,295,1,0,0,0,299,298,1,0,0,0,300,301,1,0,0,0,301,
        303,5,165,0,0,302,304,7,2,0,0,303,302,1,0,0,0,303,304,1,0,0,0,304,
        23,1,0,0,0,305,308,3,10,5,0,306,309,3,26,13,0,307,309,3,46,23,0,
        308,306,1,0,0,0,308,307,1,0,0,0,309,317,1,0,0,0,310,315,5,168,0,
        0,311,316,5,248,0,0,312,316,5,264,0,0,313,316,5,246,0,0,314,316,
        5,247,0,0,315,311,1,0,0,0,315,312,1,0,0,0,315,313,1,0,0,0,315,314,
        1,0,0,0,316,318,1,0,0,0,317,310,1,0,0,0,317,318,1,0,0,0,318,328,
        1,0,0,0,319,320,5,162,0,0,320,325,3,66,33,0,321,322,5,207,0,0,322,
        324,3,66,33,0,323,321,1,0,0,0,324,327,1,0,0,0,325,323,1,0,0,0,325,
        326,1,0,0,0,326,329,1,0,0,0,327,325,1,0,0,0,328,319,1,0,0,0,328,
        329,1,0,0,0,329,331,1,0,0,0,330,332,3,64,32,0,331,330,1,0,0,0,331,
        332,1,0,0,0,332,25,1,0,0,0,333,339,3,30,15,0,334,339,3,32,16,0,335,
        339,3,34,17,0,336,339,3,36,18,0,337,339,3,28,14,0,338,333,1,0,0,
        0,338,334,1,0,0,0,338,335,1,0,0,0,338,336,1,0,0,0,338,337,1,0,0,
        0,339,27,1,0,0,0,340,341,5,102,0,0,341,342,5,228,0,0,342,343,3,26,
        13,0,343,29,1,0,0,0,344,349,5,172,0,0,345,346,5,255,0,0,346,347,
        3,38,19,0,347,348,5,256,0,0,348,350,1,0,0,0,349,345,1,0,0,0,349,
        350,1,0,0,0,350,31,1,0,0,0,351,352,5,177,0,0,352,33,1,0,0,0,353,
        354,5,157,0,0,354,35,1,0,0,0,355,356,7,3,0,0,356,37,1,0,0,0,357,
        359,7,4,0,0,358,357,1,0,0,0,358,359,1,0,0,0,359,366,1,0,0,0,360,
        367,5,163,0,0,361,362,5,164,0,0,362,363,5,167,0,0,363,364,5,249,
        0,0,364,367,5,160,0,0,365,367,5,164,0,0,366,360,1,0,0,0,366,361,
        1,0,0,0,366,365,1,0,0,0,367,39,1,0,0,0,368,370,5,101,0,0,369,371,
        5,248,0,0,370,369,1,0,0,0,371,372,1,0,0,0,372,370,1,0,0,0,372,373,
        1,0,0,0,373,374,1,0,0,0,374,375,5,32,0,0,375,378,3,42,21,0,376,377,
        5,168,0,0,377,379,3,54,27,0,378,376,1,0,0,0,378,379,1,0,0,0,379,
        381,1,0,0,0,380,382,5,262,0,0,381,380,1,0,0,0,381,382,1,0,0,0,382,
        41,1,0,0,0,383,389,3,44,22,0,384,389,3,30,15,0,385,389,3,32,16,0,
        386,389,3,34,17,0,387,389,3,36,18,0,388,383,1,0,0,0,388,384,1,0,
        0,0,388,385,1,0,0,0,388,386,1,0,0,0,388,387,1,0,0,0,389,43,1,0,0,
        0,390,392,5,161,0,0,391,393,5,254,0,0,392,391,1,0,0,0,393,394,1,
        0,0,0,394,392,1,0,0,0,394,395,1,0,0,0,395,45,1,0,0,0,396,397,5,101,
        0,0,397,398,5,248,0,0,398,47,1,0,0,0,399,400,5,104,0,0,400,404,3,
        6,3,0,401,403,3,50,25,0,402,401,1,0,0,0,403,406,1,0,0,0,404,402,
        1,0,0,0,404,405,1,0,0,0,405,49,1,0,0,0,406,404,1,0,0,0,407,408,5,
        203,0,0,408,409,3,52,26,0,409,413,3,52,26,0,410,411,5,250,0,0,411,
        412,5,249,0,0,412,414,3,52,26,0,413,410,1,0,0,0,413,414,1,0,0,0,
        414,51,1,0,0,0,415,416,7,5,0,0,416,53,1,0,0,0,417,420,3,56,28,0,
        418,419,5,263,0,0,419,421,3,56,28,0,420,418,1,0,0,0,420,421,1,0,
        0,0,421,427,1,0,0,0,422,427,5,249,0,0,423,427,5,264,0,0,424,427,
        5,246,0,0,425,427,5,247,0,0,426,417,1,0,0,0,426,422,1,0,0,0,426,
        423,1,0,0,0,426,424,1,0,0,0,426,425,1,0,0,0,427,55,1,0,0,0,428,431,
        3,52,26,0,429,430,5,269,0,0,430,432,5,249,0,0,431,429,1,0,0,0,431,
        432,1,0,0,0,432,57,1,0,0,0,433,434,5,103,0,0,434,436,3,10,5,0,435,
        437,5,259,0,0,436,435,1,0,0,0,436,437,1,0,0,0,437,438,1,0,0,0,438,
        439,5,30,0,0,439,440,3,10,5,0,440,442,3,60,30,0,441,443,3,62,31,
        0,442,441,1,0,0,0,443,444,1,0,0,0,444,442,1,0,0,0,444,445,1,0,0,
        0,445,59,1,0,0,0,446,447,5,6,0,0,447,448,3,12,6,0,448,450,5,256,
        0,0,449,451,5,261,0,0,450,449,1,0,0,0,450,451,1,0,0,0,451,454,1,
        0,0,0,452,454,5,5,0,0,453,446,1,0,0,0,453,452,1,0,0,0,454,61,1,0,
        0,0,455,456,5,249,0,0,456,457,5,260,0,0,457,458,3,6,3,0,458,63,1,
        0,0,0,459,460,7,6,0,0,460,65,1,0,0,0,461,462,5,248,0,0,462,67,1,
        0,0,0,463,464,5,105,0,0,464,465,3,70,35,0,465,468,5,261,0,0,466,
        469,3,26,13,0,467,469,3,46,23,0,468,466,1,0,0,0,468,467,1,0,0,0,
        469,472,1,0,0,0,470,471,5,168,0,0,471,473,3,54,27,0,472,470,1,0,
        0,0,472,473,1,0,0,0,473,475,1,0,0,0,474,476,3,64,32,0,475,474,1,
        0,0,0,475,476,1,0,0,0,476,477,1,0,0,0,477,478,5,262,0,0,478,69,1,
        0,0,0,479,481,7,7,0,0,480,479,1,0,0,0,480,481,1,0,0,0,481,483,1,
        0,0,0,482,484,7,8,0,0,483,482,1,0,0,0,484,485,1,0,0,0,485,483,1,
        0,0,0,485,486,1,0,0,0,486,71,1,0,0,0,487,488,3,10,5,0,488,73,1,0,
        0,0,489,490,7,9,0,0,490,495,3,10,5,0,491,492,5,111,0,0,492,496,3,
        10,5,0,493,494,5,113,0,0,494,496,3,10,5,0,495,491,1,0,0,0,495,493,
        1,0,0,0,496,497,1,0,0,0,497,499,3,76,38,0,498,500,3,76,38,0,499,
        498,1,0,0,0,500,501,1,0,0,0,501,499,1,0,0,0,501,502,1,0,0,0,502,
        75,1,0,0,0,503,504,3,60,30,0,504,505,3,6,3,0,505,77,1,0,0,0,506,
        507,5,98,0,0,507,509,3,80,40,0,508,510,5,249,0,0,509,508,1,0,0,0,
        509,510,1,0,0,0,510,511,1,0,0,0,511,512,3,82,41,0,512,518,3,86,43,
        0,513,515,3,100,50,0,514,516,5,260,0,0,515,514,1,0,0,0,515,516,1,
        0,0,0,516,519,1,0,0,0,517,519,5,260,0,0,518,513,1,0,0,0,518,517,
        1,0,0,0,518,519,1,0,0,0,519,521,1,0,0,0,520,522,3,120,60,0,521,520,
        1,0,0,0,521,522,1,0,0,0,522,79,1,0,0,0,523,525,5,248,0,0,524,523,
        1,0,0,0,525,526,1,0,0,0,526,524,1,0,0,0,526,527,1,0,0,0,527,578,
        1,0,0,0,528,578,3,10,5,0,529,531,5,248,0,0,530,529,1,0,0,0,531,532,
        1,0,0,0,532,530,1,0,0,0,532,533,1,0,0,0,533,534,1,0,0,0,534,578,
        5,165,0,0,535,537,5,248,0,0,536,535,1,0,0,0,537,538,1,0,0,0,538,
        536,1,0,0,0,538,539,1,0,0,0,539,540,1,0,0,0,540,578,5,175,0,0,541,
        543,5,248,0,0,542,541,1,0,0,0,543,544,1,0,0,0,544,542,1,0,0,0,544,
        545,1,0,0,0,545,546,1,0,0,0,546,547,5,136,0,0,547,578,5,165,0,0,
        548,550,5,248,0,0,549,548,1,0,0,0,550,551,1,0,0,0,551,549,1,0,0,
        0,551,552,1,0,0,0,552,553,1,0,0,0,553,554,5,136,0,0,554,578,5,175,
        0,0,555,557,5,248,0,0,556,555,1,0,0,0,557,558,1,0,0,0,558,556,1,
        0,0,0,558,559,1,0,0,0,559,560,1,0,0,0,560,562,5,166,0,0,561,563,
        5,248,0,0,562,561,1,0,0,0,563,564,1,0,0,0,564,562,1,0,0,0,564,565,
        1,0,0,0,565,578,1,0,0,0,566,568,5,248,0,0,567,566,1,0,0,0,568,569,
        1,0,0,0,569,567,1,0,0,0,569,570,1,0,0,0,570,571,1,0,0,0,571,573,
        5,176,0,0,572,574,5,248,0,0,573,572,1,0,0,0,574,575,1,0,0,0,575,
        573,1,0,0,0,575,576,1,0,0,0,576,578,1,0,0,0,577,524,1,0,0,0,577,
        528,1,0,0,0,577,530,1,0,0,0,577,536,1,0,0,0,577,542,1,0,0,0,577,
        549,1,0,0,0,577,556,1,0,0,0,577,567,1,0,0,0,578,81,1,0,0,0,579,580,
        5,109,0,0,580,581,3,84,42,0,581,83,1,0,0,0,582,590,5,199,0,0,583,
        584,5,145,0,0,584,587,3,14,7,0,585,586,7,10,0,0,586,588,3,14,7,0,
        587,585,1,0,0,0,587,588,1,0,0,0,588,590,1,0,0,0,589,582,1,0,0,0,
        589,583,1,0,0,0,590,85,1,0,0,0,591,594,3,10,5,0,592,594,3,106,53,
        0,593,591,1,0,0,0,593,592,1,0,0,0,594,601,1,0,0,0,595,596,5,11,0,
        0,596,602,3,124,62,0,597,598,5,12,0,0,598,602,3,124,62,0,599,600,
        5,13,0,0,600,602,3,124,62,0,601,595,1,0,0,0,601,597,1,0,0,0,601,
        599,1,0,0,0,602,663,1,0,0,0,603,604,3,102,51,0,604,605,7,11,0,0,
        605,606,3,108,54,0,606,663,1,0,0,0,607,608,3,102,51,0,608,609,5,
        111,0,0,609,610,3,10,5,0,610,611,7,12,0,0,611,612,3,102,51,0,612,
        663,1,0,0,0,613,615,3,6,3,0,614,613,1,0,0,0,615,616,1,0,0,0,616,
        614,1,0,0,0,616,617,1,0,0,0,617,624,1,0,0,0,618,619,5,11,0,0,619,
        625,3,124,62,0,620,621,5,12,0,0,621,625,3,124,62,0,622,623,5,13,
        0,0,623,625,3,124,62,0,624,618,1,0,0,0,624,620,1,0,0,0,624,622,1,
        0,0,0,625,663,1,0,0,0,626,630,7,13,0,0,627,629,3,6,3,0,628,627,1,
        0,0,0,629,632,1,0,0,0,630,628,1,0,0,0,630,631,1,0,0,0,631,639,1,
        0,0,0,632,630,1,0,0,0,633,634,5,11,0,0,634,640,3,124,62,0,635,636,
        5,12,0,0,636,640,3,124,62,0,637,638,5,13,0,0,638,640,3,124,62,0,
        639,633,1,0,0,0,639,635,1,0,0,0,639,637,1,0,0,0,640,646,1,0,0,0,
        641,642,7,14,0,0,642,643,3,14,7,0,643,644,7,15,0,0,644,645,3,14,
        7,0,645,647,1,0,0,0,646,641,1,0,0,0,646,647,1,0,0,0,647,649,1,0,
        0,0,648,650,5,260,0,0,649,648,1,0,0,0,649,650,1,0,0,0,650,663,1,
        0,0,0,651,652,5,1,0,0,652,659,7,16,0,0,653,654,5,11,0,0,654,660,
        3,124,62,0,655,656,5,12,0,0,656,660,3,124,62,0,657,658,5,13,0,0,
        658,660,3,124,62,0,659,653,1,0,0,0,659,655,1,0,0,0,659,657,1,0,0,
        0,660,663,1,0,0,0,661,663,3,88,44,0,662,593,1,0,0,0,662,603,1,0,
        0,0,662,607,1,0,0,0,662,614,1,0,0,0,662,626,1,0,0,0,662,651,1,0,
        0,0,662,661,1,0,0,0,663,87,1,0,0,0,664,665,5,44,0,0,665,666,3,10,
        5,0,666,668,5,46,0,0,667,669,3,90,45,0,668,667,1,0,0,0,668,669,1,
        0,0,0,669,671,1,0,0,0,670,672,5,260,0,0,671,670,1,0,0,0,671,672,
        1,0,0,0,672,684,1,0,0,0,673,674,5,47,0,0,674,675,5,206,0,0,675,676,
        5,48,0,0,676,678,3,10,5,0,677,679,3,90,45,0,678,677,1,0,0,0,678,
        679,1,0,0,0,679,681,1,0,0,0,680,682,5,260,0,0,681,680,1,0,0,0,681,
        682,1,0,0,0,682,684,1,0,0,0,683,664,1,0,0,0,683,673,1,0,0,0,684,
        89,1,0,0,0,685,686,5,167,0,0,686,687,3,10,5,0,687,691,3,124,62,0,
        688,690,3,92,46,0,689,688,1,0,0,0,690,693,1,0,0,0,691,689,1,0,0,
        0,691,692,1,0,0,0,692,91,1,0,0,0,693,691,1,0,0,0,694,695,5,207,0,
        0,695,696,3,10,5,0,696,697,3,124,62,0,697,93,1,0,0,0,698,699,5,97,
        0,0,699,709,3,10,5,0,700,710,3,96,48,0,701,707,3,98,49,0,702,704,
        3,100,50,0,703,705,5,260,0,0,704,703,1,0,0,0,704,705,1,0,0,0,705,
        708,1,0,0,0,706,708,5,260,0,0,707,702,1,0,0,0,707,706,1,0,0,0,707,
        708,1,0,0,0,708,710,1,0,0,0,709,700,1,0,0,0,709,701,1,0,0,0,710,
        95,1,0,0,0,711,712,3,102,51,0,712,714,5,94,0,0,713,715,5,260,0,0,
        714,713,1,0,0,0,714,715,1,0,0,0,715,97,1,0,0,0,716,718,7,17,0,0,
        717,716,1,0,0,0,717,718,1,0,0,0,718,719,1,0,0,0,719,720,3,10,5,0,
        720,721,5,96,0,0,721,99,1,0,0,0,722,725,5,112,0,0,723,726,3,124,
        62,0,724,726,3,112,56,0,725,723,1,0,0,0,725,724,1,0,0,0,726,101,
        1,0,0,0,727,733,3,104,52,0,728,729,3,12,6,0,729,730,3,104,52,0,730,
        732,1,0,0,0,731,728,1,0,0,0,732,735,1,0,0,0,733,731,1,0,0,0,733,
        734,1,0,0,0,734,103,1,0,0,0,735,733,1,0,0,0,736,738,7,18,0,0,737,
        736,1,0,0,0,737,738,1,0,0,0,738,740,1,0,0,0,739,741,5,248,0,0,740,
        739,1,0,0,0,741,742,1,0,0,0,742,740,1,0,0,0,742,743,1,0,0,0,743,
        746,1,0,0,0,744,746,5,209,0,0,745,737,1,0,0,0,745,744,1,0,0,0,746,
        105,1,0,0,0,747,748,3,10,5,0,748,749,5,228,0,0,749,750,3,102,51,
        0,750,107,1,0,0,0,751,752,3,102,51,0,752,109,1,0,0,0,753,754,5,117,
        0,0,754,755,3,6,3,0,755,111,1,0,0,0,756,760,5,209,0,0,757,760,5,
        208,0,0,758,760,3,102,51,0,759,756,1,0,0,0,759,757,1,0,0,0,759,758,
        1,0,0,0,760,761,1,0,0,0,761,762,5,118,0,0,762,763,3,114,57,0,763,
        764,5,230,0,0,764,765,5,149,0,0,765,766,5,261,0,0,766,767,3,116,
        58,0,767,776,1,0,0,0,768,769,5,49,0,0,769,770,3,114,57,0,770,771,
        5,230,0,0,771,772,5,43,0,0,772,773,5,261,0,0,773,774,3,116,58,0,
        774,776,1,0,0,0,775,759,1,0,0,0,775,768,1,0,0,0,776,113,1,0,0,0,
        777,783,5,120,0,0,778,779,5,152,0,0,779,780,7,19,0,0,780,781,5,228,
        0,0,781,783,5,203,0,0,782,777,1,0,0,0,782,778,1,0,0,0,783,115,1,
        0,0,0,784,785,7,20,0,0,785,790,3,118,59,0,786,787,7,20,0,0,787,789,
        3,118,59,0,788,786,1,0,0,0,789,792,1,0,0,0,790,788,1,0,0,0,790,791,
        1,0,0,0,791,117,1,0,0,0,792,790,1,0,0,0,793,794,3,124,62,0,794,119,
        1,0,0,0,795,799,5,108,0,0,796,798,3,122,61,0,797,796,1,0,0,0,798,
        801,1,0,0,0,799,797,1,0,0,0,799,800,1,0,0,0,800,802,1,0,0,0,801,
        799,1,0,0,0,802,803,5,260,0,0,803,121,1,0,0,0,804,805,3,10,5,0,805,
        806,5,113,0,0,806,808,3,124,62,0,807,809,5,262,0,0,808,807,1,0,0,
        0,808,809,1,0,0,0,809,123,1,0,0,0,810,811,3,126,63,0,811,125,1,0,
        0,0,812,815,3,128,64,0,813,814,7,21,0,0,814,816,3,126,63,0,815,813,
        1,0,0,0,815,816,1,0,0,0,816,127,1,0,0,0,817,818,3,132,66,0,818,819,
        5,113,0,0,819,820,3,6,3,0,820,834,1,0,0,0,821,822,3,132,66,0,822,
        823,5,111,0,0,823,824,3,6,3,0,824,834,1,0,0,0,825,829,3,132,66,0,
        826,827,3,130,65,0,827,828,3,132,66,0,828,830,1,0,0,0,829,826,1,
        0,0,0,829,830,1,0,0,0,830,834,1,0,0,0,831,834,3,170,85,0,832,834,
        3,172,86,0,833,817,1,0,0,0,833,821,1,0,0,0,833,825,1,0,0,0,833,831,
        1,0,0,0,833,832,1,0,0,0,834,129,1,0,0,0,835,836,7,22,0,0,836,131,
        1,0,0,0,837,843,3,136,68,0,838,839,3,134,67,0,839,840,3,136,68,0,
        840,842,1,0,0,0,841,838,1,0,0,0,842,845,1,0,0,0,843,841,1,0,0,0,
        843,844,1,0,0,0,844,133,1,0,0,0,845,843,1,0,0,0,846,847,7,23,0,0,
        847,135,1,0,0,0,848,854,3,140,70,0,849,850,3,138,69,0,850,851,3,
        140,70,0,851,853,1,0,0,0,852,849,1,0,0,0,853,856,1,0,0,0,854,852,
        1,0,0,0,854,855,1,0,0,0,855,137,1,0,0,0,856,854,1,0,0,0,857,858,
        7,24,0,0,858,139,1,0,0,0,859,865,3,144,72,0,860,861,3,142,71,0,861,
        862,3,144,72,0,862,864,1,0,0,0,863,860,1,0,0,0,864,867,1,0,0,0,865,
        863,1,0,0,0,865,866,1,0,0,0,866,141,1,0,0,0,867,865,1,0,0,0,868,
        869,7,25,0,0,869,143,1,0,0,0,870,871,6,72,-1,0,871,872,5,133,0,0,
        872,1079,3,144,72,45,873,874,5,272,0,0,874,1079,3,144,72,44,875,
        876,5,136,0,0,876,1079,3,144,72,43,877,878,5,14,0,0,878,879,3,144,
        72,0,879,880,5,141,0,0,880,883,3,144,72,0,881,882,5,183,0,0,882,
        884,5,248,0,0,883,881,1,0,0,0,883,884,1,0,0,0,884,1079,1,0,0,0,885,
        886,5,187,0,0,886,887,3,144,72,0,887,888,5,141,0,0,888,891,3,144,
        72,0,889,890,5,183,0,0,890,892,5,248,0,0,891,889,1,0,0,0,891,892,
        1,0,0,0,892,1079,1,0,0,0,893,894,5,186,0,0,894,1079,3,124,62,0,895,
        897,5,208,0,0,896,895,1,0,0,0,896,897,1,0,0,0,897,898,1,0,0,0,898,
        900,5,181,0,0,899,901,5,120,0,0,900,899,1,0,0,0,900,901,1,0,0,0,
        901,902,1,0,0,0,902,1079,3,102,51,0,903,906,5,249,0,0,904,907,5,
        264,0,0,905,907,5,248,0,0,906,904,1,0,0,0,906,905,1,0,0,0,907,908,
        1,0,0,0,908,909,5,228,0,0,909,1079,3,144,72,38,910,911,5,33,0,0,
        911,916,3,144,72,0,912,913,5,259,0,0,913,915,3,144,72,0,914,912,
        1,0,0,0,915,918,1,0,0,0,916,914,1,0,0,0,916,917,1,0,0,0,917,919,
        1,0,0,0,918,916,1,0,0,0,919,920,7,21,0,0,920,921,3,144,72,35,921,
        1079,1,0,0,0,922,923,5,151,0,0,923,1079,3,144,72,33,924,925,5,15,
        0,0,925,926,5,255,0,0,926,927,3,144,72,0,927,928,5,256,0,0,928,1079,
        1,0,0,0,929,930,5,17,0,0,930,935,3,144,72,0,931,932,5,259,0,0,932,
        934,3,144,72,0,933,931,1,0,0,0,934,937,1,0,0,0,935,933,1,0,0,0,935,
        936,1,0,0,0,936,938,1,0,0,0,937,935,1,0,0,0,938,939,5,207,0,0,939,
        940,3,144,72,31,940,1079,1,0,0,0,941,942,5,16,0,0,942,947,3,144,
        72,0,943,944,5,259,0,0,944,946,3,144,72,0,945,943,1,0,0,0,946,949,
        1,0,0,0,947,945,1,0,0,0,947,948,1,0,0,0,948,950,1,0,0,0,949,947,
        1,0,0,0,950,951,5,207,0,0,951,952,3,144,72,30,952,1079,1,0,0,0,953,
        954,5,208,0,0,954,955,5,211,0,0,955,956,5,226,0,0,956,1079,3,144,
        72,29,957,958,5,203,0,0,958,959,5,213,0,0,959,960,5,226,0,0,960,
        1079,3,144,72,28,961,962,5,203,0,0,962,963,5,201,0,0,963,964,5,226,
        0,0,964,1079,3,144,72,27,965,966,5,20,0,0,966,967,5,255,0,0,967,
        968,3,144,72,0,968,969,5,259,0,0,969,970,3,144,72,0,970,971,5,259,
        0,0,971,972,3,144,72,0,972,973,5,256,0,0,973,1079,1,0,0,0,974,975,
        5,21,0,0,975,976,5,255,0,0,976,977,3,144,72,0,977,978,5,256,0,0,
        978,1079,1,0,0,0,979,980,5,182,0,0,980,985,3,144,72,0,981,982,5,
        259,0,0,982,984,3,144,72,0,983,981,1,0,0,0,984,987,1,0,0,0,985,983,
        1,0,0,0,985,986,1,0,0,0,986,988,1,0,0,0,987,985,1,0,0,0,988,989,
        5,207,0,0,989,990,3,144,72,23,990,1079,1,0,0,0,991,992,5,184,0,0,
        992,997,3,144,72,0,993,994,5,259,0,0,994,996,3,144,72,0,995,993,
        1,0,0,0,996,999,1,0,0,0,997,995,1,0,0,0,997,998,1,0,0,0,998,1000,
        1,0,0,0,999,997,1,0,0,0,1000,1001,5,207,0,0,1001,1002,3,144,72,22,
        1002,1079,1,0,0,0,1003,1004,5,18,0,0,1004,1007,3,124,62,0,1005,1006,
        5,8,0,0,1006,1008,3,124,62,0,1007,1005,1,0,0,0,1007,1008,1,0,0,0,
        1008,1079,1,0,0,0,1009,1014,5,1,0,0,1010,1011,5,203,0,0,1011,1015,
        5,213,0,0,1012,1013,5,208,0,0,1013,1015,5,211,0,0,1014,1010,1,0,
        0,0,1014,1012,1,0,0,0,1015,1016,1,0,0,0,1016,1017,5,202,0,0,1017,
        1079,3,124,62,0,1018,1020,3,6,3,0,1019,1018,1,0,0,0,1020,1021,1,
        0,0,0,1021,1019,1,0,0,0,1021,1022,1,0,0,0,1022,1023,1,0,0,0,1023,
        1024,5,18,0,0,1024,1027,3,124,62,0,1025,1026,5,8,0,0,1026,1028,3,
        124,62,0,1027,1025,1,0,0,0,1027,1028,1,0,0,0,1028,1079,1,0,0,0,1029,
        1030,5,19,0,0,1030,1031,7,16,0,0,1031,1032,5,228,0,0,1032,1035,3,
        124,62,0,1033,1034,5,8,0,0,1034,1036,3,124,62,0,1035,1033,1,0,0,
        0,1035,1036,1,0,0,0,1036,1079,1,0,0,0,1037,1039,3,6,3,0,1038,1037,
        1,0,0,0,1039,1040,1,0,0,0,1040,1038,1,0,0,0,1040,1041,1,0,0,0,1041,
        1042,1,0,0,0,1042,1043,5,19,0,0,1043,1044,7,16,0,0,1044,1045,5,228,
        0,0,1045,1048,3,124,62,0,1046,1047,5,8,0,0,1047,1049,3,124,62,0,
        1048,1046,1,0,0,0,1048,1049,1,0,0,0,1049,1079,1,0,0,0,1050,1053,
        3,158,79,0,1051,1053,3,160,80,0,1052,1050,1,0,0,0,1052,1051,1,0,
        0,0,1053,1054,1,0,0,0,1054,1055,3,106,53,0,1055,1056,3,162,81,0,
        1056,1079,1,0,0,0,1057,1079,3,106,53,0,1058,1079,3,110,55,0,1059,
        1079,3,102,51,0,1060,1079,3,10,5,0,1061,1079,3,72,36,0,1062,1079,
        5,221,0,0,1063,1079,3,6,3,0,1064,1066,5,249,0,0,1065,1067,3,52,26,
        0,1066,1065,1,0,0,0,1066,1067,1,0,0,0,1067,1079,1,0,0,0,1068,1079,
        5,253,0,0,1069,1079,5,254,0,0,1070,1079,3,14,7,0,1071,1079,5,232,
        0,0,1072,1079,5,217,0,0,1073,1079,5,209,0,0,1074,1075,5,255,0,0,
        1075,1076,3,124,62,0,1076,1077,5,256,0,0,1077,1079,1,0,0,0,1078,
        870,1,0,0,0,1078,873,1,0,0,0,1078,875,1,0,0,0,1078,877,1,0,0,0,1078,
        885,1,0,0,0,1078,893,1,0,0,0,1078,896,1,0,0,0,1078,903,1,0,0,0,1078,
        910,1,0,0,0,1078,922,1,0,0,0,1078,924,1,0,0,0,1078,929,1,0,0,0,1078,
        941,1,0,0,0,1078,953,1,0,0,0,1078,957,1,0,0,0,1078,961,1,0,0,0,1078,
        965,1,0,0,0,1078,974,1,0,0,0,1078,979,1,0,0,0,1078,991,1,0,0,0,1078,
        1003,1,0,0,0,1078,1009,1,0,0,0,1078,1019,1,0,0,0,1078,1029,1,0,0,
        0,1078,1038,1,0,0,0,1078,1052,1,0,0,0,1078,1057,1,0,0,0,1078,1058,
        1,0,0,0,1078,1059,1,0,0,0,1078,1060,1,0,0,0,1078,1061,1,0,0,0,1078,
        1062,1,0,0,0,1078,1063,1,0,0,0,1078,1064,1,0,0,0,1078,1068,1,0,0,
        0,1078,1069,1,0,0,0,1078,1070,1,0,0,0,1078,1071,1,0,0,0,1078,1072,
        1,0,0,0,1078,1073,1,0,0,0,1078,1074,1,0,0,0,1079,1102,1,0,0,0,1080,
        1083,10,34,0,0,1081,1082,5,259,0,0,1082,1084,3,144,72,0,1083,1081,
        1,0,0,0,1084,1085,1,0,0,0,1085,1083,1,0,0,0,1085,1086,1,0,0,0,1086,
        1087,1,0,0,0,1087,1088,7,21,0,0,1088,1089,3,144,72,35,1089,1101,
        1,0,0,0,1090,1091,10,37,0,0,1091,1101,3,146,73,0,1092,1093,10,36,
        0,0,1093,1094,5,259,0,0,1094,1101,3,148,74,0,1095,1096,10,24,0,0,
        1096,1097,7,26,0,0,1097,1098,3,144,72,0,1098,1099,3,6,3,0,1099,1101,
        1,0,0,0,1100,1080,1,0,0,0,1100,1090,1,0,0,0,1100,1092,1,0,0,0,1100,
        1095,1,0,0,0,1101,1104,1,0,0,0,1102,1100,1,0,0,0,1102,1103,1,0,0,
        0,1103,145,1,0,0,0,1104,1102,1,0,0,0,1105,1106,7,27,0,0,1106,1107,
        5,119,0,0,1107,1108,5,249,0,0,1108,1109,5,160,0,0,1109,147,1,0,0,
        0,1110,1117,3,150,75,0,1111,1117,3,152,76,0,1112,1113,3,150,75,0,
        1113,1114,5,207,0,0,1114,1115,3,152,76,0,1115,1117,1,0,0,0,1116,
        1110,1,0,0,0,1116,1111,1,0,0,0,1116,1112,1,0,0,0,1117,149,1,0,0,
        0,1118,1119,5,23,0,0,1119,1120,3,124,62,0,1120,151,1,0,0,0,1121,
        1122,5,24,0,0,1122,1123,3,124,62,0,1123,153,1,0,0,0,1124,1125,5,
        8,0,0,1125,1128,3,124,62,0,1126,1128,3,156,78,0,1127,1124,1,0,0,
        0,1127,1126,1,0,0,0,1128,155,1,0,0,0,1129,1130,5,145,0,0,1130,1146,
        3,14,7,0,1131,1132,5,228,0,0,1132,1133,3,14,7,0,1133,1134,5,141,
        0,0,1134,1135,3,14,7,0,1135,1146,1,0,0,0,1136,1137,5,228,0,0,1137,
        1138,3,14,7,0,1138,1139,5,143,0,0,1139,1140,3,14,7,0,1140,1146,1,
        0,0,0,1141,1142,5,141,0,0,1142,1146,3,14,7,0,1143,1144,5,143,0,0,
        1144,1146,3,14,7,0,1145,1129,1,0,0,0,1145,1131,1,0,0,0,1145,1136,
        1,0,0,0,1145,1141,1,0,0,0,1145,1143,1,0,0,0,1146,157,1,0,0,0,1147,
        1149,5,208,0,0,1148,1147,1,0,0,0,1148,1149,1,0,0,0,1149,1150,1,0,
        0,0,1150,1155,5,181,0,0,1151,1155,5,16,0,0,1152,1155,5,17,0,0,1153,
        1155,5,186,0,0,1154,1148,1,0,0,0,1154,1151,1,0,0,0,1154,1152,1,0,
        0,0,1154,1153,1,0,0,0,1155,159,1,0,0,0,1156,1157,7,28,0,0,1157,161,
        1,0,0,0,1158,1162,5,219,0,0,1159,1163,3,164,82,0,1160,1163,3,166,
        83,0,1161,1163,3,168,84,0,1162,1159,1,0,0,0,1162,1160,1,0,0,0,1162,
        1161,1,0,0,0,1163,1164,1,0,0,0,1164,1165,5,260,0,0,1165,163,1,0,
        0,0,1166,1167,5,120,0,0,1167,1168,3,10,5,0,1168,165,1,0,0,0,1169,
        1170,5,203,0,0,1170,1171,3,10,5,0,1171,1172,5,145,0,0,1172,1173,
        3,6,3,0,1173,1174,5,225,0,0,1174,1175,3,6,3,0,1175,167,1,0,0,0,1176,
        1177,5,203,0,0,1177,1178,3,10,5,0,1178,1179,5,210,0,0,1179,1180,
        5,257,0,0,1180,1185,3,6,3,0,1181,1182,5,259,0,0,1182,1184,3,6,3,
        0,1183,1181,1,0,0,0,1184,1187,1,0,0,0,1185,1183,1,0,0,0,1185,1186,
        1,0,0,0,1186,1188,1,0,0,0,1187,1185,1,0,0,0,1188,1189,5,207,0,0,
        1189,1190,3,6,3,0,1190,1191,5,258,0,0,1191,169,1,0,0,0,1192,1193,
        3,144,72,0,1193,1194,7,29,0,0,1194,1219,1,0,0,0,1195,1196,3,144,
        72,0,1196,1197,7,30,0,0,1197,1198,5,249,0,0,1198,1199,5,158,0,0,
        1199,1219,1,0,0,0,1200,1201,3,144,72,0,1201,1202,7,31,0,0,1202,1203,
        3,6,3,0,1203,1219,1,0,0,0,1204,1205,3,144,72,0,1205,1206,7,32,0,
        0,1206,1207,3,6,3,0,1207,1219,1,0,0,0,1208,1209,3,144,72,0,1209,
        1210,7,33,0,0,1210,1211,3,6,3,0,1211,1219,1,0,0,0,1212,1213,3,102,
        51,0,1213,1214,5,94,0,0,1214,1219,1,0,0,0,1215,1216,3,144,72,0,1216,
        1217,5,96,0,0,1217,1219,1,0,0,0,1218,1192,1,0,0,0,1218,1195,1,0,
        0,0,1218,1200,1,0,0,0,1218,1204,1,0,0,0,1218,1208,1,0,0,0,1218,1212,
        1,0,0,0,1218,1215,1,0,0,0,1219,171,1,0,0,0,1220,1221,5,98,0,0,1221,
        1222,3,10,5,0,1222,1223,7,34,0,0,1223,173,1,0,0,0,1224,1225,5,107,
        0,0,1225,1227,3,10,5,0,1226,1228,5,262,0,0,1227,1226,1,0,0,0,1227,
        1228,1,0,0,0,1228,175,1,0,0,0,140,181,183,194,199,204,209,214,220,
        226,232,237,243,249,251,259,274,277,280,285,290,295,299,303,308,
        315,317,325,328,331,338,349,358,366,372,378,381,388,394,404,413,
        420,426,431,436,444,450,453,468,472,475,480,485,495,501,509,515,
        518,521,526,532,538,544,551,558,564,569,575,577,587,589,593,601,
        616,624,630,639,646,649,659,662,668,671,678,681,683,691,704,707,
        709,714,717,725,733,737,742,745,759,775,782,790,799,808,815,829,
        833,843,854,865,883,891,896,900,906,916,935,947,985,997,1007,1014,
        1021,1027,1035,1040,1048,1052,1066,1078,1085,1100,1102,1116,1127,
        1145,1148,1154,1162,1185,1218,1227
    ]

class RegelSpraakParser ( Parser ):

    grammarFileName = "RegelSpraak.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'het aantal dagen in'", "'het kwartaal'", 
                     "'het deel per maand'", "'het deel per jaar'", "'(voor het attribuut zonder voorzetsel):'", 
                     "'(na het attribuut met voorzetsel'", "'Datum en tijd in millisecondes'", 
                     "'gedurende de tijd dat'", "'gedurende het gehele'", 
                     "'gedurende de gehele'", "'moet berekend worden als'", 
                     "'moet gesteld worden op'", "'moet ge\\u00EFnitialiseerd worden op'", 
                     "'de absolute tijdsduur van'", "'de absolute waarde van'", 
                     "'de maximale waarde van'", "'de minimale waarde van'", 
                     "'het totaal van'", "'het tijdsevenredig deel per'", 
                     "'de datum met jaar, maand en dag'", "'de eerste paasdag van'", 
                     "'Als onverdeelde rest blijft'", "'met een minimum van'", 
                     "'met een maximum van'", "'groter of gelijk aan'", 
                     "'kleiner of gelijk aan'", "'later of gelijk aan'", 
                     "'eerder of gelijk aan'", "', waarbij wordt verdeeld'", 
                     "', bestaande uit de'", "'Wederkerig feittype'", "'is van het type'", 
                     "'de concatenatie van'", "'het volgende criterium:'", 
                     "'volgende criteria:'", "'bij even groot criterium'", 
                     "'op volgorde van'", "'naar rato van'", "'numeriek met exact'", 
                     "'aan de elfproef'", "'groter is dan'", "'kleiner is dan'", 
                     "'wordt voldaan'", "<INVALID>", "'wordt een nieuw'", 
                     "'aangemaakt'", "'Cre\\u00EBer'", "'nieuwe'", "<INVALID>", 
                     "'is gelijk aan'", "'is ongelijk aan'", "'is kleiner dan'", 
                     "'is kleiner of gelijk aan'", "'is groter dan'", "'is groter of gelijk aan'", 
                     "'zijn gelijk aan'", "'zijn ongelijk aan'", "'zijn groter dan'", 
                     "'zijn groter of gelijk aan'", "'zijn kleiner dan'", 
                     "'zijn kleiner of gelijk aan'", "'is later dan'", "'is later of gelijk aan'", 
                     "'is eerder dan'", "'is eerder of gelijk aan'", "'zijn later dan'", 
                     "'zijn later of gelijk aan'", "'zijn eerder dan'", 
                     "'zijn eerder of gelijk aan'", "'is leeg'", "'is gevuld'", 
                     "'zijn leeg'", "'zijn gevuld'", "'is kenmerk'", "'is rol'", 
                     "'zijn kenmerk'", "'zijn rol'", "'is niet kenmerk'", 
                     "'is niet rol'", "'zijn niet kenmerk'", "'zijn niet rol'", 
                     "'voldoet aan de elfproef'", "'voldoen aan de elfproef'", 
                     "'voldoet niet aan de elfproef'", "'voldoen niet aan de elfproef'", 
                     "'is numeriek met exact'", "'is niet numeriek met exact'", 
                     "'zijn numeriek met exact'", "'zijn niet numeriek met exact'", 
                     "'is een dagsoort'", "'zijn een dagsoort'", "'is geen dagsoort'", 
                     "'zijn geen dagsoort'", "'moeten uniek zijn'", "'is gevuurd'", 
                     "'is inconsistent'", "'Consistentieregel'", "'Regel'", 
                     "'Beslistabel'", "'Objecttype'", "'Domein'", "'Lijst'", 
                     "'Dimensie'", "'Eenheidsysteem'", "'Parameter'", "'FeitType'", 
                     "'Dagsoort'", "'Daarbij geldt:'", "'geldig'", "'hebben'", 
                     "'heeft'", "'indien'", "'is'", "'moet'", "'moeten'", 
                     "'wordt verdeeld over'", "'zijn'", "'aan'", "'afgerond op'", 
                     "'alle'", "'eerder dan'", "'gedeeld door'", "'gedeeld door (ABS)'", 
                     "'gelijk aan'", "'gevuld'", "'gevuurd'", "'groter dan'", 
                     "'inconsistent'", "'kleiner dan'", "'later dan'", "'leeg'", 
                     "'maal'", "'min'", "'naar beneden'", "'naar boven'", 
                     "'niet'", "'ongelijk aan'", "'plus'", "'rekenkundig'", 
                     "'richting nul'", "'tot'", "'tot de macht'", "'tot en met'", 
                     "'uniek'", "'vanaf'", "'verenigd met'", "'verminderd met'", 
                     "'voldoen'", "'voldoet'", "'weg van nul'", "'de wortel van'", 
                     "'tenminste'", "'ten minste'", "'(bezield)'", "'(bezittelijk)'", 
                     "'(bijvoeglijk)'", "'Boolean'", "'cijfers'", "'Datum in dagen'", 
                     "'decimalen'", "'Enumeratie'", "'gedimensioneerd met'", 
                     "'geheel getal'", "'getal'", "'kenmerk'", "'kenmerken'", 
                     "'met'", "'met eenheid'", "'(mv:'", "'negatief'", "'niet-negatief'", 
                     "'Numeriek'", "'Percentage'", "'positief'", "'rol'", 
                     "'rollen'", "'Tekst'", "'voor elk jaar'", "'voor elke dag'", 
                     "'voor elke maand'", "'aantal'", "'de eerste van'", 
                     "'in hele'", "'de laatste van'", "'reeks van teksten en waarden'", 
                     "'de som van'", "'de tijdsduur van'", "'afnemende'", 
                     "'in gelijke delen'", "'over.'", "'toenemende'", "'drie'", 
                     "'\\u00E9\\u00E9n'", "'geen van de'", "'precies'", 
                     "'ten hoogste'", "'twee'", "'vier'", "'altijd'", "'bij'", 
                     "'dag'", "'dat'", "'de'", "'dd.'", "'die'", "'een'", 
                     "'en'", "'het'", "'hij'", "'in'", "'jaar'", "'kwartaal'", 
                     "'maand'", "'milliseconde'", "'minuut'", "'of'", "'onwaar'", 
                     "'op'", "'over'", "'periode'", "'Rekendatum'", "'Rekenjaar'", 
                     "'regelversie'", "'seconde'", "'t/m'", "'uit'", "'uur'", 
                     "'van'", "'volgende voorwaarde'", "'volgende voorwaarden'", 
                     "'voor'", "'waar'", "'week'", "'er'", "'meter'", "'kilogram'", 
                     "'voet'", "'pond'", "'mijl'", "'m'", "'kg'", "'s'", 
                     "'ft'", "'lb'", "'mi'", "'\\u20AC'", "'$'", "<INVALID>", 
                     "<INVALID>", "'='", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "'('", "')'", "'{'", "'}'", "','", "'.'", 
                     "':'", "';'", "'/'", "'%'", "'\\u2022'", "'*'", "'\\u00AB'", 
                     "'\\u00BB'", "'^'", "<INVALID>", "<INVALID>", "'-'" ]

    symbolicNames = [ "<INVALID>", "HET_AANTAL_DAGEN_IN", "HET_KWARTAAL", 
                      "HET_DEEL_PER_MAAND", "HET_DEEL_PER_JAAR", "VOOR_HET_ATTRIBUUT_ZONDER_VOORZETSEL", 
                      "NA_HET_ATTRIBUUT_MET_VOORZETSEL", "DATUM_TIJD_MILLIS", 
                      "GEDURENDE_DE_TIJD_DAT", "GEDURENDE_HET_GEHELE", "GEDURENDE_DE_GEHELE", 
                      "WORDT_BEREKEND_ALS", "WORDT_GESTELD_OP", "WORDT_GEINITIALISEERD_OP", 
                      "DE_ABSOLUTE_TIJDSDUUR_VAN", "DE_ABSOLUTE_WAARDE_VAN", 
                      "DE_MAXIMALE_WAARDE_VAN", "DE_MINIMALE_WAARDE_VAN", 
                      "HET_TOTAAL_VAN", "HET_TIJDSEVENREDIG_DEEL_PER", "DE_DATUM_MET", 
                      "DE_EERSTE_PAASDAG_VAN", "ALS_ONVERDEELDE_REST_BLIJFT", 
                      "MET_EEN_MINIMUM_VAN", "MET_EEN_MAXIMUM_VAN", "GROTER_OF_GELIJK_AAN", 
                      "KLEINER_OF_GELIJK_AAN", "LATER_OF_GELIJK_AAN", "EERDER_OF_GELIJK_AAN", 
                      "WAARBIJ_WORDT_VERDEELD", "BESTAANDE_UIT", "WEDERKERIG_FEITTYPE", 
                      "IS_VAN_HET_TYPE", "CONCATENATIE_VAN", "VOLGEND_CRITERIUM", 
                      "VOLGENDE_CRITERIA", "BIJ_EVEN_GROOT_CRITERIUM", "OP_VOLGORDE_VAN", 
                      "NAAR_RATO_VAN", "NUMERIEK_MET_EXACT", "AAN_DE_ELFPROEF", 
                      "GROTER_IS_DAN", "KLEINER_IS_DAN", "WORDT_VOLDAAN", 
                      "ER_WORDT_EEN_NIEUW", "WORDT_EEN_NIEUW", "AANGEMAAKT", 
                      "CREEER", "NIEUWE", "ER_AAN", "IS_GELIJK_AAN", "IS_ONGELIJK_AAN", 
                      "IS_KLEINER_DAN", "IS_KLEINER_OF_GELIJK_AAN", "IS_GROTER_DAN", 
                      "IS_GROTER_OF_GELIJK_AAN", "ZIJN_GELIJK_AAN", "ZIJN_ONGELIJK_AAN", 
                      "ZIJN_GROTER_DAN", "ZIJN_GROTER_OF_GELIJK_AAN", "ZIJN_KLEINER_DAN", 
                      "ZIJN_KLEINER_OF_GELIJK_AAN", "IS_LATER_DAN", "IS_LATER_OF_GELIJK_AAN", 
                      "IS_EERDER_DAN", "IS_EERDER_OF_GELIJK_AAN", "ZIJN_LATER_DAN", 
                      "ZIJN_LATER_OF_GELIJK_AAN", "ZIJN_EERDER_DAN", "ZIJN_EERDER_OF_GELIJK_AAN", 
                      "IS_LEEG", "IS_GEVULD", "ZIJN_LEEG", "ZIJN_GEVULD", 
                      "IS_KENMERK", "IS_ROL", "ZIJN_KENMERK", "ZIJN_ROL", 
                      "IS_NIET_KENMERK", "IS_NIET_ROL", "ZIJN_NIET_KENMERK", 
                      "ZIJN_NIET_ROL", "VOLDOET_AAN_DE_ELFPROEF", "VOLDOEN_AAN_DE_ELFPROEF", 
                      "VOLDOET_NIET_AAN_DE_ELFPROEF", "VOLDOEN_NIET_AAN_DE_ELFPROEF", 
                      "IS_NUMERIEK_MET_EXACT", "IS_NIET_NUMERIEK_MET_EXACT", 
                      "ZIJN_NUMERIEK_MET_EXACT", "ZIJN_NIET_NUMERIEK_MET_EXACT", 
                      "IS_EEN_DAGSOORT", "ZIJN_EEN_DAGSOORT", "IS_GEEN_DAGSOORT", 
                      "ZIJN_GEEN_DAGSOORT", "MOETEN_UNIEK_ZIJN", "IS_GEVUURD", 
                      "IS_INCONSISTENT", "CONSISTENTIEREGEL", "REGEL", "BESLISTABEL", 
                      "OBJECTTYPE", "DOMEIN", "LIJST", "DIMENSIE", "EENHEIDSYSTEEM", 
                      "PARAMETER", "FEITTYPE", "DAGSOORT", "DAARBIJ_GELDT", 
                      "GELDIG", "HEBBEN", "HEEFT", "INDIEN", "IS", "MOET", 
                      "MOETEN", "WORDT_VERDEELD_OVER", "ZIJN", "AAN", "AFGEROND_OP", 
                      "ALLE", "EERDER_DAN", "GEDEELD_DOOR", "GEDEELD_DOOR_ABS", 
                      "GELIJK_AAN", "GEVULD", "GEVUURD", "GROTER_DAN", "INCONSISTENT", 
                      "KLEINER_DAN", "LATER_DAN", "LEEG", "MAAL", "MIN", 
                      "NAAR_BENEDEN", "NAAR_BOVEN", "NIET", "ONGELIJK_AAN", 
                      "PLUS", "REKENKUNDIG", "RICHTING_NUL", "TOT", "TOT_DE_MACHT", 
                      "TOT_EN_MET", "UNIEK", "VANAF", "VERENIGD_MET", "VERMINDERD_MET", 
                      "VOLDOEN", "VOLDOET", "WEG_VAN_NUL", "DE_WORTEL_VAN", 
                      "TENMINSTE", "TEN_MINSTE", "BEZIELD", "BEZITTELIJK", 
                      "BIJVOEGLIJK", "BOOLEAN", "CIJFERS", "DATUM_IN_DAGEN", 
                      "DECIMALEN", "ENUMERATIE", "GEDIMENSIONEERD_MET", 
                      "GEHEEL_GETAL", "GETAL", "KENMERK", "KENMERKEN", "MET", 
                      "MET_EENHEID", "MV_START", "NEGATIEF", "NIET_NEGATIEF", 
                      "NUMERIEK", "PERCENTAGE", "POSITIEF", "ROL", "ROLLEN", 
                      "TEKST", "VOOR_ELK_JAAR", "VOOR_ELKE_DAG", "VOOR_ELKE_MAAND", 
                      "AANTAL", "EERSTE_VAN", "IN_HELE", "LAATSTE_VAN", 
                      "REEKS_VAN_TEKSTEN_EN_WAARDEN", "SOM_VAN", "TIJDSDUUR_VAN", 
                      "AFNEMENDE", "IN_GELIJKE_DELEN", "OVER_VERDELING", 
                      "TOENEMENDE", "DRIE_TELWOORD", "EEN_TELWOORD", "GEEN_VAN_DE", 
                      "PRECIES", "TEN_HOOGSTE", "TWEE_TELWOORD", "VIER_TELWOORD", 
                      "ALTIJD", "BIJ", "DAG", "DAT", "DE", "DD_PUNT", "DIE", 
                      "EEN", "EN", "HET", "HIJ", "IN", "JAAR", "KWARTAAL", 
                      "MAAND", "MILLISECONDE", "MINUUT", "OF", "ONWAAR", 
                      "OP", "OVER", "PERIODE", "REKENDATUM", "REKENJAAR", 
                      "REGELVERSIE", "SECONDE", "TM", "UIT", "UUR", "VAN", 
                      "VOLGENDE_VOORWAARDE", "VOLGENDE_VOORWAARDEN", "VOOR", 
                      "WAAR", "WEEK", "ER", "METER", "KILOGRAM", "VOET", 
                      "POND", "MIJL", "M", "KG", "S", "FT", "LB", "MI", 
                      "EURO_SYMBOL", "DOLLAR_SYMBOL", "IDENTIFIER", "NUMBER", 
                      "EQUALS", "DATE_TIME_LITERAL", "PERCENTAGE_LITERAL", 
                      "STRING_LITERAL", "ENUM_LITERAL", "LPAREN", "RPAREN", 
                      "LBRACE", "RBRACE", "COMMA", "DOT", "COLON", "SEMICOLON", 
                      "SLASH", "PERCENT_SIGN", "BULLET", "ASTERISK", "L_ANGLE_QUOTE", 
                      "R_ANGLE_QUOTE", "CARET", "WS", "LINE_COMMENT", "MINUS" ]

    RULE_regelSpraakDocument = 0
    RULE_definitie = 1
    RULE_beslistabel = 2
    RULE_identifier = 3
    RULE_naamPhrase = 4
    RULE_naamwoord = 5
    RULE_voorzetsel = 6
    RULE_datumLiteral = 7
    RULE_unit = 8
    RULE_objectTypeDefinition = 9
    RULE_objectTypeMember = 10
    RULE_kenmerkSpecificatie = 11
    RULE_attribuutSpecificatie = 12
    RULE_datatype = 13
    RULE_lijstDatatype = 14
    RULE_numeriekDatatype = 15
    RULE_tekstDatatype = 16
    RULE_booleanDatatype = 17
    RULE_datumTijdDatatype = 18
    RULE_getalSpecificatie = 19
    RULE_domeinDefinition = 20
    RULE_domeinType = 21
    RULE_enumeratieSpecificatie = 22
    RULE_domeinRef = 23
    RULE_eenheidsysteemDefinition = 24
    RULE_eenheidEntry = 25
    RULE_unitIdentifier = 26
    RULE_eenheidExpressie = 27
    RULE_eenheidMacht = 28
    RULE_dimensieDefinition = 29
    RULE_voorzetselSpecificatie = 30
    RULE_labelWaardeSpecificatie = 31
    RULE_tijdlijn = 32
    RULE_dimensieRef = 33
    RULE_parameterDefinition = 34
    RULE_parameterNamePhrase = 35
    RULE_parameterMetLidwoord = 36
    RULE_feitTypeDefinition = 37
    RULE_rolSpecificatie = 38
    RULE_regel = 39
    RULE_regelName = 40
    RULE_regelVersie = 41
    RULE_versieGeldigheid = 42
    RULE_resultaatDeel = 43
    RULE_objectCreatie = 44
    RULE_objectAttributeInit = 45
    RULE_attributeInitVervolg = 46
    RULE_consistentieregel = 47
    RULE_uniekzijnResultaat = 48
    RULE_inconsistentResultaat = 49
    RULE_voorwaardeDeel = 50
    RULE_onderwerpReferentie = 51
    RULE_basisOnderwerp = 52
    RULE_attribuutReferentie = 53
    RULE_kenmerkNaam = 54
    RULE_bezieldeReferentie = 55
    RULE_toplevelSamengesteldeVoorwaarde = 56
    RULE_voorwaardeKwantificatie = 57
    RULE_samengesteldeVoorwaardeOnderdeel = 58
    RULE_genesteVoorwaarde = 59
    RULE_variabeleDeel = 60
    RULE_variabeleToekenning = 61
    RULE_expressie = 62
    RULE_logicalExpression = 63
    RULE_comparisonExpression = 64
    RULE_comparisonOperator = 65
    RULE_additiveExpression = 66
    RULE_additiveOperator = 67
    RULE_multiplicativeExpression = 68
    RULE_multiplicativeOperator = 69
    RULE_powerExpression = 70
    RULE_powerOperator = 71
    RULE_primaryExpression = 72
    RULE_afronding = 73
    RULE_begrenzing = 74
    RULE_begrenzingMinimum = 75
    RULE_begrenzingMaximum = 76
    RULE_conditieBijExpressie = 77
    RULE_periodevergelijkingEnkelvoudig = 78
    RULE_getalAggregatieFunctie = 79
    RULE_datumAggregatieFunctie = 80
    RULE_dimensieSelectie = 81
    RULE_aggregerenOverAlleDimensies = 82
    RULE_aggregerenOverVerzameling = 83
    RULE_aggregerenOverBereik = 84
    RULE_unaryCondition = 85
    RULE_regelStatusCondition = 86
    RULE_dagsoortDefinition = 87

    ruleNames =  [ "regelSpraakDocument", "definitie", "beslistabel", "identifier", 
                   "naamPhrase", "naamwoord", "voorzetsel", "datumLiteral", 
                   "unit", "objectTypeDefinition", "objectTypeMember", "kenmerkSpecificatie", 
                   "attribuutSpecificatie", "datatype", "lijstDatatype", 
                   "numeriekDatatype", "tekstDatatype", "booleanDatatype", 
                   "datumTijdDatatype", "getalSpecificatie", "domeinDefinition", 
                   "domeinType", "enumeratieSpecificatie", "domeinRef", 
                   "eenheidsysteemDefinition", "eenheidEntry", "unitIdentifier", 
                   "eenheidExpressie", "eenheidMacht", "dimensieDefinition", 
                   "voorzetselSpecificatie", "labelWaardeSpecificatie", 
                   "tijdlijn", "dimensieRef", "parameterDefinition", "parameterNamePhrase", 
                   "parameterMetLidwoord", "feitTypeDefinition", "rolSpecificatie", 
                   "regel", "regelName", "regelVersie", "versieGeldigheid", 
                   "resultaatDeel", "objectCreatie", "objectAttributeInit", 
                   "attributeInitVervolg", "consistentieregel", "uniekzijnResultaat", 
                   "inconsistentResultaat", "voorwaardeDeel", "onderwerpReferentie", 
                   "basisOnderwerp", "attribuutReferentie", "kenmerkNaam", 
                   "bezieldeReferentie", "toplevelSamengesteldeVoorwaarde", 
                   "voorwaardeKwantificatie", "samengesteldeVoorwaardeOnderdeel", 
                   "genesteVoorwaarde", "variabeleDeel", "variabeleToekenning", 
                   "expressie", "logicalExpression", "comparisonExpression", 
                   "comparisonOperator", "additiveExpression", "additiveOperator", 
                   "multiplicativeExpression", "multiplicativeOperator", 
                   "powerExpression", "powerOperator", "primaryExpression", 
                   "afronding", "begrenzing", "begrenzingMinimum", "begrenzingMaximum", 
                   "conditieBijExpressie", "periodevergelijkingEnkelvoudig", 
                   "getalAggregatieFunctie", "datumAggregatieFunctie", "dimensieSelectie", 
                   "aggregerenOverAlleDimensies", "aggregerenOverVerzameling", 
                   "aggregerenOverBereik", "unaryCondition", "regelStatusCondition", 
                   "dagsoortDefinition" ]

    EOF = Token.EOF
    HET_AANTAL_DAGEN_IN=1
    HET_KWARTAAL=2
    HET_DEEL_PER_MAAND=3
    HET_DEEL_PER_JAAR=4
    VOOR_HET_ATTRIBUUT_ZONDER_VOORZETSEL=5
    NA_HET_ATTRIBUUT_MET_VOORZETSEL=6
    DATUM_TIJD_MILLIS=7
    GEDURENDE_DE_TIJD_DAT=8
    GEDURENDE_HET_GEHELE=9
    GEDURENDE_DE_GEHELE=10
    WORDT_BEREKEND_ALS=11
    WORDT_GESTELD_OP=12
    WORDT_GEINITIALISEERD_OP=13
    DE_ABSOLUTE_TIJDSDUUR_VAN=14
    DE_ABSOLUTE_WAARDE_VAN=15
    DE_MAXIMALE_WAARDE_VAN=16
    DE_MINIMALE_WAARDE_VAN=17
    HET_TOTAAL_VAN=18
    HET_TIJDSEVENREDIG_DEEL_PER=19
    DE_DATUM_MET=20
    DE_EERSTE_PAASDAG_VAN=21
    ALS_ONVERDEELDE_REST_BLIJFT=22
    MET_EEN_MINIMUM_VAN=23
    MET_EEN_MAXIMUM_VAN=24
    GROTER_OF_GELIJK_AAN=25
    KLEINER_OF_GELIJK_AAN=26
    LATER_OF_GELIJK_AAN=27
    EERDER_OF_GELIJK_AAN=28
    WAARBIJ_WORDT_VERDEELD=29
    BESTAANDE_UIT=30
    WEDERKERIG_FEITTYPE=31
    IS_VAN_HET_TYPE=32
    CONCATENATIE_VAN=33
    VOLGEND_CRITERIUM=34
    VOLGENDE_CRITERIA=35
    BIJ_EVEN_GROOT_CRITERIUM=36
    OP_VOLGORDE_VAN=37
    NAAR_RATO_VAN=38
    NUMERIEK_MET_EXACT=39
    AAN_DE_ELFPROEF=40
    GROTER_IS_DAN=41
    KLEINER_IS_DAN=42
    WORDT_VOLDAAN=43
    ER_WORDT_EEN_NIEUW=44
    WORDT_EEN_NIEUW=45
    AANGEMAAKT=46
    CREEER=47
    NIEUWE=48
    ER_AAN=49
    IS_GELIJK_AAN=50
    IS_ONGELIJK_AAN=51
    IS_KLEINER_DAN=52
    IS_KLEINER_OF_GELIJK_AAN=53
    IS_GROTER_DAN=54
    IS_GROTER_OF_GELIJK_AAN=55
    ZIJN_GELIJK_AAN=56
    ZIJN_ONGELIJK_AAN=57
    ZIJN_GROTER_DAN=58
    ZIJN_GROTER_OF_GELIJK_AAN=59
    ZIJN_KLEINER_DAN=60
    ZIJN_KLEINER_OF_GELIJK_AAN=61
    IS_LATER_DAN=62
    IS_LATER_OF_GELIJK_AAN=63
    IS_EERDER_DAN=64
    IS_EERDER_OF_GELIJK_AAN=65
    ZIJN_LATER_DAN=66
    ZIJN_LATER_OF_GELIJK_AAN=67
    ZIJN_EERDER_DAN=68
    ZIJN_EERDER_OF_GELIJK_AAN=69
    IS_LEEG=70
    IS_GEVULD=71
    ZIJN_LEEG=72
    ZIJN_GEVULD=73
    IS_KENMERK=74
    IS_ROL=75
    ZIJN_KENMERK=76
    ZIJN_ROL=77
    IS_NIET_KENMERK=78
    IS_NIET_ROL=79
    ZIJN_NIET_KENMERK=80
    ZIJN_NIET_ROL=81
    VOLDOET_AAN_DE_ELFPROEF=82
    VOLDOEN_AAN_DE_ELFPROEF=83
    VOLDOET_NIET_AAN_DE_ELFPROEF=84
    VOLDOEN_NIET_AAN_DE_ELFPROEF=85
    IS_NUMERIEK_MET_EXACT=86
    IS_NIET_NUMERIEK_MET_EXACT=87
    ZIJN_NUMERIEK_MET_EXACT=88
    ZIJN_NIET_NUMERIEK_MET_EXACT=89
    IS_EEN_DAGSOORT=90
    ZIJN_EEN_DAGSOORT=91
    IS_GEEN_DAGSOORT=92
    ZIJN_GEEN_DAGSOORT=93
    MOETEN_UNIEK_ZIJN=94
    IS_GEVUURD=95
    IS_INCONSISTENT=96
    CONSISTENTIEREGEL=97
    REGEL=98
    BESLISTABEL=99
    OBJECTTYPE=100
    DOMEIN=101
    LIJST=102
    DIMENSIE=103
    EENHEIDSYSTEEM=104
    PARAMETER=105
    FEITTYPE=106
    DAGSOORT=107
    DAARBIJ_GELDT=108
    GELDIG=109
    HEBBEN=110
    HEEFT=111
    INDIEN=112
    IS=113
    MOET=114
    MOETEN=115
    WORDT_VERDEELD_OVER=116
    ZIJN=117
    AAN=118
    AFGEROND_OP=119
    ALLE=120
    EERDER_DAN=121
    GEDEELD_DOOR=122
    GEDEELD_DOOR_ABS=123
    GELIJK_AAN=124
    GEVULD=125
    GEVUURD=126
    GROTER_DAN=127
    INCONSISTENT=128
    KLEINER_DAN=129
    LATER_DAN=130
    LEEG=131
    MAAL=132
    MIN=133
    NAAR_BENEDEN=134
    NAAR_BOVEN=135
    NIET=136
    ONGELIJK_AAN=137
    PLUS=138
    REKENKUNDIG=139
    RICHTING_NUL=140
    TOT=141
    TOT_DE_MACHT=142
    TOT_EN_MET=143
    UNIEK=144
    VANAF=145
    VERENIGD_MET=146
    VERMINDERD_MET=147
    VOLDOEN=148
    VOLDOET=149
    WEG_VAN_NUL=150
    DE_WORTEL_VAN=151
    TENMINSTE=152
    TEN_MINSTE=153
    BEZIELD=154
    BEZITTELIJK=155
    BIJVOEGLIJK=156
    BOOLEAN=157
    CIJFERS=158
    DATUM_IN_DAGEN=159
    DECIMALEN=160
    ENUMERATIE=161
    GEDIMENSIONEERD_MET=162
    GEHEEL_GETAL=163
    GETAL=164
    KENMERK=165
    KENMERKEN=166
    MET=167
    MET_EENHEID=168
    MV_START=169
    NEGATIEF=170
    NIET_NEGATIEF=171
    NUMERIEK=172
    PERCENTAGE=173
    POSITIEF=174
    ROL=175
    ROLLEN=176
    TEKST=177
    VOOR_ELK_JAAR=178
    VOOR_ELKE_DAG=179
    VOOR_ELKE_MAAND=180
    AANTAL=181
    EERSTE_VAN=182
    IN_HELE=183
    LAATSTE_VAN=184
    REEKS_VAN_TEKSTEN_EN_WAARDEN=185
    SOM_VAN=186
    TIJDSDUUR_VAN=187
    AFNEMENDE=188
    IN_GELIJKE_DELEN=189
    OVER_VERDELING=190
    TOENEMENDE=191
    DRIE_TELWOORD=192
    EEN_TELWOORD=193
    GEEN_VAN_DE=194
    PRECIES=195
    TEN_HOOGSTE=196
    TWEE_TELWOORD=197
    VIER_TELWOORD=198
    ALTIJD=199
    BIJ=200
    DAG=201
    DAT=202
    DE=203
    DD_PUNT=204
    DIE=205
    EEN=206
    EN=207
    HET=208
    HIJ=209
    IN=210
    JAAR=211
    KWARTAAL=212
    MAAND=213
    MILLISECONDE=214
    MINUUT=215
    OF=216
    ONWAAR=217
    OP=218
    OVER=219
    PERIODE=220
    REKENDATUM=221
    REKENJAAR=222
    REGELVERSIE=223
    SECONDE=224
    TM=225
    UIT=226
    UUR=227
    VAN=228
    VOLGENDE_VOORWAARDE=229
    VOLGENDE_VOORWAARDEN=230
    VOOR=231
    WAAR=232
    WEEK=233
    ER=234
    METER=235
    KILOGRAM=236
    VOET=237
    POND=238
    MIJL=239
    M=240
    KG=241
    S=242
    FT=243
    LB=244
    MI=245
    EURO_SYMBOL=246
    DOLLAR_SYMBOL=247
    IDENTIFIER=248
    NUMBER=249
    EQUALS=250
    DATE_TIME_LITERAL=251
    PERCENTAGE_LITERAL=252
    STRING_LITERAL=253
    ENUM_LITERAL=254
    LPAREN=255
    RPAREN=256
    LBRACE=257
    RBRACE=258
    COMMA=259
    DOT=260
    COLON=261
    SEMICOLON=262
    SLASH=263
    PERCENT_SIGN=264
    BULLET=265
    ASTERISK=266
    L_ANGLE_QUOTE=267
    R_ANGLE_QUOTE=268
    CARET=269
    WS=270
    LINE_COMMENT=271
    MINUS=272

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.13.1")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class RegelSpraakDocumentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOF(self):
            return self.getToken(RegelSpraakParser.EOF, 0)

        def definitie(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.DefinitieContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.DefinitieContext,i)


        def regel(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.RegelContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.RegelContext,i)


        def beslistabel(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.BeslistabelContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.BeslistabelContext,i)


        def consistentieregel(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.ConsistentieregelContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.ConsistentieregelContext,i)


        def eenheidsysteemDefinition(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.EenheidsysteemDefinitionContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.EenheidsysteemDefinitionContext,i)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_regelSpraakDocument

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRegelSpraakDocument" ):
                listener.enterRegelSpraakDocument(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRegelSpraakDocument" ):
                listener.exitRegelSpraakDocument(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRegelSpraakDocument" ):
                return visitor.visitRegelSpraakDocument(self)
            else:
                return visitor.visitChildren(self)




    def regelSpraakDocument(self):

        localctx = RegelSpraakParser.RegelSpraakDocumentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_regelSpraakDocument)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 183
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==31 or ((((_la - 97)) & ~0x3f) == 0 and ((1 << (_la - 97)) & 2015) != 0):
                self.state = 181
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [31, 100, 101, 103, 105, 106, 107]:
                    self.state = 176
                    self.definitie()
                    pass
                elif token in [98]:
                    self.state = 177
                    self.regel()
                    pass
                elif token in [99]:
                    self.state = 178
                    self.beslistabel()
                    pass
                elif token in [97]:
                    self.state = 179
                    self.consistentieregel()
                    pass
                elif token in [104]:
                    self.state = 180
                    self.eenheidsysteemDefinition()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 185
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 186
            self.match(RegelSpraakParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DefinitieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def objectTypeDefinition(self):
            return self.getTypedRuleContext(RegelSpraakParser.ObjectTypeDefinitionContext,0)


        def domeinDefinition(self):
            return self.getTypedRuleContext(RegelSpraakParser.DomeinDefinitionContext,0)


        def parameterDefinition(self):
            return self.getTypedRuleContext(RegelSpraakParser.ParameterDefinitionContext,0)


        def dimensieDefinition(self):
            return self.getTypedRuleContext(RegelSpraakParser.DimensieDefinitionContext,0)


        def feitTypeDefinition(self):
            return self.getTypedRuleContext(RegelSpraakParser.FeitTypeDefinitionContext,0)


        def dagsoortDefinition(self):
            return self.getTypedRuleContext(RegelSpraakParser.DagsoortDefinitionContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_definitie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDefinitie" ):
                listener.enterDefinitie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDefinitie" ):
                listener.exitDefinitie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDefinitie" ):
                return visitor.visitDefinitie(self)
            else:
                return visitor.visitChildren(self)




    def definitie(self):

        localctx = RegelSpraakParser.DefinitieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_definitie)
        try:
            self.state = 194
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [100]:
                self.enterOuterAlt(localctx, 1)
                self.state = 188
                self.objectTypeDefinition()
                pass
            elif token in [101]:
                self.enterOuterAlt(localctx, 2)
                self.state = 189
                self.domeinDefinition()
                pass
            elif token in [105]:
                self.enterOuterAlt(localctx, 3)
                self.state = 190
                self.parameterDefinition()
                pass
            elif token in [103]:
                self.enterOuterAlt(localctx, 4)
                self.state = 191
                self.dimensieDefinition()
                pass
            elif token in [31, 106]:
                self.enterOuterAlt(localctx, 5)
                self.state = 192
                self.feitTypeDefinition()
                pass
            elif token in [107]:
                self.enterOuterAlt(localctx, 6)
                self.state = 193
                self.dagsoortDefinition()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BeslistabelContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BESLISTABEL(self):
            return self.getToken(RegelSpraakParser.BESLISTABEL, 0)

        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def regelVersie(self):
            return self.getTypedRuleContext(RegelSpraakParser.RegelVersieContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_beslistabel

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBeslistabel" ):
                listener.enterBeslistabel(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBeslistabel" ):
                listener.exitBeslistabel(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBeslistabel" ):
                return visitor.visitBeslistabel(self)
            else:
                return visitor.visitChildren(self)




    def beslistabel(self):

        localctx = RegelSpraakParser.BeslistabelContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_beslistabel)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 196
            self.match(RegelSpraakParser.BESLISTABEL)
            self.state = 197
            self.naamwoord()
            self.state = 199
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==109:
                self.state = 198
                self.regelVersie()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IdentifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(RegelSpraakParser.IDENTIFIER, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_identifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIdentifier" ):
                listener.enterIdentifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIdentifier" ):
                listener.exitIdentifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIdentifier" ):
                return visitor.visitIdentifier(self)
            else:
                return visitor.visitChildren(self)




    def identifier(self):

        localctx = RegelSpraakParser.IdentifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_identifier)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 201
            self.match(RegelSpraakParser.IDENTIFIER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NaamPhraseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.IDENTIFIER)
            else:
                return self.getToken(RegelSpraakParser.IDENTIFIER, i)

        def DE(self):
            return self.getToken(RegelSpraakParser.DE, 0)

        def HET(self):
            return self.getToken(RegelSpraakParser.HET, 0)

        def ZIJN(self):
            return self.getToken(RegelSpraakParser.ZIJN, 0)

        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.IdentifierContext,i)


        def NIEUWE(self):
            return self.getToken(RegelSpraakParser.NIEUWE, 0)

        def MET(self):
            return self.getToken(RegelSpraakParser.MET, 0)

        def NIET(self):
            return self.getToken(RegelSpraakParser.NIET, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_naamPhrase

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNaamPhrase" ):
                listener.enterNaamPhrase(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNaamPhrase" ):
                listener.exitNaamPhrase(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNaamPhrase" ):
                return visitor.visitNaamPhrase(self)
            else:
                return visitor.visitChildren(self)




    def naamPhrase(self):

        localctx = RegelSpraakParser.NaamPhraseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_naamPhrase)
        self._la = 0 # Token type
        try:
            self.state = 251
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,13,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 204
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==117 or _la==203 or _la==208:
                    self.state = 203
                    _la = self._input.LA(1)
                    if not(_la==117 or _la==203 or _la==208):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                self.state = 207 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 206
                        self.match(RegelSpraakParser.IDENTIFIER)

                    else:
                        raise NoViableAltException(self)
                    self.state = 209 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,5,self._ctx)

                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 212 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 211
                        self.identifier()

                    else:
                        raise NoViableAltException(self)
                    self.state = 214 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,6,self._ctx)

                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 216
                self.match(RegelSpraakParser.NIEUWE)
                self.state = 218 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 217
                        self.match(RegelSpraakParser.IDENTIFIER)

                    else:
                        raise NoViableAltException(self)
                    self.state = 220 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,7,self._ctx)

                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 222
                self.match(RegelSpraakParser.NIEUWE)
                self.state = 224 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 223
                    self.match(RegelSpraakParser.IDENTIFIER)
                    self.state = 226 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==248):
                        break

                self.state = 228
                self.match(RegelSpraakParser.MET)
                self.state = 230 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 229
                        self.match(RegelSpraakParser.IDENTIFIER)

                    else:
                        raise NoViableAltException(self)
                    self.state = 232 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,9,self._ctx)

                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 235 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 234
                    self.identifier()
                    self.state = 237 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==248):
                        break

                self.state = 239
                self.match(RegelSpraakParser.MET)
                self.state = 241 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 240
                        self.identifier()

                    else:
                        raise NoViableAltException(self)
                    self.state = 243 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,11,self._ctx)

                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 245
                self.match(RegelSpraakParser.NIET)
                self.state = 247 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 246
                        self.match(RegelSpraakParser.IDENTIFIER)

                    else:
                        raise NoViableAltException(self)
                    self.state = 249 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,12,self._ctx)

                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NaamwoordContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def naamPhrase(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.NaamPhraseContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.NaamPhraseContext,i)


        def voorzetsel(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.VoorzetselContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.VoorzetselContext,i)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_naamwoord

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNaamwoord" ):
                listener.enterNaamwoord(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNaamwoord" ):
                listener.exitNaamwoord(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNaamwoord" ):
                return visitor.visitNaamwoord(self)
            else:
                return visitor.visitChildren(self)




    def naamwoord(self):

        localctx = RegelSpraakParser.NaamwoordContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_naamwoord)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 253
            self.naamPhrase()
            self.state = 259
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,14,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 254
                    self.voorzetsel()
                    self.state = 255
                    self.naamPhrase() 
                self.state = 261
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,14,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VoorzetselContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def VAN(self):
            return self.getToken(RegelSpraakParser.VAN, 0)

        def IN(self):
            return self.getToken(RegelSpraakParser.IN, 0)

        def VOOR(self):
            return self.getToken(RegelSpraakParser.VOOR, 0)

        def OVER(self):
            return self.getToken(RegelSpraakParser.OVER, 0)

        def OP(self):
            return self.getToken(RegelSpraakParser.OP, 0)

        def BIJ(self):
            return self.getToken(RegelSpraakParser.BIJ, 0)

        def UIT(self):
            return self.getToken(RegelSpraakParser.UIT, 0)

        def TOT(self):
            return self.getToken(RegelSpraakParser.TOT, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_voorzetsel

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVoorzetsel" ):
                listener.enterVoorzetsel(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVoorzetsel" ):
                listener.exitVoorzetsel(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVoorzetsel" ):
                return visitor.visitVoorzetsel(self)
            else:
                return visitor.visitChildren(self)




    def voorzetsel(self):

        localctx = RegelSpraakParser.VoorzetselContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_voorzetsel)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 262
            _la = self._input.LA(1)
            if not(_la==141 or _la==200 or ((((_la - 210)) & ~0x3f) == 0 and ((1 << (_la - 210)) & 2425601) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DatumLiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DATE_TIME_LITERAL(self):
            return self.getToken(RegelSpraakParser.DATE_TIME_LITERAL, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_datumLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDatumLiteral" ):
                listener.enterDatumLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDatumLiteral" ):
                listener.exitDatumLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDatumLiteral" ):
                return visitor.visitDatumLiteral(self)
            else:
                return visitor.visitChildren(self)




    def datumLiteral(self):

        localctx = RegelSpraakParser.DatumLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_datumLiteral)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 264
            self.match(RegelSpraakParser.DATE_TIME_LITERAL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UnitContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(RegelSpraakParser.IDENTIFIER, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_unit

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnit" ):
                listener.enterUnit(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnit" ):
                listener.exitUnit(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnit" ):
                return visitor.visitUnit(self)
            else:
                return visitor.visitChildren(self)




    def unit(self):

        localctx = RegelSpraakParser.UnitContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_unit)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 266
            self.match(RegelSpraakParser.IDENTIFIER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ObjectTypeDefinitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self._IDENTIFIER = None # Token
            self.plural = list() # of Tokens

        def OBJECTTYPE(self):
            return self.getToken(RegelSpraakParser.OBJECTTYPE, 0)

        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def MV_START(self):
            return self.getToken(RegelSpraakParser.MV_START, 0)

        def RPAREN(self):
            return self.getToken(RegelSpraakParser.RPAREN, 0)

        def BEZIELD(self):
            return self.getToken(RegelSpraakParser.BEZIELD, 0)

        def objectTypeMember(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.ObjectTypeMemberContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.ObjectTypeMemberContext,i)


        def IDENTIFIER(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.IDENTIFIER)
            else:
                return self.getToken(RegelSpraakParser.IDENTIFIER, i)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_objectTypeDefinition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterObjectTypeDefinition" ):
                listener.enterObjectTypeDefinition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitObjectTypeDefinition" ):
                listener.exitObjectTypeDefinition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitObjectTypeDefinition" ):
                return visitor.visitObjectTypeDefinition(self)
            else:
                return visitor.visitChildren(self)




    def objectTypeDefinition(self):

        localctx = RegelSpraakParser.ObjectTypeDefinitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_objectTypeDefinition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 268
            self.match(RegelSpraakParser.OBJECTTYPE)
            self.state = 269
            self.naamwoord()
            self.state = 277
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==169:
                self.state = 270
                self.match(RegelSpraakParser.MV_START)
                self.state = 272 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 271
                    localctx._IDENTIFIER = self.match(RegelSpraakParser.IDENTIFIER)
                    localctx.plural.append(localctx._IDENTIFIER)
                    self.state = 274 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==248):
                        break

                self.state = 276
                self.match(RegelSpraakParser.RPAREN)


            self.state = 280
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==154:
                self.state = 279
                self.match(RegelSpraakParser.BEZIELD)


            self.state = 285
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==48 or ((((_la - 113)) & ~0x3f) == 0 and ((1 << (_la - 113)) & 8388625) != 0) or ((((_la - 203)) & ~0x3f) == 0 and ((1 << (_la - 203)) & 35184372088865) != 0):
                self.state = 282
                self.objectTypeMember()
                self.state = 287
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ObjectTypeMemberContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SEMICOLON(self):
            return self.getToken(RegelSpraakParser.SEMICOLON, 0)

        def kenmerkSpecificatie(self):
            return self.getTypedRuleContext(RegelSpraakParser.KenmerkSpecificatieContext,0)


        def attribuutSpecificatie(self):
            return self.getTypedRuleContext(RegelSpraakParser.AttribuutSpecificatieContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_objectTypeMember

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterObjectTypeMember" ):
                listener.enterObjectTypeMember(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitObjectTypeMember" ):
                listener.exitObjectTypeMember(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitObjectTypeMember" ):
                return visitor.visitObjectTypeMember(self)
            else:
                return visitor.visitChildren(self)




    def objectTypeMember(self):

        localctx = RegelSpraakParser.ObjectTypeMemberContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_objectTypeMember)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 290
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,19,self._ctx)
            if la_ == 1:
                self.state = 288
                self.kenmerkSpecificatie()
                pass

            elif la_ == 2:
                self.state = 289
                self.attribuutSpecificatie()
                pass


            self.state = 292
            self.match(RegelSpraakParser.SEMICOLON)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class KenmerkSpecificatieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KENMERK(self):
            return self.getToken(RegelSpraakParser.KENMERK, 0)

        def identifier(self):
            return self.getTypedRuleContext(RegelSpraakParser.IdentifierContext,0)


        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def BIJVOEGLIJK(self):
            return self.getToken(RegelSpraakParser.BIJVOEGLIJK, 0)

        def BEZITTELIJK(self):
            return self.getToken(RegelSpraakParser.BEZITTELIJK, 0)

        def IS(self):
            return self.getToken(RegelSpraakParser.IS, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_kenmerkSpecificatie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterKenmerkSpecificatie" ):
                listener.enterKenmerkSpecificatie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitKenmerkSpecificatie" ):
                listener.exitKenmerkSpecificatie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitKenmerkSpecificatie" ):
                return visitor.visitKenmerkSpecificatie(self)
            else:
                return visitor.visitChildren(self)




    def kenmerkSpecificatie(self):

        localctx = RegelSpraakParser.KenmerkSpecificatieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_kenmerkSpecificatie)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 299
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,21,self._ctx)
            if la_ == 1:
                self.state = 295
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==113:
                    self.state = 294
                    self.match(RegelSpraakParser.IS)


                self.state = 297
                self.identifier()
                pass

            elif la_ == 2:
                self.state = 298
                self.naamwoord()
                pass


            self.state = 301
            self.match(RegelSpraakParser.KENMERK)
            self.state = 303
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==155 or _la==156:
                self.state = 302
                _la = self._input.LA(1)
                if not(_la==155 or _la==156):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AttribuutSpecificatieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.unitName = None # Token

        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def datatype(self):
            return self.getTypedRuleContext(RegelSpraakParser.DatatypeContext,0)


        def domeinRef(self):
            return self.getTypedRuleContext(RegelSpraakParser.DomeinRefContext,0)


        def MET_EENHEID(self):
            return self.getToken(RegelSpraakParser.MET_EENHEID, 0)

        def GEDIMENSIONEERD_MET(self):
            return self.getToken(RegelSpraakParser.GEDIMENSIONEERD_MET, 0)

        def dimensieRef(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.DimensieRefContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.DimensieRefContext,i)


        def tijdlijn(self):
            return self.getTypedRuleContext(RegelSpraakParser.TijdlijnContext,0)


        def PERCENT_SIGN(self):
            return self.getToken(RegelSpraakParser.PERCENT_SIGN, 0)

        def EURO_SYMBOL(self):
            return self.getToken(RegelSpraakParser.EURO_SYMBOL, 0)

        def DOLLAR_SYMBOL(self):
            return self.getToken(RegelSpraakParser.DOLLAR_SYMBOL, 0)

        def IDENTIFIER(self):
            return self.getToken(RegelSpraakParser.IDENTIFIER, 0)

        def EN(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.EN)
            else:
                return self.getToken(RegelSpraakParser.EN, i)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_attribuutSpecificatie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAttribuutSpecificatie" ):
                listener.enterAttribuutSpecificatie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAttribuutSpecificatie" ):
                listener.exitAttribuutSpecificatie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAttribuutSpecificatie" ):
                return visitor.visitAttribuutSpecificatie(self)
            else:
                return visitor.visitChildren(self)




    def attribuutSpecificatie(self):

        localctx = RegelSpraakParser.AttribuutSpecificatieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_attribuutSpecificatie)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 305
            self.naamwoord()
            self.state = 308
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [7, 102, 157, 159, 172, 177]:
                self.state = 306
                self.datatype()
                pass
            elif token in [101]:
                self.state = 307
                self.domeinRef()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 317
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==168:
                self.state = 310
                self.match(RegelSpraakParser.MET_EENHEID)
                self.state = 315
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [248]:
                    self.state = 311
                    localctx.unitName = self.match(RegelSpraakParser.IDENTIFIER)
                    pass
                elif token in [264]:
                    self.state = 312
                    self.match(RegelSpraakParser.PERCENT_SIGN)
                    pass
                elif token in [246]:
                    self.state = 313
                    self.match(RegelSpraakParser.EURO_SYMBOL)
                    pass
                elif token in [247]:
                    self.state = 314
                    self.match(RegelSpraakParser.DOLLAR_SYMBOL)
                    pass
                else:
                    raise NoViableAltException(self)



            self.state = 328
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==162:
                self.state = 319
                self.match(RegelSpraakParser.GEDIMENSIONEERD_MET)
                self.state = 320
                self.dimensieRef()
                self.state = 325
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==207:
                    self.state = 321
                    self.match(RegelSpraakParser.EN)
                    self.state = 322
                    self.dimensieRef()
                    self.state = 327
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)



            self.state = 331
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 178)) & ~0x3f) == 0 and ((1 << (_la - 178)) & 7) != 0):
                self.state = 330
                self.tijdlijn()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DatatypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def numeriekDatatype(self):
            return self.getTypedRuleContext(RegelSpraakParser.NumeriekDatatypeContext,0)


        def tekstDatatype(self):
            return self.getTypedRuleContext(RegelSpraakParser.TekstDatatypeContext,0)


        def booleanDatatype(self):
            return self.getTypedRuleContext(RegelSpraakParser.BooleanDatatypeContext,0)


        def datumTijdDatatype(self):
            return self.getTypedRuleContext(RegelSpraakParser.DatumTijdDatatypeContext,0)


        def lijstDatatype(self):
            return self.getTypedRuleContext(RegelSpraakParser.LijstDatatypeContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_datatype

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDatatype" ):
                listener.enterDatatype(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDatatype" ):
                listener.exitDatatype(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDatatype" ):
                return visitor.visitDatatype(self)
            else:
                return visitor.visitChildren(self)




    def datatype(self):

        localctx = RegelSpraakParser.DatatypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_datatype)
        try:
            self.state = 338
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [172]:
                self.enterOuterAlt(localctx, 1)
                self.state = 333
                self.numeriekDatatype()
                pass
            elif token in [177]:
                self.enterOuterAlt(localctx, 2)
                self.state = 334
                self.tekstDatatype()
                pass
            elif token in [157]:
                self.enterOuterAlt(localctx, 3)
                self.state = 335
                self.booleanDatatype()
                pass
            elif token in [7, 159]:
                self.enterOuterAlt(localctx, 4)
                self.state = 336
                self.datumTijdDatatype()
                pass
            elif token in [102]:
                self.enterOuterAlt(localctx, 5)
                self.state = 337
                self.lijstDatatype()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LijstDatatypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LIJST(self):
            return self.getToken(RegelSpraakParser.LIJST, 0)

        def VAN(self):
            return self.getToken(RegelSpraakParser.VAN, 0)

        def datatype(self):
            return self.getTypedRuleContext(RegelSpraakParser.DatatypeContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_lijstDatatype

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLijstDatatype" ):
                listener.enterLijstDatatype(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLijstDatatype" ):
                listener.exitLijstDatatype(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLijstDatatype" ):
                return visitor.visitLijstDatatype(self)
            else:
                return visitor.visitChildren(self)




    def lijstDatatype(self):

        localctx = RegelSpraakParser.LijstDatatypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_lijstDatatype)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 340
            self.match(RegelSpraakParser.LIJST)
            self.state = 341
            self.match(RegelSpraakParser.VAN)
            self.state = 342
            self.datatype()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NumeriekDatatypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NUMERIEK(self):
            return self.getToken(RegelSpraakParser.NUMERIEK, 0)

        def LPAREN(self):
            return self.getToken(RegelSpraakParser.LPAREN, 0)

        def getalSpecificatie(self):
            return self.getTypedRuleContext(RegelSpraakParser.GetalSpecificatieContext,0)


        def RPAREN(self):
            return self.getToken(RegelSpraakParser.RPAREN, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_numeriekDatatype

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumeriekDatatype" ):
                listener.enterNumeriekDatatype(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumeriekDatatype" ):
                listener.exitNumeriekDatatype(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNumeriekDatatype" ):
                return visitor.visitNumeriekDatatype(self)
            else:
                return visitor.visitChildren(self)




    def numeriekDatatype(self):

        localctx = RegelSpraakParser.NumeriekDatatypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_numeriekDatatype)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 344
            self.match(RegelSpraakParser.NUMERIEK)
            self.state = 349
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==255:
                self.state = 345
                self.match(RegelSpraakParser.LPAREN)
                self.state = 346
                self.getalSpecificatie()
                self.state = 347
                self.match(RegelSpraakParser.RPAREN)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TekstDatatypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TEKST(self):
            return self.getToken(RegelSpraakParser.TEKST, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_tekstDatatype

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTekstDatatype" ):
                listener.enterTekstDatatype(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTekstDatatype" ):
                listener.exitTekstDatatype(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTekstDatatype" ):
                return visitor.visitTekstDatatype(self)
            else:
                return visitor.visitChildren(self)




    def tekstDatatype(self):

        localctx = RegelSpraakParser.TekstDatatypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_tekstDatatype)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 351
            self.match(RegelSpraakParser.TEKST)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BooleanDatatypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BOOLEAN(self):
            return self.getToken(RegelSpraakParser.BOOLEAN, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_booleanDatatype

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBooleanDatatype" ):
                listener.enterBooleanDatatype(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBooleanDatatype" ):
                listener.exitBooleanDatatype(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBooleanDatatype" ):
                return visitor.visitBooleanDatatype(self)
            else:
                return visitor.visitChildren(self)




    def booleanDatatype(self):

        localctx = RegelSpraakParser.BooleanDatatypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_booleanDatatype)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 353
            self.match(RegelSpraakParser.BOOLEAN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DatumTijdDatatypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DATUM_IN_DAGEN(self):
            return self.getToken(RegelSpraakParser.DATUM_IN_DAGEN, 0)

        def DATUM_TIJD_MILLIS(self):
            return self.getToken(RegelSpraakParser.DATUM_TIJD_MILLIS, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_datumTijdDatatype

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDatumTijdDatatype" ):
                listener.enterDatumTijdDatatype(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDatumTijdDatatype" ):
                listener.exitDatumTijdDatatype(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDatumTijdDatatype" ):
                return visitor.visitDatumTijdDatatype(self)
            else:
                return visitor.visitChildren(self)




    def datumTijdDatatype(self):

        localctx = RegelSpraakParser.DatumTijdDatatypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_datumTijdDatatype)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 355
            _la = self._input.LA(1)
            if not(_la==7 or _la==159):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GetalSpecificatieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GEHEEL_GETAL(self):
            return self.getToken(RegelSpraakParser.GEHEEL_GETAL, 0)

        def GETAL(self):
            return self.getToken(RegelSpraakParser.GETAL, 0)

        def NEGATIEF(self):
            return self.getToken(RegelSpraakParser.NEGATIEF, 0)

        def NIET_NEGATIEF(self):
            return self.getToken(RegelSpraakParser.NIET_NEGATIEF, 0)

        def POSITIEF(self):
            return self.getToken(RegelSpraakParser.POSITIEF, 0)

        def MET(self):
            return self.getToken(RegelSpraakParser.MET, 0)

        def NUMBER(self):
            return self.getToken(RegelSpraakParser.NUMBER, 0)

        def DECIMALEN(self):
            return self.getToken(RegelSpraakParser.DECIMALEN, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_getalSpecificatie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGetalSpecificatie" ):
                listener.enterGetalSpecificatie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGetalSpecificatie" ):
                listener.exitGetalSpecificatie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGetalSpecificatie" ):
                return visitor.visitGetalSpecificatie(self)
            else:
                return visitor.visitChildren(self)




    def getalSpecificatie(self):

        localctx = RegelSpraakParser.GetalSpecificatieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_getalSpecificatie)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 358
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 170)) & ~0x3f) == 0 and ((1 << (_la - 170)) & 19) != 0):
                self.state = 357
                _la = self._input.LA(1)
                if not(((((_la - 170)) & ~0x3f) == 0 and ((1 << (_la - 170)) & 19) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


            self.state = 366
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,32,self._ctx)
            if la_ == 1:
                self.state = 360
                self.match(RegelSpraakParser.GEHEEL_GETAL)
                pass

            elif la_ == 2:
                self.state = 361
                self.match(RegelSpraakParser.GETAL)
                self.state = 362
                self.match(RegelSpraakParser.MET)
                self.state = 363
                self.match(RegelSpraakParser.NUMBER)
                self.state = 364
                self.match(RegelSpraakParser.DECIMALEN)
                pass

            elif la_ == 3:
                self.state = 365
                self.match(RegelSpraakParser.GETAL)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DomeinDefinitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self._IDENTIFIER = None # Token
            self.name = list() # of Tokens

        def DOMEIN(self):
            return self.getToken(RegelSpraakParser.DOMEIN, 0)

        def IS_VAN_HET_TYPE(self):
            return self.getToken(RegelSpraakParser.IS_VAN_HET_TYPE, 0)

        def domeinType(self):
            return self.getTypedRuleContext(RegelSpraakParser.DomeinTypeContext,0)


        def MET_EENHEID(self):
            return self.getToken(RegelSpraakParser.MET_EENHEID, 0)

        def eenheidExpressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.EenheidExpressieContext,0)


        def SEMICOLON(self):
            return self.getToken(RegelSpraakParser.SEMICOLON, 0)

        def IDENTIFIER(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.IDENTIFIER)
            else:
                return self.getToken(RegelSpraakParser.IDENTIFIER, i)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_domeinDefinition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDomeinDefinition" ):
                listener.enterDomeinDefinition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDomeinDefinition" ):
                listener.exitDomeinDefinition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDomeinDefinition" ):
                return visitor.visitDomeinDefinition(self)
            else:
                return visitor.visitChildren(self)




    def domeinDefinition(self):

        localctx = RegelSpraakParser.DomeinDefinitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_domeinDefinition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 368
            self.match(RegelSpraakParser.DOMEIN)
            self.state = 370 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 369
                localctx._IDENTIFIER = self.match(RegelSpraakParser.IDENTIFIER)
                localctx.name.append(localctx._IDENTIFIER)
                self.state = 372 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==248):
                    break

            self.state = 374
            self.match(RegelSpraakParser.IS_VAN_HET_TYPE)
            self.state = 375
            self.domeinType()
            self.state = 378
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==168:
                self.state = 376
                self.match(RegelSpraakParser.MET_EENHEID)
                self.state = 377
                self.eenheidExpressie()


            self.state = 381
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==262:
                self.state = 380
                self.match(RegelSpraakParser.SEMICOLON)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DomeinTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def enumeratieSpecificatie(self):
            return self.getTypedRuleContext(RegelSpraakParser.EnumeratieSpecificatieContext,0)


        def numeriekDatatype(self):
            return self.getTypedRuleContext(RegelSpraakParser.NumeriekDatatypeContext,0)


        def tekstDatatype(self):
            return self.getTypedRuleContext(RegelSpraakParser.TekstDatatypeContext,0)


        def booleanDatatype(self):
            return self.getTypedRuleContext(RegelSpraakParser.BooleanDatatypeContext,0)


        def datumTijdDatatype(self):
            return self.getTypedRuleContext(RegelSpraakParser.DatumTijdDatatypeContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_domeinType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDomeinType" ):
                listener.enterDomeinType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDomeinType" ):
                listener.exitDomeinType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDomeinType" ):
                return visitor.visitDomeinType(self)
            else:
                return visitor.visitChildren(self)




    def domeinType(self):

        localctx = RegelSpraakParser.DomeinTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_domeinType)
        try:
            self.state = 388
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [161]:
                self.enterOuterAlt(localctx, 1)
                self.state = 383
                self.enumeratieSpecificatie()
                pass
            elif token in [172]:
                self.enterOuterAlt(localctx, 2)
                self.state = 384
                self.numeriekDatatype()
                pass
            elif token in [177]:
                self.enterOuterAlt(localctx, 3)
                self.state = 385
                self.tekstDatatype()
                pass
            elif token in [157]:
                self.enterOuterAlt(localctx, 4)
                self.state = 386
                self.booleanDatatype()
                pass
            elif token in [7, 159]:
                self.enterOuterAlt(localctx, 5)
                self.state = 387
                self.datumTijdDatatype()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EnumeratieSpecificatieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ENUMERATIE(self):
            return self.getToken(RegelSpraakParser.ENUMERATIE, 0)

        def ENUM_LITERAL(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.ENUM_LITERAL)
            else:
                return self.getToken(RegelSpraakParser.ENUM_LITERAL, i)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_enumeratieSpecificatie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEnumeratieSpecificatie" ):
                listener.enterEnumeratieSpecificatie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEnumeratieSpecificatie" ):
                listener.exitEnumeratieSpecificatie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEnumeratieSpecificatie" ):
                return visitor.visitEnumeratieSpecificatie(self)
            else:
                return visitor.visitChildren(self)




    def enumeratieSpecificatie(self):

        localctx = RegelSpraakParser.EnumeratieSpecificatieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_enumeratieSpecificatie)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 390
            self.match(RegelSpraakParser.ENUMERATIE)
            self.state = 392 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 391
                self.match(RegelSpraakParser.ENUM_LITERAL)
                self.state = 394 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==254):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DomeinRefContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.name = None # Token

        def DOMEIN(self):
            return self.getToken(RegelSpraakParser.DOMEIN, 0)

        def IDENTIFIER(self):
            return self.getToken(RegelSpraakParser.IDENTIFIER, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_domeinRef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDomeinRef" ):
                listener.enterDomeinRef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDomeinRef" ):
                listener.exitDomeinRef(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDomeinRef" ):
                return visitor.visitDomeinRef(self)
            else:
                return visitor.visitChildren(self)




    def domeinRef(self):

        localctx = RegelSpraakParser.DomeinRefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_domeinRef)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 396
            self.match(RegelSpraakParser.DOMEIN)
            self.state = 397
            localctx.name = self.match(RegelSpraakParser.IDENTIFIER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EenheidsysteemDefinitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.name = None # IdentifierContext

        def EENHEIDSYSTEEM(self):
            return self.getToken(RegelSpraakParser.EENHEIDSYSTEEM, 0)

        def identifier(self):
            return self.getTypedRuleContext(RegelSpraakParser.IdentifierContext,0)


        def eenheidEntry(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.EenheidEntryContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.EenheidEntryContext,i)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_eenheidsysteemDefinition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEenheidsysteemDefinition" ):
                listener.enterEenheidsysteemDefinition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEenheidsysteemDefinition" ):
                listener.exitEenheidsysteemDefinition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEenheidsysteemDefinition" ):
                return visitor.visitEenheidsysteemDefinition(self)
            else:
                return visitor.visitChildren(self)




    def eenheidsysteemDefinition(self):

        localctx = RegelSpraakParser.EenheidsysteemDefinitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_eenheidsysteemDefinition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 399
            self.match(RegelSpraakParser.EENHEIDSYSTEEM)
            self.state = 400
            localctx.name = self.identifier()
            self.state = 404
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==203:
                self.state = 401
                self.eenheidEntry()
                self.state = 406
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EenheidEntryContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.unitName = None # UnitIdentifierContext
            self.abbrev = None # UnitIdentifierContext
            self.value = None # Token
            self.targetUnit = None # UnitIdentifierContext

        def DE(self):
            return self.getToken(RegelSpraakParser.DE, 0)

        def unitIdentifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.UnitIdentifierContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.UnitIdentifierContext,i)


        def EQUALS(self):
            return self.getToken(RegelSpraakParser.EQUALS, 0)

        def NUMBER(self):
            return self.getToken(RegelSpraakParser.NUMBER, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_eenheidEntry

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEenheidEntry" ):
                listener.enterEenheidEntry(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEenheidEntry" ):
                listener.exitEenheidEntry(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEenheidEntry" ):
                return visitor.visitEenheidEntry(self)
            else:
                return visitor.visitChildren(self)




    def eenheidEntry(self):

        localctx = RegelSpraakParser.EenheidEntryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_eenheidEntry)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 407
            self.match(RegelSpraakParser.DE)
            self.state = 408
            localctx.unitName = self.unitIdentifier()
            self.state = 409
            localctx.abbrev = self.unitIdentifier()
            self.state = 413
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==250:
                self.state = 410
                self.match(RegelSpraakParser.EQUALS)
                self.state = 411
                localctx.value = self.match(RegelSpraakParser.NUMBER)
                self.state = 412
                localctx.targetUnit = self.unitIdentifier()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UnitIdentifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(RegelSpraakParser.IDENTIFIER, 0)

        def METER(self):
            return self.getToken(RegelSpraakParser.METER, 0)

        def KILOGRAM(self):
            return self.getToken(RegelSpraakParser.KILOGRAM, 0)

        def SECONDE(self):
            return self.getToken(RegelSpraakParser.SECONDE, 0)

        def MINUUT(self):
            return self.getToken(RegelSpraakParser.MINUUT, 0)

        def UUR(self):
            return self.getToken(RegelSpraakParser.UUR, 0)

        def VOET(self):
            return self.getToken(RegelSpraakParser.VOET, 0)

        def POND(self):
            return self.getToken(RegelSpraakParser.POND, 0)

        def MIJL(self):
            return self.getToken(RegelSpraakParser.MIJL, 0)

        def M(self):
            return self.getToken(RegelSpraakParser.M, 0)

        def KG(self):
            return self.getToken(RegelSpraakParser.KG, 0)

        def S(self):
            return self.getToken(RegelSpraakParser.S, 0)

        def FT(self):
            return self.getToken(RegelSpraakParser.FT, 0)

        def LB(self):
            return self.getToken(RegelSpraakParser.LB, 0)

        def MIN(self):
            return self.getToken(RegelSpraakParser.MIN, 0)

        def MI(self):
            return self.getToken(RegelSpraakParser.MI, 0)

        def EURO_SYMBOL(self):
            return self.getToken(RegelSpraakParser.EURO_SYMBOL, 0)

        def DOLLAR_SYMBOL(self):
            return self.getToken(RegelSpraakParser.DOLLAR_SYMBOL, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_unitIdentifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnitIdentifier" ):
                listener.enterUnitIdentifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnitIdentifier" ):
                listener.exitUnitIdentifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnitIdentifier" ):
                return visitor.visitUnitIdentifier(self)
            else:
                return visitor.visitChildren(self)




    def unitIdentifier(self):

        localctx = RegelSpraakParser.UnitIdentifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_unitIdentifier)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 415
            _la = self._input.LA(1)
            if not(_la==133 or ((((_la - 215)) & ~0x3f) == 0 and ((1 << (_la - 215)) & 17178825217) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EenheidExpressieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def eenheidMacht(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.EenheidMachtContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.EenheidMachtContext,i)


        def SLASH(self):
            return self.getToken(RegelSpraakParser.SLASH, 0)

        def NUMBER(self):
            return self.getToken(RegelSpraakParser.NUMBER, 0)

        def PERCENT_SIGN(self):
            return self.getToken(RegelSpraakParser.PERCENT_SIGN, 0)

        def EURO_SYMBOL(self):
            return self.getToken(RegelSpraakParser.EURO_SYMBOL, 0)

        def DOLLAR_SYMBOL(self):
            return self.getToken(RegelSpraakParser.DOLLAR_SYMBOL, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_eenheidExpressie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEenheidExpressie" ):
                listener.enterEenheidExpressie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEenheidExpressie" ):
                listener.exitEenheidExpressie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEenheidExpressie" ):
                return visitor.visitEenheidExpressie(self)
            else:
                return visitor.visitChildren(self)




    def eenheidExpressie(self):

        localctx = RegelSpraakParser.EenheidExpressieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_eenheidExpressie)
        self._la = 0 # Token type
        try:
            self.state = 426
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,41,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 417
                self.eenheidMacht()
                self.state = 420
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==263:
                    self.state = 418
                    self.match(RegelSpraakParser.SLASH)
                    self.state = 419
                    self.eenheidMacht()


                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 422
                self.match(RegelSpraakParser.NUMBER)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 423
                self.match(RegelSpraakParser.PERCENT_SIGN)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 424
                self.match(RegelSpraakParser.EURO_SYMBOL)
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 425
                self.match(RegelSpraakParser.DOLLAR_SYMBOL)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EenheidMachtContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def unitIdentifier(self):
            return self.getTypedRuleContext(RegelSpraakParser.UnitIdentifierContext,0)


        def CARET(self):
            return self.getToken(RegelSpraakParser.CARET, 0)

        def NUMBER(self):
            return self.getToken(RegelSpraakParser.NUMBER, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_eenheidMacht

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEenheidMacht" ):
                listener.enterEenheidMacht(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEenheidMacht" ):
                listener.exitEenheidMacht(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEenheidMacht" ):
                return visitor.visitEenheidMacht(self)
            else:
                return visitor.visitChildren(self)




    def eenheidMacht(self):

        localctx = RegelSpraakParser.EenheidMachtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_eenheidMacht)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 428
            self.unitIdentifier()
            self.state = 431
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==269:
                self.state = 429
                self.match(RegelSpraakParser.CARET)
                self.state = 430
                self.match(RegelSpraakParser.NUMBER)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DimensieDefinitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.dimensieNaamMeervoud = None # NaamwoordContext

        def DIMENSIE(self):
            return self.getToken(RegelSpraakParser.DIMENSIE, 0)

        def naamwoord(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.NaamwoordContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,i)


        def BESTAANDE_UIT(self):
            return self.getToken(RegelSpraakParser.BESTAANDE_UIT, 0)

        def voorzetselSpecificatie(self):
            return self.getTypedRuleContext(RegelSpraakParser.VoorzetselSpecificatieContext,0)


        def COMMA(self):
            return self.getToken(RegelSpraakParser.COMMA, 0)

        def labelWaardeSpecificatie(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.LabelWaardeSpecificatieContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.LabelWaardeSpecificatieContext,i)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_dimensieDefinition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDimensieDefinition" ):
                listener.enterDimensieDefinition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDimensieDefinition" ):
                listener.exitDimensieDefinition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDimensieDefinition" ):
                return visitor.visitDimensieDefinition(self)
            else:
                return visitor.visitChildren(self)




    def dimensieDefinition(self):

        localctx = RegelSpraakParser.DimensieDefinitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_dimensieDefinition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 433
            self.match(RegelSpraakParser.DIMENSIE)
            self.state = 434
            self.naamwoord()
            self.state = 436
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==259:
                self.state = 435
                self.match(RegelSpraakParser.COMMA)


            self.state = 438
            self.match(RegelSpraakParser.BESTAANDE_UIT)
            self.state = 439
            localctx.dimensieNaamMeervoud = self.naamwoord()
            self.state = 440
            self.voorzetselSpecificatie()
            self.state = 442 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 441
                self.labelWaardeSpecificatie()
                self.state = 444 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==249):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VoorzetselSpecificatieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.vz = None # VoorzetselContext

        def NA_HET_ATTRIBUUT_MET_VOORZETSEL(self):
            return self.getToken(RegelSpraakParser.NA_HET_ATTRIBUUT_MET_VOORZETSEL, 0)

        def RPAREN(self):
            return self.getToken(RegelSpraakParser.RPAREN, 0)

        def voorzetsel(self):
            return self.getTypedRuleContext(RegelSpraakParser.VoorzetselContext,0)


        def COLON(self):
            return self.getToken(RegelSpraakParser.COLON, 0)

        def VOOR_HET_ATTRIBUUT_ZONDER_VOORZETSEL(self):
            return self.getToken(RegelSpraakParser.VOOR_HET_ATTRIBUUT_ZONDER_VOORZETSEL, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_voorzetselSpecificatie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVoorzetselSpecificatie" ):
                listener.enterVoorzetselSpecificatie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVoorzetselSpecificatie" ):
                listener.exitVoorzetselSpecificatie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVoorzetselSpecificatie" ):
                return visitor.visitVoorzetselSpecificatie(self)
            else:
                return visitor.visitChildren(self)




    def voorzetselSpecificatie(self):

        localctx = RegelSpraakParser.VoorzetselSpecificatieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_voorzetselSpecificatie)
        self._la = 0 # Token type
        try:
            self.state = 453
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [6]:
                self.enterOuterAlt(localctx, 1)
                self.state = 446
                self.match(RegelSpraakParser.NA_HET_ATTRIBUUT_MET_VOORZETSEL)
                self.state = 447
                localctx.vz = self.voorzetsel()
                self.state = 448
                self.match(RegelSpraakParser.RPAREN)
                self.state = 450
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==261:
                    self.state = 449
                    self.match(RegelSpraakParser.COLON)


                pass
            elif token in [5]:
                self.enterOuterAlt(localctx, 2)
                self.state = 452
                self.match(RegelSpraakParser.VOOR_HET_ATTRIBUUT_ZONDER_VOORZETSEL)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LabelWaardeSpecificatieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.dimWaarde = None # IdentifierContext

        def NUMBER(self):
            return self.getToken(RegelSpraakParser.NUMBER, 0)

        def DOT(self):
            return self.getToken(RegelSpraakParser.DOT, 0)

        def identifier(self):
            return self.getTypedRuleContext(RegelSpraakParser.IdentifierContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_labelWaardeSpecificatie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLabelWaardeSpecificatie" ):
                listener.enterLabelWaardeSpecificatie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLabelWaardeSpecificatie" ):
                listener.exitLabelWaardeSpecificatie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLabelWaardeSpecificatie" ):
                return visitor.visitLabelWaardeSpecificatie(self)
            else:
                return visitor.visitChildren(self)




    def labelWaardeSpecificatie(self):

        localctx = RegelSpraakParser.LabelWaardeSpecificatieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_labelWaardeSpecificatie)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 455
            self.match(RegelSpraakParser.NUMBER)
            self.state = 456
            self.match(RegelSpraakParser.DOT)
            self.state = 457
            localctx.dimWaarde = self.identifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TijdlijnContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def VOOR_ELKE_DAG(self):
            return self.getToken(RegelSpraakParser.VOOR_ELKE_DAG, 0)

        def VOOR_ELKE_MAAND(self):
            return self.getToken(RegelSpraakParser.VOOR_ELKE_MAAND, 0)

        def VOOR_ELK_JAAR(self):
            return self.getToken(RegelSpraakParser.VOOR_ELK_JAAR, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_tijdlijn

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTijdlijn" ):
                listener.enterTijdlijn(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTijdlijn" ):
                listener.exitTijdlijn(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTijdlijn" ):
                return visitor.visitTijdlijn(self)
            else:
                return visitor.visitChildren(self)




    def tijdlijn(self):

        localctx = RegelSpraakParser.TijdlijnContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_tijdlijn)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 459
            _la = self._input.LA(1)
            if not(((((_la - 178)) & ~0x3f) == 0 and ((1 << (_la - 178)) & 7) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DimensieRefContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.name = None # Token

        def IDENTIFIER(self):
            return self.getToken(RegelSpraakParser.IDENTIFIER, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_dimensieRef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDimensieRef" ):
                listener.enterDimensieRef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDimensieRef" ):
                listener.exitDimensieRef(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDimensieRef" ):
                return visitor.visitDimensieRef(self)
            else:
                return visitor.visitChildren(self)




    def dimensieRef(self):

        localctx = RegelSpraakParser.DimensieRefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_dimensieRef)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 461
            localctx.name = self.match(RegelSpraakParser.IDENTIFIER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParameterDefinitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PARAMETER(self):
            return self.getToken(RegelSpraakParser.PARAMETER, 0)

        def parameterNamePhrase(self):
            return self.getTypedRuleContext(RegelSpraakParser.ParameterNamePhraseContext,0)


        def COLON(self):
            return self.getToken(RegelSpraakParser.COLON, 0)

        def SEMICOLON(self):
            return self.getToken(RegelSpraakParser.SEMICOLON, 0)

        def datatype(self):
            return self.getTypedRuleContext(RegelSpraakParser.DatatypeContext,0)


        def domeinRef(self):
            return self.getTypedRuleContext(RegelSpraakParser.DomeinRefContext,0)


        def MET_EENHEID(self):
            return self.getToken(RegelSpraakParser.MET_EENHEID, 0)

        def eenheidExpressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.EenheidExpressieContext,0)


        def tijdlijn(self):
            return self.getTypedRuleContext(RegelSpraakParser.TijdlijnContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_parameterDefinition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParameterDefinition" ):
                listener.enterParameterDefinition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParameterDefinition" ):
                listener.exitParameterDefinition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParameterDefinition" ):
                return visitor.visitParameterDefinition(self)
            else:
                return visitor.visitChildren(self)




    def parameterDefinition(self):

        localctx = RegelSpraakParser.ParameterDefinitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_parameterDefinition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 463
            self.match(RegelSpraakParser.PARAMETER)
            self.state = 464
            self.parameterNamePhrase()
            self.state = 465
            self.match(RegelSpraakParser.COLON)
            self.state = 468
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [7, 102, 157, 159, 172, 177]:
                self.state = 466
                self.datatype()
                pass
            elif token in [101]:
                self.state = 467
                self.domeinRef()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 472
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==168:
                self.state = 470
                self.match(RegelSpraakParser.MET_EENHEID)
                self.state = 471
                self.eenheidExpressie()


            self.state = 475
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 178)) & ~0x3f) == 0 and ((1 << (_la - 178)) & 7) != 0):
                self.state = 474
                self.tijdlijn()


            self.state = 477
            self.match(RegelSpraakParser.SEMICOLON)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParameterNamePhraseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DE(self):
            return self.getToken(RegelSpraakParser.DE, 0)

        def HET(self):
            return self.getToken(RegelSpraakParser.HET, 0)

        def IDENTIFIER(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.IDENTIFIER)
            else:
                return self.getToken(RegelSpraakParser.IDENTIFIER, i)

        def AANTAL(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.AANTAL)
            else:
                return self.getToken(RegelSpraakParser.AANTAL, i)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_parameterNamePhrase

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParameterNamePhrase" ):
                listener.enterParameterNamePhrase(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParameterNamePhrase" ):
                listener.exitParameterNamePhrase(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParameterNamePhrase" ):
                return visitor.visitParameterNamePhrase(self)
            else:
                return visitor.visitChildren(self)




    def parameterNamePhrase(self):

        localctx = RegelSpraakParser.ParameterNamePhraseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_parameterNamePhrase)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 480
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==203 or _la==208:
                self.state = 479
                _la = self._input.LA(1)
                if not(_la==203 or _la==208):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


            self.state = 483 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 482
                _la = self._input.LA(1)
                if not(_la==181 or _la==248):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 485 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==181 or _la==248):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParameterMetLidwoordContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_parameterMetLidwoord

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParameterMetLidwoord" ):
                listener.enterParameterMetLidwoord(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParameterMetLidwoord" ):
                listener.exitParameterMetLidwoord(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParameterMetLidwoord" ):
                return visitor.visitParameterMetLidwoord(self)
            else:
                return visitor.visitChildren(self)




    def parameterMetLidwoord(self):

        localctx = RegelSpraakParser.ParameterMetLidwoordContext(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_parameterMetLidwoord)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 487
            self.naamwoord()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FeitTypeDefinitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.subject = None # NaamwoordContext
            self.object_ = None # NaamwoordContext
            self.description = None # NaamwoordContext

        def rolSpecificatie(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.RolSpecificatieContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.RolSpecificatieContext,i)


        def WEDERKERIG_FEITTYPE(self):
            return self.getToken(RegelSpraakParser.WEDERKERIG_FEITTYPE, 0)

        def FEITTYPE(self):
            return self.getToken(RegelSpraakParser.FEITTYPE, 0)

        def naamwoord(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.NaamwoordContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,i)


        def HEEFT(self):
            return self.getToken(RegelSpraakParser.HEEFT, 0)

        def IS(self):
            return self.getToken(RegelSpraakParser.IS, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_feitTypeDefinition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFeitTypeDefinition" ):
                listener.enterFeitTypeDefinition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFeitTypeDefinition" ):
                listener.exitFeitTypeDefinition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFeitTypeDefinition" ):
                return visitor.visitFeitTypeDefinition(self)
            else:
                return visitor.visitChildren(self)




    def feitTypeDefinition(self):

        localctx = RegelSpraakParser.FeitTypeDefinitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 74, self.RULE_feitTypeDefinition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 489
            _la = self._input.LA(1)
            if not(_la==31 or _la==106):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 490
            localctx.subject = self.naamwoord()
            self.state = 495
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [111]:
                self.state = 491
                self.match(RegelSpraakParser.HEEFT)
                self.state = 492
                localctx.object_ = self.naamwoord()
                pass
            elif token in [113]:
                self.state = 493
                self.match(RegelSpraakParser.IS)
                self.state = 494
                localctx.description = self.naamwoord()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 497
            self.rolSpecificatie()
            self.state = 499 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 498
                self.rolSpecificatie()
                self.state = 501 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==5 or _la==6):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RolSpecificatieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def voorzetselSpecificatie(self):
            return self.getTypedRuleContext(RegelSpraakParser.VoorzetselSpecificatieContext,0)


        def identifier(self):
            return self.getTypedRuleContext(RegelSpraakParser.IdentifierContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_rolSpecificatie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRolSpecificatie" ):
                listener.enterRolSpecificatie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRolSpecificatie" ):
                listener.exitRolSpecificatie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRolSpecificatie" ):
                return visitor.visitRolSpecificatie(self)
            else:
                return visitor.visitChildren(self)




    def rolSpecificatie(self):

        localctx = RegelSpraakParser.RolSpecificatieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 76, self.RULE_rolSpecificatie)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 503
            self.voorzetselSpecificatie()
            self.state = 504
            self.identifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RegelContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def REGEL(self):
            return self.getToken(RegelSpraakParser.REGEL, 0)

        def regelName(self):
            return self.getTypedRuleContext(RegelSpraakParser.RegelNameContext,0)


        def regelVersie(self):
            return self.getTypedRuleContext(RegelSpraakParser.RegelVersieContext,0)


        def resultaatDeel(self):
            return self.getTypedRuleContext(RegelSpraakParser.ResultaatDeelContext,0)


        def NUMBER(self):
            return self.getToken(RegelSpraakParser.NUMBER, 0)

        def voorwaardeDeel(self):
            return self.getTypedRuleContext(RegelSpraakParser.VoorwaardeDeelContext,0)


        def DOT(self):
            return self.getToken(RegelSpraakParser.DOT, 0)

        def variabeleDeel(self):
            return self.getTypedRuleContext(RegelSpraakParser.VariabeleDeelContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_regel

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRegel" ):
                listener.enterRegel(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRegel" ):
                listener.exitRegel(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRegel" ):
                return visitor.visitRegel(self)
            else:
                return visitor.visitChildren(self)




    def regel(self):

        localctx = RegelSpraakParser.RegelContext(self, self._ctx, self.state)
        self.enterRule(localctx, 78, self.RULE_regel)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 506
            self.match(RegelSpraakParser.REGEL)
            self.state = 507
            self.regelName()
            self.state = 509
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==249:
                self.state = 508
                self.match(RegelSpraakParser.NUMBER)


            self.state = 511
            self.regelVersie()
            self.state = 512
            self.resultaatDeel()
            self.state = 518
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [112]:
                self.state = 513
                self.voorwaardeDeel()
                self.state = 515
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==260:
                    self.state = 514
                    self.match(RegelSpraakParser.DOT)


                pass
            elif token in [260]:
                self.state = 517
                self.match(RegelSpraakParser.DOT)
                pass
            elif token in [-1, 31, 97, 98, 99, 100, 101, 103, 104, 105, 106, 107, 108]:
                pass
            else:
                pass
            self.state = 521
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==108:
                self.state = 520
                self.variabeleDeel()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RegelNameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.IDENTIFIER)
            else:
                return self.getToken(RegelSpraakParser.IDENTIFIER, i)

        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def KENMERK(self):
            return self.getToken(RegelSpraakParser.KENMERK, 0)

        def ROL(self):
            return self.getToken(RegelSpraakParser.ROL, 0)

        def NIET(self):
            return self.getToken(RegelSpraakParser.NIET, 0)

        def KENMERKEN(self):
            return self.getToken(RegelSpraakParser.KENMERKEN, 0)

        def ROLLEN(self):
            return self.getToken(RegelSpraakParser.ROLLEN, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_regelName

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRegelName" ):
                listener.enterRegelName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRegelName" ):
                listener.exitRegelName(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRegelName" ):
                return visitor.visitRegelName(self)
            else:
                return visitor.visitChildren(self)




    def regelName(self):

        localctx = RegelSpraakParser.RegelNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 80, self.RULE_regelName)
        self._la = 0 # Token type
        try:
            self.state = 577
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,67,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 524 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 523
                    self.match(RegelSpraakParser.IDENTIFIER)
                    self.state = 526 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==248):
                        break

                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 528
                self.naamwoord()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 530 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 529
                    self.match(RegelSpraakParser.IDENTIFIER)
                    self.state = 532 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==248):
                        break

                self.state = 534
                self.match(RegelSpraakParser.KENMERK)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 536 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 535
                    self.match(RegelSpraakParser.IDENTIFIER)
                    self.state = 538 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==248):
                        break

                self.state = 540
                self.match(RegelSpraakParser.ROL)
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 542 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 541
                    self.match(RegelSpraakParser.IDENTIFIER)
                    self.state = 544 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==248):
                        break

                self.state = 546
                self.match(RegelSpraakParser.NIET)
                self.state = 547
                self.match(RegelSpraakParser.KENMERK)
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 549 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 548
                    self.match(RegelSpraakParser.IDENTIFIER)
                    self.state = 551 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==248):
                        break

                self.state = 553
                self.match(RegelSpraakParser.NIET)
                self.state = 554
                self.match(RegelSpraakParser.ROL)
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 556 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 555
                    self.match(RegelSpraakParser.IDENTIFIER)
                    self.state = 558 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==248):
                        break

                self.state = 560
                self.match(RegelSpraakParser.KENMERKEN)
                self.state = 562 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 561
                    self.match(RegelSpraakParser.IDENTIFIER)
                    self.state = 564 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==248):
                        break

                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 567 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 566
                    self.match(RegelSpraakParser.IDENTIFIER)
                    self.state = 569 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==248):
                        break

                self.state = 571
                self.match(RegelSpraakParser.ROLLEN)
                self.state = 573 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 572
                    self.match(RegelSpraakParser.IDENTIFIER)
                    self.state = 575 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==248):
                        break

                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RegelVersieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GELDIG(self):
            return self.getToken(RegelSpraakParser.GELDIG, 0)

        def versieGeldigheid(self):
            return self.getTypedRuleContext(RegelSpraakParser.VersieGeldigheidContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_regelVersie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRegelVersie" ):
                listener.enterRegelVersie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRegelVersie" ):
                listener.exitRegelVersie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRegelVersie" ):
                return visitor.visitRegelVersie(self)
            else:
                return visitor.visitChildren(self)




    def regelVersie(self):

        localctx = RegelSpraakParser.RegelVersieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 82, self.RULE_regelVersie)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 579
            self.match(RegelSpraakParser.GELDIG)
            self.state = 580
            self.versieGeldigheid()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VersieGeldigheidContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ALTIJD(self):
            return self.getToken(RegelSpraakParser.ALTIJD, 0)

        def VANAF(self):
            return self.getToken(RegelSpraakParser.VANAF, 0)

        def datumLiteral(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.DatumLiteralContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.DatumLiteralContext,i)


        def TM(self):
            return self.getToken(RegelSpraakParser.TM, 0)

        def TOT_EN_MET(self):
            return self.getToken(RegelSpraakParser.TOT_EN_MET, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_versieGeldigheid

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVersieGeldigheid" ):
                listener.enterVersieGeldigheid(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVersieGeldigheid" ):
                listener.exitVersieGeldigheid(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVersieGeldigheid" ):
                return visitor.visitVersieGeldigheid(self)
            else:
                return visitor.visitChildren(self)




    def versieGeldigheid(self):

        localctx = RegelSpraakParser.VersieGeldigheidContext(self, self._ctx, self.state)
        self.enterRule(localctx, 84, self.RULE_versieGeldigheid)
        self._la = 0 # Token type
        try:
            self.state = 589
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [199]:
                self.enterOuterAlt(localctx, 1)
                self.state = 582
                self.match(RegelSpraakParser.ALTIJD)
                pass
            elif token in [145]:
                self.enterOuterAlt(localctx, 2)
                self.state = 583
                self.match(RegelSpraakParser.VANAF)
                self.state = 584
                self.datumLiteral()
                self.state = 587
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==143 or _la==225:
                    self.state = 585
                    _la = self._input.LA(1)
                    if not(_la==143 or _la==225):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()
                    self.state = 586
                    self.datumLiteral()


                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ResultaatDeelContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_resultaatDeel

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class AantalDagenInResultaatContext(ResultaatDeelContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.ResultaatDeelContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def HET_AANTAL_DAGEN_IN(self):
            return self.getToken(RegelSpraakParser.HET_AANTAL_DAGEN_IN, 0)
        def MAAND(self):
            return self.getToken(RegelSpraakParser.MAAND, 0)
        def JAAR(self):
            return self.getToken(RegelSpraakParser.JAAR, 0)
        def WORDT_BEREKEND_ALS(self):
            return self.getToken(RegelSpraakParser.WORDT_BEREKEND_ALS, 0)
        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)

        def WORDT_GESTELD_OP(self):
            return self.getToken(RegelSpraakParser.WORDT_GESTELD_OP, 0)
        def WORDT_GEINITIALISEERD_OP(self):
            return self.getToken(RegelSpraakParser.WORDT_GEINITIALISEERD_OP, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAantalDagenInResultaat" ):
                listener.enterAantalDagenInResultaat(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAantalDagenInResultaat" ):
                listener.exitAantalDagenInResultaat(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAantalDagenInResultaat" ):
                return visitor.visitAantalDagenInResultaat(self)
            else:
                return visitor.visitChildren(self)


    class GelijkstellingResultaatContext(ResultaatDeelContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.ResultaatDeelContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)

        def attribuutReferentie(self):
            return self.getTypedRuleContext(RegelSpraakParser.AttribuutReferentieContext,0)

        def WORDT_BEREKEND_ALS(self):
            return self.getToken(RegelSpraakParser.WORDT_BEREKEND_ALS, 0)
        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)

        def WORDT_GESTELD_OP(self):
            return self.getToken(RegelSpraakParser.WORDT_GESTELD_OP, 0)
        def WORDT_GEINITIALISEERD_OP(self):
            return self.getToken(RegelSpraakParser.WORDT_GEINITIALISEERD_OP, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGelijkstellingResultaat" ):
                listener.enterGelijkstellingResultaat(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGelijkstellingResultaat" ):
                listener.exitGelijkstellingResultaat(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGelijkstellingResultaat" ):
                return visitor.visitGelijkstellingResultaat(self)
            else:
                return visitor.visitChildren(self)


    class CapitalizedGelijkstellingResultaatContext(ResultaatDeelContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.ResultaatDeelContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def WORDT_BEREKEND_ALS(self):
            return self.getToken(RegelSpraakParser.WORDT_BEREKEND_ALS, 0)
        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)

        def WORDT_GESTELD_OP(self):
            return self.getToken(RegelSpraakParser.WORDT_GESTELD_OP, 0)
        def WORDT_GEINITIALISEERD_OP(self):
            return self.getToken(RegelSpraakParser.WORDT_GEINITIALISEERD_OP, 0)
        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.IdentifierContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCapitalizedGelijkstellingResultaat" ):
                listener.enterCapitalizedGelijkstellingResultaat(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCapitalizedGelijkstellingResultaat" ):
                listener.exitCapitalizedGelijkstellingResultaat(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCapitalizedGelijkstellingResultaat" ):
                return visitor.visitCapitalizedGelijkstellingResultaat(self)
            else:
                return visitor.visitChildren(self)


    class SpecialPhraseResultaatContext(ResultaatDeelContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.ResultaatDeelContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def HET_KWARTAAL(self):
            return self.getToken(RegelSpraakParser.HET_KWARTAAL, 0)
        def HET_DEEL_PER_MAAND(self):
            return self.getToken(RegelSpraakParser.HET_DEEL_PER_MAAND, 0)
        def HET_DEEL_PER_JAAR(self):
            return self.getToken(RegelSpraakParser.HET_DEEL_PER_JAAR, 0)
        def WORDT_BEREKEND_ALS(self):
            return self.getToken(RegelSpraakParser.WORDT_BEREKEND_ALS, 0)
        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)

        def WORDT_GESTELD_OP(self):
            return self.getToken(RegelSpraakParser.WORDT_GESTELD_OP, 0)
        def WORDT_GEINITIALISEERD_OP(self):
            return self.getToken(RegelSpraakParser.WORDT_GEINITIALISEERD_OP, 0)
        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.IdentifierContext,i)

        def datumLiteral(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.DatumLiteralContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.DatumLiteralContext,i)

        def DOT(self):
            return self.getToken(RegelSpraakParser.DOT, 0)
        def VANAF(self):
            return self.getToken(RegelSpraakParser.VANAF, 0)
        def VAN(self):
            return self.getToken(RegelSpraakParser.VAN, 0)
        def TOT(self):
            return self.getToken(RegelSpraakParser.TOT, 0)
        def TOT_EN_MET(self):
            return self.getToken(RegelSpraakParser.TOT_EN_MET, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSpecialPhraseResultaat" ):
                listener.enterSpecialPhraseResultaat(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSpecialPhraseResultaat" ):
                listener.exitSpecialPhraseResultaat(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSpecialPhraseResultaat" ):
                return visitor.visitSpecialPhraseResultaat(self)
            else:
                return visitor.visitChildren(self)


    class KenmerkFeitResultaatContext(ResultaatDeelContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.ResultaatDeelContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def onderwerpReferentie(self):
            return self.getTypedRuleContext(RegelSpraakParser.OnderwerpReferentieContext,0)

        def kenmerkNaam(self):
            return self.getTypedRuleContext(RegelSpraakParser.KenmerkNaamContext,0)

        def IS(self):
            return self.getToken(RegelSpraakParser.IS, 0)
        def HEEFT(self):
            return self.getToken(RegelSpraakParser.HEEFT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterKenmerkFeitResultaat" ):
                listener.enterKenmerkFeitResultaat(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitKenmerkFeitResultaat" ):
                listener.exitKenmerkFeitResultaat(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitKenmerkFeitResultaat" ):
                return visitor.visitKenmerkFeitResultaat(self)
            else:
                return visitor.visitChildren(self)


    class ObjectCreatieActieContext(ResultaatDeelContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.ResultaatDeelContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def objectCreatie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ObjectCreatieContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterObjectCreatieActie" ):
                listener.enterObjectCreatieActie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitObjectCreatieActie" ):
                listener.exitObjectCreatieActie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitObjectCreatieActie" ):
                return visitor.visitObjectCreatieActie(self)
            else:
                return visitor.visitChildren(self)


    class FeitCreatieResultaatContext(ResultaatDeelContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.ResultaatDeelContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def onderwerpReferentie(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.OnderwerpReferentieContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.OnderwerpReferentieContext,i)

        def HEEFT(self):
            return self.getToken(RegelSpraakParser.HEEFT, 0)
        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)

        def MET(self):
            return self.getToken(RegelSpraakParser.MET, 0)
        def TOT(self):
            return self.getToken(RegelSpraakParser.TOT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFeitCreatieResultaat" ):
                listener.enterFeitCreatieResultaat(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFeitCreatieResultaat" ):
                listener.exitFeitCreatieResultaat(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFeitCreatieResultaat" ):
                return visitor.visitFeitCreatieResultaat(self)
            else:
                return visitor.visitChildren(self)



    def resultaatDeel(self):

        localctx = RegelSpraakParser.ResultaatDeelContext(self, self._ctx, self.state)
        self.enterRule(localctx, 86, self.RULE_resultaatDeel)
        self._la = 0 # Token type
        try:
            self.state = 662
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,79,self._ctx)
            if la_ == 1:
                localctx = RegelSpraakParser.GelijkstellingResultaatContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 593
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,70,self._ctx)
                if la_ == 1:
                    self.state = 591
                    self.naamwoord()
                    pass

                elif la_ == 2:
                    self.state = 592
                    self.attribuutReferentie()
                    pass


                self.state = 601
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [11]:
                    self.state = 595
                    self.match(RegelSpraakParser.WORDT_BEREKEND_ALS)
                    self.state = 596
                    self.expressie()
                    pass
                elif token in [12]:
                    self.state = 597
                    self.match(RegelSpraakParser.WORDT_GESTELD_OP)
                    self.state = 598
                    self.expressie()
                    pass
                elif token in [13]:
                    self.state = 599
                    self.match(RegelSpraakParser.WORDT_GEINITIALISEERD_OP)
                    self.state = 600
                    self.expressie()
                    pass
                else:
                    raise NoViableAltException(self)

                pass

            elif la_ == 2:
                localctx = RegelSpraakParser.KenmerkFeitResultaatContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 603
                self.onderwerpReferentie()
                self.state = 604
                _la = self._input.LA(1)
                if not(_la==111 or _la==113):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 605
                self.kenmerkNaam()
                pass

            elif la_ == 3:
                localctx = RegelSpraakParser.FeitCreatieResultaatContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 607
                self.onderwerpReferentie()
                self.state = 608
                self.match(RegelSpraakParser.HEEFT)
                self.state = 609
                self.naamwoord()
                self.state = 610
                _la = self._input.LA(1)
                if not(_la==141 or _la==167):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 611
                self.onderwerpReferentie()
                pass

            elif la_ == 4:
                localctx = RegelSpraakParser.CapitalizedGelijkstellingResultaatContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 614 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 613
                    self.identifier()
                    self.state = 616 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==248):
                        break

                self.state = 624
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [11]:
                    self.state = 618
                    self.match(RegelSpraakParser.WORDT_BEREKEND_ALS)
                    self.state = 619
                    self.expressie()
                    pass
                elif token in [12]:
                    self.state = 620
                    self.match(RegelSpraakParser.WORDT_GESTELD_OP)
                    self.state = 621
                    self.expressie()
                    pass
                elif token in [13]:
                    self.state = 622
                    self.match(RegelSpraakParser.WORDT_GEINITIALISEERD_OP)
                    self.state = 623
                    self.expressie()
                    pass
                else:
                    raise NoViableAltException(self)

                pass

            elif la_ == 5:
                localctx = RegelSpraakParser.SpecialPhraseResultaatContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 626
                _la = self._input.LA(1)
                if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 28) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 630
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==248:
                    self.state = 627
                    self.identifier()
                    self.state = 632
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 639
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [11]:
                    self.state = 633
                    self.match(RegelSpraakParser.WORDT_BEREKEND_ALS)
                    self.state = 634
                    self.expressie()
                    pass
                elif token in [12]:
                    self.state = 635
                    self.match(RegelSpraakParser.WORDT_GESTELD_OP)
                    self.state = 636
                    self.expressie()
                    pass
                elif token in [13]:
                    self.state = 637
                    self.match(RegelSpraakParser.WORDT_GEINITIALISEERD_OP)
                    self.state = 638
                    self.expressie()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 646
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==145 or _la==228:
                    self.state = 641
                    _la = self._input.LA(1)
                    if not(_la==145 or _la==228):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()
                    self.state = 642
                    self.datumLiteral()
                    self.state = 643
                    _la = self._input.LA(1)
                    if not(_la==141 or _la==143):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()
                    self.state = 644
                    self.datumLiteral()


                self.state = 649
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,77,self._ctx)
                if la_ == 1:
                    self.state = 648
                    self.match(RegelSpraakParser.DOT)


                pass

            elif la_ == 6:
                localctx = RegelSpraakParser.AantalDagenInResultaatContext(self, localctx)
                self.enterOuterAlt(localctx, 6)
                self.state = 651
                self.match(RegelSpraakParser.HET_AANTAL_DAGEN_IN)
                self.state = 652
                _la = self._input.LA(1)
                if not(_la==211 or _la==213):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 659
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [11]:
                    self.state = 653
                    self.match(RegelSpraakParser.WORDT_BEREKEND_ALS)
                    self.state = 654
                    self.expressie()
                    pass
                elif token in [12]:
                    self.state = 655
                    self.match(RegelSpraakParser.WORDT_GESTELD_OP)
                    self.state = 656
                    self.expressie()
                    pass
                elif token in [13]:
                    self.state = 657
                    self.match(RegelSpraakParser.WORDT_GEINITIALISEERD_OP)
                    self.state = 658
                    self.expressie()
                    pass
                else:
                    raise NoViableAltException(self)

                pass

            elif la_ == 7:
                localctx = RegelSpraakParser.ObjectCreatieActieContext(self, localctx)
                self.enterOuterAlt(localctx, 7)
                self.state = 661
                self.objectCreatie()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ObjectCreatieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.objectType = None # NaamwoordContext

        def ER_WORDT_EEN_NIEUW(self):
            return self.getToken(RegelSpraakParser.ER_WORDT_EEN_NIEUW, 0)

        def AANGEMAAKT(self):
            return self.getToken(RegelSpraakParser.AANGEMAAKT, 0)

        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def objectAttributeInit(self):
            return self.getTypedRuleContext(RegelSpraakParser.ObjectAttributeInitContext,0)


        def DOT(self):
            return self.getToken(RegelSpraakParser.DOT, 0)

        def CREEER(self):
            return self.getToken(RegelSpraakParser.CREEER, 0)

        def EEN(self):
            return self.getToken(RegelSpraakParser.EEN, 0)

        def NIEUWE(self):
            return self.getToken(RegelSpraakParser.NIEUWE, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_objectCreatie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterObjectCreatie" ):
                listener.enterObjectCreatie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitObjectCreatie" ):
                listener.exitObjectCreatie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitObjectCreatie" ):
                return visitor.visitObjectCreatie(self)
            else:
                return visitor.visitChildren(self)




    def objectCreatie(self):

        localctx = RegelSpraakParser.ObjectCreatieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 88, self.RULE_objectCreatie)
        self._la = 0 # Token type
        try:
            self.state = 683
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [44]:
                self.enterOuterAlt(localctx, 1)
                self.state = 664
                self.match(RegelSpraakParser.ER_WORDT_EEN_NIEUW)
                self.state = 665
                localctx.objectType = self.naamwoord()
                self.state = 666
                self.match(RegelSpraakParser.AANGEMAAKT)
                self.state = 668
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==167:
                    self.state = 667
                    self.objectAttributeInit()


                self.state = 671
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,81,self._ctx)
                if la_ == 1:
                    self.state = 670
                    self.match(RegelSpraakParser.DOT)


                pass
            elif token in [47]:
                self.enterOuterAlt(localctx, 2)
                self.state = 673
                self.match(RegelSpraakParser.CREEER)
                self.state = 674
                self.match(RegelSpraakParser.EEN)
                self.state = 675
                self.match(RegelSpraakParser.NIEUWE)
                self.state = 676
                localctx.objectType = self.naamwoord()
                self.state = 678
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==167:
                    self.state = 677
                    self.objectAttributeInit()


                self.state = 681
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,83,self._ctx)
                if la_ == 1:
                    self.state = 680
                    self.match(RegelSpraakParser.DOT)


                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ObjectAttributeInitContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.attribuut = None # NaamwoordContext
            self.waarde = None # ExpressieContext

        def MET(self):
            return self.getToken(RegelSpraakParser.MET, 0)

        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)


        def attributeInitVervolg(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.AttributeInitVervolgContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.AttributeInitVervolgContext,i)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_objectAttributeInit

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterObjectAttributeInit" ):
                listener.enterObjectAttributeInit(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitObjectAttributeInit" ):
                listener.exitObjectAttributeInit(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitObjectAttributeInit" ):
                return visitor.visitObjectAttributeInit(self)
            else:
                return visitor.visitChildren(self)




    def objectAttributeInit(self):

        localctx = RegelSpraakParser.ObjectAttributeInitContext(self, self._ctx, self.state)
        self.enterRule(localctx, 90, self.RULE_objectAttributeInit)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 685
            self.match(RegelSpraakParser.MET)
            self.state = 686
            localctx.attribuut = self.naamwoord()
            self.state = 687
            localctx.waarde = self.expressie()
            self.state = 691
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==207:
                self.state = 688
                self.attributeInitVervolg()
                self.state = 693
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AttributeInitVervolgContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.attribuut = None # NaamwoordContext
            self.waarde = None # ExpressieContext

        def EN(self):
            return self.getToken(RegelSpraakParser.EN, 0)

        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_attributeInitVervolg

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAttributeInitVervolg" ):
                listener.enterAttributeInitVervolg(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAttributeInitVervolg" ):
                listener.exitAttributeInitVervolg(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAttributeInitVervolg" ):
                return visitor.visitAttributeInitVervolg(self)
            else:
                return visitor.visitChildren(self)




    def attributeInitVervolg(self):

        localctx = RegelSpraakParser.AttributeInitVervolgContext(self, self._ctx, self.state)
        self.enterRule(localctx, 92, self.RULE_attributeInitVervolg)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 694
            self.match(RegelSpraakParser.EN)
            self.state = 695
            localctx.attribuut = self.naamwoord()
            self.state = 696
            localctx.waarde = self.expressie()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConsistentieregelContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CONSISTENTIEREGEL(self):
            return self.getToken(RegelSpraakParser.CONSISTENTIEREGEL, 0)

        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def uniekzijnResultaat(self):
            return self.getTypedRuleContext(RegelSpraakParser.UniekzijnResultaatContext,0)


        def inconsistentResultaat(self):
            return self.getTypedRuleContext(RegelSpraakParser.InconsistentResultaatContext,0)


        def voorwaardeDeel(self):
            return self.getTypedRuleContext(RegelSpraakParser.VoorwaardeDeelContext,0)


        def DOT(self):
            return self.getToken(RegelSpraakParser.DOT, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_consistentieregel

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConsistentieregel" ):
                listener.enterConsistentieregel(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConsistentieregel" ):
                listener.exitConsistentieregel(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConsistentieregel" ):
                return visitor.visitConsistentieregel(self)
            else:
                return visitor.visitChildren(self)




    def consistentieregel(self):

        localctx = RegelSpraakParser.ConsistentieregelContext(self, self._ctx, self.state)
        self.enterRule(localctx, 94, self.RULE_consistentieregel)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 698
            self.match(RegelSpraakParser.CONSISTENTIEREGEL)
            self.state = 699
            self.naamwoord()
            self.state = 709
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,88,self._ctx)
            if la_ == 1:
                self.state = 700
                self.uniekzijnResultaat()
                pass

            elif la_ == 2:
                self.state = 701
                self.inconsistentResultaat()
                self.state = 707
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [112]:
                    self.state = 702
                    self.voorwaardeDeel()
                    self.state = 704
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==260:
                        self.state = 703
                        self.match(RegelSpraakParser.DOT)


                    pass
                elif token in [260]:
                    self.state = 706
                    self.match(RegelSpraakParser.DOT)
                    pass
                elif token in [-1, 31, 97, 98, 99, 100, 101, 103, 104, 105, 106, 107]:
                    pass
                else:
                    pass
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UniekzijnResultaatContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def onderwerpReferentie(self):
            return self.getTypedRuleContext(RegelSpraakParser.OnderwerpReferentieContext,0)


        def MOETEN_UNIEK_ZIJN(self):
            return self.getToken(RegelSpraakParser.MOETEN_UNIEK_ZIJN, 0)

        def DOT(self):
            return self.getToken(RegelSpraakParser.DOT, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_uniekzijnResultaat

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUniekzijnResultaat" ):
                listener.enterUniekzijnResultaat(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUniekzijnResultaat" ):
                listener.exitUniekzijnResultaat(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUniekzijnResultaat" ):
                return visitor.visitUniekzijnResultaat(self)
            else:
                return visitor.visitChildren(self)




    def uniekzijnResultaat(self):

        localctx = RegelSpraakParser.UniekzijnResultaatContext(self, self._ctx, self.state)
        self.enterRule(localctx, 96, self.RULE_uniekzijnResultaat)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 711
            self.onderwerpReferentie()
            self.state = 712
            self.match(RegelSpraakParser.MOETEN_UNIEK_ZIJN)
            self.state = 714
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==260:
                self.state = 713
                self.match(RegelSpraakParser.DOT)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InconsistentResultaatContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def IS_INCONSISTENT(self):
            return self.getToken(RegelSpraakParser.IS_INCONSISTENT, 0)

        def DE(self):
            return self.getToken(RegelSpraakParser.DE, 0)

        def HET(self):
            return self.getToken(RegelSpraakParser.HET, 0)

        def ER(self):
            return self.getToken(RegelSpraakParser.ER, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_inconsistentResultaat

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInconsistentResultaat" ):
                listener.enterInconsistentResultaat(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInconsistentResultaat" ):
                listener.exitInconsistentResultaat(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInconsistentResultaat" ):
                return visitor.visitInconsistentResultaat(self)
            else:
                return visitor.visitChildren(self)




    def inconsistentResultaat(self):

        localctx = RegelSpraakParser.InconsistentResultaatContext(self, self._ctx, self.state)
        self.enterRule(localctx, 98, self.RULE_inconsistentResultaat)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 717
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,90,self._ctx)
            if la_ == 1:
                self.state = 716
                _la = self._input.LA(1)
                if not(((((_la - 203)) & ~0x3f) == 0 and ((1 << (_la - 203)) & 2147483681) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


            self.state = 719
            self.naamwoord()
            self.state = 720
            self.match(RegelSpraakParser.IS_INCONSISTENT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VoorwaardeDeelContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INDIEN(self):
            return self.getToken(RegelSpraakParser.INDIEN, 0)

        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)


        def toplevelSamengesteldeVoorwaarde(self):
            return self.getTypedRuleContext(RegelSpraakParser.ToplevelSamengesteldeVoorwaardeContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_voorwaardeDeel

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVoorwaardeDeel" ):
                listener.enterVoorwaardeDeel(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVoorwaardeDeel" ):
                listener.exitVoorwaardeDeel(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVoorwaardeDeel" ):
                return visitor.visitVoorwaardeDeel(self)
            else:
                return visitor.visitChildren(self)




    def voorwaardeDeel(self):

        localctx = RegelSpraakParser.VoorwaardeDeelContext(self, self._ctx, self.state)
        self.enterRule(localctx, 100, self.RULE_voorwaardeDeel)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 722
            self.match(RegelSpraakParser.INDIEN)
            self.state = 725
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,91,self._ctx)
            if la_ == 1:
                self.state = 723
                self.expressie()
                pass

            elif la_ == 2:
                self.state = 724
                self.toplevelSamengesteldeVoorwaarde()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OnderwerpReferentieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def basisOnderwerp(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.BasisOnderwerpContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.BasisOnderwerpContext,i)


        def voorzetsel(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.VoorzetselContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.VoorzetselContext,i)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_onderwerpReferentie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOnderwerpReferentie" ):
                listener.enterOnderwerpReferentie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOnderwerpReferentie" ):
                listener.exitOnderwerpReferentie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOnderwerpReferentie" ):
                return visitor.visitOnderwerpReferentie(self)
            else:
                return visitor.visitChildren(self)




    def onderwerpReferentie(self):

        localctx = RegelSpraakParser.OnderwerpReferentieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 102, self.RULE_onderwerpReferentie)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 727
            self.basisOnderwerp()
            self.state = 733
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,92,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 728
                    self.voorzetsel()
                    self.state = 729
                    self.basisOnderwerp() 
                self.state = 735
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,92,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BasisOnderwerpContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.IDENTIFIER)
            else:
                return self.getToken(RegelSpraakParser.IDENTIFIER, i)

        def DE(self):
            return self.getToken(RegelSpraakParser.DE, 0)

        def HET(self):
            return self.getToken(RegelSpraakParser.HET, 0)

        def EEN(self):
            return self.getToken(RegelSpraakParser.EEN, 0)

        def ZIJN(self):
            return self.getToken(RegelSpraakParser.ZIJN, 0)

        def ALLE(self):
            return self.getToken(RegelSpraakParser.ALLE, 0)

        def HIJ(self):
            return self.getToken(RegelSpraakParser.HIJ, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_basisOnderwerp

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBasisOnderwerp" ):
                listener.enterBasisOnderwerp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBasisOnderwerp" ):
                listener.exitBasisOnderwerp(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBasisOnderwerp" ):
                return visitor.visitBasisOnderwerp(self)
            else:
                return visitor.visitChildren(self)




    def basisOnderwerp(self):

        localctx = RegelSpraakParser.BasisOnderwerpContext(self, self._ctx, self.state)
        self.enterRule(localctx, 104, self.RULE_basisOnderwerp)
        self._la = 0 # Token type
        try:
            self.state = 745
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [117, 120, 203, 206, 208, 248]:
                self.enterOuterAlt(localctx, 1)
                self.state = 737
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==117 or _la==120 or ((((_la - 203)) & ~0x3f) == 0 and ((1 << (_la - 203)) & 41) != 0):
                    self.state = 736
                    _la = self._input.LA(1)
                    if not(_la==117 or _la==120 or ((((_la - 203)) & ~0x3f) == 0 and ((1 << (_la - 203)) & 41) != 0)):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                self.state = 740 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 739
                        self.match(RegelSpraakParser.IDENTIFIER)

                    else:
                        raise NoViableAltException(self)
                    self.state = 742 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,94,self._ctx)

                pass
            elif token in [209]:
                self.enterOuterAlt(localctx, 2)
                self.state = 744
                self.match(RegelSpraakParser.HIJ)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AttribuutReferentieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def VAN(self):
            return self.getToken(RegelSpraakParser.VAN, 0)

        def onderwerpReferentie(self):
            return self.getTypedRuleContext(RegelSpraakParser.OnderwerpReferentieContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_attribuutReferentie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAttribuutReferentie" ):
                listener.enterAttribuutReferentie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAttribuutReferentie" ):
                listener.exitAttribuutReferentie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAttribuutReferentie" ):
                return visitor.visitAttribuutReferentie(self)
            else:
                return visitor.visitChildren(self)




    def attribuutReferentie(self):

        localctx = RegelSpraakParser.AttribuutReferentieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 106, self.RULE_attribuutReferentie)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 747
            self.naamwoord()
            self.state = 748
            self.match(RegelSpraakParser.VAN)
            self.state = 749
            self.onderwerpReferentie()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class KenmerkNaamContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def onderwerpReferentie(self):
            return self.getTypedRuleContext(RegelSpraakParser.OnderwerpReferentieContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_kenmerkNaam

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterKenmerkNaam" ):
                listener.enterKenmerkNaam(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitKenmerkNaam" ):
                listener.exitKenmerkNaam(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitKenmerkNaam" ):
                return visitor.visitKenmerkNaam(self)
            else:
                return visitor.visitChildren(self)




    def kenmerkNaam(self):

        localctx = RegelSpraakParser.KenmerkNaamContext(self, self._ctx, self.state)
        self.enterRule(localctx, 108, self.RULE_kenmerkNaam)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 751
            self.onderwerpReferentie()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BezieldeReferentieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ZIJN(self):
            return self.getToken(RegelSpraakParser.ZIJN, 0)

        def identifier(self):
            return self.getTypedRuleContext(RegelSpraakParser.IdentifierContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_bezieldeReferentie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBezieldeReferentie" ):
                listener.enterBezieldeReferentie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBezieldeReferentie" ):
                listener.exitBezieldeReferentie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBezieldeReferentie" ):
                return visitor.visitBezieldeReferentie(self)
            else:
                return visitor.visitChildren(self)




    def bezieldeReferentie(self):

        localctx = RegelSpraakParser.BezieldeReferentieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 110, self.RULE_bezieldeReferentie)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 753
            self.match(RegelSpraakParser.ZIJN)
            self.state = 754
            self.identifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ToplevelSamengesteldeVoorwaardeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def AAN(self):
            return self.getToken(RegelSpraakParser.AAN, 0)

        def voorwaardeKwantificatie(self):
            return self.getTypedRuleContext(RegelSpraakParser.VoorwaardeKwantificatieContext,0)


        def VOLGENDE_VOORWAARDEN(self):
            return self.getToken(RegelSpraakParser.VOLGENDE_VOORWAARDEN, 0)

        def VOLDOET(self):
            return self.getToken(RegelSpraakParser.VOLDOET, 0)

        def COLON(self):
            return self.getToken(RegelSpraakParser.COLON, 0)

        def samengesteldeVoorwaardeOnderdeel(self):
            return self.getTypedRuleContext(RegelSpraakParser.SamengesteldeVoorwaardeOnderdeelContext,0)


        def HIJ(self):
            return self.getToken(RegelSpraakParser.HIJ, 0)

        def HET(self):
            return self.getToken(RegelSpraakParser.HET, 0)

        def onderwerpReferentie(self):
            return self.getTypedRuleContext(RegelSpraakParser.OnderwerpReferentieContext,0)


        def ER_AAN(self):
            return self.getToken(RegelSpraakParser.ER_AAN, 0)

        def WORDT_VOLDAAN(self):
            return self.getToken(RegelSpraakParser.WORDT_VOLDAAN, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_toplevelSamengesteldeVoorwaarde

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterToplevelSamengesteldeVoorwaarde" ):
                listener.enterToplevelSamengesteldeVoorwaarde(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitToplevelSamengesteldeVoorwaarde" ):
                listener.exitToplevelSamengesteldeVoorwaarde(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitToplevelSamengesteldeVoorwaarde" ):
                return visitor.visitToplevelSamengesteldeVoorwaarde(self)
            else:
                return visitor.visitChildren(self)




    def toplevelSamengesteldeVoorwaarde(self):

        localctx = RegelSpraakParser.ToplevelSamengesteldeVoorwaardeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 112, self.RULE_toplevelSamengesteldeVoorwaarde)
        try:
            self.state = 775
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [117, 120, 203, 206, 208, 209, 248]:
                self.enterOuterAlt(localctx, 1)
                self.state = 759
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,96,self._ctx)
                if la_ == 1:
                    self.state = 756
                    self.match(RegelSpraakParser.HIJ)
                    pass

                elif la_ == 2:
                    self.state = 757
                    self.match(RegelSpraakParser.HET)
                    pass

                elif la_ == 3:
                    self.state = 758
                    self.onderwerpReferentie()
                    pass


                self.state = 761
                self.match(RegelSpraakParser.AAN)
                self.state = 762
                self.voorwaardeKwantificatie()
                self.state = 763
                self.match(RegelSpraakParser.VOLGENDE_VOORWAARDEN)
                self.state = 764
                self.match(RegelSpraakParser.VOLDOET)
                self.state = 765
                self.match(RegelSpraakParser.COLON)
                self.state = 766
                self.samengesteldeVoorwaardeOnderdeel()
                pass
            elif token in [49]:
                self.enterOuterAlt(localctx, 2)
                self.state = 768
                self.match(RegelSpraakParser.ER_AAN)
                self.state = 769
                self.voorwaardeKwantificatie()
                self.state = 770
                self.match(RegelSpraakParser.VOLGENDE_VOORWAARDEN)
                self.state = 771
                self.match(RegelSpraakParser.WORDT_VOLDAAN)
                self.state = 772
                self.match(RegelSpraakParser.COLON)
                self.state = 773
                self.samengesteldeVoorwaardeOnderdeel()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VoorwaardeKwantificatieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ALLE(self):
            return self.getToken(RegelSpraakParser.ALLE, 0)

        def TENMINSTE(self):
            return self.getToken(RegelSpraakParser.TENMINSTE, 0)

        def VAN(self):
            return self.getToken(RegelSpraakParser.VAN, 0)

        def DE(self):
            return self.getToken(RegelSpraakParser.DE, 0)

        def EEN_TELWOORD(self):
            return self.getToken(RegelSpraakParser.EEN_TELWOORD, 0)

        def TWEE_TELWOORD(self):
            return self.getToken(RegelSpraakParser.TWEE_TELWOORD, 0)

        def DRIE_TELWOORD(self):
            return self.getToken(RegelSpraakParser.DRIE_TELWOORD, 0)

        def VIER_TELWOORD(self):
            return self.getToken(RegelSpraakParser.VIER_TELWOORD, 0)

        def NUMBER(self):
            return self.getToken(RegelSpraakParser.NUMBER, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_voorwaardeKwantificatie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVoorwaardeKwantificatie" ):
                listener.enterVoorwaardeKwantificatie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVoorwaardeKwantificatie" ):
                listener.exitVoorwaardeKwantificatie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVoorwaardeKwantificatie" ):
                return visitor.visitVoorwaardeKwantificatie(self)
            else:
                return visitor.visitChildren(self)




    def voorwaardeKwantificatie(self):

        localctx = RegelSpraakParser.VoorwaardeKwantificatieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 114, self.RULE_voorwaardeKwantificatie)
        self._la = 0 # Token type
        try:
            self.state = 782
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [120]:
                self.enterOuterAlt(localctx, 1)
                self.state = 777
                self.match(RegelSpraakParser.ALLE)
                pass
            elif token in [152]:
                self.enterOuterAlt(localctx, 2)
                self.state = 778
                self.match(RegelSpraakParser.TENMINSTE)
                self.state = 779
                _la = self._input.LA(1)
                if not(((((_la - 192)) & ~0x3f) == 0 and ((1 << (_la - 192)) & 144115188075855971) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 780
                self.match(RegelSpraakParser.VAN)
                self.state = 781
                self.match(RegelSpraakParser.DE)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SamengesteldeVoorwaardeOnderdeelContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def genesteVoorwaarde(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.GenesteVoorwaardeContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.GenesteVoorwaardeContext,i)


        def BULLET(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.BULLET)
            else:
                return self.getToken(RegelSpraakParser.BULLET, i)

        def MINUS(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.MINUS)
            else:
                return self.getToken(RegelSpraakParser.MINUS, i)

        def ASTERISK(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.ASTERISK)
            else:
                return self.getToken(RegelSpraakParser.ASTERISK, i)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_samengesteldeVoorwaardeOnderdeel

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSamengesteldeVoorwaardeOnderdeel" ):
                listener.enterSamengesteldeVoorwaardeOnderdeel(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSamengesteldeVoorwaardeOnderdeel" ):
                listener.exitSamengesteldeVoorwaardeOnderdeel(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSamengesteldeVoorwaardeOnderdeel" ):
                return visitor.visitSamengesteldeVoorwaardeOnderdeel(self)
            else:
                return visitor.visitChildren(self)




    def samengesteldeVoorwaardeOnderdeel(self):

        localctx = RegelSpraakParser.SamengesteldeVoorwaardeOnderdeelContext(self, self._ctx, self.state)
        self.enterRule(localctx, 116, self.RULE_samengesteldeVoorwaardeOnderdeel)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 784
            _la = self._input.LA(1)
            if not(((((_la - 265)) & ~0x3f) == 0 and ((1 << (_la - 265)) & 131) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 785
            self.genesteVoorwaarde()
            self.state = 790
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((((_la - 265)) & ~0x3f) == 0 and ((1 << (_la - 265)) & 131) != 0):
                self.state = 786
                _la = self._input.LA(1)
                if not(((((_la - 265)) & ~0x3f) == 0 and ((1 << (_la - 265)) & 131) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 787
                self.genesteVoorwaarde()
                self.state = 792
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GenesteVoorwaardeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_genesteVoorwaarde

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGenesteVoorwaarde" ):
                listener.enterGenesteVoorwaarde(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGenesteVoorwaarde" ):
                listener.exitGenesteVoorwaarde(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGenesteVoorwaarde" ):
                return visitor.visitGenesteVoorwaarde(self)
            else:
                return visitor.visitChildren(self)




    def genesteVoorwaarde(self):

        localctx = RegelSpraakParser.GenesteVoorwaardeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 118, self.RULE_genesteVoorwaarde)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 793
            self.expressie()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VariabeleDeelContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DAARBIJ_GELDT(self):
            return self.getToken(RegelSpraakParser.DAARBIJ_GELDT, 0)

        def DOT(self):
            return self.getToken(RegelSpraakParser.DOT, 0)

        def variabeleToekenning(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.VariabeleToekenningContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.VariabeleToekenningContext,i)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_variabeleDeel

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVariabeleDeel" ):
                listener.enterVariabeleDeel(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVariabeleDeel" ):
                listener.exitVariabeleDeel(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVariabeleDeel" ):
                return visitor.visitVariabeleDeel(self)
            else:
                return visitor.visitChildren(self)




    def variabeleDeel(self):

        localctx = RegelSpraakParser.VariabeleDeelContext(self, self._ctx, self.state)
        self.enterRule(localctx, 120, self.RULE_variabeleDeel)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 795
            self.match(RegelSpraakParser.DAARBIJ_GELDT)
            self.state = 799
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==48 or _la==117 or _la==136 or ((((_la - 203)) & ~0x3f) == 0 and ((1 << (_la - 203)) & 35184372088865) != 0):
                self.state = 796
                self.variabeleToekenning()
                self.state = 801
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 802
            self.match(RegelSpraakParser.DOT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VariabeleToekenningContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def IS(self):
            return self.getToken(RegelSpraakParser.IS, 0)

        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)


        def SEMICOLON(self):
            return self.getToken(RegelSpraakParser.SEMICOLON, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_variabeleToekenning

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVariabeleToekenning" ):
                listener.enterVariabeleToekenning(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVariabeleToekenning" ):
                listener.exitVariabeleToekenning(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVariabeleToekenning" ):
                return visitor.visitVariabeleToekenning(self)
            else:
                return visitor.visitChildren(self)




    def variabeleToekenning(self):

        localctx = RegelSpraakParser.VariabeleToekenningContext(self, self._ctx, self.state)
        self.enterRule(localctx, 122, self.RULE_variabeleToekenning)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 804
            self.naamwoord()
            self.state = 805
            self.match(RegelSpraakParser.IS)
            self.state = 806
            self.expressie()
            self.state = 808
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==262:
                self.state = 807
                self.match(RegelSpraakParser.SEMICOLON)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExpressieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def logicalExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.LogicalExpressionContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_expressie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpressie" ):
                listener.enterExpressie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpressie" ):
                listener.exitExpressie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExpressie" ):
                return visitor.visitExpressie(self)
            else:
                return visitor.visitChildren(self)




    def expressie(self):

        localctx = RegelSpraakParser.ExpressieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 124, self.RULE_expressie)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 810
            self.logicalExpression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LogicalExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_logicalExpression

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class LogicalExprContext(LogicalExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.LogicalExpressionContext
            super().__init__(parser)
            self.left = None # ComparisonExpressionContext
            self.op = None # Token
            self.right = None # LogicalExpressionContext
            self.copyFrom(ctx)

        def comparisonExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.ComparisonExpressionContext,0)

        def logicalExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.LogicalExpressionContext,0)

        def EN(self):
            return self.getToken(RegelSpraakParser.EN, 0)
        def OF(self):
            return self.getToken(RegelSpraakParser.OF, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLogicalExpr" ):
                listener.enterLogicalExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLogicalExpr" ):
                listener.exitLogicalExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLogicalExpr" ):
                return visitor.visitLogicalExpr(self)
            else:
                return visitor.visitChildren(self)



    def logicalExpression(self):

        localctx = RegelSpraakParser.LogicalExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 126, self.RULE_logicalExpression)
        self._la = 0 # Token type
        try:
            localctx = RegelSpraakParser.LogicalExprContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 812
            localctx.left = self.comparisonExpression()
            self.state = 815
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,102,self._ctx)
            if la_ == 1:
                self.state = 813
                localctx.op = self._input.LT(1)
                _la = self._input.LA(1)
                if not(_la==207 or _la==216):
                    localctx.op = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 814
                localctx.right = self.logicalExpression()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ComparisonExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_comparisonExpression

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class BinaryComparisonExprContext(ComparisonExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.ComparisonExpressionContext
            super().__init__(parser)
            self.left = None # AdditiveExpressionContext
            self.right = None # AdditiveExpressionContext
            self.copyFrom(ctx)

        def additiveExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.AdditiveExpressionContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.AdditiveExpressionContext,i)

        def comparisonOperator(self):
            return self.getTypedRuleContext(RegelSpraakParser.ComparisonOperatorContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBinaryComparisonExpr" ):
                listener.enterBinaryComparisonExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBinaryComparisonExpr" ):
                listener.exitBinaryComparisonExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBinaryComparisonExpr" ):
                return visitor.visitBinaryComparisonExpr(self)
            else:
                return visitor.visitChildren(self)


    class UnaryConditionExprContext(ComparisonExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.ComparisonExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def unaryCondition(self):
            return self.getTypedRuleContext(RegelSpraakParser.UnaryConditionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnaryConditionExpr" ):
                listener.enterUnaryConditionExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnaryConditionExpr" ):
                listener.exitUnaryConditionExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnaryConditionExpr" ):
                return visitor.visitUnaryConditionExpr(self)
            else:
                return visitor.visitChildren(self)


    class HeeftKenmerkExprContext(ComparisonExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.ComparisonExpressionContext
            super().__init__(parser)
            self.left = None # AdditiveExpressionContext
            self.copyFrom(ctx)

        def HEEFT(self):
            return self.getToken(RegelSpraakParser.HEEFT, 0)
        def identifier(self):
            return self.getTypedRuleContext(RegelSpraakParser.IdentifierContext,0)

        def additiveExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.AdditiveExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterHeeftKenmerkExpr" ):
                listener.enterHeeftKenmerkExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitHeeftKenmerkExpr" ):
                listener.exitHeeftKenmerkExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitHeeftKenmerkExpr" ):
                return visitor.visitHeeftKenmerkExpr(self)
            else:
                return visitor.visitChildren(self)


    class IsKenmerkExprContext(ComparisonExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.ComparisonExpressionContext
            super().__init__(parser)
            self.left = None # AdditiveExpressionContext
            self.copyFrom(ctx)

        def IS(self):
            return self.getToken(RegelSpraakParser.IS, 0)
        def identifier(self):
            return self.getTypedRuleContext(RegelSpraakParser.IdentifierContext,0)

        def additiveExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.AdditiveExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIsKenmerkExpr" ):
                listener.enterIsKenmerkExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIsKenmerkExpr" ):
                listener.exitIsKenmerkExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIsKenmerkExpr" ):
                return visitor.visitIsKenmerkExpr(self)
            else:
                return visitor.visitChildren(self)


    class RegelStatusConditionExprContext(ComparisonExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.ComparisonExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def regelStatusCondition(self):
            return self.getTypedRuleContext(RegelSpraakParser.RegelStatusConditionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRegelStatusConditionExpr" ):
                listener.enterRegelStatusConditionExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRegelStatusConditionExpr" ):
                listener.exitRegelStatusConditionExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRegelStatusConditionExpr" ):
                return visitor.visitRegelStatusConditionExpr(self)
            else:
                return visitor.visitChildren(self)



    def comparisonExpression(self):

        localctx = RegelSpraakParser.ComparisonExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 128, self.RULE_comparisonExpression)
        try:
            self.state = 833
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,104,self._ctx)
            if la_ == 1:
                localctx = RegelSpraakParser.IsKenmerkExprContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 817
                localctx.left = self.additiveExpression()
                self.state = 818
                self.match(RegelSpraakParser.IS)
                self.state = 819
                self.identifier()
                pass

            elif la_ == 2:
                localctx = RegelSpraakParser.HeeftKenmerkExprContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 821
                localctx.left = self.additiveExpression()
                self.state = 822
                self.match(RegelSpraakParser.HEEFT)
                self.state = 823
                self.identifier()
                pass

            elif la_ == 3:
                localctx = RegelSpraakParser.BinaryComparisonExprContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 825
                localctx.left = self.additiveExpression()
                self.state = 829
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,103,self._ctx)
                if la_ == 1:
                    self.state = 826
                    self.comparisonOperator()
                    self.state = 827
                    localctx.right = self.additiveExpression()


                pass

            elif la_ == 4:
                localctx = RegelSpraakParser.UnaryConditionExprContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 831
                self.unaryCondition()
                pass

            elif la_ == 5:
                localctx = RegelSpraakParser.RegelStatusConditionExprContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 832
                self.regelStatusCondition()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ComparisonOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.GELIJK_AAN, 0)

        def ONGELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.ONGELIJK_AAN, 0)

        def GROTER_DAN(self):
            return self.getToken(RegelSpraakParser.GROTER_DAN, 0)

        def GROTER_OF_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.GROTER_OF_GELIJK_AAN, 0)

        def KLEINER_DAN(self):
            return self.getToken(RegelSpraakParser.KLEINER_DAN, 0)

        def KLEINER_OF_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.KLEINER_OF_GELIJK_AAN, 0)

        def KLEINER_IS_DAN(self):
            return self.getToken(RegelSpraakParser.KLEINER_IS_DAN, 0)

        def GROTER_IS_DAN(self):
            return self.getToken(RegelSpraakParser.GROTER_IS_DAN, 0)

        def IS(self):
            return self.getToken(RegelSpraakParser.IS, 0)

        def IN(self):
            return self.getToken(RegelSpraakParser.IN, 0)

        def LATER_DAN(self):
            return self.getToken(RegelSpraakParser.LATER_DAN, 0)

        def LATER_OF_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.LATER_OF_GELIJK_AAN, 0)

        def EERDER_DAN(self):
            return self.getToken(RegelSpraakParser.EERDER_DAN, 0)

        def EERDER_OF_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.EERDER_OF_GELIJK_AAN, 0)

        def NIET(self):
            return self.getToken(RegelSpraakParser.NIET, 0)

        def IS_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.IS_GELIJK_AAN, 0)

        def IS_ONGELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.IS_ONGELIJK_AAN, 0)

        def IS_KLEINER_DAN(self):
            return self.getToken(RegelSpraakParser.IS_KLEINER_DAN, 0)

        def IS_KLEINER_OF_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.IS_KLEINER_OF_GELIJK_AAN, 0)

        def IS_GROTER_DAN(self):
            return self.getToken(RegelSpraakParser.IS_GROTER_DAN, 0)

        def IS_GROTER_OF_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.IS_GROTER_OF_GELIJK_AAN, 0)

        def ZIJN_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.ZIJN_GELIJK_AAN, 0)

        def ZIJN_ONGELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.ZIJN_ONGELIJK_AAN, 0)

        def ZIJN_KLEINER_DAN(self):
            return self.getToken(RegelSpraakParser.ZIJN_KLEINER_DAN, 0)

        def ZIJN_KLEINER_OF_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.ZIJN_KLEINER_OF_GELIJK_AAN, 0)

        def ZIJN_GROTER_DAN(self):
            return self.getToken(RegelSpraakParser.ZIJN_GROTER_DAN, 0)

        def ZIJN_GROTER_OF_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.ZIJN_GROTER_OF_GELIJK_AAN, 0)

        def IS_LATER_DAN(self):
            return self.getToken(RegelSpraakParser.IS_LATER_DAN, 0)

        def IS_LATER_OF_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.IS_LATER_OF_GELIJK_AAN, 0)

        def IS_EERDER_DAN(self):
            return self.getToken(RegelSpraakParser.IS_EERDER_DAN, 0)

        def IS_EERDER_OF_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.IS_EERDER_OF_GELIJK_AAN, 0)

        def ZIJN_LATER_DAN(self):
            return self.getToken(RegelSpraakParser.ZIJN_LATER_DAN, 0)

        def ZIJN_LATER_OF_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.ZIJN_LATER_OF_GELIJK_AAN, 0)

        def ZIJN_EERDER_DAN(self):
            return self.getToken(RegelSpraakParser.ZIJN_EERDER_DAN, 0)

        def ZIJN_EERDER_OF_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.ZIJN_EERDER_OF_GELIJK_AAN, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_comparisonOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterComparisonOperator" ):
                listener.enterComparisonOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitComparisonOperator" ):
                listener.exitComparisonOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitComparisonOperator" ):
                return visitor.visitComparisonOperator(self)
            else:
                return visitor.visitChildren(self)




    def comparisonOperator(self):

        localctx = RegelSpraakParser.ComparisonOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 130, self.RULE_comparisonOperator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 835
            _la = self._input.LA(1)
            if not(((((_la - 25)) & ~0x3f) == 0 and ((1 << (_la - 25)) & 35184338731023) != 0) or ((((_la - 113)) & ~0x3f) == 0 and ((1 << (_la - 113)) & 25381121) != 0) or _la==210):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AdditiveExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.left = None # MultiplicativeExpressionContext
            self.right = None # MultiplicativeExpressionContext

        def multiplicativeExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.MultiplicativeExpressionContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.MultiplicativeExpressionContext,i)


        def additiveOperator(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.AdditiveOperatorContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.AdditiveOperatorContext,i)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_additiveExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAdditiveExpression" ):
                listener.enterAdditiveExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAdditiveExpression" ):
                listener.exitAdditiveExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAdditiveExpression" ):
                return visitor.visitAdditiveExpression(self)
            else:
                return visitor.visitChildren(self)




    def additiveExpression(self):

        localctx = RegelSpraakParser.AdditiveExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 132, self.RULE_additiveExpression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 837
            localctx.left = self.multiplicativeExpression()
            self.state = 843
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,105,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 838
                    self.additiveOperator()
                    self.state = 839
                    localctx.right = self.multiplicativeExpression() 
                self.state = 845
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,105,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AdditiveOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PLUS(self):
            return self.getToken(RegelSpraakParser.PLUS, 0)

        def MIN(self):
            return self.getToken(RegelSpraakParser.MIN, 0)

        def VERMINDERD_MET(self):
            return self.getToken(RegelSpraakParser.VERMINDERD_MET, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_additiveOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAdditiveOperator" ):
                listener.enterAdditiveOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAdditiveOperator" ):
                listener.exitAdditiveOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAdditiveOperator" ):
                return visitor.visitAdditiveOperator(self)
            else:
                return visitor.visitChildren(self)




    def additiveOperator(self):

        localctx = RegelSpraakParser.AdditiveOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 134, self.RULE_additiveOperator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 846
            _la = self._input.LA(1)
            if not(((((_la - 133)) & ~0x3f) == 0 and ((1 << (_la - 133)) & 16417) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MultiplicativeExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.left = None # PowerExpressionContext
            self.right = None # PowerExpressionContext

        def powerExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.PowerExpressionContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.PowerExpressionContext,i)


        def multiplicativeOperator(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.MultiplicativeOperatorContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.MultiplicativeOperatorContext,i)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_multiplicativeExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMultiplicativeExpression" ):
                listener.enterMultiplicativeExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMultiplicativeExpression" ):
                listener.exitMultiplicativeExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMultiplicativeExpression" ):
                return visitor.visitMultiplicativeExpression(self)
            else:
                return visitor.visitChildren(self)




    def multiplicativeExpression(self):

        localctx = RegelSpraakParser.MultiplicativeExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 136, self.RULE_multiplicativeExpression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 848
            localctx.left = self.powerExpression()
            self.state = 854
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,106,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 849
                    self.multiplicativeOperator()
                    self.state = 850
                    localctx.right = self.powerExpression() 
                self.state = 856
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,106,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MultiplicativeOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MAAL(self):
            return self.getToken(RegelSpraakParser.MAAL, 0)

        def GEDEELD_DOOR(self):
            return self.getToken(RegelSpraakParser.GEDEELD_DOOR, 0)

        def GEDEELD_DOOR_ABS(self):
            return self.getToken(RegelSpraakParser.GEDEELD_DOOR_ABS, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_multiplicativeOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMultiplicativeOperator" ):
                listener.enterMultiplicativeOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMultiplicativeOperator" ):
                listener.exitMultiplicativeOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMultiplicativeOperator" ):
                return visitor.visitMultiplicativeOperator(self)
            else:
                return visitor.visitChildren(self)




    def multiplicativeOperator(self):

        localctx = RegelSpraakParser.MultiplicativeOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 138, self.RULE_multiplicativeOperator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 857
            _la = self._input.LA(1)
            if not(((((_la - 122)) & ~0x3f) == 0 and ((1 << (_la - 122)) & 1027) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PowerExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.left = None # PrimaryExpressionContext
            self.right = None # PrimaryExpressionContext

        def primaryExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.PrimaryExpressionContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,i)


        def powerOperator(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.PowerOperatorContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.PowerOperatorContext,i)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_powerExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPowerExpression" ):
                listener.enterPowerExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPowerExpression" ):
                listener.exitPowerExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPowerExpression" ):
                return visitor.visitPowerExpression(self)
            else:
                return visitor.visitChildren(self)




    def powerExpression(self):

        localctx = RegelSpraakParser.PowerExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 140, self.RULE_powerExpression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 859
            localctx.left = self.primaryExpression(0)
            self.state = 865
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,107,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 860
                    self.powerOperator()
                    self.state = 861
                    localctx.right = self.primaryExpression(0) 
                self.state = 867
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,107,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PowerOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TOT_DE_MACHT(self):
            return self.getToken(RegelSpraakParser.TOT_DE_MACHT, 0)

        def CARET(self):
            return self.getToken(RegelSpraakParser.CARET, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_powerOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPowerOperator" ):
                listener.enterPowerOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPowerOperator" ):
                listener.exitPowerOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPowerOperator" ):
                return visitor.visitPowerOperator(self)
            else:
                return visitor.visitChildren(self)




    def powerOperator(self):

        localctx = RegelSpraakParser.PowerOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 142, self.RULE_powerOperator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 868
            _la = self._input.LA(1)
            if not(_la==142 or _la==269):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PrimaryExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_primaryExpression

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)


    class WortelFuncExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def DE_WORTEL_VAN(self):
            return self.getToken(RegelSpraakParser.DE_WORTEL_VAN, 0)
        def primaryExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWortelFuncExpr" ):
                listener.enterWortelFuncExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWortelFuncExpr" ):
                listener.exitWortelFuncExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitWortelFuncExpr" ):
                return visitor.visitWortelFuncExpr(self)
            else:
                return visitor.visitChildren(self)


    class BooleanTrueLiteralExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def WAAR(self):
            return self.getToken(RegelSpraakParser.WAAR, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBooleanTrueLiteralExpr" ):
                listener.enterBooleanTrueLiteralExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBooleanTrueLiteralExpr" ):
                listener.exitBooleanTrueLiteralExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBooleanTrueLiteralExpr" ):
                return visitor.visitBooleanTrueLiteralExpr(self)
            else:
                return visitor.visitChildren(self)


    class DatumMetFuncExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def DE_DATUM_MET(self):
            return self.getToken(RegelSpraakParser.DE_DATUM_MET, 0)
        def LPAREN(self):
            return self.getToken(RegelSpraakParser.LPAREN, 0)
        def primaryExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.PrimaryExpressionContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,i)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.COMMA)
            else:
                return self.getToken(RegelSpraakParser.COMMA, i)
        def RPAREN(self):
            return self.getToken(RegelSpraakParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDatumMetFuncExpr" ):
                listener.enterDatumMetFuncExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDatumMetFuncExpr" ):
                listener.exitDatumMetFuncExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDatumMetFuncExpr" ):
                return visitor.visitDatumMetFuncExpr(self)
            else:
                return visitor.visitChildren(self)


    class StringLiteralExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def STRING_LITERAL(self):
            return self.getToken(RegelSpraakParser.STRING_LITERAL, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStringLiteralExpr" ):
                listener.enterStringLiteralExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStringLiteralExpr" ):
                listener.exitStringLiteralExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStringLiteralExpr" ):
                return visitor.visitStringLiteralExpr(self)
            else:
                return visitor.visitChildren(self)


    class AbsValFuncExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def DE_ABSOLUTE_WAARDE_VAN(self):
            return self.getToken(RegelSpraakParser.DE_ABSOLUTE_WAARDE_VAN, 0)
        def LPAREN(self):
            return self.getToken(RegelSpraakParser.LPAREN, 0)
        def primaryExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,0)

        def RPAREN(self):
            return self.getToken(RegelSpraakParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAbsValFuncExpr" ):
                listener.enterAbsValFuncExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAbsValFuncExpr" ):
                listener.exitAbsValFuncExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAbsValFuncExpr" ):
                return visitor.visitAbsValFuncExpr(self)
            else:
                return visitor.visitChildren(self)


    class MaxValFuncExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def DE_MAXIMALE_WAARDE_VAN(self):
            return self.getToken(RegelSpraakParser.DE_MAXIMALE_WAARDE_VAN, 0)
        def primaryExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.PrimaryExpressionContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,i)

        def EN(self):
            return self.getToken(RegelSpraakParser.EN, 0)
        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.COMMA)
            else:
                return self.getToken(RegelSpraakParser.COMMA, i)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMaxValFuncExpr" ):
                listener.enterMaxValFuncExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMaxValFuncExpr" ):
                listener.exitMaxValFuncExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMaxValFuncExpr" ):
                return visitor.visitMaxValFuncExpr(self)
            else:
                return visitor.visitChildren(self)


    class RekendatumKeywordExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def REKENDATUM(self):
            return self.getToken(RegelSpraakParser.REKENDATUM, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRekendatumKeywordExpr" ):
                listener.enterRekendatumKeywordExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRekendatumKeywordExpr" ):
                listener.exitRekendatumKeywordExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRekendatumKeywordExpr" ):
                return visitor.visitRekendatumKeywordExpr(self)
            else:
                return visitor.visitChildren(self)


    class PercentageFuncExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.p = None # Token
            self.copyFrom(ctx)

        def NUMBER(self):
            return self.getToken(RegelSpraakParser.NUMBER, 0)
        def VAN(self):
            return self.getToken(RegelSpraakParser.VAN, 0)
        def primaryExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,0)

        def PERCENT_SIGN(self):
            return self.getToken(RegelSpraakParser.PERCENT_SIGN, 0)
        def IDENTIFIER(self):
            return self.getToken(RegelSpraakParser.IDENTIFIER, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPercentageFuncExpr" ):
                listener.enterPercentageFuncExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPercentageFuncExpr" ):
                listener.exitPercentageFuncExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPercentageFuncExpr" ):
                return visitor.visitPercentageFuncExpr(self)
            else:
                return visitor.visitChildren(self)


    class EersteDatumFuncExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def EERSTE_VAN(self):
            return self.getToken(RegelSpraakParser.EERSTE_VAN, 0)
        def primaryExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.PrimaryExpressionContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,i)

        def EN(self):
            return self.getToken(RegelSpraakParser.EN, 0)
        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.COMMA)
            else:
                return self.getToken(RegelSpraakParser.COMMA, i)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEersteDatumFuncExpr" ):
                listener.enterEersteDatumFuncExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEersteDatumFuncExpr" ):
                listener.exitEersteDatumFuncExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEersteDatumFuncExpr" ):
                return visitor.visitEersteDatumFuncExpr(self)
            else:
                return visitor.visitChildren(self)


    class PasenFuncExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def DE_EERSTE_PAASDAG_VAN(self):
            return self.getToken(RegelSpraakParser.DE_EERSTE_PAASDAG_VAN, 0)
        def LPAREN(self):
            return self.getToken(RegelSpraakParser.LPAREN, 0)
        def primaryExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,0)

        def RPAREN(self):
            return self.getToken(RegelSpraakParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPasenFuncExpr" ):
                listener.enterPasenFuncExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPasenFuncExpr" ):
                listener.exitPasenFuncExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPasenFuncExpr" ):
                return visitor.visitPasenFuncExpr(self)
            else:
                return visitor.visitChildren(self)


    class EnumLiteralExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ENUM_LITERAL(self):
            return self.getToken(RegelSpraakParser.ENUM_LITERAL, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEnumLiteralExpr" ):
                listener.enterEnumLiteralExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEnumLiteralExpr" ):
                listener.exitEnumLiteralExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEnumLiteralExpr" ):
                return visitor.visitEnumLiteralExpr(self)
            else:
                return visitor.visitChildren(self)


    class NumberLiteralExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def NUMBER(self):
            return self.getToken(RegelSpraakParser.NUMBER, 0)
        def unitIdentifier(self):
            return self.getTypedRuleContext(RegelSpraakParser.UnitIdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumberLiteralExpr" ):
                listener.enterNumberLiteralExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumberLiteralExpr" ):
                listener.exitNumberLiteralExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNumberLiteralExpr" ):
                return visitor.visitNumberLiteralExpr(self)
            else:
                return visitor.visitChildren(self)


    class AbsTijdsduurFuncExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.unitName = None # Token
            self.copyFrom(ctx)

        def DE_ABSOLUTE_TIJDSDUUR_VAN(self):
            return self.getToken(RegelSpraakParser.DE_ABSOLUTE_TIJDSDUUR_VAN, 0)
        def primaryExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.PrimaryExpressionContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,i)

        def TOT(self):
            return self.getToken(RegelSpraakParser.TOT, 0)
        def IN_HELE(self):
            return self.getToken(RegelSpraakParser.IN_HELE, 0)
        def IDENTIFIER(self):
            return self.getToken(RegelSpraakParser.IDENTIFIER, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAbsTijdsduurFuncExpr" ):
                listener.enterAbsTijdsduurFuncExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAbsTijdsduurFuncExpr" ):
                listener.exitAbsTijdsduurFuncExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAbsTijdsduurFuncExpr" ):
                return visitor.visitAbsTijdsduurFuncExpr(self)
            else:
                return visitor.visitChildren(self)


    class MaandUitFuncExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def DE(self):
            return self.getToken(RegelSpraakParser.DE, 0)
        def MAAND(self):
            return self.getToken(RegelSpraakParser.MAAND, 0)
        def UIT(self):
            return self.getToken(RegelSpraakParser.UIT, 0)
        def primaryExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMaandUitFuncExpr" ):
                listener.enterMaandUitFuncExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMaandUitFuncExpr" ):
                listener.exitMaandUitFuncExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMaandUitFuncExpr" ):
                return visitor.visitMaandUitFuncExpr(self)
            else:
                return visitor.visitChildren(self)


    class CapitalizedTotaalVanExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.condition = None # ExpressieContext
            self.copyFrom(ctx)

        def HET_TOTAAL_VAN(self):
            return self.getToken(RegelSpraakParser.HET_TOTAAL_VAN, 0)
        def expressie(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.ExpressieContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,i)

        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.IdentifierContext,i)

        def GEDURENDE_DE_TIJD_DAT(self):
            return self.getToken(RegelSpraakParser.GEDURENDE_DE_TIJD_DAT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCapitalizedTotaalVanExpr" ):
                listener.enterCapitalizedTotaalVanExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCapitalizedTotaalVanExpr" ):
                listener.exitCapitalizedTotaalVanExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCapitalizedTotaalVanExpr" ):
                return visitor.visitCapitalizedTotaalVanExpr(self)
            else:
                return visitor.visitChildren(self)


    class IdentifierExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(RegelSpraakParser.IdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIdentifierExpr" ):
                listener.enterIdentifierExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIdentifierExpr" ):
                listener.exitIdentifierExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIdentifierExpr" ):
                return visitor.visitIdentifierExpr(self)
            else:
                return visitor.visitChildren(self)


    class DatumLiteralExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def datumLiteral(self):
            return self.getTypedRuleContext(RegelSpraakParser.DatumLiteralContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDatumLiteralExpr" ):
                listener.enterDatumLiteralExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDatumLiteralExpr" ):
                listener.exitDatumLiteralExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDatumLiteralExpr" ):
                return visitor.visitDatumLiteralExpr(self)
            else:
                return visitor.visitChildren(self)


    class DimensieAggExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def attribuutReferentie(self):
            return self.getTypedRuleContext(RegelSpraakParser.AttribuutReferentieContext,0)

        def dimensieSelectie(self):
            return self.getTypedRuleContext(RegelSpraakParser.DimensieSelectieContext,0)

        def getalAggregatieFunctie(self):
            return self.getTypedRuleContext(RegelSpraakParser.GetalAggregatieFunctieContext,0)

        def datumAggregatieFunctie(self):
            return self.getTypedRuleContext(RegelSpraakParser.DatumAggregatieFunctieContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDimensieAggExpr" ):
                listener.enterDimensieAggExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDimensieAggExpr" ):
                listener.exitDimensieAggExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDimensieAggExpr" ):
                return visitor.visitDimensieAggExpr(self)
            else:
                return visitor.visitChildren(self)


    class TijdsduurFuncExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.unitName = None # Token
            self.copyFrom(ctx)

        def TIJDSDUUR_VAN(self):
            return self.getToken(RegelSpraakParser.TIJDSDUUR_VAN, 0)
        def primaryExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.PrimaryExpressionContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,i)

        def TOT(self):
            return self.getToken(RegelSpraakParser.TOT, 0)
        def IN_HELE(self):
            return self.getToken(RegelSpraakParser.IN_HELE, 0)
        def IDENTIFIER(self):
            return self.getToken(RegelSpraakParser.IDENTIFIER, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTijdsduurFuncExpr" ):
                listener.enterTijdsduurFuncExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTijdsduurFuncExpr" ):
                listener.exitTijdsduurFuncExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTijdsduurFuncExpr" ):
                return visitor.visitTijdsduurFuncExpr(self)
            else:
                return visitor.visitChildren(self)


    class AantalFuncExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def AANTAL(self):
            return self.getToken(RegelSpraakParser.AANTAL, 0)
        def onderwerpReferentie(self):
            return self.getTypedRuleContext(RegelSpraakParser.OnderwerpReferentieContext,0)

        def HET(self):
            return self.getToken(RegelSpraakParser.HET, 0)
        def ALLE(self):
            return self.getToken(RegelSpraakParser.ALLE, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAantalFuncExpr" ):
                listener.enterAantalFuncExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAantalFuncExpr" ):
                listener.exitAantalFuncExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAantalFuncExpr" ):
                return visitor.visitAantalFuncExpr(self)
            else:
                return visitor.visitChildren(self)


    class UnaryNietExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def NIET(self):
            return self.getToken(RegelSpraakParser.NIET, 0)
        def primaryExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnaryNietExpr" ):
                listener.enterUnaryNietExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnaryNietExpr" ):
                listener.exitUnaryNietExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnaryNietExpr" ):
                return visitor.visitUnaryNietExpr(self)
            else:
                return visitor.visitChildren(self)


    class ConcatenatieExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def CONCATENATIE_VAN(self):
            return self.getToken(RegelSpraakParser.CONCATENATIE_VAN, 0)
        def primaryExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.PrimaryExpressionContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,i)

        def EN(self):
            return self.getToken(RegelSpraakParser.EN, 0)
        def OF(self):
            return self.getToken(RegelSpraakParser.OF, 0)
        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.COMMA)
            else:
                return self.getToken(RegelSpraakParser.COMMA, i)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConcatenatieExpr" ):
                listener.enterConcatenatieExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConcatenatieExpr" ):
                listener.exitConcatenatieExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConcatenatieExpr" ):
                return visitor.visitConcatenatieExpr(self)
            else:
                return visitor.visitChildren(self)


    class OnderwerpRefExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def onderwerpReferentie(self):
            return self.getTypedRuleContext(RegelSpraakParser.OnderwerpReferentieContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOnderwerpRefExpr" ):
                listener.enterOnderwerpRefExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOnderwerpRefExpr" ):
                listener.exitOnderwerpRefExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOnderwerpRefExpr" ):
                return visitor.visitOnderwerpRefExpr(self)
            else:
                return visitor.visitChildren(self)


    class SomFuncExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def SOM_VAN(self):
            return self.getToken(RegelSpraakParser.SOM_VAN, 0)
        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSomFuncExpr" ):
                listener.enterSomFuncExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSomFuncExpr" ):
                listener.exitSomFuncExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSomFuncExpr" ):
                return visitor.visitSomFuncExpr(self)
            else:
                return visitor.visitChildren(self)


    class AttrRefExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def attribuutReferentie(self):
            return self.getTypedRuleContext(RegelSpraakParser.AttribuutReferentieContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAttrRefExpr" ):
                listener.enterAttrRefExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAttrRefExpr" ):
                listener.exitAttrRefExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAttrRefExpr" ):
                return visitor.visitAttrRefExpr(self)
            else:
                return visitor.visitChildren(self)


    class DagUitFuncExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def DE(self):
            return self.getToken(RegelSpraakParser.DE, 0)
        def DAG(self):
            return self.getToken(RegelSpraakParser.DAG, 0)
        def UIT(self):
            return self.getToken(RegelSpraakParser.UIT, 0)
        def primaryExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDagUitFuncExpr" ):
                listener.enterDagUitFuncExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDagUitFuncExpr" ):
                listener.exitDagUitFuncExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDagUitFuncExpr" ):
                return visitor.visitDagUitFuncExpr(self)
            else:
                return visitor.visitChildren(self)


    class SimpleConcatenatieExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def primaryExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.PrimaryExpressionContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,i)

        def EN(self):
            return self.getToken(RegelSpraakParser.EN, 0)
        def OF(self):
            return self.getToken(RegelSpraakParser.OF, 0)
        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.COMMA)
            else:
                return self.getToken(RegelSpraakParser.COMMA, i)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSimpleConcatenatieExpr" ):
                listener.enterSimpleConcatenatieExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSimpleConcatenatieExpr" ):
                listener.exitSimpleConcatenatieExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSimpleConcatenatieExpr" ):
                return visitor.visitSimpleConcatenatieExpr(self)
            else:
                return visitor.visitChildren(self)


    class BegrenzingExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def primaryExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,0)

        def COMMA(self):
            return self.getToken(RegelSpraakParser.COMMA, 0)
        def begrenzing(self):
            return self.getTypedRuleContext(RegelSpraakParser.BegrenzingContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBegrenzingExpr" ):
                listener.enterBegrenzingExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBegrenzingExpr" ):
                listener.exitBegrenzingExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBegrenzingExpr" ):
                return visitor.visitBegrenzingExpr(self)
            else:
                return visitor.visitChildren(self)


    class NaamwoordExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNaamwoordExpr" ):
                listener.enterNaamwoordExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNaamwoordExpr" ):
                listener.exitNaamwoordExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNaamwoordExpr" ):
                return visitor.visitNaamwoordExpr(self)
            else:
                return visitor.visitChildren(self)


    class BooleanFalseLiteralExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ONWAAR(self):
            return self.getToken(RegelSpraakParser.ONWAAR, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBooleanFalseLiteralExpr" ):
                listener.enterBooleanFalseLiteralExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBooleanFalseLiteralExpr" ):
                listener.exitBooleanFalseLiteralExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBooleanFalseLiteralExpr" ):
                return visitor.visitBooleanFalseLiteralExpr(self)
            else:
                return visitor.visitChildren(self)


    class MinValFuncExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def DE_MINIMALE_WAARDE_VAN(self):
            return self.getToken(RegelSpraakParser.DE_MINIMALE_WAARDE_VAN, 0)
        def primaryExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.PrimaryExpressionContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,i)

        def EN(self):
            return self.getToken(RegelSpraakParser.EN, 0)
        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.COMMA)
            else:
                return self.getToken(RegelSpraakParser.COMMA, i)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMinValFuncExpr" ):
                listener.enterMinValFuncExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMinValFuncExpr" ):
                listener.exitMinValFuncExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMinValFuncExpr" ):
                return visitor.visitMinValFuncExpr(self)
            else:
                return visitor.visitChildren(self)


    class JaarUitFuncExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def HET(self):
            return self.getToken(RegelSpraakParser.HET, 0)
        def JAAR(self):
            return self.getToken(RegelSpraakParser.JAAR, 0)
        def UIT(self):
            return self.getToken(RegelSpraakParser.UIT, 0)
        def primaryExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterJaarUitFuncExpr" ):
                listener.enterJaarUitFuncExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitJaarUitFuncExpr" ):
                listener.exitJaarUitFuncExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitJaarUitFuncExpr" ):
                return visitor.visitJaarUitFuncExpr(self)
            else:
                return visitor.visitChildren(self)


    class BezieldeRefExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def bezieldeReferentie(self):
            return self.getTypedRuleContext(RegelSpraakParser.BezieldeReferentieContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBezieldeRefExpr" ):
                listener.enterBezieldeRefExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBezieldeRefExpr" ):
                listener.exitBezieldeRefExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBezieldeRefExpr" ):
                return visitor.visitBezieldeRefExpr(self)
            else:
                return visitor.visitChildren(self)


    class DateCalcExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def primaryExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.PrimaryExpressionContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,i)

        def identifier(self):
            return self.getTypedRuleContext(RegelSpraakParser.IdentifierContext,0)

        def PLUS(self):
            return self.getToken(RegelSpraakParser.PLUS, 0)
        def MIN(self):
            return self.getToken(RegelSpraakParser.MIN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDateCalcExpr" ):
                listener.enterDateCalcExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDateCalcExpr" ):
                listener.exitDateCalcExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDateCalcExpr" ):
                return visitor.visitDateCalcExpr(self)
            else:
                return visitor.visitChildren(self)


    class TotaalVanExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.condition = None # ExpressieContext
            self.copyFrom(ctx)

        def HET_TOTAAL_VAN(self):
            return self.getToken(RegelSpraakParser.HET_TOTAAL_VAN, 0)
        def expressie(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.ExpressieContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,i)

        def GEDURENDE_DE_TIJD_DAT(self):
            return self.getToken(RegelSpraakParser.GEDURENDE_DE_TIJD_DAT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTotaalVanExpr" ):
                listener.enterTotaalVanExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTotaalVanExpr" ):
                listener.exitTotaalVanExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTotaalVanExpr" ):
                return visitor.visitTotaalVanExpr(self)
            else:
                return visitor.visitChildren(self)


    class AfrondingExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def primaryExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,0)

        def afronding(self):
            return self.getTypedRuleContext(RegelSpraakParser.AfrondingContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAfrondingExpr" ):
                listener.enterAfrondingExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAfrondingExpr" ):
                listener.exitAfrondingExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAfrondingExpr" ):
                return visitor.visitAfrondingExpr(self)
            else:
                return visitor.visitChildren(self)


    class LaatsteDatumFuncExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LAATSTE_VAN(self):
            return self.getToken(RegelSpraakParser.LAATSTE_VAN, 0)
        def primaryExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.PrimaryExpressionContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,i)

        def EN(self):
            return self.getToken(RegelSpraakParser.EN, 0)
        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.COMMA)
            else:
                return self.getToken(RegelSpraakParser.COMMA, i)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLaatsteDatumFuncExpr" ):
                listener.enterLaatsteDatumFuncExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLaatsteDatumFuncExpr" ):
                listener.exitLaatsteDatumFuncExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLaatsteDatumFuncExpr" ):
                return visitor.visitLaatsteDatumFuncExpr(self)
            else:
                return visitor.visitChildren(self)


    class HetAantalDagenInExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def HET_AANTAL_DAGEN_IN(self):
            return self.getToken(RegelSpraakParser.HET_AANTAL_DAGEN_IN, 0)
        def DAT(self):
            return self.getToken(RegelSpraakParser.DAT, 0)
        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)

        def DE(self):
            return self.getToken(RegelSpraakParser.DE, 0)
        def MAAND(self):
            return self.getToken(RegelSpraakParser.MAAND, 0)
        def HET(self):
            return self.getToken(RegelSpraakParser.HET, 0)
        def JAAR(self):
            return self.getToken(RegelSpraakParser.JAAR, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterHetAantalDagenInExpr" ):
                listener.enterHetAantalDagenInExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitHetAantalDagenInExpr" ):
                listener.exitHetAantalDagenInExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitHetAantalDagenInExpr" ):
                return visitor.visitHetAantalDagenInExpr(self)
            else:
                return visitor.visitChildren(self)


    class TijdsevenredigDeelExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.condition = None # ExpressieContext
            self.copyFrom(ctx)

        def HET_TIJDSEVENREDIG_DEEL_PER(self):
            return self.getToken(RegelSpraakParser.HET_TIJDSEVENREDIG_DEEL_PER, 0)
        def VAN(self):
            return self.getToken(RegelSpraakParser.VAN, 0)
        def expressie(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.ExpressieContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,i)

        def MAAND(self):
            return self.getToken(RegelSpraakParser.MAAND, 0)
        def JAAR(self):
            return self.getToken(RegelSpraakParser.JAAR, 0)
        def GEDURENDE_DE_TIJD_DAT(self):
            return self.getToken(RegelSpraakParser.GEDURENDE_DE_TIJD_DAT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTijdsevenredigDeelExpr" ):
                listener.enterTijdsevenredigDeelExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTijdsevenredigDeelExpr" ):
                listener.exitTijdsevenredigDeelExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTijdsevenredigDeelExpr" ):
                return visitor.visitTijdsevenredigDeelExpr(self)
            else:
                return visitor.visitChildren(self)


    class CapitalizedTijdsevenredigDeelExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.condition = None # ExpressieContext
            self.copyFrom(ctx)

        def HET_TIJDSEVENREDIG_DEEL_PER(self):
            return self.getToken(RegelSpraakParser.HET_TIJDSEVENREDIG_DEEL_PER, 0)
        def VAN(self):
            return self.getToken(RegelSpraakParser.VAN, 0)
        def expressie(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.ExpressieContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,i)

        def MAAND(self):
            return self.getToken(RegelSpraakParser.MAAND, 0)
        def JAAR(self):
            return self.getToken(RegelSpraakParser.JAAR, 0)
        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.IdentifierContext,i)

        def GEDURENDE_DE_TIJD_DAT(self):
            return self.getToken(RegelSpraakParser.GEDURENDE_DE_TIJD_DAT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCapitalizedTijdsevenredigDeelExpr" ):
                listener.enterCapitalizedTijdsevenredigDeelExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCapitalizedTijdsevenredigDeelExpr" ):
                listener.exitCapitalizedTijdsevenredigDeelExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCapitalizedTijdsevenredigDeelExpr" ):
                return visitor.visitCapitalizedTijdsevenredigDeelExpr(self)
            else:
                return visitor.visitChildren(self)


    class ParenExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(RegelSpraakParser.LPAREN, 0)
        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)

        def RPAREN(self):
            return self.getToken(RegelSpraakParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParenExpr" ):
                listener.enterParenExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParenExpr" ):
                listener.exitParenExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParenExpr" ):
                return visitor.visitParenExpr(self)
            else:
                return visitor.visitChildren(self)


    class UnaryMinusExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def MIN(self):
            return self.getToken(RegelSpraakParser.MIN, 0)
        def primaryExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,0)

        def MINUS(self):
            return self.getToken(RegelSpraakParser.MINUS, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnaryMinusExpr" ):
                listener.enterUnaryMinusExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnaryMinusExpr" ):
                listener.exitUnaryMinusExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnaryMinusExpr" ):
                return visitor.visitUnaryMinusExpr(self)
            else:
                return visitor.visitChildren(self)


    class ParamRefExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def parameterMetLidwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.ParameterMetLidwoordContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParamRefExpr" ):
                listener.enterParamRefExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParamRefExpr" ):
                listener.exitParamRefExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParamRefExpr" ):
                return visitor.visitParamRefExpr(self)
            else:
                return visitor.visitChildren(self)


    class PronounExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def HIJ(self):
            return self.getToken(RegelSpraakParser.HIJ, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPronounExpr" ):
                listener.enterPronounExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPronounExpr" ):
                listener.exitPronounExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPronounExpr" ):
                return visitor.visitPronounExpr(self)
            else:
                return visitor.visitChildren(self)



    def primaryExpression(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = RegelSpraakParser.PrimaryExpressionContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 144
        self.enterRecursionRule(localctx, 144, self.RULE_primaryExpression, _p)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1078
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,127,self._ctx)
            if la_ == 1:
                localctx = RegelSpraakParser.UnaryMinusExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx

                self.state = 871
                self.match(RegelSpraakParser.MIN)
                self.state = 872
                self.primaryExpression(45)
                pass

            elif la_ == 2:
                localctx = RegelSpraakParser.UnaryMinusExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 873
                self.match(RegelSpraakParser.MINUS)
                self.state = 874
                self.primaryExpression(44)
                pass

            elif la_ == 3:
                localctx = RegelSpraakParser.UnaryNietExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 875
                self.match(RegelSpraakParser.NIET)
                self.state = 876
                self.primaryExpression(43)
                pass

            elif la_ == 4:
                localctx = RegelSpraakParser.AbsTijdsduurFuncExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 877
                self.match(RegelSpraakParser.DE_ABSOLUTE_TIJDSDUUR_VAN)
                self.state = 878
                self.primaryExpression(0)
                self.state = 879
                self.match(RegelSpraakParser.TOT)
                self.state = 880
                self.primaryExpression(0)
                self.state = 883
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,108,self._ctx)
                if la_ == 1:
                    self.state = 881
                    self.match(RegelSpraakParser.IN_HELE)
                    self.state = 882
                    localctx.unitName = self.match(RegelSpraakParser.IDENTIFIER)


                pass

            elif la_ == 5:
                localctx = RegelSpraakParser.TijdsduurFuncExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 885
                self.match(RegelSpraakParser.TIJDSDUUR_VAN)
                self.state = 886
                self.primaryExpression(0)
                self.state = 887
                self.match(RegelSpraakParser.TOT)
                self.state = 888
                self.primaryExpression(0)
                self.state = 891
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,109,self._ctx)
                if la_ == 1:
                    self.state = 889
                    self.match(RegelSpraakParser.IN_HELE)
                    self.state = 890
                    localctx.unitName = self.match(RegelSpraakParser.IDENTIFIER)


                pass

            elif la_ == 6:
                localctx = RegelSpraakParser.SomFuncExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 893
                self.match(RegelSpraakParser.SOM_VAN)
                self.state = 894
                self.expressie()
                pass

            elif la_ == 7:
                localctx = RegelSpraakParser.AantalFuncExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 896
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==208:
                    self.state = 895
                    self.match(RegelSpraakParser.HET)


                self.state = 898
                self.match(RegelSpraakParser.AANTAL)

                self.state = 900
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,111,self._ctx)
                if la_ == 1:
                    self.state = 899
                    self.match(RegelSpraakParser.ALLE)


                self.state = 902
                self.onderwerpReferentie()
                pass

            elif la_ == 8:
                localctx = RegelSpraakParser.PercentageFuncExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 903
                self.match(RegelSpraakParser.NUMBER)
                self.state = 906
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [264]:
                    self.state = 904
                    self.match(RegelSpraakParser.PERCENT_SIGN)
                    pass
                elif token in [248]:
                    self.state = 905
                    localctx.p = self.match(RegelSpraakParser.IDENTIFIER)
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 908
                self.match(RegelSpraakParser.VAN)
                self.state = 909
                self.primaryExpression(38)
                pass

            elif la_ == 9:
                localctx = RegelSpraakParser.ConcatenatieExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 910
                self.match(RegelSpraakParser.CONCATENATIE_VAN)
                self.state = 911
                self.primaryExpression(0)
                self.state = 916
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==259:
                    self.state = 912
                    self.match(RegelSpraakParser.COMMA)
                    self.state = 913
                    self.primaryExpression(0)
                    self.state = 918
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 919
                _la = self._input.LA(1)
                if not(_la==207 or _la==216):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 920
                self.primaryExpression(35)
                pass

            elif la_ == 10:
                localctx = RegelSpraakParser.WortelFuncExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 922
                self.match(RegelSpraakParser.DE_WORTEL_VAN)
                self.state = 923
                self.primaryExpression(33)
                pass

            elif la_ == 11:
                localctx = RegelSpraakParser.AbsValFuncExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 924
                self.match(RegelSpraakParser.DE_ABSOLUTE_WAARDE_VAN)
                self.state = 925
                self.match(RegelSpraakParser.LPAREN)
                self.state = 926
                self.primaryExpression(0)
                self.state = 927
                self.match(RegelSpraakParser.RPAREN)
                pass

            elif la_ == 12:
                localctx = RegelSpraakParser.MinValFuncExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 929
                self.match(RegelSpraakParser.DE_MINIMALE_WAARDE_VAN)
                self.state = 930
                self.primaryExpression(0)
                self.state = 935
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==259:
                    self.state = 931
                    self.match(RegelSpraakParser.COMMA)
                    self.state = 932
                    self.primaryExpression(0)
                    self.state = 937
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 938
                self.match(RegelSpraakParser.EN)
                self.state = 939
                self.primaryExpression(31)
                pass

            elif la_ == 13:
                localctx = RegelSpraakParser.MaxValFuncExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 941
                self.match(RegelSpraakParser.DE_MAXIMALE_WAARDE_VAN)
                self.state = 942
                self.primaryExpression(0)
                self.state = 947
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==259:
                    self.state = 943
                    self.match(RegelSpraakParser.COMMA)
                    self.state = 944
                    self.primaryExpression(0)
                    self.state = 949
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 950
                self.match(RegelSpraakParser.EN)
                self.state = 951
                self.primaryExpression(30)
                pass

            elif la_ == 14:
                localctx = RegelSpraakParser.JaarUitFuncExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 953
                self.match(RegelSpraakParser.HET)
                self.state = 954
                self.match(RegelSpraakParser.JAAR)
                self.state = 955
                self.match(RegelSpraakParser.UIT)
                self.state = 956
                self.primaryExpression(29)
                pass

            elif la_ == 15:
                localctx = RegelSpraakParser.MaandUitFuncExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 957
                self.match(RegelSpraakParser.DE)
                self.state = 958
                self.match(RegelSpraakParser.MAAND)
                self.state = 959
                self.match(RegelSpraakParser.UIT)
                self.state = 960
                self.primaryExpression(28)
                pass

            elif la_ == 16:
                localctx = RegelSpraakParser.DagUitFuncExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 961
                self.match(RegelSpraakParser.DE)
                self.state = 962
                self.match(RegelSpraakParser.DAG)
                self.state = 963
                self.match(RegelSpraakParser.UIT)
                self.state = 964
                self.primaryExpression(27)
                pass

            elif la_ == 17:
                localctx = RegelSpraakParser.DatumMetFuncExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 965
                self.match(RegelSpraakParser.DE_DATUM_MET)
                self.state = 966
                self.match(RegelSpraakParser.LPAREN)
                self.state = 967
                self.primaryExpression(0)
                self.state = 968
                self.match(RegelSpraakParser.COMMA)
                self.state = 969
                self.primaryExpression(0)
                self.state = 970
                self.match(RegelSpraakParser.COMMA)
                self.state = 971
                self.primaryExpression(0)
                self.state = 972
                self.match(RegelSpraakParser.RPAREN)
                pass

            elif la_ == 18:
                localctx = RegelSpraakParser.PasenFuncExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 974
                self.match(RegelSpraakParser.DE_EERSTE_PAASDAG_VAN)
                self.state = 975
                self.match(RegelSpraakParser.LPAREN)
                self.state = 976
                self.primaryExpression(0)
                self.state = 977
                self.match(RegelSpraakParser.RPAREN)
                pass

            elif la_ == 19:
                localctx = RegelSpraakParser.EersteDatumFuncExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 979
                self.match(RegelSpraakParser.EERSTE_VAN)
                self.state = 980
                self.primaryExpression(0)
                self.state = 985
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==259:
                    self.state = 981
                    self.match(RegelSpraakParser.COMMA)
                    self.state = 982
                    self.primaryExpression(0)
                    self.state = 987
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 988
                self.match(RegelSpraakParser.EN)
                self.state = 989
                self.primaryExpression(23)
                pass

            elif la_ == 20:
                localctx = RegelSpraakParser.LaatsteDatumFuncExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 991
                self.match(RegelSpraakParser.LAATSTE_VAN)
                self.state = 992
                self.primaryExpression(0)
                self.state = 997
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==259:
                    self.state = 993
                    self.match(RegelSpraakParser.COMMA)
                    self.state = 994
                    self.primaryExpression(0)
                    self.state = 999
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 1000
                self.match(RegelSpraakParser.EN)
                self.state = 1001
                self.primaryExpression(22)
                pass

            elif la_ == 21:
                localctx = RegelSpraakParser.TotaalVanExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1003
                self.match(RegelSpraakParser.HET_TOTAAL_VAN)
                self.state = 1004
                self.expressie()
                self.state = 1007
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,118,self._ctx)
                if la_ == 1:
                    self.state = 1005
                    self.match(RegelSpraakParser.GEDURENDE_DE_TIJD_DAT)
                    self.state = 1006
                    localctx.condition = self.expressie()


                pass

            elif la_ == 22:
                localctx = RegelSpraakParser.HetAantalDagenInExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1009
                self.match(RegelSpraakParser.HET_AANTAL_DAGEN_IN)
                self.state = 1014
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [203]:
                    self.state = 1010
                    self.match(RegelSpraakParser.DE)
                    self.state = 1011
                    self.match(RegelSpraakParser.MAAND)
                    pass
                elif token in [208]:
                    self.state = 1012
                    self.match(RegelSpraakParser.HET)
                    self.state = 1013
                    self.match(RegelSpraakParser.JAAR)
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 1016
                self.match(RegelSpraakParser.DAT)
                self.state = 1017
                self.expressie()
                pass

            elif la_ == 23:
                localctx = RegelSpraakParser.CapitalizedTotaalVanExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1019 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 1018
                    self.identifier()
                    self.state = 1021 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==248):
                        break

                self.state = 1023
                self.match(RegelSpraakParser.HET_TOTAAL_VAN)
                self.state = 1024
                self.expressie()
                self.state = 1027
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,121,self._ctx)
                if la_ == 1:
                    self.state = 1025
                    self.match(RegelSpraakParser.GEDURENDE_DE_TIJD_DAT)
                    self.state = 1026
                    localctx.condition = self.expressie()


                pass

            elif la_ == 24:
                localctx = RegelSpraakParser.TijdsevenredigDeelExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1029
                self.match(RegelSpraakParser.HET_TIJDSEVENREDIG_DEEL_PER)
                self.state = 1030
                _la = self._input.LA(1)
                if not(_la==211 or _la==213):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1031
                self.match(RegelSpraakParser.VAN)
                self.state = 1032
                self.expressie()
                self.state = 1035
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,122,self._ctx)
                if la_ == 1:
                    self.state = 1033
                    self.match(RegelSpraakParser.GEDURENDE_DE_TIJD_DAT)
                    self.state = 1034
                    localctx.condition = self.expressie()


                pass

            elif la_ == 25:
                localctx = RegelSpraakParser.CapitalizedTijdsevenredigDeelExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1038 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 1037
                    self.identifier()
                    self.state = 1040 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==248):
                        break

                self.state = 1042
                self.match(RegelSpraakParser.HET_TIJDSEVENREDIG_DEEL_PER)
                self.state = 1043
                _la = self._input.LA(1)
                if not(_la==211 or _la==213):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1044
                self.match(RegelSpraakParser.VAN)
                self.state = 1045
                self.expressie()
                self.state = 1048
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,124,self._ctx)
                if la_ == 1:
                    self.state = 1046
                    self.match(RegelSpraakParser.GEDURENDE_DE_TIJD_DAT)
                    self.state = 1047
                    localctx.condition = self.expressie()


                pass

            elif la_ == 26:
                localctx = RegelSpraakParser.DimensieAggExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1052
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [16, 17, 181, 186, 208]:
                    self.state = 1050
                    self.getalAggregatieFunctie()
                    pass
                elif token in [182, 184]:
                    self.state = 1051
                    self.datumAggregatieFunctie()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 1054
                self.attribuutReferentie()
                self.state = 1055
                self.dimensieSelectie()
                pass

            elif la_ == 27:
                localctx = RegelSpraakParser.AttrRefExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1057
                self.attribuutReferentie()
                pass

            elif la_ == 28:
                localctx = RegelSpraakParser.BezieldeRefExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1058
                self.bezieldeReferentie()
                pass

            elif la_ == 29:
                localctx = RegelSpraakParser.OnderwerpRefExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1059
                self.onderwerpReferentie()
                pass

            elif la_ == 30:
                localctx = RegelSpraakParser.NaamwoordExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1060
                self.naamwoord()
                pass

            elif la_ == 31:
                localctx = RegelSpraakParser.ParamRefExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1061
                self.parameterMetLidwoord()
                pass

            elif la_ == 32:
                localctx = RegelSpraakParser.RekendatumKeywordExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1062
                self.match(RegelSpraakParser.REKENDATUM)
                pass

            elif la_ == 33:
                localctx = RegelSpraakParser.IdentifierExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1063
                self.identifier()
                pass

            elif la_ == 34:
                localctx = RegelSpraakParser.NumberLiteralExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1064
                self.match(RegelSpraakParser.NUMBER)
                self.state = 1066
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,126,self._ctx)
                if la_ == 1:
                    self.state = 1065
                    self.unitIdentifier()


                pass

            elif la_ == 35:
                localctx = RegelSpraakParser.StringLiteralExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1068
                self.match(RegelSpraakParser.STRING_LITERAL)
                pass

            elif la_ == 36:
                localctx = RegelSpraakParser.EnumLiteralExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1069
                self.match(RegelSpraakParser.ENUM_LITERAL)
                pass

            elif la_ == 37:
                localctx = RegelSpraakParser.DatumLiteralExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1070
                self.datumLiteral()
                pass

            elif la_ == 38:
                localctx = RegelSpraakParser.BooleanTrueLiteralExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1071
                self.match(RegelSpraakParser.WAAR)
                pass

            elif la_ == 39:
                localctx = RegelSpraakParser.BooleanFalseLiteralExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1072
                self.match(RegelSpraakParser.ONWAAR)
                pass

            elif la_ == 40:
                localctx = RegelSpraakParser.PronounExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1073
                self.match(RegelSpraakParser.HIJ)
                pass

            elif la_ == 41:
                localctx = RegelSpraakParser.ParenExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1074
                self.match(RegelSpraakParser.LPAREN)
                self.state = 1075
                self.expressie()
                self.state = 1076
                self.match(RegelSpraakParser.RPAREN)
                pass


            self._ctx.stop = self._input.LT(-1)
            self.state = 1102
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,130,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    self.state = 1100
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,129,self._ctx)
                    if la_ == 1:
                        localctx = RegelSpraakParser.SimpleConcatenatieExprContext(self, RegelSpraakParser.PrimaryExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_primaryExpression)
                        self.state = 1080
                        if not self.precpred(self._ctx, 34):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 34)")
                        self.state = 1083 
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        while True:
                            self.state = 1081
                            self.match(RegelSpraakParser.COMMA)
                            self.state = 1082
                            self.primaryExpression(0)
                            self.state = 1085 
                            self._errHandler.sync(self)
                            _la = self._input.LA(1)
                            if not (_la==259):
                                break

                        self.state = 1087
                        _la = self._input.LA(1)
                        if not(_la==207 or _la==216):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 1088
                        self.primaryExpression(35)
                        pass

                    elif la_ == 2:
                        localctx = RegelSpraakParser.AfrondingExprContext(self, RegelSpraakParser.PrimaryExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_primaryExpression)
                        self.state = 1090
                        if not self.precpred(self._ctx, 37):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 37)")
                        self.state = 1091
                        self.afronding()
                        pass

                    elif la_ == 3:
                        localctx = RegelSpraakParser.BegrenzingExprContext(self, RegelSpraakParser.PrimaryExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_primaryExpression)
                        self.state = 1092
                        if not self.precpred(self._ctx, 36):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 36)")
                        self.state = 1093
                        self.match(RegelSpraakParser.COMMA)
                        self.state = 1094
                        self.begrenzing()
                        pass

                    elif la_ == 4:
                        localctx = RegelSpraakParser.DateCalcExprContext(self, RegelSpraakParser.PrimaryExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_primaryExpression)
                        self.state = 1095
                        if not self.precpred(self._ctx, 24):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 24)")
                        self.state = 1096
                        _la = self._input.LA(1)
                        if not(_la==133 or _la==138):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 1097
                        self.primaryExpression(0)
                        self.state = 1098
                        self.identifier()
                        pass

             
                self.state = 1104
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,130,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class AfrondingContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def AFGEROND_OP(self):
            return self.getToken(RegelSpraakParser.AFGEROND_OP, 0)

        def NUMBER(self):
            return self.getToken(RegelSpraakParser.NUMBER, 0)

        def DECIMALEN(self):
            return self.getToken(RegelSpraakParser.DECIMALEN, 0)

        def NAAR_BENEDEN(self):
            return self.getToken(RegelSpraakParser.NAAR_BENEDEN, 0)

        def NAAR_BOVEN(self):
            return self.getToken(RegelSpraakParser.NAAR_BOVEN, 0)

        def REKENKUNDIG(self):
            return self.getToken(RegelSpraakParser.REKENKUNDIG, 0)

        def RICHTING_NUL(self):
            return self.getToken(RegelSpraakParser.RICHTING_NUL, 0)

        def WEG_VAN_NUL(self):
            return self.getToken(RegelSpraakParser.WEG_VAN_NUL, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_afronding

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAfronding" ):
                listener.enterAfronding(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAfronding" ):
                listener.exitAfronding(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAfronding" ):
                return visitor.visitAfronding(self)
            else:
                return visitor.visitChildren(self)




    def afronding(self):

        localctx = RegelSpraakParser.AfrondingContext(self, self._ctx, self.state)
        self.enterRule(localctx, 146, self.RULE_afronding)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1105
            _la = self._input.LA(1)
            if not(((((_la - 134)) & ~0x3f) == 0 and ((1 << (_la - 134)) & 65635) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 1106
            self.match(RegelSpraakParser.AFGEROND_OP)
            self.state = 1107
            self.match(RegelSpraakParser.NUMBER)
            self.state = 1108
            self.match(RegelSpraakParser.DECIMALEN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BegrenzingContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def begrenzingMinimum(self):
            return self.getTypedRuleContext(RegelSpraakParser.BegrenzingMinimumContext,0)


        def begrenzingMaximum(self):
            return self.getTypedRuleContext(RegelSpraakParser.BegrenzingMaximumContext,0)


        def EN(self):
            return self.getToken(RegelSpraakParser.EN, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_begrenzing

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBegrenzing" ):
                listener.enterBegrenzing(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBegrenzing" ):
                listener.exitBegrenzing(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBegrenzing" ):
                return visitor.visitBegrenzing(self)
            else:
                return visitor.visitChildren(self)




    def begrenzing(self):

        localctx = RegelSpraakParser.BegrenzingContext(self, self._ctx, self.state)
        self.enterRule(localctx, 148, self.RULE_begrenzing)
        try:
            self.state = 1116
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,131,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1110
                self.begrenzingMinimum()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1111
                self.begrenzingMaximum()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1112
                self.begrenzingMinimum()
                self.state = 1113
                self.match(RegelSpraakParser.EN)
                self.state = 1114
                self.begrenzingMaximum()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BegrenzingMinimumContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MET_EEN_MINIMUM_VAN(self):
            return self.getToken(RegelSpraakParser.MET_EEN_MINIMUM_VAN, 0)

        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_begrenzingMinimum

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBegrenzingMinimum" ):
                listener.enterBegrenzingMinimum(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBegrenzingMinimum" ):
                listener.exitBegrenzingMinimum(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBegrenzingMinimum" ):
                return visitor.visitBegrenzingMinimum(self)
            else:
                return visitor.visitChildren(self)




    def begrenzingMinimum(self):

        localctx = RegelSpraakParser.BegrenzingMinimumContext(self, self._ctx, self.state)
        self.enterRule(localctx, 150, self.RULE_begrenzingMinimum)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1118
            self.match(RegelSpraakParser.MET_EEN_MINIMUM_VAN)
            self.state = 1119
            self.expressie()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BegrenzingMaximumContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MET_EEN_MAXIMUM_VAN(self):
            return self.getToken(RegelSpraakParser.MET_EEN_MAXIMUM_VAN, 0)

        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_begrenzingMaximum

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBegrenzingMaximum" ):
                listener.enterBegrenzingMaximum(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBegrenzingMaximum" ):
                listener.exitBegrenzingMaximum(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBegrenzingMaximum" ):
                return visitor.visitBegrenzingMaximum(self)
            else:
                return visitor.visitChildren(self)




    def begrenzingMaximum(self):

        localctx = RegelSpraakParser.BegrenzingMaximumContext(self, self._ctx, self.state)
        self.enterRule(localctx, 152, self.RULE_begrenzingMaximum)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1121
            self.match(RegelSpraakParser.MET_EEN_MAXIMUM_VAN)
            self.state = 1122
            self.expressie()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConditieBijExpressieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.condition = None # ExpressieContext

        def GEDURENDE_DE_TIJD_DAT(self):
            return self.getToken(RegelSpraakParser.GEDURENDE_DE_TIJD_DAT, 0)

        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)


        def periodevergelijkingEnkelvoudig(self):
            return self.getTypedRuleContext(RegelSpraakParser.PeriodevergelijkingEnkelvoudigContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_conditieBijExpressie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConditieBijExpressie" ):
                listener.enterConditieBijExpressie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConditieBijExpressie" ):
                listener.exitConditieBijExpressie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConditieBijExpressie" ):
                return visitor.visitConditieBijExpressie(self)
            else:
                return visitor.visitChildren(self)




    def conditieBijExpressie(self):

        localctx = RegelSpraakParser.ConditieBijExpressieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 154, self.RULE_conditieBijExpressie)
        try:
            self.state = 1127
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [8]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1124
                self.match(RegelSpraakParser.GEDURENDE_DE_TIJD_DAT)
                self.state = 1125
                localctx.condition = self.expressie()
                pass
            elif token in [141, 143, 145, 228]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1126
                self.periodevergelijkingEnkelvoudig()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PeriodevergelijkingEnkelvoudigContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def VANAF(self):
            return self.getToken(RegelSpraakParser.VANAF, 0)

        def datumLiteral(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.DatumLiteralContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.DatumLiteralContext,i)


        def VAN(self):
            return self.getToken(RegelSpraakParser.VAN, 0)

        def TOT(self):
            return self.getToken(RegelSpraakParser.TOT, 0)

        def TOT_EN_MET(self):
            return self.getToken(RegelSpraakParser.TOT_EN_MET, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_periodevergelijkingEnkelvoudig

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPeriodevergelijkingEnkelvoudig" ):
                listener.enterPeriodevergelijkingEnkelvoudig(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPeriodevergelijkingEnkelvoudig" ):
                listener.exitPeriodevergelijkingEnkelvoudig(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPeriodevergelijkingEnkelvoudig" ):
                return visitor.visitPeriodevergelijkingEnkelvoudig(self)
            else:
                return visitor.visitChildren(self)




    def periodevergelijkingEnkelvoudig(self):

        localctx = RegelSpraakParser.PeriodevergelijkingEnkelvoudigContext(self, self._ctx, self.state)
        self.enterRule(localctx, 156, self.RULE_periodevergelijkingEnkelvoudig)
        try:
            self.state = 1145
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,133,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1129
                self.match(RegelSpraakParser.VANAF)
                self.state = 1130
                self.datumLiteral()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1131
                self.match(RegelSpraakParser.VAN)
                self.state = 1132
                self.datumLiteral()
                self.state = 1133
                self.match(RegelSpraakParser.TOT)
                self.state = 1134
                self.datumLiteral()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1136
                self.match(RegelSpraakParser.VAN)
                self.state = 1137
                self.datumLiteral()
                self.state = 1138
                self.match(RegelSpraakParser.TOT_EN_MET)
                self.state = 1139
                self.datumLiteral()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 1141
                self.match(RegelSpraakParser.TOT)
                self.state = 1142
                self.datumLiteral()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 1143
                self.match(RegelSpraakParser.TOT_EN_MET)
                self.state = 1144
                self.datumLiteral()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GetalAggregatieFunctieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def AANTAL(self):
            return self.getToken(RegelSpraakParser.AANTAL, 0)

        def HET(self):
            return self.getToken(RegelSpraakParser.HET, 0)

        def DE_MAXIMALE_WAARDE_VAN(self):
            return self.getToken(RegelSpraakParser.DE_MAXIMALE_WAARDE_VAN, 0)

        def DE_MINIMALE_WAARDE_VAN(self):
            return self.getToken(RegelSpraakParser.DE_MINIMALE_WAARDE_VAN, 0)

        def SOM_VAN(self):
            return self.getToken(RegelSpraakParser.SOM_VAN, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_getalAggregatieFunctie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGetalAggregatieFunctie" ):
                listener.enterGetalAggregatieFunctie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGetalAggregatieFunctie" ):
                listener.exitGetalAggregatieFunctie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGetalAggregatieFunctie" ):
                return visitor.visitGetalAggregatieFunctie(self)
            else:
                return visitor.visitChildren(self)




    def getalAggregatieFunctie(self):

        localctx = RegelSpraakParser.GetalAggregatieFunctieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 158, self.RULE_getalAggregatieFunctie)
        self._la = 0 # Token type
        try:
            self.state = 1154
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [181, 208]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1148
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==208:
                    self.state = 1147
                    self.match(RegelSpraakParser.HET)


                self.state = 1150
                self.match(RegelSpraakParser.AANTAL)
                pass
            elif token in [16]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1151
                self.match(RegelSpraakParser.DE_MAXIMALE_WAARDE_VAN)
                pass
            elif token in [17]:
                self.enterOuterAlt(localctx, 3)
                self.state = 1152
                self.match(RegelSpraakParser.DE_MINIMALE_WAARDE_VAN)
                pass
            elif token in [186]:
                self.enterOuterAlt(localctx, 4)
                self.state = 1153
                self.match(RegelSpraakParser.SOM_VAN)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DatumAggregatieFunctieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EERSTE_VAN(self):
            return self.getToken(RegelSpraakParser.EERSTE_VAN, 0)

        def LAATSTE_VAN(self):
            return self.getToken(RegelSpraakParser.LAATSTE_VAN, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_datumAggregatieFunctie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDatumAggregatieFunctie" ):
                listener.enterDatumAggregatieFunctie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDatumAggregatieFunctie" ):
                listener.exitDatumAggregatieFunctie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDatumAggregatieFunctie" ):
                return visitor.visitDatumAggregatieFunctie(self)
            else:
                return visitor.visitChildren(self)




    def datumAggregatieFunctie(self):

        localctx = RegelSpraakParser.DatumAggregatieFunctieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 160, self.RULE_datumAggregatieFunctie)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1156
            _la = self._input.LA(1)
            if not(_la==182 or _la==184):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DimensieSelectieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OVER(self):
            return self.getToken(RegelSpraakParser.OVER, 0)

        def DOT(self):
            return self.getToken(RegelSpraakParser.DOT, 0)

        def aggregerenOverAlleDimensies(self):
            return self.getTypedRuleContext(RegelSpraakParser.AggregerenOverAlleDimensiesContext,0)


        def aggregerenOverVerzameling(self):
            return self.getTypedRuleContext(RegelSpraakParser.AggregerenOverVerzamelingContext,0)


        def aggregerenOverBereik(self):
            return self.getTypedRuleContext(RegelSpraakParser.AggregerenOverBereikContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_dimensieSelectie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDimensieSelectie" ):
                listener.enterDimensieSelectie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDimensieSelectie" ):
                listener.exitDimensieSelectie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDimensieSelectie" ):
                return visitor.visitDimensieSelectie(self)
            else:
                return visitor.visitChildren(self)




    def dimensieSelectie(self):

        localctx = RegelSpraakParser.DimensieSelectieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 162, self.RULE_dimensieSelectie)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1158
            self.match(RegelSpraakParser.OVER)
            self.state = 1162
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,136,self._ctx)
            if la_ == 1:
                self.state = 1159
                self.aggregerenOverAlleDimensies()
                pass

            elif la_ == 2:
                self.state = 1160
                self.aggregerenOverVerzameling()
                pass

            elif la_ == 3:
                self.state = 1161
                self.aggregerenOverBereik()
                pass


            self.state = 1164
            self.match(RegelSpraakParser.DOT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AggregerenOverAlleDimensiesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ALLE(self):
            return self.getToken(RegelSpraakParser.ALLE, 0)

        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_aggregerenOverAlleDimensies

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAggregerenOverAlleDimensies" ):
                listener.enterAggregerenOverAlleDimensies(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAggregerenOverAlleDimensies" ):
                listener.exitAggregerenOverAlleDimensies(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAggregerenOverAlleDimensies" ):
                return visitor.visitAggregerenOverAlleDimensies(self)
            else:
                return visitor.visitChildren(self)




    def aggregerenOverAlleDimensies(self):

        localctx = RegelSpraakParser.AggregerenOverAlleDimensiesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 164, self.RULE_aggregerenOverAlleDimensies)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1166
            self.match(RegelSpraakParser.ALLE)
            self.state = 1167
            self.naamwoord()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AggregerenOverVerzamelingContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DE(self):
            return self.getToken(RegelSpraakParser.DE, 0)

        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def VANAF(self):
            return self.getToken(RegelSpraakParser.VANAF, 0)

        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.IdentifierContext,i)


        def TM(self):
            return self.getToken(RegelSpraakParser.TM, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_aggregerenOverVerzameling

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAggregerenOverVerzameling" ):
                listener.enterAggregerenOverVerzameling(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAggregerenOverVerzameling" ):
                listener.exitAggregerenOverVerzameling(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAggregerenOverVerzameling" ):
                return visitor.visitAggregerenOverVerzameling(self)
            else:
                return visitor.visitChildren(self)




    def aggregerenOverVerzameling(self):

        localctx = RegelSpraakParser.AggregerenOverVerzamelingContext(self, self._ctx, self.state)
        self.enterRule(localctx, 166, self.RULE_aggregerenOverVerzameling)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1169
            self.match(RegelSpraakParser.DE)
            self.state = 1170
            self.naamwoord()
            self.state = 1171
            self.match(RegelSpraakParser.VANAF)
            self.state = 1172
            self.identifier()
            self.state = 1173
            self.match(RegelSpraakParser.TM)
            self.state = 1174
            self.identifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AggregerenOverBereikContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DE(self):
            return self.getToken(RegelSpraakParser.DE, 0)

        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def IN(self):
            return self.getToken(RegelSpraakParser.IN, 0)

        def LBRACE(self):
            return self.getToken(RegelSpraakParser.LBRACE, 0)

        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.IdentifierContext,i)


        def EN(self):
            return self.getToken(RegelSpraakParser.EN, 0)

        def RBRACE(self):
            return self.getToken(RegelSpraakParser.RBRACE, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.COMMA)
            else:
                return self.getToken(RegelSpraakParser.COMMA, i)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_aggregerenOverBereik

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAggregerenOverBereik" ):
                listener.enterAggregerenOverBereik(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAggregerenOverBereik" ):
                listener.exitAggregerenOverBereik(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAggregerenOverBereik" ):
                return visitor.visitAggregerenOverBereik(self)
            else:
                return visitor.visitChildren(self)




    def aggregerenOverBereik(self):

        localctx = RegelSpraakParser.AggregerenOverBereikContext(self, self._ctx, self.state)
        self.enterRule(localctx, 168, self.RULE_aggregerenOverBereik)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1176
            self.match(RegelSpraakParser.DE)
            self.state = 1177
            self.naamwoord()
            self.state = 1178
            self.match(RegelSpraakParser.IN)
            self.state = 1179
            self.match(RegelSpraakParser.LBRACE)
            self.state = 1180
            self.identifier()
            self.state = 1185
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==259:
                self.state = 1181
                self.match(RegelSpraakParser.COMMA)
                self.state = 1182
                self.identifier()
                self.state = 1187
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1188
            self.match(RegelSpraakParser.EN)
            self.state = 1189
            self.identifier()
            self.state = 1190
            self.match(RegelSpraakParser.RBRACE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UnaryConditionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_unaryCondition

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class UnaryCheckConditionContext(UnaryConditionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.UnaryConditionContext
            super().__init__(parser)
            self.expr = None # PrimaryExpressionContext
            self.op = None # Token
            self.copyFrom(ctx)

        def primaryExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,0)

        def IS_LEEG(self):
            return self.getToken(RegelSpraakParser.IS_LEEG, 0)
        def IS_GEVULD(self):
            return self.getToken(RegelSpraakParser.IS_GEVULD, 0)
        def VOLDOET_AAN_DE_ELFPROEF(self):
            return self.getToken(RegelSpraakParser.VOLDOET_AAN_DE_ELFPROEF, 0)
        def VOLDOET_NIET_AAN_DE_ELFPROEF(self):
            return self.getToken(RegelSpraakParser.VOLDOET_NIET_AAN_DE_ELFPROEF, 0)
        def ZIJN_LEEG(self):
            return self.getToken(RegelSpraakParser.ZIJN_LEEG, 0)
        def ZIJN_GEVULD(self):
            return self.getToken(RegelSpraakParser.ZIJN_GEVULD, 0)
        def VOLDOEN_AAN_DE_ELFPROEF(self):
            return self.getToken(RegelSpraakParser.VOLDOEN_AAN_DE_ELFPROEF, 0)
        def VOLDOEN_NIET_AAN_DE_ELFPROEF(self):
            return self.getToken(RegelSpraakParser.VOLDOEN_NIET_AAN_DE_ELFPROEF, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnaryCheckCondition" ):
                listener.enterUnaryCheckCondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnaryCheckCondition" ):
                listener.exitUnaryCheckCondition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnaryCheckCondition" ):
                return visitor.visitUnaryCheckCondition(self)
            else:
                return visitor.visitChildren(self)


    class UnaryKenmerkConditionContext(UnaryConditionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.UnaryConditionContext
            super().__init__(parser)
            self.expr = None # PrimaryExpressionContext
            self.op = None # Token
            self.kenmerk = None # IdentifierContext
            self.copyFrom(ctx)

        def primaryExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,0)

        def identifier(self):
            return self.getTypedRuleContext(RegelSpraakParser.IdentifierContext,0)

        def IS_KENMERK(self):
            return self.getToken(RegelSpraakParser.IS_KENMERK, 0)
        def ZIJN_KENMERK(self):
            return self.getToken(RegelSpraakParser.ZIJN_KENMERK, 0)
        def IS_NIET_KENMERK(self):
            return self.getToken(RegelSpraakParser.IS_NIET_KENMERK, 0)
        def ZIJN_NIET_KENMERK(self):
            return self.getToken(RegelSpraakParser.ZIJN_NIET_KENMERK, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnaryKenmerkCondition" ):
                listener.enterUnaryKenmerkCondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnaryKenmerkCondition" ):
                listener.exitUnaryKenmerkCondition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnaryKenmerkCondition" ):
                return visitor.visitUnaryKenmerkCondition(self)
            else:
                return visitor.visitChildren(self)


    class UnaryNumeriekExactConditionContext(UnaryConditionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.UnaryConditionContext
            super().__init__(parser)
            self.expr = None # PrimaryExpressionContext
            self.op = None # Token
            self.copyFrom(ctx)

        def NUMBER(self):
            return self.getToken(RegelSpraakParser.NUMBER, 0)
        def CIJFERS(self):
            return self.getToken(RegelSpraakParser.CIJFERS, 0)
        def primaryExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,0)

        def IS_NUMERIEK_MET_EXACT(self):
            return self.getToken(RegelSpraakParser.IS_NUMERIEK_MET_EXACT, 0)
        def IS_NIET_NUMERIEK_MET_EXACT(self):
            return self.getToken(RegelSpraakParser.IS_NIET_NUMERIEK_MET_EXACT, 0)
        def ZIJN_NUMERIEK_MET_EXACT(self):
            return self.getToken(RegelSpraakParser.ZIJN_NUMERIEK_MET_EXACT, 0)
        def ZIJN_NIET_NUMERIEK_MET_EXACT(self):
            return self.getToken(RegelSpraakParser.ZIJN_NIET_NUMERIEK_MET_EXACT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnaryNumeriekExactCondition" ):
                listener.enterUnaryNumeriekExactCondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnaryNumeriekExactCondition" ):
                listener.exitUnaryNumeriekExactCondition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnaryNumeriekExactCondition" ):
                return visitor.visitUnaryNumeriekExactCondition(self)
            else:
                return visitor.visitChildren(self)


    class UnaryRolConditionContext(UnaryConditionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.UnaryConditionContext
            super().__init__(parser)
            self.expr = None # PrimaryExpressionContext
            self.op = None # Token
            self.rol = None # IdentifierContext
            self.copyFrom(ctx)

        def primaryExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,0)

        def identifier(self):
            return self.getTypedRuleContext(RegelSpraakParser.IdentifierContext,0)

        def IS_ROL(self):
            return self.getToken(RegelSpraakParser.IS_ROL, 0)
        def ZIJN_ROL(self):
            return self.getToken(RegelSpraakParser.ZIJN_ROL, 0)
        def IS_NIET_ROL(self):
            return self.getToken(RegelSpraakParser.IS_NIET_ROL, 0)
        def ZIJN_NIET_ROL(self):
            return self.getToken(RegelSpraakParser.ZIJN_NIET_ROL, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnaryRolCondition" ):
                listener.enterUnaryRolCondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnaryRolCondition" ):
                listener.exitUnaryRolCondition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnaryRolCondition" ):
                return visitor.visitUnaryRolCondition(self)
            else:
                return visitor.visitChildren(self)


    class UnaryDagsoortConditionContext(UnaryConditionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.UnaryConditionContext
            super().__init__(parser)
            self.expr = None # PrimaryExpressionContext
            self.op = None # Token
            self.dagsoort = None # IdentifierContext
            self.copyFrom(ctx)

        def primaryExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,0)

        def identifier(self):
            return self.getTypedRuleContext(RegelSpraakParser.IdentifierContext,0)

        def IS_EEN_DAGSOORT(self):
            return self.getToken(RegelSpraakParser.IS_EEN_DAGSOORT, 0)
        def ZIJN_EEN_DAGSOORT(self):
            return self.getToken(RegelSpraakParser.ZIJN_EEN_DAGSOORT, 0)
        def IS_GEEN_DAGSOORT(self):
            return self.getToken(RegelSpraakParser.IS_GEEN_DAGSOORT, 0)
        def ZIJN_GEEN_DAGSOORT(self):
            return self.getToken(RegelSpraakParser.ZIJN_GEEN_DAGSOORT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnaryDagsoortCondition" ):
                listener.enterUnaryDagsoortCondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnaryDagsoortCondition" ):
                listener.exitUnaryDagsoortCondition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnaryDagsoortCondition" ):
                return visitor.visitUnaryDagsoortCondition(self)
            else:
                return visitor.visitChildren(self)


    class UnaryInconsistentDataConditionContext(UnaryConditionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.UnaryConditionContext
            super().__init__(parser)
            self.expr = None # PrimaryExpressionContext
            self.copyFrom(ctx)

        def IS_INCONSISTENT(self):
            return self.getToken(RegelSpraakParser.IS_INCONSISTENT, 0)
        def primaryExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnaryInconsistentDataCondition" ):
                listener.enterUnaryInconsistentDataCondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnaryInconsistentDataCondition" ):
                listener.exitUnaryInconsistentDataCondition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnaryInconsistentDataCondition" ):
                return visitor.visitUnaryInconsistentDataCondition(self)
            else:
                return visitor.visitChildren(self)


    class UnaryUniekConditionContext(UnaryConditionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.UnaryConditionContext
            super().__init__(parser)
            self.ref = None # OnderwerpReferentieContext
            self.copyFrom(ctx)

        def MOETEN_UNIEK_ZIJN(self):
            return self.getToken(RegelSpraakParser.MOETEN_UNIEK_ZIJN, 0)
        def onderwerpReferentie(self):
            return self.getTypedRuleContext(RegelSpraakParser.OnderwerpReferentieContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnaryUniekCondition" ):
                listener.enterUnaryUniekCondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnaryUniekCondition" ):
                listener.exitUnaryUniekCondition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnaryUniekCondition" ):
                return visitor.visitUnaryUniekCondition(self)
            else:
                return visitor.visitChildren(self)



    def unaryCondition(self):

        localctx = RegelSpraakParser.UnaryConditionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 170, self.RULE_unaryCondition)
        self._la = 0 # Token type
        try:
            self.state = 1218
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,138,self._ctx)
            if la_ == 1:
                localctx = RegelSpraakParser.UnaryCheckConditionContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1192
                localctx.expr = self.primaryExpression(0)
                self.state = 1193
                localctx.op = self._input.LT(1)
                _la = self._input.LA(1)
                if not(((((_la - 70)) & ~0x3f) == 0 and ((1 << (_la - 70)) & 61455) != 0)):
                    localctx.op = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass

            elif la_ == 2:
                localctx = RegelSpraakParser.UnaryNumeriekExactConditionContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1195
                localctx.expr = self.primaryExpression(0)
                self.state = 1196
                localctx.op = self._input.LT(1)
                _la = self._input.LA(1)
                if not(((((_la - 86)) & ~0x3f) == 0 and ((1 << (_la - 86)) & 15) != 0)):
                    localctx.op = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1197
                self.match(RegelSpraakParser.NUMBER)
                self.state = 1198
                self.match(RegelSpraakParser.CIJFERS)
                pass

            elif la_ == 3:
                localctx = RegelSpraakParser.UnaryDagsoortConditionContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 1200
                localctx.expr = self.primaryExpression(0)
                self.state = 1201
                localctx.op = self._input.LT(1)
                _la = self._input.LA(1)
                if not(((((_la - 90)) & ~0x3f) == 0 and ((1 << (_la - 90)) & 15) != 0)):
                    localctx.op = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1202
                localctx.dagsoort = self.identifier()
                pass

            elif la_ == 4:
                localctx = RegelSpraakParser.UnaryKenmerkConditionContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 1204
                localctx.expr = self.primaryExpression(0)
                self.state = 1205
                localctx.op = self._input.LT(1)
                _la = self._input.LA(1)
                if not(((((_la - 74)) & ~0x3f) == 0 and ((1 << (_la - 74)) & 85) != 0)):
                    localctx.op = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1206
                localctx.kenmerk = self.identifier()
                pass

            elif la_ == 5:
                localctx = RegelSpraakParser.UnaryRolConditionContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 1208
                localctx.expr = self.primaryExpression(0)
                self.state = 1209
                localctx.op = self._input.LT(1)
                _la = self._input.LA(1)
                if not(((((_la - 75)) & ~0x3f) == 0 and ((1 << (_la - 75)) & 85) != 0)):
                    localctx.op = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1210
                localctx.rol = self.identifier()
                pass

            elif la_ == 6:
                localctx = RegelSpraakParser.UnaryUniekConditionContext(self, localctx)
                self.enterOuterAlt(localctx, 6)
                self.state = 1212
                localctx.ref = self.onderwerpReferentie()
                self.state = 1213
                self.match(RegelSpraakParser.MOETEN_UNIEK_ZIJN)
                pass

            elif la_ == 7:
                localctx = RegelSpraakParser.UnaryInconsistentDataConditionContext(self, localctx)
                self.enterOuterAlt(localctx, 7)
                self.state = 1215
                localctx.expr = self.primaryExpression(0)
                self.state = 1216
                self.match(RegelSpraakParser.IS_INCONSISTENT)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RegelStatusConditionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_regelStatusCondition

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class RegelStatusCheckContext(RegelStatusConditionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.RegelStatusConditionContext
            super().__init__(parser)
            self.name = None # NaamwoordContext
            self.op = None # Token
            self.copyFrom(ctx)

        def REGEL(self):
            return self.getToken(RegelSpraakParser.REGEL, 0)
        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)

        def IS_GEVUURD(self):
            return self.getToken(RegelSpraakParser.IS_GEVUURD, 0)
        def IS_INCONSISTENT(self):
            return self.getToken(RegelSpraakParser.IS_INCONSISTENT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRegelStatusCheck" ):
                listener.enterRegelStatusCheck(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRegelStatusCheck" ):
                listener.exitRegelStatusCheck(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRegelStatusCheck" ):
                return visitor.visitRegelStatusCheck(self)
            else:
                return visitor.visitChildren(self)



    def regelStatusCondition(self):

        localctx = RegelSpraakParser.RegelStatusConditionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 172, self.RULE_regelStatusCondition)
        self._la = 0 # Token type
        try:
            localctx = RegelSpraakParser.RegelStatusCheckContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 1220
            self.match(RegelSpraakParser.REGEL)
            self.state = 1221
            localctx.name = self.naamwoord()
            self.state = 1222
            localctx.op = self._input.LT(1)
            _la = self._input.LA(1)
            if not(_la==95 or _la==96):
                localctx.op = self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DagsoortDefinitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DAGSOORT(self):
            return self.getToken(RegelSpraakParser.DAGSOORT, 0)

        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def SEMICOLON(self):
            return self.getToken(RegelSpraakParser.SEMICOLON, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_dagsoortDefinition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDagsoortDefinition" ):
                listener.enterDagsoortDefinition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDagsoortDefinition" ):
                listener.exitDagsoortDefinition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDagsoortDefinition" ):
                return visitor.visitDagsoortDefinition(self)
            else:
                return visitor.visitChildren(self)




    def dagsoortDefinition(self):

        localctx = RegelSpraakParser.DagsoortDefinitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 174, self.RULE_dagsoortDefinition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1224
            self.match(RegelSpraakParser.DAGSOORT)
            self.state = 1225
            self.naamwoord()
            self.state = 1227
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==262:
                self.state = 1226
                self.match(RegelSpraakParser.SEMICOLON)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx



    def sempred(self, localctx:RuleContext, ruleIndex:int, predIndex:int):
        if self._predicates == None:
            self._predicates = dict()
        self._predicates[72] = self.primaryExpression_sempred
        pred = self._predicates.get(ruleIndex, None)
        if pred is None:
            raise Exception("No predicate with index:" + str(ruleIndex))
        else:
            return pred(localctx, predIndex)

    def primaryExpression_sempred(self, localctx:PrimaryExpressionContext, predIndex:int):
            if predIndex == 0:
                return self.precpred(self._ctx, 34)
         

            if predIndex == 1:
                return self.precpred(self._ctx, 37)
         

            if predIndex == 2:
                return self.precpred(self._ctx, 36)
         

            if predIndex == 3:
                return self.precpred(self._ctx, 24)
         




