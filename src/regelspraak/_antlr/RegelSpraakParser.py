# Generated from RegelSpraak.g4 by ANTLR 4.13.1
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO

def serializedATN():
    return [
        4,1,277,1285,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,
        7,6,2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,
        13,2,14,7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,
        20,7,20,2,21,7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,
        26,2,27,7,27,2,28,7,28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,
        33,7,33,2,34,7,34,2,35,7,35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,
        39,2,40,7,40,2,41,7,41,2,42,7,42,2,43,7,43,2,44,7,44,2,45,7,45,2,
        46,7,46,2,47,7,47,2,48,7,48,2,49,7,49,2,50,7,50,2,51,7,51,2,52,7,
        52,2,53,7,53,2,54,7,54,2,55,7,55,2,56,7,56,2,57,7,57,2,58,7,58,2,
        59,7,59,2,60,7,60,2,61,7,61,2,62,7,62,2,63,7,63,2,64,7,64,2,65,7,
        65,2,66,7,66,2,67,7,67,2,68,7,68,2,69,7,69,2,70,7,70,2,71,7,71,2,
        72,7,72,2,73,7,73,2,74,7,74,2,75,7,75,2,76,7,76,2,77,7,77,2,78,7,
        78,2,79,7,79,2,80,7,80,2,81,7,81,2,82,7,82,2,83,7,83,2,84,7,84,2,
        85,7,85,2,86,7,86,2,87,7,87,2,88,7,88,2,89,7,89,2,90,7,90,1,0,1,
        0,1,0,1,0,1,0,5,0,188,8,0,10,0,12,0,191,9,0,1,0,1,0,1,1,1,1,1,1,
        1,1,1,1,1,1,3,1,201,8,1,1,2,1,2,1,2,3,2,206,8,2,1,3,1,3,1,4,1,4,
        1,5,3,5,213,8,5,1,5,4,5,216,8,5,11,5,12,5,217,1,5,4,5,221,8,5,11,
        5,12,5,222,1,5,1,5,4,5,227,8,5,11,5,12,5,228,1,5,1,5,4,5,233,8,5,
        11,5,12,5,234,1,5,1,5,4,5,239,8,5,11,5,12,5,240,1,5,4,5,244,8,5,
        11,5,12,5,245,1,5,1,5,4,5,250,8,5,11,5,12,5,251,1,5,1,5,4,5,256,
        8,5,11,5,12,5,257,3,5,260,8,5,1,6,1,6,1,6,1,6,5,6,266,8,6,10,6,12,
        6,269,9,6,1,7,1,7,1,8,1,8,1,9,1,9,1,10,1,10,1,10,1,10,4,10,281,8,
        10,11,10,12,10,282,1,10,3,10,286,8,10,1,10,3,10,289,8,10,1,10,5,
        10,292,8,10,10,10,12,10,295,9,10,1,11,1,11,3,11,299,8,11,1,11,1,
        11,1,12,3,12,304,8,12,1,12,1,12,3,12,308,8,12,1,12,1,12,3,12,312,
        8,12,1,13,1,13,1,13,3,13,317,8,13,1,13,1,13,1,13,1,13,1,13,3,13,
        324,8,13,3,13,326,8,13,1,13,1,13,1,13,1,13,5,13,332,8,13,10,13,12,
        13,335,9,13,3,13,337,8,13,1,13,3,13,340,8,13,1,14,1,14,1,14,1,14,
        1,14,3,14,347,8,14,1,15,1,15,1,15,1,15,1,16,1,16,1,16,1,16,1,16,
        3,16,358,8,16,1,17,1,17,1,18,1,18,1,19,1,19,1,20,3,20,367,8,20,1,
        20,1,20,1,20,1,20,1,20,1,20,3,20,375,8,20,1,21,1,21,4,21,379,8,21,
        11,21,12,21,380,1,21,1,21,1,21,1,21,3,21,387,8,21,1,21,3,21,390,
        8,21,1,22,1,22,1,22,1,22,1,22,3,22,397,8,22,1,23,1,23,4,23,401,8,
        23,11,23,12,23,402,1,24,1,24,1,24,1,25,1,25,1,25,5,25,411,8,25,10,
        25,12,25,414,9,25,1,26,1,26,1,26,1,26,1,26,1,26,3,26,422,8,26,1,
        27,1,27,1,28,1,28,1,28,3,28,429,8,28,1,28,1,28,1,28,1,28,3,28,435,
        8,28,1,29,1,29,1,29,3,29,440,8,29,1,30,1,30,1,30,3,30,445,8,30,1,
        30,1,30,1,30,1,30,4,30,451,8,30,11,30,12,30,452,1,31,1,31,1,31,1,
        31,3,31,459,8,31,1,31,3,31,462,8,31,1,32,1,32,1,32,1,32,1,33,1,33,
        1,34,1,34,1,35,1,35,1,35,1,35,1,35,3,35,477,8,35,1,35,1,35,3,35,
        481,8,35,1,35,3,35,484,8,35,1,35,1,35,1,36,3,36,489,8,36,1,36,4,
        36,492,8,36,11,36,12,36,493,1,37,1,37,1,38,1,38,1,38,1,38,1,38,1,
        38,3,38,504,8,38,1,38,1,38,4,38,508,8,38,11,38,12,38,509,1,39,1,
        39,1,39,1,40,1,40,1,40,3,40,518,8,40,1,40,1,40,1,40,1,40,3,40,524,
        8,40,1,40,3,40,527,8,40,1,40,3,40,530,8,40,1,41,4,41,533,8,41,11,
        41,12,41,534,1,41,1,41,4,41,539,8,41,11,41,12,41,540,1,41,1,41,4,
        41,545,8,41,11,41,12,41,546,1,41,1,41,4,41,551,8,41,11,41,12,41,
        552,1,41,1,41,1,41,4,41,558,8,41,11,41,12,41,559,1,41,1,41,1,41,
        4,41,565,8,41,11,41,12,41,566,1,41,1,41,4,41,571,8,41,11,41,12,41,
        572,1,41,4,41,576,8,41,11,41,12,41,577,1,41,1,41,4,41,582,8,41,11,
        41,12,41,583,3,41,586,8,41,1,42,1,42,1,42,1,43,1,43,1,43,1,43,1,
        43,3,43,596,8,43,3,43,598,8,43,1,44,1,44,3,44,602,8,44,1,44,1,44,
        1,44,1,44,1,44,1,44,3,44,610,8,44,1,44,1,44,1,44,1,44,1,44,1,44,
        1,44,1,44,1,44,1,44,1,44,4,44,623,8,44,11,44,12,44,624,1,44,1,44,
        1,44,1,44,1,44,1,44,3,44,633,8,44,1,44,1,44,5,44,637,8,44,10,44,
        12,44,640,9,44,1,44,1,44,1,44,1,44,1,44,1,44,3,44,648,8,44,1,44,
        1,44,1,44,1,44,1,44,3,44,655,8,44,1,44,3,44,658,8,44,1,44,1,44,1,
        44,1,44,1,44,1,44,1,44,1,44,3,44,668,8,44,1,44,3,44,671,8,44,1,45,
        1,45,1,45,1,45,3,45,677,8,45,1,45,3,45,680,8,45,1,45,1,45,1,45,1,
        45,1,45,3,45,687,8,45,1,45,3,45,690,8,45,3,45,692,8,45,1,46,1,46,
        1,46,1,46,5,46,698,8,46,10,46,12,46,701,9,46,1,47,1,47,1,47,1,47,
        1,48,1,48,1,48,1,48,1,48,1,48,3,48,713,8,48,1,48,3,48,716,8,48,3,
        48,718,8,48,1,49,1,49,1,49,3,49,723,8,49,1,50,3,50,726,8,50,1,50,
        1,50,1,50,1,51,1,51,1,51,3,51,734,8,51,1,52,1,52,1,52,1,52,1,52,
        1,52,4,52,742,8,52,11,52,12,52,743,1,52,1,52,1,52,1,52,3,52,750,
        8,52,1,52,1,52,1,52,1,52,1,52,1,52,4,52,758,8,52,11,52,12,52,759,
        1,52,1,52,1,52,1,52,3,52,766,8,52,1,52,1,52,1,52,1,52,1,52,1,52,
        4,52,774,8,52,11,52,12,52,775,3,52,778,8,52,1,53,1,53,1,53,1,53,
        1,53,1,53,1,53,1,53,1,53,1,53,1,53,1,53,1,53,1,53,1,53,1,53,3,53,
        796,8,53,1,54,1,54,1,54,3,54,801,8,54,1,55,1,55,1,56,1,56,1,57,1,
        57,1,57,3,57,810,8,57,1,57,1,57,1,57,1,57,1,57,1,57,4,57,818,8,57,
        11,57,12,57,819,1,58,1,58,1,58,1,58,5,58,826,8,58,10,58,12,58,829,
        9,58,1,59,3,59,832,8,59,1,59,4,59,835,8,59,11,59,12,59,836,1,59,
        3,59,840,8,59,1,60,1,60,1,60,1,60,1,61,1,61,1,62,1,62,1,62,1,63,
        1,63,5,63,853,8,63,10,63,12,63,856,9,63,1,63,1,63,1,64,1,64,1,64,
        1,64,3,64,864,8,64,1,65,1,65,1,66,1,66,1,66,3,66,871,8,66,1,67,1,
        67,1,67,1,67,1,67,1,67,1,67,1,67,1,67,1,67,1,67,1,67,3,67,885,8,
        67,1,67,1,67,3,67,889,8,67,1,68,1,68,1,69,1,69,1,69,1,69,5,69,897,
        8,69,10,69,12,69,900,9,69,1,70,1,70,1,71,1,71,1,71,1,71,5,71,908,
        8,71,10,71,12,71,911,9,71,1,72,1,72,1,73,1,73,1,73,1,73,5,73,919,
        8,73,10,73,12,73,922,9,73,1,74,1,74,1,75,1,75,1,75,1,75,1,75,1,75,
        1,75,1,75,1,75,1,75,1,75,1,75,1,75,3,75,939,8,75,1,75,1,75,1,75,
        1,75,1,75,1,75,3,75,947,8,75,1,75,1,75,1,75,3,75,952,8,75,1,75,1,
        75,3,75,956,8,75,1,75,1,75,1,75,1,75,3,75,962,8,75,1,75,1,75,1,75,
        1,75,1,75,1,75,5,75,970,8,75,10,75,12,75,973,9,75,1,75,1,75,1,75,
        1,75,1,75,1,75,1,75,1,75,1,75,1,75,1,75,1,75,1,75,1,75,5,75,989,
        8,75,10,75,12,75,992,9,75,1,75,1,75,1,75,1,75,1,75,1,75,1,75,5,75,
        1001,8,75,10,75,12,75,1004,9,75,1,75,1,75,1,75,1,75,1,75,1,75,1,
        75,1,75,1,75,1,75,1,75,1,75,1,75,1,75,1,75,1,75,1,75,1,75,1,75,1,
        75,1,75,1,75,1,75,1,75,1,75,1,75,1,75,1,75,1,75,1,75,1,75,1,75,1,
        75,5,75,1039,8,75,10,75,12,75,1042,9,75,1,75,1,75,1,75,1,75,1,75,
        1,75,1,75,5,75,1051,8,75,10,75,12,75,1054,9,75,1,75,1,75,1,75,1,
        75,1,75,1,75,1,75,3,75,1063,8,75,1,75,1,75,1,75,1,75,1,75,3,75,1070,
        8,75,1,75,1,75,1,75,4,75,1075,8,75,11,75,12,75,1076,1,75,1,75,1,
        75,1,75,3,75,1083,8,75,1,75,1,75,1,75,1,75,1,75,1,75,3,75,1091,8,
        75,1,75,4,75,1094,8,75,11,75,12,75,1095,1,75,1,75,1,75,1,75,1,75,
        1,75,3,75,1104,8,75,1,75,1,75,3,75,1108,8,75,1,75,1,75,1,75,1,75,
        1,75,1,75,1,75,1,75,1,75,1,75,1,75,1,75,3,75,1122,8,75,1,75,1,75,
        1,75,1,75,1,75,1,75,1,75,1,75,1,75,1,75,3,75,1134,8,75,1,75,1,75,
        1,75,4,75,1139,8,75,11,75,12,75,1140,1,75,1,75,1,75,1,75,1,75,1,
        75,1,75,1,75,1,75,1,75,1,75,1,75,1,75,5,75,1156,8,75,10,75,12,75,
        1159,9,75,1,76,1,76,1,76,1,76,1,76,1,77,1,77,1,77,1,77,1,77,1,77,
        3,77,1172,8,77,1,78,1,78,1,78,1,79,1,79,1,79,1,80,1,80,1,80,3,80,
        1183,8,80,1,81,1,81,1,81,1,81,1,81,1,81,1,81,1,81,1,81,1,81,1,81,
        1,81,1,81,1,81,1,81,1,81,3,81,1201,8,81,1,82,3,82,1204,8,82,1,82,
        1,82,1,82,1,82,3,82,1210,8,82,1,83,1,83,1,84,1,84,1,84,1,84,3,84,
        1218,8,84,1,84,1,84,1,85,1,85,1,85,1,86,1,86,1,86,1,86,1,86,1,86,
        1,86,1,87,1,87,1,87,1,87,1,87,1,87,1,87,5,87,1239,8,87,10,87,12,
        87,1242,9,87,1,87,1,87,1,87,1,87,1,88,1,88,1,88,1,88,1,88,1,88,1,
        88,1,88,1,88,1,88,1,88,1,88,1,88,1,88,1,88,1,88,1,88,1,88,1,88,1,
        88,1,88,1,88,1,88,1,88,1,88,1,88,3,88,1274,8,88,1,89,1,89,1,89,1,
        89,1,90,1,90,1,90,3,90,1283,8,90,1,90,0,1,150,91,0,2,4,6,8,10,12,
        14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,
        58,60,62,64,66,68,70,72,74,76,78,80,82,84,86,88,90,92,94,96,98,100,
        102,104,106,108,110,112,114,116,118,120,122,124,126,128,130,132,
        134,136,138,140,142,144,146,148,150,152,154,156,158,160,162,164,
        166,168,170,172,174,176,178,180,0,38,8,0,98,98,156,156,185,185,204,
        204,214,214,216,216,223,223,252,252,3,0,117,117,206,206,211,211,
        7,0,141,141,203,203,213,213,221,222,229,229,231,231,235,235,1,0,
        159,160,2,0,7,7,163,163,2,0,174,175,178,178,5,0,133,133,218,218,
        227,227,230,230,239,252,1,0,182,184,2,0,206,206,211,211,2,0,185,
        185,252,252,2,0,31,31,106,106,2,0,143,143,228,228,2,0,111,111,113,
        113,2,0,141,141,171,171,1,0,2,4,2,0,145,145,231,231,2,0,141,141,
        143,143,2,0,214,214,216,216,3,0,206,206,211,211,238,238,1,0,232,
        233,1,0,152,153,3,0,196,197,200,201,209,209,3,0,269,270,274,274,
        277,277,5,0,117,117,120,120,206,206,209,209,211,211,2,0,210,210,
        219,219,10,0,25,28,41,42,50,69,113,113,121,121,124,124,127,127,129,
        130,136,137,213,213,3,0,133,133,138,138,147,147,2,0,122,123,132,
        132,2,0,142,142,273,273,2,0,133,133,138,138,3,0,134,135,139,140,
        150,150,2,0,186,186,188,188,2,0,70,73,82,85,1,0,86,89,1,0,90,93,
        4,0,74,74,76,76,78,78,80,80,4,0,75,75,77,77,79,79,81,81,1,0,95,96,
        1444,0,189,1,0,0,0,2,200,1,0,0,0,4,202,1,0,0,0,6,207,1,0,0,0,8,209,
        1,0,0,0,10,259,1,0,0,0,12,261,1,0,0,0,14,270,1,0,0,0,16,272,1,0,
        0,0,18,274,1,0,0,0,20,276,1,0,0,0,22,298,1,0,0,0,24,307,1,0,0,0,
        26,313,1,0,0,0,28,346,1,0,0,0,30,348,1,0,0,0,32,352,1,0,0,0,34,359,
        1,0,0,0,36,361,1,0,0,0,38,363,1,0,0,0,40,366,1,0,0,0,42,376,1,0,
        0,0,44,396,1,0,0,0,46,398,1,0,0,0,48,404,1,0,0,0,50,407,1,0,0,0,
        52,415,1,0,0,0,54,423,1,0,0,0,56,434,1,0,0,0,58,436,1,0,0,0,60,441,
        1,0,0,0,62,461,1,0,0,0,64,463,1,0,0,0,66,467,1,0,0,0,68,469,1,0,
        0,0,70,471,1,0,0,0,72,488,1,0,0,0,74,495,1,0,0,0,76,497,1,0,0,0,
        78,511,1,0,0,0,80,514,1,0,0,0,82,585,1,0,0,0,84,587,1,0,0,0,86,597,
        1,0,0,0,88,670,1,0,0,0,90,691,1,0,0,0,92,693,1,0,0,0,94,702,1,0,
        0,0,96,706,1,0,0,0,98,719,1,0,0,0,100,725,1,0,0,0,102,730,1,0,0,
        0,104,777,1,0,0,0,106,795,1,0,0,0,108,797,1,0,0,0,110,802,1,0,0,
        0,112,804,1,0,0,0,114,809,1,0,0,0,116,821,1,0,0,0,118,839,1,0,0,
        0,120,841,1,0,0,0,122,845,1,0,0,0,124,847,1,0,0,0,126,850,1,0,0,
        0,128,859,1,0,0,0,130,865,1,0,0,0,132,867,1,0,0,0,134,888,1,0,0,
        0,136,890,1,0,0,0,138,892,1,0,0,0,140,901,1,0,0,0,142,903,1,0,0,
        0,144,912,1,0,0,0,146,914,1,0,0,0,148,923,1,0,0,0,150,1133,1,0,0,
        0,152,1160,1,0,0,0,154,1171,1,0,0,0,156,1173,1,0,0,0,158,1176,1,
        0,0,0,160,1182,1,0,0,0,162,1200,1,0,0,0,164,1209,1,0,0,0,166,1211,
        1,0,0,0,168,1213,1,0,0,0,170,1221,1,0,0,0,172,1224,1,0,0,0,174,1231,
        1,0,0,0,176,1273,1,0,0,0,178,1275,1,0,0,0,180,1279,1,0,0,0,182,188,
        3,2,1,0,183,188,3,80,40,0,184,188,3,4,2,0,185,188,3,96,48,0,186,
        188,3,50,25,0,187,182,1,0,0,0,187,183,1,0,0,0,187,184,1,0,0,0,187,
        185,1,0,0,0,187,186,1,0,0,0,188,191,1,0,0,0,189,187,1,0,0,0,189,
        190,1,0,0,0,190,192,1,0,0,0,191,189,1,0,0,0,192,193,5,0,0,1,193,
        1,1,0,0,0,194,201,3,20,10,0,195,201,3,42,21,0,196,201,3,70,35,0,
        197,201,3,60,30,0,198,201,3,76,38,0,199,201,3,180,90,0,200,194,1,
        0,0,0,200,195,1,0,0,0,200,196,1,0,0,0,200,197,1,0,0,0,200,198,1,
        0,0,0,200,199,1,0,0,0,201,3,1,0,0,0,202,203,5,99,0,0,203,205,3,12,
        6,0,204,206,3,84,42,0,205,204,1,0,0,0,205,206,1,0,0,0,206,5,1,0,
        0,0,207,208,5,252,0,0,208,7,1,0,0,0,209,210,7,0,0,0,210,9,1,0,0,
        0,211,213,7,1,0,0,212,211,1,0,0,0,212,213,1,0,0,0,213,215,1,0,0,
        0,214,216,3,8,4,0,215,214,1,0,0,0,216,217,1,0,0,0,217,215,1,0,0,
        0,217,218,1,0,0,0,218,260,1,0,0,0,219,221,3,8,4,0,220,219,1,0,0,
        0,221,222,1,0,0,0,222,220,1,0,0,0,222,223,1,0,0,0,223,260,1,0,0,
        0,224,226,5,48,0,0,225,227,3,8,4,0,226,225,1,0,0,0,227,228,1,0,0,
        0,228,226,1,0,0,0,228,229,1,0,0,0,229,260,1,0,0,0,230,232,5,48,0,
        0,231,233,3,8,4,0,232,231,1,0,0,0,233,234,1,0,0,0,234,232,1,0,0,
        0,234,235,1,0,0,0,235,236,1,0,0,0,236,238,5,171,0,0,237,239,3,8,
        4,0,238,237,1,0,0,0,239,240,1,0,0,0,240,238,1,0,0,0,240,241,1,0,
        0,0,241,260,1,0,0,0,242,244,3,8,4,0,243,242,1,0,0,0,244,245,1,0,
        0,0,245,243,1,0,0,0,245,246,1,0,0,0,246,247,1,0,0,0,247,249,5,171,
        0,0,248,250,3,8,4,0,249,248,1,0,0,0,250,251,1,0,0,0,251,249,1,0,
        0,0,251,252,1,0,0,0,252,260,1,0,0,0,253,255,5,136,0,0,254,256,3,
        8,4,0,255,254,1,0,0,0,256,257,1,0,0,0,257,255,1,0,0,0,257,258,1,
        0,0,0,258,260,1,0,0,0,259,212,1,0,0,0,259,220,1,0,0,0,259,224,1,
        0,0,0,259,230,1,0,0,0,259,243,1,0,0,0,259,253,1,0,0,0,260,11,1,0,
        0,0,261,267,3,10,5,0,262,263,3,14,7,0,263,264,3,10,5,0,264,266,1,
        0,0,0,265,262,1,0,0,0,266,269,1,0,0,0,267,265,1,0,0,0,267,268,1,
        0,0,0,268,13,1,0,0,0,269,267,1,0,0,0,270,271,7,2,0,0,271,15,1,0,
        0,0,272,273,5,255,0,0,273,17,1,0,0,0,274,275,5,252,0,0,275,19,1,
        0,0,0,276,277,5,100,0,0,277,285,3,12,6,0,278,280,5,173,0,0,279,281,
        5,252,0,0,280,279,1,0,0,0,281,282,1,0,0,0,282,280,1,0,0,0,282,283,
        1,0,0,0,283,284,1,0,0,0,284,286,5,260,0,0,285,278,1,0,0,0,285,286,
        1,0,0,0,286,288,1,0,0,0,287,289,5,158,0,0,288,287,1,0,0,0,288,289,
        1,0,0,0,289,293,1,0,0,0,290,292,3,22,11,0,291,290,1,0,0,0,292,295,
        1,0,0,0,293,291,1,0,0,0,293,294,1,0,0,0,294,21,1,0,0,0,295,293,1,
        0,0,0,296,299,3,24,12,0,297,299,3,26,13,0,298,296,1,0,0,0,298,297,
        1,0,0,0,299,300,1,0,0,0,300,301,5,266,0,0,301,23,1,0,0,0,302,304,
        5,113,0,0,303,302,1,0,0,0,303,304,1,0,0,0,304,305,1,0,0,0,305,308,
        3,6,3,0,306,308,3,12,6,0,307,303,1,0,0,0,307,306,1,0,0,0,308,309,
        1,0,0,0,309,311,5,169,0,0,310,312,7,3,0,0,311,310,1,0,0,0,311,312,
        1,0,0,0,312,25,1,0,0,0,313,316,3,12,6,0,314,317,3,28,14,0,315,317,
        3,48,24,0,316,314,1,0,0,0,316,315,1,0,0,0,317,325,1,0,0,0,318,323,
        5,172,0,0,319,324,5,252,0,0,320,324,5,268,0,0,321,324,5,250,0,0,
        322,324,5,251,0,0,323,319,1,0,0,0,323,320,1,0,0,0,323,321,1,0,0,
        0,323,322,1,0,0,0,324,326,1,0,0,0,325,318,1,0,0,0,325,326,1,0,0,
        0,326,336,1,0,0,0,327,328,5,166,0,0,328,333,3,68,34,0,329,330,5,
        210,0,0,330,332,3,68,34,0,331,329,1,0,0,0,332,335,1,0,0,0,333,331,
        1,0,0,0,333,334,1,0,0,0,334,337,1,0,0,0,335,333,1,0,0,0,336,327,
        1,0,0,0,336,337,1,0,0,0,337,339,1,0,0,0,338,340,3,66,33,0,339,338,
        1,0,0,0,339,340,1,0,0,0,340,27,1,0,0,0,341,347,3,32,16,0,342,347,
        3,34,17,0,343,347,3,36,18,0,344,347,3,38,19,0,345,347,3,30,15,0,
        346,341,1,0,0,0,346,342,1,0,0,0,346,343,1,0,0,0,346,344,1,0,0,0,
        346,345,1,0,0,0,347,29,1,0,0,0,348,349,5,102,0,0,349,350,5,231,0,
        0,350,351,3,28,14,0,351,31,1,0,0,0,352,357,5,176,0,0,353,354,5,259,
        0,0,354,355,3,40,20,0,355,356,5,260,0,0,356,358,1,0,0,0,357,353,
        1,0,0,0,357,358,1,0,0,0,358,33,1,0,0,0,359,360,5,181,0,0,360,35,
        1,0,0,0,361,362,5,161,0,0,362,37,1,0,0,0,363,364,7,4,0,0,364,39,
        1,0,0,0,365,367,7,5,0,0,366,365,1,0,0,0,366,367,1,0,0,0,367,374,
        1,0,0,0,368,375,5,167,0,0,369,370,5,168,0,0,370,371,5,171,0,0,371,
        372,5,253,0,0,372,375,5,164,0,0,373,375,5,168,0,0,374,368,1,0,0,
        0,374,369,1,0,0,0,374,373,1,0,0,0,375,41,1,0,0,0,376,378,5,101,0,
        0,377,379,5,252,0,0,378,377,1,0,0,0,379,380,1,0,0,0,380,378,1,0,
        0,0,380,381,1,0,0,0,381,382,1,0,0,0,382,383,5,32,0,0,383,386,3,44,
        22,0,384,385,5,172,0,0,385,387,3,56,28,0,386,384,1,0,0,0,386,387,
        1,0,0,0,387,389,1,0,0,0,388,390,5,266,0,0,389,388,1,0,0,0,389,390,
        1,0,0,0,390,43,1,0,0,0,391,397,3,46,23,0,392,397,3,32,16,0,393,397,
        3,34,17,0,394,397,3,36,18,0,395,397,3,38,19,0,396,391,1,0,0,0,396,
        392,1,0,0,0,396,393,1,0,0,0,396,394,1,0,0,0,396,395,1,0,0,0,397,
        45,1,0,0,0,398,400,5,165,0,0,399,401,5,258,0,0,400,399,1,0,0,0,401,
        402,1,0,0,0,402,400,1,0,0,0,402,403,1,0,0,0,403,47,1,0,0,0,404,405,
        5,101,0,0,405,406,5,252,0,0,406,49,1,0,0,0,407,408,5,104,0,0,408,
        412,3,6,3,0,409,411,3,52,26,0,410,409,1,0,0,0,411,414,1,0,0,0,412,
        410,1,0,0,0,412,413,1,0,0,0,413,51,1,0,0,0,414,412,1,0,0,0,415,416,
        5,206,0,0,416,417,3,54,27,0,417,421,3,54,27,0,418,419,5,254,0,0,
        419,420,5,253,0,0,420,422,3,54,27,0,421,418,1,0,0,0,421,422,1,0,
        0,0,422,53,1,0,0,0,423,424,7,6,0,0,424,55,1,0,0,0,425,428,3,58,29,
        0,426,427,5,267,0,0,427,429,3,58,29,0,428,426,1,0,0,0,428,429,1,
        0,0,0,429,435,1,0,0,0,430,435,5,253,0,0,431,435,5,268,0,0,432,435,
        5,250,0,0,433,435,5,251,0,0,434,425,1,0,0,0,434,430,1,0,0,0,434,
        431,1,0,0,0,434,432,1,0,0,0,434,433,1,0,0,0,435,57,1,0,0,0,436,439,
        3,54,27,0,437,438,5,273,0,0,438,440,5,253,0,0,439,437,1,0,0,0,439,
        440,1,0,0,0,440,59,1,0,0,0,441,442,5,103,0,0,442,444,3,12,6,0,443,
        445,5,263,0,0,444,443,1,0,0,0,444,445,1,0,0,0,445,446,1,0,0,0,446,
        447,5,30,0,0,447,448,3,12,6,0,448,450,3,62,31,0,449,451,3,64,32,
        0,450,449,1,0,0,0,451,452,1,0,0,0,452,450,1,0,0,0,452,453,1,0,0,
        0,453,61,1,0,0,0,454,455,5,6,0,0,455,456,3,14,7,0,456,458,5,260,
        0,0,457,459,5,265,0,0,458,457,1,0,0,0,458,459,1,0,0,0,459,462,1,
        0,0,0,460,462,5,5,0,0,461,454,1,0,0,0,461,460,1,0,0,0,462,63,1,0,
        0,0,463,464,5,253,0,0,464,465,5,264,0,0,465,466,3,6,3,0,466,65,1,
        0,0,0,467,468,7,7,0,0,468,67,1,0,0,0,469,470,5,252,0,0,470,69,1,
        0,0,0,471,472,5,105,0,0,472,473,3,72,36,0,473,476,5,265,0,0,474,
        477,3,28,14,0,475,477,3,48,24,0,476,474,1,0,0,0,476,475,1,0,0,0,
        477,480,1,0,0,0,478,479,5,172,0,0,479,481,3,56,28,0,480,478,1,0,
        0,0,480,481,1,0,0,0,481,483,1,0,0,0,482,484,3,66,33,0,483,482,1,
        0,0,0,483,484,1,0,0,0,484,485,1,0,0,0,485,486,5,266,0,0,486,71,1,
        0,0,0,487,489,7,8,0,0,488,487,1,0,0,0,488,489,1,0,0,0,489,491,1,
        0,0,0,490,492,7,9,0,0,491,490,1,0,0,0,492,493,1,0,0,0,493,491,1,
        0,0,0,493,494,1,0,0,0,494,73,1,0,0,0,495,496,3,12,6,0,496,75,1,0,
        0,0,497,498,7,10,0,0,498,503,3,12,6,0,499,500,5,111,0,0,500,504,
        3,12,6,0,501,502,5,113,0,0,502,504,3,12,6,0,503,499,1,0,0,0,503,
        501,1,0,0,0,504,505,1,0,0,0,505,507,3,78,39,0,506,508,3,78,39,0,
        507,506,1,0,0,0,508,509,1,0,0,0,509,507,1,0,0,0,509,510,1,0,0,0,
        510,77,1,0,0,0,511,512,3,62,31,0,512,513,3,6,3,0,513,79,1,0,0,0,
        514,515,5,98,0,0,515,517,3,82,41,0,516,518,5,253,0,0,517,516,1,0,
        0,0,517,518,1,0,0,0,518,519,1,0,0,0,519,520,3,84,42,0,520,526,3,
        88,44,0,521,523,3,102,51,0,522,524,5,264,0,0,523,522,1,0,0,0,523,
        524,1,0,0,0,524,527,1,0,0,0,525,527,5,264,0,0,526,521,1,0,0,0,526,
        525,1,0,0,0,526,527,1,0,0,0,527,529,1,0,0,0,528,530,3,126,63,0,529,
        528,1,0,0,0,529,530,1,0,0,0,530,81,1,0,0,0,531,533,5,252,0,0,532,
        531,1,0,0,0,533,534,1,0,0,0,534,532,1,0,0,0,534,535,1,0,0,0,535,
        586,1,0,0,0,536,586,3,12,6,0,537,539,5,252,0,0,538,537,1,0,0,0,539,
        540,1,0,0,0,540,538,1,0,0,0,540,541,1,0,0,0,541,542,1,0,0,0,542,
        586,5,169,0,0,543,545,5,252,0,0,544,543,1,0,0,0,545,546,1,0,0,0,
        546,544,1,0,0,0,546,547,1,0,0,0,547,548,1,0,0,0,548,586,5,179,0,
        0,549,551,5,252,0,0,550,549,1,0,0,0,551,552,1,0,0,0,552,550,1,0,
        0,0,552,553,1,0,0,0,553,554,1,0,0,0,554,555,5,136,0,0,555,586,5,
        169,0,0,556,558,5,252,0,0,557,556,1,0,0,0,558,559,1,0,0,0,559,557,
        1,0,0,0,559,560,1,0,0,0,560,561,1,0,0,0,561,562,5,136,0,0,562,586,
        5,179,0,0,563,565,5,252,0,0,564,563,1,0,0,0,565,566,1,0,0,0,566,
        564,1,0,0,0,566,567,1,0,0,0,567,568,1,0,0,0,568,570,5,170,0,0,569,
        571,5,252,0,0,570,569,1,0,0,0,571,572,1,0,0,0,572,570,1,0,0,0,572,
        573,1,0,0,0,573,586,1,0,0,0,574,576,5,252,0,0,575,574,1,0,0,0,576,
        577,1,0,0,0,577,575,1,0,0,0,577,578,1,0,0,0,578,579,1,0,0,0,579,
        581,5,180,0,0,580,582,5,252,0,0,581,580,1,0,0,0,582,583,1,0,0,0,
        583,581,1,0,0,0,583,584,1,0,0,0,584,586,1,0,0,0,585,532,1,0,0,0,
        585,536,1,0,0,0,585,538,1,0,0,0,585,544,1,0,0,0,585,550,1,0,0,0,
        585,557,1,0,0,0,585,564,1,0,0,0,585,575,1,0,0,0,586,83,1,0,0,0,587,
        588,5,109,0,0,588,589,3,86,43,0,589,85,1,0,0,0,590,598,5,202,0,0,
        591,592,5,145,0,0,592,595,3,16,8,0,593,594,7,11,0,0,594,596,3,16,
        8,0,595,593,1,0,0,0,595,596,1,0,0,0,596,598,1,0,0,0,597,590,1,0,
        0,0,597,591,1,0,0,0,598,87,1,0,0,0,599,602,3,12,6,0,600,602,3,120,
        60,0,601,599,1,0,0,0,601,600,1,0,0,0,602,609,1,0,0,0,603,604,5,11,
        0,0,604,610,3,130,65,0,605,606,5,12,0,0,606,610,3,130,65,0,607,608,
        5,13,0,0,608,610,3,130,65,0,609,603,1,0,0,0,609,605,1,0,0,0,609,
        607,1,0,0,0,610,671,1,0,0,0,611,612,3,116,58,0,612,613,7,12,0,0,
        613,614,3,122,61,0,614,671,1,0,0,0,615,616,3,116,58,0,616,617,5,
        111,0,0,617,618,3,12,6,0,618,619,7,13,0,0,619,620,3,116,58,0,620,
        671,1,0,0,0,621,623,3,6,3,0,622,621,1,0,0,0,623,624,1,0,0,0,624,
        622,1,0,0,0,624,625,1,0,0,0,625,632,1,0,0,0,626,627,5,11,0,0,627,
        633,3,130,65,0,628,629,5,12,0,0,629,633,3,130,65,0,630,631,5,13,
        0,0,631,633,3,130,65,0,632,626,1,0,0,0,632,628,1,0,0,0,632,630,1,
        0,0,0,633,671,1,0,0,0,634,638,7,14,0,0,635,637,3,6,3,0,636,635,1,
        0,0,0,637,640,1,0,0,0,638,636,1,0,0,0,638,639,1,0,0,0,639,647,1,
        0,0,0,640,638,1,0,0,0,641,642,5,11,0,0,642,648,3,130,65,0,643,644,
        5,12,0,0,644,648,3,130,65,0,645,646,5,13,0,0,646,648,3,130,65,0,
        647,641,1,0,0,0,647,643,1,0,0,0,647,645,1,0,0,0,648,654,1,0,0,0,
        649,650,7,15,0,0,650,651,3,16,8,0,651,652,7,16,0,0,652,653,3,16,
        8,0,653,655,1,0,0,0,654,649,1,0,0,0,654,655,1,0,0,0,655,657,1,0,
        0,0,656,658,5,264,0,0,657,656,1,0,0,0,657,658,1,0,0,0,658,671,1,
        0,0,0,659,660,5,1,0,0,660,667,7,17,0,0,661,662,5,11,0,0,662,668,
        3,130,65,0,663,664,5,12,0,0,664,668,3,130,65,0,665,666,5,13,0,0,
        666,668,3,130,65,0,667,661,1,0,0,0,667,663,1,0,0,0,667,665,1,0,0,
        0,668,671,1,0,0,0,669,671,3,90,45,0,670,601,1,0,0,0,670,611,1,0,
        0,0,670,615,1,0,0,0,670,622,1,0,0,0,670,634,1,0,0,0,670,659,1,0,
        0,0,670,669,1,0,0,0,671,89,1,0,0,0,672,673,5,44,0,0,673,674,3,12,
        6,0,674,676,5,46,0,0,675,677,3,92,46,0,676,675,1,0,0,0,676,677,1,
        0,0,0,677,679,1,0,0,0,678,680,5,264,0,0,679,678,1,0,0,0,679,680,
        1,0,0,0,680,692,1,0,0,0,681,682,5,47,0,0,682,683,5,209,0,0,683,684,
        5,48,0,0,684,686,3,12,6,0,685,687,3,92,46,0,686,685,1,0,0,0,686,
        687,1,0,0,0,687,689,1,0,0,0,688,690,5,264,0,0,689,688,1,0,0,0,689,
        690,1,0,0,0,690,692,1,0,0,0,691,672,1,0,0,0,691,681,1,0,0,0,692,
        91,1,0,0,0,693,694,5,171,0,0,694,695,3,12,6,0,695,699,3,130,65,0,
        696,698,3,94,47,0,697,696,1,0,0,0,698,701,1,0,0,0,699,697,1,0,0,
        0,699,700,1,0,0,0,700,93,1,0,0,0,701,699,1,0,0,0,702,703,5,210,0,
        0,703,704,3,12,6,0,704,705,3,130,65,0,705,95,1,0,0,0,706,707,5,97,
        0,0,707,717,3,12,6,0,708,718,3,98,49,0,709,715,3,100,50,0,710,712,
        3,102,51,0,711,713,5,264,0,0,712,711,1,0,0,0,712,713,1,0,0,0,713,
        716,1,0,0,0,714,716,5,264,0,0,715,710,1,0,0,0,715,714,1,0,0,0,715,
        716,1,0,0,0,716,718,1,0,0,0,717,708,1,0,0,0,717,709,1,0,0,0,718,
        97,1,0,0,0,719,720,3,116,58,0,720,722,5,94,0,0,721,723,5,264,0,0,
        722,721,1,0,0,0,722,723,1,0,0,0,723,99,1,0,0,0,724,726,7,18,0,0,
        725,724,1,0,0,0,725,726,1,0,0,0,726,727,1,0,0,0,727,728,3,12,6,0,
        728,729,5,96,0,0,729,101,1,0,0,0,730,733,5,112,0,0,731,734,3,130,
        65,0,732,734,3,104,52,0,733,731,1,0,0,0,733,732,1,0,0,0,734,103,
        1,0,0,0,735,736,5,49,0,0,736,737,3,106,53,0,737,738,7,19,0,0,738,
        739,5,43,0,0,739,741,5,265,0,0,740,742,3,108,54,0,741,740,1,0,0,
        0,742,743,1,0,0,0,743,741,1,0,0,0,743,744,1,0,0,0,744,778,1,0,0,
        0,745,750,3,116,58,0,746,750,5,212,0,0,747,750,5,211,0,0,748,750,
        5,238,0,0,749,745,1,0,0,0,749,746,1,0,0,0,749,747,1,0,0,0,749,748,
        1,0,0,0,750,751,1,0,0,0,751,752,5,118,0,0,752,753,3,106,53,0,753,
        754,7,19,0,0,754,755,5,149,0,0,755,757,5,265,0,0,756,758,3,108,54,
        0,757,756,1,0,0,0,758,759,1,0,0,0,759,757,1,0,0,0,759,760,1,0,0,
        0,760,778,1,0,0,0,761,766,3,116,58,0,762,766,5,212,0,0,763,766,5,
        211,0,0,764,766,5,238,0,0,765,761,1,0,0,0,765,762,1,0,0,0,765,763,
        1,0,0,0,765,764,1,0,0,0,766,767,1,0,0,0,767,768,5,149,0,0,768,769,
        5,118,0,0,769,770,3,106,53,0,770,771,7,19,0,0,771,773,5,265,0,0,
        772,774,3,108,54,0,773,772,1,0,0,0,774,775,1,0,0,0,775,773,1,0,0,
        0,775,776,1,0,0,0,776,778,1,0,0,0,777,735,1,0,0,0,777,749,1,0,0,
        0,777,765,1,0,0,0,778,105,1,0,0,0,779,796,5,120,0,0,780,781,5,199,
        0,0,781,782,5,231,0,0,782,796,5,206,0,0,783,784,7,20,0,0,784,785,
        7,21,0,0,785,786,5,231,0,0,786,796,5,206,0,0,787,788,5,154,0,0,788,
        789,7,21,0,0,789,790,5,231,0,0,790,796,5,206,0,0,791,792,5,155,0,
        0,792,793,7,21,0,0,793,794,5,231,0,0,794,796,5,206,0,0,795,779,1,
        0,0,0,795,780,1,0,0,0,795,783,1,0,0,0,795,787,1,0,0,0,795,791,1,
        0,0,0,796,107,1,0,0,0,797,800,3,110,55,0,798,801,3,112,56,0,799,
        801,3,114,57,0,800,798,1,0,0,0,800,799,1,0,0,0,801,109,1,0,0,0,802,
        803,7,22,0,0,803,111,1,0,0,0,804,805,3,130,65,0,805,113,1,0,0,0,
        806,810,3,116,58,0,807,810,5,212,0,0,808,810,5,238,0,0,809,806,1,
        0,0,0,809,807,1,0,0,0,809,808,1,0,0,0,810,811,1,0,0,0,811,812,5,
        149,0,0,812,813,5,118,0,0,813,814,3,106,53,0,814,815,7,19,0,0,815,
        817,5,265,0,0,816,818,3,108,54,0,817,816,1,0,0,0,818,819,1,0,0,0,
        819,817,1,0,0,0,819,820,1,0,0,0,820,115,1,0,0,0,821,827,3,118,59,
        0,822,823,3,14,7,0,823,824,3,118,59,0,824,826,1,0,0,0,825,822,1,
        0,0,0,826,829,1,0,0,0,827,825,1,0,0,0,827,828,1,0,0,0,828,117,1,
        0,0,0,829,827,1,0,0,0,830,832,7,23,0,0,831,830,1,0,0,0,831,832,1,
        0,0,0,832,834,1,0,0,0,833,835,3,8,4,0,834,833,1,0,0,0,835,836,1,
        0,0,0,836,834,1,0,0,0,836,837,1,0,0,0,837,840,1,0,0,0,838,840,5,
        212,0,0,839,831,1,0,0,0,839,838,1,0,0,0,840,119,1,0,0,0,841,842,
        3,12,6,0,842,843,5,231,0,0,843,844,3,116,58,0,844,121,1,0,0,0,845,
        846,3,116,58,0,846,123,1,0,0,0,847,848,5,117,0,0,848,849,3,6,3,0,
        849,125,1,0,0,0,850,854,5,108,0,0,851,853,3,128,64,0,852,851,1,0,
        0,0,853,856,1,0,0,0,854,852,1,0,0,0,854,855,1,0,0,0,855,857,1,0,
        0,0,856,854,1,0,0,0,857,858,5,264,0,0,858,127,1,0,0,0,859,860,3,
        12,6,0,860,861,5,113,0,0,861,863,3,130,65,0,862,864,5,266,0,0,863,
        862,1,0,0,0,863,864,1,0,0,0,864,129,1,0,0,0,865,866,3,132,66,0,866,
        131,1,0,0,0,867,870,3,134,67,0,868,869,7,24,0,0,869,871,3,132,66,
        0,870,868,1,0,0,0,870,871,1,0,0,0,871,133,1,0,0,0,872,873,3,138,
        69,0,873,874,5,113,0,0,874,875,3,6,3,0,875,889,1,0,0,0,876,877,3,
        138,69,0,877,878,5,111,0,0,878,879,3,6,3,0,879,889,1,0,0,0,880,884,
        3,138,69,0,881,882,3,136,68,0,882,883,3,138,69,0,883,885,1,0,0,0,
        884,881,1,0,0,0,884,885,1,0,0,0,885,889,1,0,0,0,886,889,3,176,88,
        0,887,889,3,178,89,0,888,872,1,0,0,0,888,876,1,0,0,0,888,880,1,0,
        0,0,888,886,1,0,0,0,888,887,1,0,0,0,889,135,1,0,0,0,890,891,7,25,
        0,0,891,137,1,0,0,0,892,898,3,142,71,0,893,894,3,140,70,0,894,895,
        3,142,71,0,895,897,1,0,0,0,896,893,1,0,0,0,897,900,1,0,0,0,898,896,
        1,0,0,0,898,899,1,0,0,0,899,139,1,0,0,0,900,898,1,0,0,0,901,902,
        7,26,0,0,902,141,1,0,0,0,903,909,3,146,73,0,904,905,3,144,72,0,905,
        906,3,146,73,0,906,908,1,0,0,0,907,904,1,0,0,0,908,911,1,0,0,0,909,
        907,1,0,0,0,909,910,1,0,0,0,910,143,1,0,0,0,911,909,1,0,0,0,912,
        913,7,27,0,0,913,145,1,0,0,0,914,920,3,150,75,0,915,916,3,148,74,
        0,916,917,3,150,75,0,917,919,1,0,0,0,918,915,1,0,0,0,919,922,1,0,
        0,0,920,918,1,0,0,0,920,921,1,0,0,0,921,147,1,0,0,0,922,920,1,0,
        0,0,923,924,7,28,0,0,924,149,1,0,0,0,925,926,6,75,-1,0,926,927,5,
        133,0,0,927,1134,3,150,75,45,928,929,5,277,0,0,929,1134,3,150,75,
        44,930,931,5,136,0,0,931,1134,3,150,75,43,932,933,5,14,0,0,933,934,
        3,150,75,0,934,935,5,141,0,0,935,938,3,150,75,0,936,937,5,187,0,
        0,937,939,5,252,0,0,938,936,1,0,0,0,938,939,1,0,0,0,939,1134,1,0,
        0,0,940,941,5,191,0,0,941,942,3,150,75,0,942,943,5,141,0,0,943,946,
        3,150,75,0,944,945,5,187,0,0,945,947,5,252,0,0,946,944,1,0,0,0,946,
        947,1,0,0,0,947,1134,1,0,0,0,948,949,5,190,0,0,949,1134,3,130,65,
        0,950,952,5,211,0,0,951,950,1,0,0,0,951,952,1,0,0,0,952,953,1,0,
        0,0,953,955,5,185,0,0,954,956,5,120,0,0,955,954,1,0,0,0,955,956,
        1,0,0,0,956,957,1,0,0,0,957,1134,3,116,58,0,958,961,5,253,0,0,959,
        962,5,268,0,0,960,962,5,252,0,0,961,959,1,0,0,0,961,960,1,0,0,0,
        962,963,1,0,0,0,963,964,5,231,0,0,964,1134,3,150,75,38,965,966,5,
        33,0,0,966,971,3,150,75,0,967,968,5,263,0,0,968,970,3,150,75,0,969,
        967,1,0,0,0,970,973,1,0,0,0,971,969,1,0,0,0,971,972,1,0,0,0,972,
        974,1,0,0,0,973,971,1,0,0,0,974,975,7,24,0,0,975,976,3,150,75,35,
        976,1134,1,0,0,0,977,978,5,151,0,0,978,1134,3,150,75,33,979,980,
        5,15,0,0,980,981,5,259,0,0,981,982,3,150,75,0,982,983,5,260,0,0,
        983,1134,1,0,0,0,984,985,5,17,0,0,985,990,3,150,75,0,986,987,5,263,
        0,0,987,989,3,150,75,0,988,986,1,0,0,0,989,992,1,0,0,0,990,988,1,
        0,0,0,990,991,1,0,0,0,991,993,1,0,0,0,992,990,1,0,0,0,993,994,5,
        210,0,0,994,995,3,150,75,31,995,1134,1,0,0,0,996,997,5,16,0,0,997,
        1002,3,150,75,0,998,999,5,263,0,0,999,1001,3,150,75,0,1000,998,1,
        0,0,0,1001,1004,1,0,0,0,1002,1000,1,0,0,0,1002,1003,1,0,0,0,1003,
        1005,1,0,0,0,1004,1002,1,0,0,0,1005,1006,5,210,0,0,1006,1007,3,150,
        75,30,1007,1134,1,0,0,0,1008,1009,5,211,0,0,1009,1010,5,214,0,0,
        1010,1011,5,229,0,0,1011,1134,3,150,75,29,1012,1013,5,206,0,0,1013,
        1014,5,216,0,0,1014,1015,5,229,0,0,1015,1134,3,150,75,28,1016,1017,
        5,206,0,0,1017,1018,5,204,0,0,1018,1019,5,229,0,0,1019,1134,3,150,
        75,27,1020,1021,5,20,0,0,1021,1022,5,259,0,0,1022,1023,3,150,75,
        0,1023,1024,5,263,0,0,1024,1025,3,150,75,0,1025,1026,5,263,0,0,1026,
        1027,3,150,75,0,1027,1028,5,260,0,0,1028,1134,1,0,0,0,1029,1030,
        5,21,0,0,1030,1031,5,259,0,0,1031,1032,3,150,75,0,1032,1033,5,260,
        0,0,1033,1134,1,0,0,0,1034,1035,5,186,0,0,1035,1040,3,150,75,0,1036,
        1037,5,263,0,0,1037,1039,3,150,75,0,1038,1036,1,0,0,0,1039,1042,
        1,0,0,0,1040,1038,1,0,0,0,1040,1041,1,0,0,0,1041,1043,1,0,0,0,1042,
        1040,1,0,0,0,1043,1044,5,210,0,0,1044,1045,3,150,75,23,1045,1134,
        1,0,0,0,1046,1047,5,188,0,0,1047,1052,3,150,75,0,1048,1049,5,263,
        0,0,1049,1051,3,150,75,0,1050,1048,1,0,0,0,1051,1054,1,0,0,0,1052,
        1050,1,0,0,0,1052,1053,1,0,0,0,1053,1055,1,0,0,0,1054,1052,1,0,0,
        0,1055,1056,5,210,0,0,1056,1057,3,150,75,22,1057,1134,1,0,0,0,1058,
        1059,5,18,0,0,1059,1062,3,130,65,0,1060,1061,5,8,0,0,1061,1063,3,
        130,65,0,1062,1060,1,0,0,0,1062,1063,1,0,0,0,1063,1134,1,0,0,0,1064,
        1069,5,1,0,0,1065,1066,5,206,0,0,1066,1070,5,216,0,0,1067,1068,5,
        211,0,0,1068,1070,5,214,0,0,1069,1065,1,0,0,0,1069,1067,1,0,0,0,
        1070,1071,1,0,0,0,1071,1072,5,205,0,0,1072,1134,3,130,65,0,1073,
        1075,3,6,3,0,1074,1073,1,0,0,0,1075,1076,1,0,0,0,1076,1074,1,0,0,
        0,1076,1077,1,0,0,0,1077,1078,1,0,0,0,1078,1079,5,18,0,0,1079,1082,
        3,130,65,0,1080,1081,5,8,0,0,1081,1083,3,130,65,0,1082,1080,1,0,
        0,0,1082,1083,1,0,0,0,1083,1134,1,0,0,0,1084,1085,5,19,0,0,1085,
        1086,7,17,0,0,1086,1087,5,231,0,0,1087,1090,3,130,65,0,1088,1089,
        5,8,0,0,1089,1091,3,130,65,0,1090,1088,1,0,0,0,1090,1091,1,0,0,0,
        1091,1134,1,0,0,0,1092,1094,3,6,3,0,1093,1092,1,0,0,0,1094,1095,
        1,0,0,0,1095,1093,1,0,0,0,1095,1096,1,0,0,0,1096,1097,1,0,0,0,1097,
        1098,5,19,0,0,1098,1099,7,17,0,0,1099,1100,5,231,0,0,1100,1103,3,
        130,65,0,1101,1102,5,8,0,0,1102,1104,3,130,65,0,1103,1101,1,0,0,
        0,1103,1104,1,0,0,0,1104,1134,1,0,0,0,1105,1108,3,164,82,0,1106,
        1108,3,166,83,0,1107,1105,1,0,0,0,1107,1106,1,0,0,0,1108,1109,1,
        0,0,0,1109,1110,3,120,60,0,1110,1111,3,168,84,0,1111,1134,1,0,0,
        0,1112,1134,3,120,60,0,1113,1134,3,124,62,0,1114,1134,3,116,58,0,
        1115,1134,3,12,6,0,1116,1134,3,74,37,0,1117,1134,5,224,0,0,1118,
        1134,3,6,3,0,1119,1121,5,253,0,0,1120,1122,3,54,27,0,1121,1120,1,
        0,0,0,1121,1122,1,0,0,0,1122,1134,1,0,0,0,1123,1134,5,257,0,0,1124,
        1134,5,258,0,0,1125,1134,3,16,8,0,1126,1134,5,236,0,0,1127,1134,
        5,220,0,0,1128,1134,5,212,0,0,1129,1130,5,259,0,0,1130,1131,3,130,
        65,0,1131,1132,5,260,0,0,1132,1134,1,0,0,0,1133,925,1,0,0,0,1133,
        928,1,0,0,0,1133,930,1,0,0,0,1133,932,1,0,0,0,1133,940,1,0,0,0,1133,
        948,1,0,0,0,1133,951,1,0,0,0,1133,958,1,0,0,0,1133,965,1,0,0,0,1133,
        977,1,0,0,0,1133,979,1,0,0,0,1133,984,1,0,0,0,1133,996,1,0,0,0,1133,
        1008,1,0,0,0,1133,1012,1,0,0,0,1133,1016,1,0,0,0,1133,1020,1,0,0,
        0,1133,1029,1,0,0,0,1133,1034,1,0,0,0,1133,1046,1,0,0,0,1133,1058,
        1,0,0,0,1133,1064,1,0,0,0,1133,1074,1,0,0,0,1133,1084,1,0,0,0,1133,
        1093,1,0,0,0,1133,1107,1,0,0,0,1133,1112,1,0,0,0,1133,1113,1,0,0,
        0,1133,1114,1,0,0,0,1133,1115,1,0,0,0,1133,1116,1,0,0,0,1133,1117,
        1,0,0,0,1133,1118,1,0,0,0,1133,1119,1,0,0,0,1133,1123,1,0,0,0,1133,
        1124,1,0,0,0,1133,1125,1,0,0,0,1133,1126,1,0,0,0,1133,1127,1,0,0,
        0,1133,1128,1,0,0,0,1133,1129,1,0,0,0,1134,1157,1,0,0,0,1135,1138,
        10,34,0,0,1136,1137,5,263,0,0,1137,1139,3,150,75,0,1138,1136,1,0,
        0,0,1139,1140,1,0,0,0,1140,1138,1,0,0,0,1140,1141,1,0,0,0,1141,1142,
        1,0,0,0,1142,1143,7,24,0,0,1143,1144,3,150,75,35,1144,1156,1,0,0,
        0,1145,1146,10,37,0,0,1146,1156,3,152,76,0,1147,1148,10,36,0,0,1148,
        1149,5,263,0,0,1149,1156,3,154,77,0,1150,1151,10,24,0,0,1151,1152,
        7,29,0,0,1152,1153,3,150,75,0,1153,1154,3,6,3,0,1154,1156,1,0,0,
        0,1155,1135,1,0,0,0,1155,1145,1,0,0,0,1155,1147,1,0,0,0,1155,1150,
        1,0,0,0,1156,1159,1,0,0,0,1157,1155,1,0,0,0,1157,1158,1,0,0,0,1158,
        151,1,0,0,0,1159,1157,1,0,0,0,1160,1161,7,30,0,0,1161,1162,5,119,
        0,0,1162,1163,5,253,0,0,1163,1164,5,164,0,0,1164,153,1,0,0,0,1165,
        1172,3,156,78,0,1166,1172,3,158,79,0,1167,1168,3,156,78,0,1168,1169,
        5,210,0,0,1169,1170,3,158,79,0,1170,1172,1,0,0,0,1171,1165,1,0,0,
        0,1171,1166,1,0,0,0,1171,1167,1,0,0,0,1172,155,1,0,0,0,1173,1174,
        5,23,0,0,1174,1175,3,130,65,0,1175,157,1,0,0,0,1176,1177,5,24,0,
        0,1177,1178,3,130,65,0,1178,159,1,0,0,0,1179,1180,5,8,0,0,1180,1183,
        3,130,65,0,1181,1183,3,162,81,0,1182,1179,1,0,0,0,1182,1181,1,0,
        0,0,1183,161,1,0,0,0,1184,1185,5,145,0,0,1185,1201,3,16,8,0,1186,
        1187,5,231,0,0,1187,1188,3,16,8,0,1188,1189,5,141,0,0,1189,1190,
        3,16,8,0,1190,1201,1,0,0,0,1191,1192,5,231,0,0,1192,1193,3,16,8,
        0,1193,1194,5,143,0,0,1194,1195,3,16,8,0,1195,1201,1,0,0,0,1196,
        1197,5,141,0,0,1197,1201,3,16,8,0,1198,1199,5,143,0,0,1199,1201,
        3,16,8,0,1200,1184,1,0,0,0,1200,1186,1,0,0,0,1200,1191,1,0,0,0,1200,
        1196,1,0,0,0,1200,1198,1,0,0,0,1201,163,1,0,0,0,1202,1204,5,211,
        0,0,1203,1202,1,0,0,0,1203,1204,1,0,0,0,1204,1205,1,0,0,0,1205,1210,
        5,185,0,0,1206,1210,5,16,0,0,1207,1210,5,17,0,0,1208,1210,5,190,
        0,0,1209,1203,1,0,0,0,1209,1206,1,0,0,0,1209,1207,1,0,0,0,1209,1208,
        1,0,0,0,1210,165,1,0,0,0,1211,1212,7,31,0,0,1212,167,1,0,0,0,1213,
        1217,5,222,0,0,1214,1218,3,170,85,0,1215,1218,3,172,86,0,1216,1218,
        3,174,87,0,1217,1214,1,0,0,0,1217,1215,1,0,0,0,1217,1216,1,0,0,0,
        1218,1219,1,0,0,0,1219,1220,5,264,0,0,1220,169,1,0,0,0,1221,1222,
        5,120,0,0,1222,1223,3,12,6,0,1223,171,1,0,0,0,1224,1225,5,206,0,
        0,1225,1226,3,12,6,0,1226,1227,5,145,0,0,1227,1228,3,6,3,0,1228,
        1229,5,228,0,0,1229,1230,3,6,3,0,1230,173,1,0,0,0,1231,1232,5,206,
        0,0,1232,1233,3,12,6,0,1233,1234,5,213,0,0,1234,1235,5,261,0,0,1235,
        1240,3,6,3,0,1236,1237,5,263,0,0,1237,1239,3,6,3,0,1238,1236,1,0,
        0,0,1239,1242,1,0,0,0,1240,1238,1,0,0,0,1240,1241,1,0,0,0,1241,1243,
        1,0,0,0,1242,1240,1,0,0,0,1243,1244,5,210,0,0,1244,1245,3,6,3,0,
        1245,1246,5,262,0,0,1246,175,1,0,0,0,1247,1248,3,150,75,0,1248,1249,
        7,32,0,0,1249,1274,1,0,0,0,1250,1251,3,150,75,0,1251,1252,7,33,0,
        0,1252,1253,5,253,0,0,1253,1254,5,162,0,0,1254,1274,1,0,0,0,1255,
        1256,3,150,75,0,1256,1257,7,34,0,0,1257,1258,3,6,3,0,1258,1274,1,
        0,0,0,1259,1260,3,150,75,0,1260,1261,7,35,0,0,1261,1262,3,6,3,0,
        1262,1274,1,0,0,0,1263,1264,3,150,75,0,1264,1265,7,36,0,0,1265,1266,
        3,6,3,0,1266,1274,1,0,0,0,1267,1268,3,116,58,0,1268,1269,5,94,0,
        0,1269,1274,1,0,0,0,1270,1271,3,150,75,0,1271,1272,5,96,0,0,1272,
        1274,1,0,0,0,1273,1247,1,0,0,0,1273,1250,1,0,0,0,1273,1255,1,0,0,
        0,1273,1259,1,0,0,0,1273,1263,1,0,0,0,1273,1267,1,0,0,0,1273,1270,
        1,0,0,0,1274,177,1,0,0,0,1275,1276,5,98,0,0,1276,1277,3,12,6,0,1277,
        1278,7,37,0,0,1278,179,1,0,0,0,1279,1280,5,107,0,0,1280,1282,3,12,
        6,0,1281,1283,5,266,0,0,1282,1281,1,0,0,0,1282,1283,1,0,0,0,1283,
        181,1,0,0,0,146,187,189,200,205,212,217,222,228,234,240,245,251,
        257,259,267,282,285,288,293,298,303,307,311,316,323,325,333,336,
        339,346,357,366,374,380,386,389,396,402,412,421,428,434,439,444,
        452,458,461,476,480,483,488,493,503,509,517,523,526,529,534,540,
        546,552,559,566,572,577,583,585,595,597,601,609,624,632,638,647,
        654,657,667,670,676,679,686,689,691,699,712,715,717,722,725,733,
        743,749,759,765,775,777,795,800,809,819,827,831,836,839,854,863,
        870,884,888,898,909,920,938,946,951,955,961,971,990,1002,1040,1052,
        1062,1069,1076,1082,1090,1095,1103,1107,1121,1133,1140,1155,1157,
        1171,1182,1200,1203,1209,1217,1240,1273,1282
    ]

class RegelSpraakParser ( Parser ):

    grammarFileName = "RegelSpraak.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'het aantal dagen in'", "'het kwartaal'", 
                     "'het deel per maand'", "'het deel per jaar'", "'(voor het attribuut zonder voorzetsel):'", 
                     "'(na het attribuut met voorzetsel'", "'Datum en tijd in millisecondes'", 
                     "'gedurende de tijd dat'", "'gedurende het gehele'", 
                     "'gedurende de gehele'", "'moet berekend worden als'", 
                     "'moet gesteld worden op'", "'moet ge\\u00EFnitialiseerd worden op'", 
                     "'de absolute tijdsduur van'", "'de absolute waarde van'", 
                     "'de maximale waarde van'", "'de minimale waarde van'", 
                     "'het totaal van'", "'het tijdsevenredig deel per'", 
                     "'de datum met jaar, maand en dag'", "'de eerste paasdag van'", 
                     "'Als onverdeelde rest blijft'", "'met een minimum van'", 
                     "'met een maximum van'", "'groter of gelijk aan'", 
                     "'kleiner of gelijk aan'", "'later of gelijk aan'", 
                     "'eerder of gelijk aan'", "', waarbij wordt verdeeld'", 
                     "', bestaande uit de'", "'Wederkerig feittype'", "'is van het type'", 
                     "'de concatenatie van'", "'het volgende criterium:'", 
                     "'volgende criteria:'", "'bij even groot criterium'", 
                     "'op volgorde van'", "'naar rato van'", "'numeriek met exact'", 
                     "'aan de elfproef'", "'groter is dan'", "'kleiner is dan'", 
                     "'wordt voldaan'", "<INVALID>", "'wordt een nieuw'", 
                     "'aangemaakt'", "'Cre\\u00EBer'", "'nieuwe'", "<INVALID>", 
                     "'is gelijk aan'", "'is ongelijk aan'", "'is kleiner dan'", 
                     "'is kleiner of gelijk aan'", "'is groter dan'", "'is groter of gelijk aan'", 
                     "'zijn gelijk aan'", "'zijn ongelijk aan'", "'zijn groter dan'", 
                     "'zijn groter of gelijk aan'", "'zijn kleiner dan'", 
                     "'zijn kleiner of gelijk aan'", "'is later dan'", "'is later of gelijk aan'", 
                     "'is eerder dan'", "'is eerder of gelijk aan'", "'zijn later dan'", 
                     "'zijn later of gelijk aan'", "'zijn eerder dan'", 
                     "'zijn eerder of gelijk aan'", "'is leeg'", "'is gevuld'", 
                     "'zijn leeg'", "'zijn gevuld'", "'is kenmerk'", "'is rol'", 
                     "'zijn kenmerk'", "'zijn rol'", "'is niet kenmerk'", 
                     "'is niet rol'", "'zijn niet kenmerk'", "'zijn niet rol'", 
                     "'voldoet aan de elfproef'", "'voldoen aan de elfproef'", 
                     "'voldoet niet aan de elfproef'", "'voldoen niet aan de elfproef'", 
                     "'is numeriek met exact'", "'is niet numeriek met exact'", 
                     "'zijn numeriek met exact'", "'zijn niet numeriek met exact'", 
                     "'is een dagsoort'", "'zijn een dagsoort'", "'is geen dagsoort'", 
                     "'zijn geen dagsoort'", "'moeten uniek zijn'", "'is gevuurd'", 
                     "'is inconsistent'", "'Consistentieregel'", "'Regel'", 
                     "'Beslistabel'", "'Objecttype'", "'Domein'", "'Lijst'", 
                     "'Dimensie'", "'Eenheidsysteem'", "'Parameter'", "'FeitType'", 
                     "'Dagsoort'", "'Daarbij geldt:'", "'geldig'", "'hebben'", 
                     "'heeft'", "'indien'", "'is'", "'moet'", "'moeten'", 
                     "'wordt verdeeld over'", "'zijn'", "'aan'", "'afgerond op'", 
                     "'alle'", "'eerder dan'", "'gedeeld door'", "'gedeeld door (ABS)'", 
                     "'gelijk aan'", "'gevuld'", "'gevuurd'", "'groter dan'", 
                     "'inconsistent'", "'kleiner dan'", "'later dan'", "'leeg'", 
                     "'maal'", "'min'", "'naar beneden'", "'naar boven'", 
                     "'niet'", "'ongelijk aan'", "'plus'", "'rekenkundig'", 
                     "'richting nul'", "'tot'", "'tot de macht'", "'tot en met'", 
                     "'uniek'", "'vanaf'", "'verenigd met'", "'verminderd met'", 
                     "'voldoen'", "'voldoet'", "'weg van nul'", "'de wortel van'", 
                     "'tenminste'", "'ten minste'", "'ten hoogste'", "'precies'", 
                     "'voorwaarde'", "'voorwaarden'", "'(bezield)'", "'(bezittelijk)'", 
                     "'(bijvoeglijk)'", "'Boolean'", "'cijfers'", "'Datum in dagen'", 
                     "'decimalen'", "'Enumeratie'", "'gedimensioneerd met'", 
                     "'geheel getal'", "'getal'", "'kenmerk'", "'kenmerken'", 
                     "'met'", "'met eenheid'", "'(mv:'", "'negatief'", "'niet-negatief'", 
                     "'Numeriek'", "'Percentage'", "'positief'", "'rol'", 
                     "'rollen'", "'Tekst'", "'voor elk jaar'", "'voor elke dag'", 
                     "'voor elke maand'", "'aantal'", "'de eerste van'", 
                     "'in hele'", "'de laatste van'", "'reeks van teksten en waarden'", 
                     "'de som van'", "'de tijdsduur van'", "'afnemende'", 
                     "'in gelijke delen'", "'over.'", "'toenemende'", "'drie'", 
                     "'\\u00E9\\u00E9n'", "'geen van de'", "'geen'", "'twee'", 
                     "'vier'", "'altijd'", "'bij'", "'dag'", "'dat'", "'de'", 
                     "'dd.'", "'die'", "'een'", "'en'", "'het'", "'hij'", 
                     "'in'", "'jaar'", "'kwartaal'", "'maand'", "'milliseconde'", 
                     "'minuut'", "'of'", "'onwaar'", "'op'", "'over'", "'periode'", 
                     "'Rekendatum'", "'Rekenjaar'", "'regelversie'", "'seconde'", 
                     "'t/m'", "'uit'", "'uur'", "'van'", "'volgende voorwaarde'", 
                     "'volgende voorwaarden'", "'volgende'", "'voor'", "'waar'", 
                     "'week'", "'er'", "'meter'", "'kilogram'", "'voet'", 
                     "'pond'", "'mijl'", "'m'", "'kg'", "'s'", "'ft'", "'lb'", 
                     "'mi'", "'\\u20AC'", "'$'", "<INVALID>", "<INVALID>", 
                     "'='", "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "'('", "')'", "'{'", "'}'", "','", "'.'", "':'", "';'", 
                     "'/'", "'%'", "'\\u2022'", "'*'", "'\\u00AB'", "'\\u00BB'", 
                     "'^'", "'..'", "<INVALID>", "<INVALID>", "'-'" ]

    symbolicNames = [ "<INVALID>", "HET_AANTAL_DAGEN_IN", "HET_KWARTAAL", 
                      "HET_DEEL_PER_MAAND", "HET_DEEL_PER_JAAR", "VOOR_HET_ATTRIBUUT_ZONDER_VOORZETSEL", 
                      "NA_HET_ATTRIBUUT_MET_VOORZETSEL", "DATUM_TIJD_MILLIS", 
                      "GEDURENDE_DE_TIJD_DAT", "GEDURENDE_HET_GEHELE", "GEDURENDE_DE_GEHELE", 
                      "WORDT_BEREKEND_ALS", "WORDT_GESTELD_OP", "WORDT_GEINITIALISEERD_OP", 
                      "DE_ABSOLUTE_TIJDSDUUR_VAN", "DE_ABSOLUTE_WAARDE_VAN", 
                      "DE_MAXIMALE_WAARDE_VAN", "DE_MINIMALE_WAARDE_VAN", 
                      "HET_TOTAAL_VAN", "HET_TIJDSEVENREDIG_DEEL_PER", "DE_DATUM_MET", 
                      "DE_EERSTE_PAASDAG_VAN", "ALS_ONVERDEELDE_REST_BLIJFT", 
                      "MET_EEN_MINIMUM_VAN", "MET_EEN_MAXIMUM_VAN", "GROTER_OF_GELIJK_AAN", 
                      "KLEINER_OF_GELIJK_AAN", "LATER_OF_GELIJK_AAN", "EERDER_OF_GELIJK_AAN", 
                      "WAARBIJ_WORDT_VERDEELD", "BESTAANDE_UIT", "WEDERKERIG_FEITTYPE", 
                      "IS_VAN_HET_TYPE", "CONCATENATIE_VAN", "VOLGEND_CRITERIUM", 
                      "VOLGENDE_CRITERIA", "BIJ_EVEN_GROOT_CRITERIUM", "OP_VOLGORDE_VAN", 
                      "NAAR_RATO_VAN", "NUMERIEK_MET_EXACT", "AAN_DE_ELFPROEF", 
                      "GROTER_IS_DAN", "KLEINER_IS_DAN", "WORDT_VOLDAAN", 
                      "ER_WORDT_EEN_NIEUW", "WORDT_EEN_NIEUW", "AANGEMAAKT", 
                      "CREEER", "NIEUWE", "ER_AAN", "IS_GELIJK_AAN", "IS_ONGELIJK_AAN", 
                      "IS_KLEINER_DAN", "IS_KLEINER_OF_GELIJK_AAN", "IS_GROTER_DAN", 
                      "IS_GROTER_OF_GELIJK_AAN", "ZIJN_GELIJK_AAN", "ZIJN_ONGELIJK_AAN", 
                      "ZIJN_GROTER_DAN", "ZIJN_GROTER_OF_GELIJK_AAN", "ZIJN_KLEINER_DAN", 
                      "ZIJN_KLEINER_OF_GELIJK_AAN", "IS_LATER_DAN", "IS_LATER_OF_GELIJK_AAN", 
                      "IS_EERDER_DAN", "IS_EERDER_OF_GELIJK_AAN", "ZIJN_LATER_DAN", 
                      "ZIJN_LATER_OF_GELIJK_AAN", "ZIJN_EERDER_DAN", "ZIJN_EERDER_OF_GELIJK_AAN", 
                      "IS_LEEG", "IS_GEVULD", "ZIJN_LEEG", "ZIJN_GEVULD", 
                      "IS_KENMERK", "IS_ROL", "ZIJN_KENMERK", "ZIJN_ROL", 
                      "IS_NIET_KENMERK", "IS_NIET_ROL", "ZIJN_NIET_KENMERK", 
                      "ZIJN_NIET_ROL", "VOLDOET_AAN_DE_ELFPROEF", "VOLDOEN_AAN_DE_ELFPROEF", 
                      "VOLDOET_NIET_AAN_DE_ELFPROEF", "VOLDOEN_NIET_AAN_DE_ELFPROEF", 
                      "IS_NUMERIEK_MET_EXACT", "IS_NIET_NUMERIEK_MET_EXACT", 
                      "ZIJN_NUMERIEK_MET_EXACT", "ZIJN_NIET_NUMERIEK_MET_EXACT", 
                      "IS_EEN_DAGSOORT", "ZIJN_EEN_DAGSOORT", "IS_GEEN_DAGSOORT", 
                      "ZIJN_GEEN_DAGSOORT", "MOETEN_UNIEK_ZIJN", "IS_GEVUURD", 
                      "IS_INCONSISTENT", "CONSISTENTIEREGEL", "REGEL", "BESLISTABEL", 
                      "OBJECTTYPE", "DOMEIN", "LIJST", "DIMENSIE", "EENHEIDSYSTEEM", 
                      "PARAMETER", "FEITTYPE", "DAGSOORT", "DAARBIJ_GELDT", 
                      "GELDIG", "HEBBEN", "HEEFT", "INDIEN", "IS", "MOET", 
                      "MOETEN", "WORDT_VERDEELD_OVER", "ZIJN", "AAN", "AFGEROND_OP", 
                      "ALLE", "EERDER_DAN", "GEDEELD_DOOR", "GEDEELD_DOOR_ABS", 
                      "GELIJK_AAN", "GEVULD", "GEVUURD", "GROTER_DAN", "INCONSISTENT", 
                      "KLEINER_DAN", "LATER_DAN", "LEEG", "MAAL", "MIN", 
                      "NAAR_BENEDEN", "NAAR_BOVEN", "NIET", "ONGELIJK_AAN", 
                      "PLUS", "REKENKUNDIG", "RICHTING_NUL", "TOT", "TOT_DE_MACHT", 
                      "TOT_EN_MET", "UNIEK", "VANAF", "VERENIGD_MET", "VERMINDERD_MET", 
                      "VOLDOEN", "VOLDOET", "WEG_VAN_NUL", "DE_WORTEL_VAN", 
                      "TENMINSTE", "TEN_MINSTE", "TEN_HOOGSTE", "PRECIES", 
                      "VOORWAARDE", "VOORWAARDEN", "BEZIELD", "BEZITTELIJK", 
                      "BIJVOEGLIJK", "BOOLEAN", "CIJFERS", "DATUM_IN_DAGEN", 
                      "DECIMALEN", "ENUMERATIE", "GEDIMENSIONEERD_MET", 
                      "GEHEEL_GETAL", "GETAL", "KENMERK", "KENMERKEN", "MET", 
                      "MET_EENHEID", "MV_START", "NEGATIEF", "NIET_NEGATIEF", 
                      "NUMERIEK", "PERCENTAGE", "POSITIEF", "ROL", "ROLLEN", 
                      "TEKST", "VOOR_ELK_JAAR", "VOOR_ELKE_DAG", "VOOR_ELKE_MAAND", 
                      "AANTAL", "EERSTE_VAN", "IN_HELE", "LAATSTE_VAN", 
                      "REEKS_VAN_TEKSTEN_EN_WAARDEN", "SOM_VAN", "TIJDSDUUR_VAN", 
                      "AFNEMENDE", "IN_GELIJKE_DELEN", "OVER_VERDELING", 
                      "TOENEMENDE", "DRIE_TELWOORD", "EEN_TELWOORD", "GEEN_VAN_DE", 
                      "GEEN", "TWEE_TELWOORD", "VIER_TELWOORD", "ALTIJD", 
                      "BIJ", "DAG", "DAT", "DE", "DD_PUNT", "DIE", "EEN", 
                      "EN", "HET", "HIJ", "IN", "JAAR", "KWARTAAL", "MAAND", 
                      "MILLISECONDE", "MINUUT", "OF", "ONWAAR", "OP", "OVER", 
                      "PERIODE", "REKENDATUM", "REKENJAAR", "REGELVERSIE", 
                      "SECONDE", "TM", "UIT", "UUR", "VAN", "VOLGENDE_VOORWAARDE", 
                      "VOLGENDE_VOORWAARDEN", "VOLGENDE", "VOOR", "WAAR", 
                      "WEEK", "ER", "METER", "KILOGRAM", "VOET", "POND", 
                      "MIJL", "M", "KG", "S", "FT", "LB", "MI", "EURO_SYMBOL", 
                      "DOLLAR_SYMBOL", "IDENTIFIER", "NUMBER", "EQUALS", 
                      "DATE_TIME_LITERAL", "PERCENTAGE_LITERAL", "STRING_LITERAL", 
                      "ENUM_LITERAL", "LPAREN", "RPAREN", "LBRACE", "RBRACE", 
                      "COMMA", "DOT", "COLON", "SEMICOLON", "SLASH", "PERCENT_SIGN", 
                      "BULLET", "ASTERISK", "L_ANGLE_QUOTE", "R_ANGLE_QUOTE", 
                      "CARET", "DOUBLE_DOT", "WS", "LINE_COMMENT", "MINUS" ]

    RULE_regelSpraakDocument = 0
    RULE_definitie = 1
    RULE_beslistabel = 2
    RULE_identifier = 3
    RULE_identifierOrKeyword = 4
    RULE_naamPhrase = 5
    RULE_naamwoord = 6
    RULE_voorzetsel = 7
    RULE_datumLiteral = 8
    RULE_unit = 9
    RULE_objectTypeDefinition = 10
    RULE_objectTypeMember = 11
    RULE_kenmerkSpecificatie = 12
    RULE_attribuutSpecificatie = 13
    RULE_datatype = 14
    RULE_lijstDatatype = 15
    RULE_numeriekDatatype = 16
    RULE_tekstDatatype = 17
    RULE_booleanDatatype = 18
    RULE_datumTijdDatatype = 19
    RULE_getalSpecificatie = 20
    RULE_domeinDefinition = 21
    RULE_domeinType = 22
    RULE_enumeratieSpecificatie = 23
    RULE_domeinRef = 24
    RULE_eenheidsysteemDefinition = 25
    RULE_eenheidEntry = 26
    RULE_unitIdentifier = 27
    RULE_eenheidExpressie = 28
    RULE_eenheidMacht = 29
    RULE_dimensieDefinition = 30
    RULE_voorzetselSpecificatie = 31
    RULE_labelWaardeSpecificatie = 32
    RULE_tijdlijn = 33
    RULE_dimensieRef = 34
    RULE_parameterDefinition = 35
    RULE_parameterNamePhrase = 36
    RULE_parameterMetLidwoord = 37
    RULE_feitTypeDefinition = 38
    RULE_rolSpecificatie = 39
    RULE_regel = 40
    RULE_regelName = 41
    RULE_regelVersie = 42
    RULE_versieGeldigheid = 43
    RULE_resultaatDeel = 44
    RULE_objectCreatie = 45
    RULE_objectAttributeInit = 46
    RULE_attributeInitVervolg = 47
    RULE_consistentieregel = 48
    RULE_uniekzijnResultaat = 49
    RULE_inconsistentResultaat = 50
    RULE_voorwaardeDeel = 51
    RULE_toplevelSamengesteldeVoorwaarde = 52
    RULE_voorwaardeKwantificatie = 53
    RULE_samengesteldeVoorwaardeOnderdeel = 54
    RULE_bulletPrefix = 55
    RULE_elementaireVoorwaarde = 56
    RULE_genesteSamengesteldeVoorwaarde = 57
    RULE_onderwerpReferentie = 58
    RULE_basisOnderwerp = 59
    RULE_attribuutReferentie = 60
    RULE_kenmerkNaam = 61
    RULE_bezieldeReferentie = 62
    RULE_variabeleDeel = 63
    RULE_variabeleToekenning = 64
    RULE_expressie = 65
    RULE_logicalExpression = 66
    RULE_comparisonExpression = 67
    RULE_comparisonOperator = 68
    RULE_additiveExpression = 69
    RULE_additiveOperator = 70
    RULE_multiplicativeExpression = 71
    RULE_multiplicativeOperator = 72
    RULE_powerExpression = 73
    RULE_powerOperator = 74
    RULE_primaryExpression = 75
    RULE_afronding = 76
    RULE_begrenzing = 77
    RULE_begrenzingMinimum = 78
    RULE_begrenzingMaximum = 79
    RULE_conditieBijExpressie = 80
    RULE_periodevergelijkingEnkelvoudig = 81
    RULE_getalAggregatieFunctie = 82
    RULE_datumAggregatieFunctie = 83
    RULE_dimensieSelectie = 84
    RULE_aggregerenOverAlleDimensies = 85
    RULE_aggregerenOverVerzameling = 86
    RULE_aggregerenOverBereik = 87
    RULE_unaryCondition = 88
    RULE_regelStatusCondition = 89
    RULE_dagsoortDefinition = 90

    ruleNames =  [ "regelSpraakDocument", "definitie", "beslistabel", "identifier", 
                   "identifierOrKeyword", "naamPhrase", "naamwoord", "voorzetsel", 
                   "datumLiteral", "unit", "objectTypeDefinition", "objectTypeMember", 
                   "kenmerkSpecificatie", "attribuutSpecificatie", "datatype", 
                   "lijstDatatype", "numeriekDatatype", "tekstDatatype", 
                   "booleanDatatype", "datumTijdDatatype", "getalSpecificatie", 
                   "domeinDefinition", "domeinType", "enumeratieSpecificatie", 
                   "domeinRef", "eenheidsysteemDefinition", "eenheidEntry", 
                   "unitIdentifier", "eenheidExpressie", "eenheidMacht", 
                   "dimensieDefinition", "voorzetselSpecificatie", "labelWaardeSpecificatie", 
                   "tijdlijn", "dimensieRef", "parameterDefinition", "parameterNamePhrase", 
                   "parameterMetLidwoord", "feitTypeDefinition", "rolSpecificatie", 
                   "regel", "regelName", "regelVersie", "versieGeldigheid", 
                   "resultaatDeel", "objectCreatie", "objectAttributeInit", 
                   "attributeInitVervolg", "consistentieregel", "uniekzijnResultaat", 
                   "inconsistentResultaat", "voorwaardeDeel", "toplevelSamengesteldeVoorwaarde", 
                   "voorwaardeKwantificatie", "samengesteldeVoorwaardeOnderdeel", 
                   "bulletPrefix", "elementaireVoorwaarde", "genesteSamengesteldeVoorwaarde", 
                   "onderwerpReferentie", "basisOnderwerp", "attribuutReferentie", 
                   "kenmerkNaam", "bezieldeReferentie", "variabeleDeel", 
                   "variabeleToekenning", "expressie", "logicalExpression", 
                   "comparisonExpression", "comparisonOperator", "additiveExpression", 
                   "additiveOperator", "multiplicativeExpression", "multiplicativeOperator", 
                   "powerExpression", "powerOperator", "primaryExpression", 
                   "afronding", "begrenzing", "begrenzingMinimum", "begrenzingMaximum", 
                   "conditieBijExpressie", "periodevergelijkingEnkelvoudig", 
                   "getalAggregatieFunctie", "datumAggregatieFunctie", "dimensieSelectie", 
                   "aggregerenOverAlleDimensies", "aggregerenOverVerzameling", 
                   "aggregerenOverBereik", "unaryCondition", "regelStatusCondition", 
                   "dagsoortDefinition" ]

    EOF = Token.EOF
    HET_AANTAL_DAGEN_IN=1
    HET_KWARTAAL=2
    HET_DEEL_PER_MAAND=3
    HET_DEEL_PER_JAAR=4
    VOOR_HET_ATTRIBUUT_ZONDER_VOORZETSEL=5
    NA_HET_ATTRIBUUT_MET_VOORZETSEL=6
    DATUM_TIJD_MILLIS=7
    GEDURENDE_DE_TIJD_DAT=8
    GEDURENDE_HET_GEHELE=9
    GEDURENDE_DE_GEHELE=10
    WORDT_BEREKEND_ALS=11
    WORDT_GESTELD_OP=12
    WORDT_GEINITIALISEERD_OP=13
    DE_ABSOLUTE_TIJDSDUUR_VAN=14
    DE_ABSOLUTE_WAARDE_VAN=15
    DE_MAXIMALE_WAARDE_VAN=16
    DE_MINIMALE_WAARDE_VAN=17
    HET_TOTAAL_VAN=18
    HET_TIJDSEVENREDIG_DEEL_PER=19
    DE_DATUM_MET=20
    DE_EERSTE_PAASDAG_VAN=21
    ALS_ONVERDEELDE_REST_BLIJFT=22
    MET_EEN_MINIMUM_VAN=23
    MET_EEN_MAXIMUM_VAN=24
    GROTER_OF_GELIJK_AAN=25
    KLEINER_OF_GELIJK_AAN=26
    LATER_OF_GELIJK_AAN=27
    EERDER_OF_GELIJK_AAN=28
    WAARBIJ_WORDT_VERDEELD=29
    BESTAANDE_UIT=30
    WEDERKERIG_FEITTYPE=31
    IS_VAN_HET_TYPE=32
    CONCATENATIE_VAN=33
    VOLGEND_CRITERIUM=34
    VOLGENDE_CRITERIA=35
    BIJ_EVEN_GROOT_CRITERIUM=36
    OP_VOLGORDE_VAN=37
    NAAR_RATO_VAN=38
    NUMERIEK_MET_EXACT=39
    AAN_DE_ELFPROEF=40
    GROTER_IS_DAN=41
    KLEINER_IS_DAN=42
    WORDT_VOLDAAN=43
    ER_WORDT_EEN_NIEUW=44
    WORDT_EEN_NIEUW=45
    AANGEMAAKT=46
    CREEER=47
    NIEUWE=48
    ER_AAN=49
    IS_GELIJK_AAN=50
    IS_ONGELIJK_AAN=51
    IS_KLEINER_DAN=52
    IS_KLEINER_OF_GELIJK_AAN=53
    IS_GROTER_DAN=54
    IS_GROTER_OF_GELIJK_AAN=55
    ZIJN_GELIJK_AAN=56
    ZIJN_ONGELIJK_AAN=57
    ZIJN_GROTER_DAN=58
    ZIJN_GROTER_OF_GELIJK_AAN=59
    ZIJN_KLEINER_DAN=60
    ZIJN_KLEINER_OF_GELIJK_AAN=61
    IS_LATER_DAN=62
    IS_LATER_OF_GELIJK_AAN=63
    IS_EERDER_DAN=64
    IS_EERDER_OF_GELIJK_AAN=65
    ZIJN_LATER_DAN=66
    ZIJN_LATER_OF_GELIJK_AAN=67
    ZIJN_EERDER_DAN=68
    ZIJN_EERDER_OF_GELIJK_AAN=69
    IS_LEEG=70
    IS_GEVULD=71
    ZIJN_LEEG=72
    ZIJN_GEVULD=73
    IS_KENMERK=74
    IS_ROL=75
    ZIJN_KENMERK=76
    ZIJN_ROL=77
    IS_NIET_KENMERK=78
    IS_NIET_ROL=79
    ZIJN_NIET_KENMERK=80
    ZIJN_NIET_ROL=81
    VOLDOET_AAN_DE_ELFPROEF=82
    VOLDOEN_AAN_DE_ELFPROEF=83
    VOLDOET_NIET_AAN_DE_ELFPROEF=84
    VOLDOEN_NIET_AAN_DE_ELFPROEF=85
    IS_NUMERIEK_MET_EXACT=86
    IS_NIET_NUMERIEK_MET_EXACT=87
    ZIJN_NUMERIEK_MET_EXACT=88
    ZIJN_NIET_NUMERIEK_MET_EXACT=89
    IS_EEN_DAGSOORT=90
    ZIJN_EEN_DAGSOORT=91
    IS_GEEN_DAGSOORT=92
    ZIJN_GEEN_DAGSOORT=93
    MOETEN_UNIEK_ZIJN=94
    IS_GEVUURD=95
    IS_INCONSISTENT=96
    CONSISTENTIEREGEL=97
    REGEL=98
    BESLISTABEL=99
    OBJECTTYPE=100
    DOMEIN=101
    LIJST=102
    DIMENSIE=103
    EENHEIDSYSTEEM=104
    PARAMETER=105
    FEITTYPE=106
    DAGSOORT=107
    DAARBIJ_GELDT=108
    GELDIG=109
    HEBBEN=110
    HEEFT=111
    INDIEN=112
    IS=113
    MOET=114
    MOETEN=115
    WORDT_VERDEELD_OVER=116
    ZIJN=117
    AAN=118
    AFGEROND_OP=119
    ALLE=120
    EERDER_DAN=121
    GEDEELD_DOOR=122
    GEDEELD_DOOR_ABS=123
    GELIJK_AAN=124
    GEVULD=125
    GEVUURD=126
    GROTER_DAN=127
    INCONSISTENT=128
    KLEINER_DAN=129
    LATER_DAN=130
    LEEG=131
    MAAL=132
    MIN=133
    NAAR_BENEDEN=134
    NAAR_BOVEN=135
    NIET=136
    ONGELIJK_AAN=137
    PLUS=138
    REKENKUNDIG=139
    RICHTING_NUL=140
    TOT=141
    TOT_DE_MACHT=142
    TOT_EN_MET=143
    UNIEK=144
    VANAF=145
    VERENIGD_MET=146
    VERMINDERD_MET=147
    VOLDOEN=148
    VOLDOET=149
    WEG_VAN_NUL=150
    DE_WORTEL_VAN=151
    TENMINSTE=152
    TEN_MINSTE=153
    TEN_HOOGSTE=154
    PRECIES=155
    VOORWAARDE=156
    VOORWAARDEN=157
    BEZIELD=158
    BEZITTELIJK=159
    BIJVOEGLIJK=160
    BOOLEAN=161
    CIJFERS=162
    DATUM_IN_DAGEN=163
    DECIMALEN=164
    ENUMERATIE=165
    GEDIMENSIONEERD_MET=166
    GEHEEL_GETAL=167
    GETAL=168
    KENMERK=169
    KENMERKEN=170
    MET=171
    MET_EENHEID=172
    MV_START=173
    NEGATIEF=174
    NIET_NEGATIEF=175
    NUMERIEK=176
    PERCENTAGE=177
    POSITIEF=178
    ROL=179
    ROLLEN=180
    TEKST=181
    VOOR_ELK_JAAR=182
    VOOR_ELKE_DAG=183
    VOOR_ELKE_MAAND=184
    AANTAL=185
    EERSTE_VAN=186
    IN_HELE=187
    LAATSTE_VAN=188
    REEKS_VAN_TEKSTEN_EN_WAARDEN=189
    SOM_VAN=190
    TIJDSDUUR_VAN=191
    AFNEMENDE=192
    IN_GELIJKE_DELEN=193
    OVER_VERDELING=194
    TOENEMENDE=195
    DRIE_TELWOORD=196
    EEN_TELWOORD=197
    GEEN_VAN_DE=198
    GEEN=199
    TWEE_TELWOORD=200
    VIER_TELWOORD=201
    ALTIJD=202
    BIJ=203
    DAG=204
    DAT=205
    DE=206
    DD_PUNT=207
    DIE=208
    EEN=209
    EN=210
    HET=211
    HIJ=212
    IN=213
    JAAR=214
    KWARTAAL=215
    MAAND=216
    MILLISECONDE=217
    MINUUT=218
    OF=219
    ONWAAR=220
    OP=221
    OVER=222
    PERIODE=223
    REKENDATUM=224
    REKENJAAR=225
    REGELVERSIE=226
    SECONDE=227
    TM=228
    UIT=229
    UUR=230
    VAN=231
    VOLGENDE_VOORWAARDE=232
    VOLGENDE_VOORWAARDEN=233
    VOLGENDE=234
    VOOR=235
    WAAR=236
    WEEK=237
    ER=238
    METER=239
    KILOGRAM=240
    VOET=241
    POND=242
    MIJL=243
    M=244
    KG=245
    S=246
    FT=247
    LB=248
    MI=249
    EURO_SYMBOL=250
    DOLLAR_SYMBOL=251
    IDENTIFIER=252
    NUMBER=253
    EQUALS=254
    DATE_TIME_LITERAL=255
    PERCENTAGE_LITERAL=256
    STRING_LITERAL=257
    ENUM_LITERAL=258
    LPAREN=259
    RPAREN=260
    LBRACE=261
    RBRACE=262
    COMMA=263
    DOT=264
    COLON=265
    SEMICOLON=266
    SLASH=267
    PERCENT_SIGN=268
    BULLET=269
    ASTERISK=270
    L_ANGLE_QUOTE=271
    R_ANGLE_QUOTE=272
    CARET=273
    DOUBLE_DOT=274
    WS=275
    LINE_COMMENT=276
    MINUS=277

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.13.1")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class RegelSpraakDocumentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOF(self):
            return self.getToken(RegelSpraakParser.EOF, 0)

        def definitie(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.DefinitieContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.DefinitieContext,i)


        def regel(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.RegelContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.RegelContext,i)


        def beslistabel(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.BeslistabelContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.BeslistabelContext,i)


        def consistentieregel(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.ConsistentieregelContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.ConsistentieregelContext,i)


        def eenheidsysteemDefinition(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.EenheidsysteemDefinitionContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.EenheidsysteemDefinitionContext,i)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_regelSpraakDocument

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRegelSpraakDocument" ):
                listener.enterRegelSpraakDocument(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRegelSpraakDocument" ):
                listener.exitRegelSpraakDocument(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRegelSpraakDocument" ):
                return visitor.visitRegelSpraakDocument(self)
            else:
                return visitor.visitChildren(self)




    def regelSpraakDocument(self):

        localctx = RegelSpraakParser.RegelSpraakDocumentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_regelSpraakDocument)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 189
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==31 or ((((_la - 97)) & ~0x3f) == 0 and ((1 << (_la - 97)) & 2015) != 0):
                self.state = 187
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [31, 100, 101, 103, 105, 106, 107]:
                    self.state = 182
                    self.definitie()
                    pass
                elif token in [98]:
                    self.state = 183
                    self.regel()
                    pass
                elif token in [99]:
                    self.state = 184
                    self.beslistabel()
                    pass
                elif token in [97]:
                    self.state = 185
                    self.consistentieregel()
                    pass
                elif token in [104]:
                    self.state = 186
                    self.eenheidsysteemDefinition()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 191
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 192
            self.match(RegelSpraakParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DefinitieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def objectTypeDefinition(self):
            return self.getTypedRuleContext(RegelSpraakParser.ObjectTypeDefinitionContext,0)


        def domeinDefinition(self):
            return self.getTypedRuleContext(RegelSpraakParser.DomeinDefinitionContext,0)


        def parameterDefinition(self):
            return self.getTypedRuleContext(RegelSpraakParser.ParameterDefinitionContext,0)


        def dimensieDefinition(self):
            return self.getTypedRuleContext(RegelSpraakParser.DimensieDefinitionContext,0)


        def feitTypeDefinition(self):
            return self.getTypedRuleContext(RegelSpraakParser.FeitTypeDefinitionContext,0)


        def dagsoortDefinition(self):
            return self.getTypedRuleContext(RegelSpraakParser.DagsoortDefinitionContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_definitie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDefinitie" ):
                listener.enterDefinitie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDefinitie" ):
                listener.exitDefinitie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDefinitie" ):
                return visitor.visitDefinitie(self)
            else:
                return visitor.visitChildren(self)




    def definitie(self):

        localctx = RegelSpraakParser.DefinitieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_definitie)
        try:
            self.state = 200
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [100]:
                self.enterOuterAlt(localctx, 1)
                self.state = 194
                self.objectTypeDefinition()
                pass
            elif token in [101]:
                self.enterOuterAlt(localctx, 2)
                self.state = 195
                self.domeinDefinition()
                pass
            elif token in [105]:
                self.enterOuterAlt(localctx, 3)
                self.state = 196
                self.parameterDefinition()
                pass
            elif token in [103]:
                self.enterOuterAlt(localctx, 4)
                self.state = 197
                self.dimensieDefinition()
                pass
            elif token in [31, 106]:
                self.enterOuterAlt(localctx, 5)
                self.state = 198
                self.feitTypeDefinition()
                pass
            elif token in [107]:
                self.enterOuterAlt(localctx, 6)
                self.state = 199
                self.dagsoortDefinition()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BeslistabelContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BESLISTABEL(self):
            return self.getToken(RegelSpraakParser.BESLISTABEL, 0)

        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def regelVersie(self):
            return self.getTypedRuleContext(RegelSpraakParser.RegelVersieContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_beslistabel

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBeslistabel" ):
                listener.enterBeslistabel(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBeslistabel" ):
                listener.exitBeslistabel(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBeslistabel" ):
                return visitor.visitBeslistabel(self)
            else:
                return visitor.visitChildren(self)




    def beslistabel(self):

        localctx = RegelSpraakParser.BeslistabelContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_beslistabel)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 202
            self.match(RegelSpraakParser.BESLISTABEL)
            self.state = 203
            self.naamwoord()
            self.state = 205
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==109:
                self.state = 204
                self.regelVersie()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IdentifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(RegelSpraakParser.IDENTIFIER, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_identifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIdentifier" ):
                listener.enterIdentifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIdentifier" ):
                listener.exitIdentifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIdentifier" ):
                return visitor.visitIdentifier(self)
            else:
                return visitor.visitChildren(self)




    def identifier(self):

        localctx = RegelSpraakParser.IdentifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_identifier)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 207
            self.match(RegelSpraakParser.IDENTIFIER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IdentifierOrKeywordContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(RegelSpraakParser.IDENTIFIER, 0)

        def DAG(self):
            return self.getToken(RegelSpraakParser.DAG, 0)

        def MAAND(self):
            return self.getToken(RegelSpraakParser.MAAND, 0)

        def JAAR(self):
            return self.getToken(RegelSpraakParser.JAAR, 0)

        def AANTAL(self):
            return self.getToken(RegelSpraakParser.AANTAL, 0)

        def PERIODE(self):
            return self.getToken(RegelSpraakParser.PERIODE, 0)

        def REGEL(self):
            return self.getToken(RegelSpraakParser.REGEL, 0)

        def VOORWAARDE(self):
            return self.getToken(RegelSpraakParser.VOORWAARDE, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_identifierOrKeyword

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIdentifierOrKeyword" ):
                listener.enterIdentifierOrKeyword(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIdentifierOrKeyword" ):
                listener.exitIdentifierOrKeyword(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIdentifierOrKeyword" ):
                return visitor.visitIdentifierOrKeyword(self)
            else:
                return visitor.visitChildren(self)




    def identifierOrKeyword(self):

        localctx = RegelSpraakParser.IdentifierOrKeywordContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_identifierOrKeyword)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 209
            _la = self._input.LA(1)
            if not(_la==98 or _la==156 or ((((_la - 185)) & ~0x3f) == 0 and ((1 << (_la - 185)) & 277562785793) != 0) or _la==252):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NaamPhraseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifierOrKeyword(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.IdentifierOrKeywordContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.IdentifierOrKeywordContext,i)


        def DE(self):
            return self.getToken(RegelSpraakParser.DE, 0)

        def HET(self):
            return self.getToken(RegelSpraakParser.HET, 0)

        def ZIJN(self):
            return self.getToken(RegelSpraakParser.ZIJN, 0)

        def NIEUWE(self):
            return self.getToken(RegelSpraakParser.NIEUWE, 0)

        def MET(self):
            return self.getToken(RegelSpraakParser.MET, 0)

        def NIET(self):
            return self.getToken(RegelSpraakParser.NIET, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_naamPhrase

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNaamPhrase" ):
                listener.enterNaamPhrase(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNaamPhrase" ):
                listener.exitNaamPhrase(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNaamPhrase" ):
                return visitor.visitNaamPhrase(self)
            else:
                return visitor.visitChildren(self)




    def naamPhrase(self):

        localctx = RegelSpraakParser.NaamPhraseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_naamPhrase)
        self._la = 0 # Token type
        try:
            self.state = 259
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,13,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 212
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==117 or _la==206 or _la==211:
                    self.state = 211
                    _la = self._input.LA(1)
                    if not(_la==117 or _la==206 or _la==211):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                self.state = 215 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 214
                        self.identifierOrKeyword()

                    else:
                        raise NoViableAltException(self)
                    self.state = 217 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,5,self._ctx)

                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 220 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 219
                        self.identifierOrKeyword()

                    else:
                        raise NoViableAltException(self)
                    self.state = 222 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,6,self._ctx)

                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 224
                self.match(RegelSpraakParser.NIEUWE)
                self.state = 226 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 225
                        self.identifierOrKeyword()

                    else:
                        raise NoViableAltException(self)
                    self.state = 228 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,7,self._ctx)

                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 230
                self.match(RegelSpraakParser.NIEUWE)
                self.state = 232 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 231
                    self.identifierOrKeyword()
                    self.state = 234 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==98 or _la==156 or ((((_la - 185)) & ~0x3f) == 0 and ((1 << (_la - 185)) & 277562785793) != 0) or _la==252):
                        break

                self.state = 236
                self.match(RegelSpraakParser.MET)
                self.state = 238 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 237
                        self.identifierOrKeyword()

                    else:
                        raise NoViableAltException(self)
                    self.state = 240 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,9,self._ctx)

                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 243 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 242
                    self.identifierOrKeyword()
                    self.state = 245 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==98 or _la==156 or ((((_la - 185)) & ~0x3f) == 0 and ((1 << (_la - 185)) & 277562785793) != 0) or _la==252):
                        break

                self.state = 247
                self.match(RegelSpraakParser.MET)
                self.state = 249 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 248
                        self.identifierOrKeyword()

                    else:
                        raise NoViableAltException(self)
                    self.state = 251 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,11,self._ctx)

                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 253
                self.match(RegelSpraakParser.NIET)
                self.state = 255 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 254
                        self.identifierOrKeyword()

                    else:
                        raise NoViableAltException(self)
                    self.state = 257 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,12,self._ctx)

                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NaamwoordContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def naamPhrase(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.NaamPhraseContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.NaamPhraseContext,i)


        def voorzetsel(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.VoorzetselContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.VoorzetselContext,i)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_naamwoord

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNaamwoord" ):
                listener.enterNaamwoord(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNaamwoord" ):
                listener.exitNaamwoord(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNaamwoord" ):
                return visitor.visitNaamwoord(self)
            else:
                return visitor.visitChildren(self)




    def naamwoord(self):

        localctx = RegelSpraakParser.NaamwoordContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_naamwoord)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 261
            self.naamPhrase()
            self.state = 267
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,14,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 262
                    self.voorzetsel()
                    self.state = 263
                    self.naamPhrase() 
                self.state = 269
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,14,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VoorzetselContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def VAN(self):
            return self.getToken(RegelSpraakParser.VAN, 0)

        def IN(self):
            return self.getToken(RegelSpraakParser.IN, 0)

        def VOOR(self):
            return self.getToken(RegelSpraakParser.VOOR, 0)

        def OVER(self):
            return self.getToken(RegelSpraakParser.OVER, 0)

        def OP(self):
            return self.getToken(RegelSpraakParser.OP, 0)

        def BIJ(self):
            return self.getToken(RegelSpraakParser.BIJ, 0)

        def UIT(self):
            return self.getToken(RegelSpraakParser.UIT, 0)

        def TOT(self):
            return self.getToken(RegelSpraakParser.TOT, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_voorzetsel

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVoorzetsel" ):
                listener.enterVoorzetsel(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVoorzetsel" ):
                listener.exitVoorzetsel(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVoorzetsel" ):
                return visitor.visitVoorzetsel(self)
            else:
                return visitor.visitChildren(self)




    def voorzetsel(self):

        localctx = RegelSpraakParser.VoorzetselContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_voorzetsel)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 270
            _la = self._input.LA(1)
            if not(_la==141 or _la==203 or ((((_la - 213)) & ~0x3f) == 0 and ((1 << (_la - 213)) & 4522753) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DatumLiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DATE_TIME_LITERAL(self):
            return self.getToken(RegelSpraakParser.DATE_TIME_LITERAL, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_datumLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDatumLiteral" ):
                listener.enterDatumLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDatumLiteral" ):
                listener.exitDatumLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDatumLiteral" ):
                return visitor.visitDatumLiteral(self)
            else:
                return visitor.visitChildren(self)




    def datumLiteral(self):

        localctx = RegelSpraakParser.DatumLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_datumLiteral)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 272
            self.match(RegelSpraakParser.DATE_TIME_LITERAL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UnitContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(RegelSpraakParser.IDENTIFIER, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_unit

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnit" ):
                listener.enterUnit(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnit" ):
                listener.exitUnit(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnit" ):
                return visitor.visitUnit(self)
            else:
                return visitor.visitChildren(self)




    def unit(self):

        localctx = RegelSpraakParser.UnitContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_unit)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 274
            self.match(RegelSpraakParser.IDENTIFIER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ObjectTypeDefinitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self._IDENTIFIER = None # Token
            self.plural = list() # of Tokens

        def OBJECTTYPE(self):
            return self.getToken(RegelSpraakParser.OBJECTTYPE, 0)

        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def MV_START(self):
            return self.getToken(RegelSpraakParser.MV_START, 0)

        def RPAREN(self):
            return self.getToken(RegelSpraakParser.RPAREN, 0)

        def BEZIELD(self):
            return self.getToken(RegelSpraakParser.BEZIELD, 0)

        def objectTypeMember(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.ObjectTypeMemberContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.ObjectTypeMemberContext,i)


        def IDENTIFIER(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.IDENTIFIER)
            else:
                return self.getToken(RegelSpraakParser.IDENTIFIER, i)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_objectTypeDefinition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterObjectTypeDefinition" ):
                listener.enterObjectTypeDefinition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitObjectTypeDefinition" ):
                listener.exitObjectTypeDefinition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitObjectTypeDefinition" ):
                return visitor.visitObjectTypeDefinition(self)
            else:
                return visitor.visitChildren(self)




    def objectTypeDefinition(self):

        localctx = RegelSpraakParser.ObjectTypeDefinitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_objectTypeDefinition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 276
            self.match(RegelSpraakParser.OBJECTTYPE)
            self.state = 277
            self.naamwoord()
            self.state = 285
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==173:
                self.state = 278
                self.match(RegelSpraakParser.MV_START)
                self.state = 280 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 279
                    localctx._IDENTIFIER = self.match(RegelSpraakParser.IDENTIFIER)
                    localctx.plural.append(localctx._IDENTIFIER)
                    self.state = 282 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==252):
                        break

                self.state = 284
                self.match(RegelSpraakParser.RPAREN)


            self.state = 288
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==158:
                self.state = 287
                self.match(RegelSpraakParser.BEZIELD)


            self.state = 293
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,18,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 290
                    self.objectTypeMember() 
                self.state = 295
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,18,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ObjectTypeMemberContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SEMICOLON(self):
            return self.getToken(RegelSpraakParser.SEMICOLON, 0)

        def kenmerkSpecificatie(self):
            return self.getTypedRuleContext(RegelSpraakParser.KenmerkSpecificatieContext,0)


        def attribuutSpecificatie(self):
            return self.getTypedRuleContext(RegelSpraakParser.AttribuutSpecificatieContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_objectTypeMember

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterObjectTypeMember" ):
                listener.enterObjectTypeMember(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitObjectTypeMember" ):
                listener.exitObjectTypeMember(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitObjectTypeMember" ):
                return visitor.visitObjectTypeMember(self)
            else:
                return visitor.visitChildren(self)




    def objectTypeMember(self):

        localctx = RegelSpraakParser.ObjectTypeMemberContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_objectTypeMember)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 298
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,19,self._ctx)
            if la_ == 1:
                self.state = 296
                self.kenmerkSpecificatie()
                pass

            elif la_ == 2:
                self.state = 297
                self.attribuutSpecificatie()
                pass


            self.state = 300
            self.match(RegelSpraakParser.SEMICOLON)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class KenmerkSpecificatieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KENMERK(self):
            return self.getToken(RegelSpraakParser.KENMERK, 0)

        def identifier(self):
            return self.getTypedRuleContext(RegelSpraakParser.IdentifierContext,0)


        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def BIJVOEGLIJK(self):
            return self.getToken(RegelSpraakParser.BIJVOEGLIJK, 0)

        def BEZITTELIJK(self):
            return self.getToken(RegelSpraakParser.BEZITTELIJK, 0)

        def IS(self):
            return self.getToken(RegelSpraakParser.IS, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_kenmerkSpecificatie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterKenmerkSpecificatie" ):
                listener.enterKenmerkSpecificatie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitKenmerkSpecificatie" ):
                listener.exitKenmerkSpecificatie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitKenmerkSpecificatie" ):
                return visitor.visitKenmerkSpecificatie(self)
            else:
                return visitor.visitChildren(self)




    def kenmerkSpecificatie(self):

        localctx = RegelSpraakParser.KenmerkSpecificatieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_kenmerkSpecificatie)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 307
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,21,self._ctx)
            if la_ == 1:
                self.state = 303
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==113:
                    self.state = 302
                    self.match(RegelSpraakParser.IS)


                self.state = 305
                self.identifier()
                pass

            elif la_ == 2:
                self.state = 306
                self.naamwoord()
                pass


            self.state = 309
            self.match(RegelSpraakParser.KENMERK)
            self.state = 311
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==159 or _la==160:
                self.state = 310
                _la = self._input.LA(1)
                if not(_la==159 or _la==160):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AttribuutSpecificatieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.unitName = None # Token

        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def datatype(self):
            return self.getTypedRuleContext(RegelSpraakParser.DatatypeContext,0)


        def domeinRef(self):
            return self.getTypedRuleContext(RegelSpraakParser.DomeinRefContext,0)


        def MET_EENHEID(self):
            return self.getToken(RegelSpraakParser.MET_EENHEID, 0)

        def GEDIMENSIONEERD_MET(self):
            return self.getToken(RegelSpraakParser.GEDIMENSIONEERD_MET, 0)

        def dimensieRef(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.DimensieRefContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.DimensieRefContext,i)


        def tijdlijn(self):
            return self.getTypedRuleContext(RegelSpraakParser.TijdlijnContext,0)


        def PERCENT_SIGN(self):
            return self.getToken(RegelSpraakParser.PERCENT_SIGN, 0)

        def EURO_SYMBOL(self):
            return self.getToken(RegelSpraakParser.EURO_SYMBOL, 0)

        def DOLLAR_SYMBOL(self):
            return self.getToken(RegelSpraakParser.DOLLAR_SYMBOL, 0)

        def IDENTIFIER(self):
            return self.getToken(RegelSpraakParser.IDENTIFIER, 0)

        def EN(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.EN)
            else:
                return self.getToken(RegelSpraakParser.EN, i)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_attribuutSpecificatie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAttribuutSpecificatie" ):
                listener.enterAttribuutSpecificatie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAttribuutSpecificatie" ):
                listener.exitAttribuutSpecificatie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAttribuutSpecificatie" ):
                return visitor.visitAttribuutSpecificatie(self)
            else:
                return visitor.visitChildren(self)




    def attribuutSpecificatie(self):

        localctx = RegelSpraakParser.AttribuutSpecificatieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_attribuutSpecificatie)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 313
            self.naamwoord()
            self.state = 316
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [7, 102, 161, 163, 176, 181]:
                self.state = 314
                self.datatype()
                pass
            elif token in [101]:
                self.state = 315
                self.domeinRef()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 325
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==172:
                self.state = 318
                self.match(RegelSpraakParser.MET_EENHEID)
                self.state = 323
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [252]:
                    self.state = 319
                    localctx.unitName = self.match(RegelSpraakParser.IDENTIFIER)
                    pass
                elif token in [268]:
                    self.state = 320
                    self.match(RegelSpraakParser.PERCENT_SIGN)
                    pass
                elif token in [250]:
                    self.state = 321
                    self.match(RegelSpraakParser.EURO_SYMBOL)
                    pass
                elif token in [251]:
                    self.state = 322
                    self.match(RegelSpraakParser.DOLLAR_SYMBOL)
                    pass
                else:
                    raise NoViableAltException(self)



            self.state = 336
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==166:
                self.state = 327
                self.match(RegelSpraakParser.GEDIMENSIONEERD_MET)
                self.state = 328
                self.dimensieRef()
                self.state = 333
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==210:
                    self.state = 329
                    self.match(RegelSpraakParser.EN)
                    self.state = 330
                    self.dimensieRef()
                    self.state = 335
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)



            self.state = 339
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 182)) & ~0x3f) == 0 and ((1 << (_la - 182)) & 7) != 0):
                self.state = 338
                self.tijdlijn()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DatatypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def numeriekDatatype(self):
            return self.getTypedRuleContext(RegelSpraakParser.NumeriekDatatypeContext,0)


        def tekstDatatype(self):
            return self.getTypedRuleContext(RegelSpraakParser.TekstDatatypeContext,0)


        def booleanDatatype(self):
            return self.getTypedRuleContext(RegelSpraakParser.BooleanDatatypeContext,0)


        def datumTijdDatatype(self):
            return self.getTypedRuleContext(RegelSpraakParser.DatumTijdDatatypeContext,0)


        def lijstDatatype(self):
            return self.getTypedRuleContext(RegelSpraakParser.LijstDatatypeContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_datatype

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDatatype" ):
                listener.enterDatatype(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDatatype" ):
                listener.exitDatatype(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDatatype" ):
                return visitor.visitDatatype(self)
            else:
                return visitor.visitChildren(self)




    def datatype(self):

        localctx = RegelSpraakParser.DatatypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_datatype)
        try:
            self.state = 346
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [176]:
                self.enterOuterAlt(localctx, 1)
                self.state = 341
                self.numeriekDatatype()
                pass
            elif token in [181]:
                self.enterOuterAlt(localctx, 2)
                self.state = 342
                self.tekstDatatype()
                pass
            elif token in [161]:
                self.enterOuterAlt(localctx, 3)
                self.state = 343
                self.booleanDatatype()
                pass
            elif token in [7, 163]:
                self.enterOuterAlt(localctx, 4)
                self.state = 344
                self.datumTijdDatatype()
                pass
            elif token in [102]:
                self.enterOuterAlt(localctx, 5)
                self.state = 345
                self.lijstDatatype()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LijstDatatypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LIJST(self):
            return self.getToken(RegelSpraakParser.LIJST, 0)

        def VAN(self):
            return self.getToken(RegelSpraakParser.VAN, 0)

        def datatype(self):
            return self.getTypedRuleContext(RegelSpraakParser.DatatypeContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_lijstDatatype

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLijstDatatype" ):
                listener.enterLijstDatatype(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLijstDatatype" ):
                listener.exitLijstDatatype(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLijstDatatype" ):
                return visitor.visitLijstDatatype(self)
            else:
                return visitor.visitChildren(self)




    def lijstDatatype(self):

        localctx = RegelSpraakParser.LijstDatatypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_lijstDatatype)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 348
            self.match(RegelSpraakParser.LIJST)
            self.state = 349
            self.match(RegelSpraakParser.VAN)
            self.state = 350
            self.datatype()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NumeriekDatatypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NUMERIEK(self):
            return self.getToken(RegelSpraakParser.NUMERIEK, 0)

        def LPAREN(self):
            return self.getToken(RegelSpraakParser.LPAREN, 0)

        def getalSpecificatie(self):
            return self.getTypedRuleContext(RegelSpraakParser.GetalSpecificatieContext,0)


        def RPAREN(self):
            return self.getToken(RegelSpraakParser.RPAREN, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_numeriekDatatype

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumeriekDatatype" ):
                listener.enterNumeriekDatatype(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumeriekDatatype" ):
                listener.exitNumeriekDatatype(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNumeriekDatatype" ):
                return visitor.visitNumeriekDatatype(self)
            else:
                return visitor.visitChildren(self)




    def numeriekDatatype(self):

        localctx = RegelSpraakParser.NumeriekDatatypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_numeriekDatatype)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 352
            self.match(RegelSpraakParser.NUMERIEK)
            self.state = 357
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==259:
                self.state = 353
                self.match(RegelSpraakParser.LPAREN)
                self.state = 354
                self.getalSpecificatie()
                self.state = 355
                self.match(RegelSpraakParser.RPAREN)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TekstDatatypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TEKST(self):
            return self.getToken(RegelSpraakParser.TEKST, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_tekstDatatype

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTekstDatatype" ):
                listener.enterTekstDatatype(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTekstDatatype" ):
                listener.exitTekstDatatype(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTekstDatatype" ):
                return visitor.visitTekstDatatype(self)
            else:
                return visitor.visitChildren(self)




    def tekstDatatype(self):

        localctx = RegelSpraakParser.TekstDatatypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_tekstDatatype)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 359
            self.match(RegelSpraakParser.TEKST)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BooleanDatatypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BOOLEAN(self):
            return self.getToken(RegelSpraakParser.BOOLEAN, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_booleanDatatype

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBooleanDatatype" ):
                listener.enterBooleanDatatype(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBooleanDatatype" ):
                listener.exitBooleanDatatype(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBooleanDatatype" ):
                return visitor.visitBooleanDatatype(self)
            else:
                return visitor.visitChildren(self)




    def booleanDatatype(self):

        localctx = RegelSpraakParser.BooleanDatatypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_booleanDatatype)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 361
            self.match(RegelSpraakParser.BOOLEAN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DatumTijdDatatypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DATUM_IN_DAGEN(self):
            return self.getToken(RegelSpraakParser.DATUM_IN_DAGEN, 0)

        def DATUM_TIJD_MILLIS(self):
            return self.getToken(RegelSpraakParser.DATUM_TIJD_MILLIS, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_datumTijdDatatype

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDatumTijdDatatype" ):
                listener.enterDatumTijdDatatype(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDatumTijdDatatype" ):
                listener.exitDatumTijdDatatype(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDatumTijdDatatype" ):
                return visitor.visitDatumTijdDatatype(self)
            else:
                return visitor.visitChildren(self)




    def datumTijdDatatype(self):

        localctx = RegelSpraakParser.DatumTijdDatatypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_datumTijdDatatype)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 363
            _la = self._input.LA(1)
            if not(_la==7 or _la==163):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GetalSpecificatieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GEHEEL_GETAL(self):
            return self.getToken(RegelSpraakParser.GEHEEL_GETAL, 0)

        def GETAL(self):
            return self.getToken(RegelSpraakParser.GETAL, 0)

        def NEGATIEF(self):
            return self.getToken(RegelSpraakParser.NEGATIEF, 0)

        def NIET_NEGATIEF(self):
            return self.getToken(RegelSpraakParser.NIET_NEGATIEF, 0)

        def POSITIEF(self):
            return self.getToken(RegelSpraakParser.POSITIEF, 0)

        def MET(self):
            return self.getToken(RegelSpraakParser.MET, 0)

        def NUMBER(self):
            return self.getToken(RegelSpraakParser.NUMBER, 0)

        def DECIMALEN(self):
            return self.getToken(RegelSpraakParser.DECIMALEN, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_getalSpecificatie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGetalSpecificatie" ):
                listener.enterGetalSpecificatie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGetalSpecificatie" ):
                listener.exitGetalSpecificatie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGetalSpecificatie" ):
                return visitor.visitGetalSpecificatie(self)
            else:
                return visitor.visitChildren(self)




    def getalSpecificatie(self):

        localctx = RegelSpraakParser.GetalSpecificatieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_getalSpecificatie)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 366
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 174)) & ~0x3f) == 0 and ((1 << (_la - 174)) & 19) != 0):
                self.state = 365
                _la = self._input.LA(1)
                if not(((((_la - 174)) & ~0x3f) == 0 and ((1 << (_la - 174)) & 19) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


            self.state = 374
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,32,self._ctx)
            if la_ == 1:
                self.state = 368
                self.match(RegelSpraakParser.GEHEEL_GETAL)
                pass

            elif la_ == 2:
                self.state = 369
                self.match(RegelSpraakParser.GETAL)
                self.state = 370
                self.match(RegelSpraakParser.MET)
                self.state = 371
                self.match(RegelSpraakParser.NUMBER)
                self.state = 372
                self.match(RegelSpraakParser.DECIMALEN)
                pass

            elif la_ == 3:
                self.state = 373
                self.match(RegelSpraakParser.GETAL)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DomeinDefinitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self._IDENTIFIER = None # Token
            self.name = list() # of Tokens

        def DOMEIN(self):
            return self.getToken(RegelSpraakParser.DOMEIN, 0)

        def IS_VAN_HET_TYPE(self):
            return self.getToken(RegelSpraakParser.IS_VAN_HET_TYPE, 0)

        def domeinType(self):
            return self.getTypedRuleContext(RegelSpraakParser.DomeinTypeContext,0)


        def MET_EENHEID(self):
            return self.getToken(RegelSpraakParser.MET_EENHEID, 0)

        def eenheidExpressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.EenheidExpressieContext,0)


        def SEMICOLON(self):
            return self.getToken(RegelSpraakParser.SEMICOLON, 0)

        def IDENTIFIER(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.IDENTIFIER)
            else:
                return self.getToken(RegelSpraakParser.IDENTIFIER, i)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_domeinDefinition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDomeinDefinition" ):
                listener.enterDomeinDefinition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDomeinDefinition" ):
                listener.exitDomeinDefinition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDomeinDefinition" ):
                return visitor.visitDomeinDefinition(self)
            else:
                return visitor.visitChildren(self)




    def domeinDefinition(self):

        localctx = RegelSpraakParser.DomeinDefinitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_domeinDefinition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 376
            self.match(RegelSpraakParser.DOMEIN)
            self.state = 378 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 377
                localctx._IDENTIFIER = self.match(RegelSpraakParser.IDENTIFIER)
                localctx.name.append(localctx._IDENTIFIER)
                self.state = 380 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==252):
                    break

            self.state = 382
            self.match(RegelSpraakParser.IS_VAN_HET_TYPE)
            self.state = 383
            self.domeinType()
            self.state = 386
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==172:
                self.state = 384
                self.match(RegelSpraakParser.MET_EENHEID)
                self.state = 385
                self.eenheidExpressie()


            self.state = 389
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==266:
                self.state = 388
                self.match(RegelSpraakParser.SEMICOLON)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DomeinTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def enumeratieSpecificatie(self):
            return self.getTypedRuleContext(RegelSpraakParser.EnumeratieSpecificatieContext,0)


        def numeriekDatatype(self):
            return self.getTypedRuleContext(RegelSpraakParser.NumeriekDatatypeContext,0)


        def tekstDatatype(self):
            return self.getTypedRuleContext(RegelSpraakParser.TekstDatatypeContext,0)


        def booleanDatatype(self):
            return self.getTypedRuleContext(RegelSpraakParser.BooleanDatatypeContext,0)


        def datumTijdDatatype(self):
            return self.getTypedRuleContext(RegelSpraakParser.DatumTijdDatatypeContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_domeinType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDomeinType" ):
                listener.enterDomeinType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDomeinType" ):
                listener.exitDomeinType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDomeinType" ):
                return visitor.visitDomeinType(self)
            else:
                return visitor.visitChildren(self)




    def domeinType(self):

        localctx = RegelSpraakParser.DomeinTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_domeinType)
        try:
            self.state = 396
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [165]:
                self.enterOuterAlt(localctx, 1)
                self.state = 391
                self.enumeratieSpecificatie()
                pass
            elif token in [176]:
                self.enterOuterAlt(localctx, 2)
                self.state = 392
                self.numeriekDatatype()
                pass
            elif token in [181]:
                self.enterOuterAlt(localctx, 3)
                self.state = 393
                self.tekstDatatype()
                pass
            elif token in [161]:
                self.enterOuterAlt(localctx, 4)
                self.state = 394
                self.booleanDatatype()
                pass
            elif token in [7, 163]:
                self.enterOuterAlt(localctx, 5)
                self.state = 395
                self.datumTijdDatatype()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EnumeratieSpecificatieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ENUMERATIE(self):
            return self.getToken(RegelSpraakParser.ENUMERATIE, 0)

        def ENUM_LITERAL(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.ENUM_LITERAL)
            else:
                return self.getToken(RegelSpraakParser.ENUM_LITERAL, i)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_enumeratieSpecificatie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEnumeratieSpecificatie" ):
                listener.enterEnumeratieSpecificatie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEnumeratieSpecificatie" ):
                listener.exitEnumeratieSpecificatie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEnumeratieSpecificatie" ):
                return visitor.visitEnumeratieSpecificatie(self)
            else:
                return visitor.visitChildren(self)




    def enumeratieSpecificatie(self):

        localctx = RegelSpraakParser.EnumeratieSpecificatieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_enumeratieSpecificatie)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 398
            self.match(RegelSpraakParser.ENUMERATIE)
            self.state = 400 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 399
                self.match(RegelSpraakParser.ENUM_LITERAL)
                self.state = 402 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==258):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DomeinRefContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.name = None # Token

        def DOMEIN(self):
            return self.getToken(RegelSpraakParser.DOMEIN, 0)

        def IDENTIFIER(self):
            return self.getToken(RegelSpraakParser.IDENTIFIER, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_domeinRef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDomeinRef" ):
                listener.enterDomeinRef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDomeinRef" ):
                listener.exitDomeinRef(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDomeinRef" ):
                return visitor.visitDomeinRef(self)
            else:
                return visitor.visitChildren(self)




    def domeinRef(self):

        localctx = RegelSpraakParser.DomeinRefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_domeinRef)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 404
            self.match(RegelSpraakParser.DOMEIN)
            self.state = 405
            localctx.name = self.match(RegelSpraakParser.IDENTIFIER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EenheidsysteemDefinitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.name = None # IdentifierContext

        def EENHEIDSYSTEEM(self):
            return self.getToken(RegelSpraakParser.EENHEIDSYSTEEM, 0)

        def identifier(self):
            return self.getTypedRuleContext(RegelSpraakParser.IdentifierContext,0)


        def eenheidEntry(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.EenheidEntryContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.EenheidEntryContext,i)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_eenheidsysteemDefinition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEenheidsysteemDefinition" ):
                listener.enterEenheidsysteemDefinition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEenheidsysteemDefinition" ):
                listener.exitEenheidsysteemDefinition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEenheidsysteemDefinition" ):
                return visitor.visitEenheidsysteemDefinition(self)
            else:
                return visitor.visitChildren(self)




    def eenheidsysteemDefinition(self):

        localctx = RegelSpraakParser.EenheidsysteemDefinitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_eenheidsysteemDefinition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 407
            self.match(RegelSpraakParser.EENHEIDSYSTEEM)
            self.state = 408
            localctx.name = self.identifier()
            self.state = 412
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==206:
                self.state = 409
                self.eenheidEntry()
                self.state = 414
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EenheidEntryContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.unitName = None # UnitIdentifierContext
            self.abbrev = None # UnitIdentifierContext
            self.value = None # Token
            self.targetUnit = None # UnitIdentifierContext

        def DE(self):
            return self.getToken(RegelSpraakParser.DE, 0)

        def unitIdentifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.UnitIdentifierContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.UnitIdentifierContext,i)


        def EQUALS(self):
            return self.getToken(RegelSpraakParser.EQUALS, 0)

        def NUMBER(self):
            return self.getToken(RegelSpraakParser.NUMBER, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_eenheidEntry

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEenheidEntry" ):
                listener.enterEenheidEntry(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEenheidEntry" ):
                listener.exitEenheidEntry(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEenheidEntry" ):
                return visitor.visitEenheidEntry(self)
            else:
                return visitor.visitChildren(self)




    def eenheidEntry(self):

        localctx = RegelSpraakParser.EenheidEntryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_eenheidEntry)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 415
            self.match(RegelSpraakParser.DE)
            self.state = 416
            localctx.unitName = self.unitIdentifier()
            self.state = 417
            localctx.abbrev = self.unitIdentifier()
            self.state = 421
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==254:
                self.state = 418
                self.match(RegelSpraakParser.EQUALS)
                self.state = 419
                localctx.value = self.match(RegelSpraakParser.NUMBER)
                self.state = 420
                localctx.targetUnit = self.unitIdentifier()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UnitIdentifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(RegelSpraakParser.IDENTIFIER, 0)

        def METER(self):
            return self.getToken(RegelSpraakParser.METER, 0)

        def KILOGRAM(self):
            return self.getToken(RegelSpraakParser.KILOGRAM, 0)

        def SECONDE(self):
            return self.getToken(RegelSpraakParser.SECONDE, 0)

        def MINUUT(self):
            return self.getToken(RegelSpraakParser.MINUUT, 0)

        def UUR(self):
            return self.getToken(RegelSpraakParser.UUR, 0)

        def VOET(self):
            return self.getToken(RegelSpraakParser.VOET, 0)

        def POND(self):
            return self.getToken(RegelSpraakParser.POND, 0)

        def MIJL(self):
            return self.getToken(RegelSpraakParser.MIJL, 0)

        def M(self):
            return self.getToken(RegelSpraakParser.M, 0)

        def KG(self):
            return self.getToken(RegelSpraakParser.KG, 0)

        def S(self):
            return self.getToken(RegelSpraakParser.S, 0)

        def FT(self):
            return self.getToken(RegelSpraakParser.FT, 0)

        def LB(self):
            return self.getToken(RegelSpraakParser.LB, 0)

        def MIN(self):
            return self.getToken(RegelSpraakParser.MIN, 0)

        def MI(self):
            return self.getToken(RegelSpraakParser.MI, 0)

        def EURO_SYMBOL(self):
            return self.getToken(RegelSpraakParser.EURO_SYMBOL, 0)

        def DOLLAR_SYMBOL(self):
            return self.getToken(RegelSpraakParser.DOLLAR_SYMBOL, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_unitIdentifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnitIdentifier" ):
                listener.enterUnitIdentifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnitIdentifier" ):
                listener.exitUnitIdentifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnitIdentifier" ):
                return visitor.visitUnitIdentifier(self)
            else:
                return visitor.visitChildren(self)




    def unitIdentifier(self):

        localctx = RegelSpraakParser.UnitIdentifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_unitIdentifier)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 423
            _la = self._input.LA(1)
            if not(_la==133 or ((((_la - 218)) & ~0x3f) == 0 and ((1 << (_la - 218)) & 34357645825) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EenheidExpressieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def eenheidMacht(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.EenheidMachtContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.EenheidMachtContext,i)


        def SLASH(self):
            return self.getToken(RegelSpraakParser.SLASH, 0)

        def NUMBER(self):
            return self.getToken(RegelSpraakParser.NUMBER, 0)

        def PERCENT_SIGN(self):
            return self.getToken(RegelSpraakParser.PERCENT_SIGN, 0)

        def EURO_SYMBOL(self):
            return self.getToken(RegelSpraakParser.EURO_SYMBOL, 0)

        def DOLLAR_SYMBOL(self):
            return self.getToken(RegelSpraakParser.DOLLAR_SYMBOL, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_eenheidExpressie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEenheidExpressie" ):
                listener.enterEenheidExpressie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEenheidExpressie" ):
                listener.exitEenheidExpressie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEenheidExpressie" ):
                return visitor.visitEenheidExpressie(self)
            else:
                return visitor.visitChildren(self)




    def eenheidExpressie(self):

        localctx = RegelSpraakParser.EenheidExpressieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_eenheidExpressie)
        self._la = 0 # Token type
        try:
            self.state = 434
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,41,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 425
                self.eenheidMacht()
                self.state = 428
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==267:
                    self.state = 426
                    self.match(RegelSpraakParser.SLASH)
                    self.state = 427
                    self.eenheidMacht()


                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 430
                self.match(RegelSpraakParser.NUMBER)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 431
                self.match(RegelSpraakParser.PERCENT_SIGN)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 432
                self.match(RegelSpraakParser.EURO_SYMBOL)
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 433
                self.match(RegelSpraakParser.DOLLAR_SYMBOL)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EenheidMachtContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def unitIdentifier(self):
            return self.getTypedRuleContext(RegelSpraakParser.UnitIdentifierContext,0)


        def CARET(self):
            return self.getToken(RegelSpraakParser.CARET, 0)

        def NUMBER(self):
            return self.getToken(RegelSpraakParser.NUMBER, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_eenheidMacht

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEenheidMacht" ):
                listener.enterEenheidMacht(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEenheidMacht" ):
                listener.exitEenheidMacht(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEenheidMacht" ):
                return visitor.visitEenheidMacht(self)
            else:
                return visitor.visitChildren(self)




    def eenheidMacht(self):

        localctx = RegelSpraakParser.EenheidMachtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_eenheidMacht)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 436
            self.unitIdentifier()
            self.state = 439
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==273:
                self.state = 437
                self.match(RegelSpraakParser.CARET)
                self.state = 438
                self.match(RegelSpraakParser.NUMBER)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DimensieDefinitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.dimensieNaamMeervoud = None # NaamwoordContext

        def DIMENSIE(self):
            return self.getToken(RegelSpraakParser.DIMENSIE, 0)

        def naamwoord(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.NaamwoordContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,i)


        def BESTAANDE_UIT(self):
            return self.getToken(RegelSpraakParser.BESTAANDE_UIT, 0)

        def voorzetselSpecificatie(self):
            return self.getTypedRuleContext(RegelSpraakParser.VoorzetselSpecificatieContext,0)


        def COMMA(self):
            return self.getToken(RegelSpraakParser.COMMA, 0)

        def labelWaardeSpecificatie(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.LabelWaardeSpecificatieContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.LabelWaardeSpecificatieContext,i)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_dimensieDefinition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDimensieDefinition" ):
                listener.enterDimensieDefinition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDimensieDefinition" ):
                listener.exitDimensieDefinition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDimensieDefinition" ):
                return visitor.visitDimensieDefinition(self)
            else:
                return visitor.visitChildren(self)




    def dimensieDefinition(self):

        localctx = RegelSpraakParser.DimensieDefinitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_dimensieDefinition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 441
            self.match(RegelSpraakParser.DIMENSIE)
            self.state = 442
            self.naamwoord()
            self.state = 444
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==263:
                self.state = 443
                self.match(RegelSpraakParser.COMMA)


            self.state = 446
            self.match(RegelSpraakParser.BESTAANDE_UIT)
            self.state = 447
            localctx.dimensieNaamMeervoud = self.naamwoord()
            self.state = 448
            self.voorzetselSpecificatie()
            self.state = 450 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 449
                self.labelWaardeSpecificatie()
                self.state = 452 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==253):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VoorzetselSpecificatieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.vz = None # VoorzetselContext

        def NA_HET_ATTRIBUUT_MET_VOORZETSEL(self):
            return self.getToken(RegelSpraakParser.NA_HET_ATTRIBUUT_MET_VOORZETSEL, 0)

        def RPAREN(self):
            return self.getToken(RegelSpraakParser.RPAREN, 0)

        def voorzetsel(self):
            return self.getTypedRuleContext(RegelSpraakParser.VoorzetselContext,0)


        def COLON(self):
            return self.getToken(RegelSpraakParser.COLON, 0)

        def VOOR_HET_ATTRIBUUT_ZONDER_VOORZETSEL(self):
            return self.getToken(RegelSpraakParser.VOOR_HET_ATTRIBUUT_ZONDER_VOORZETSEL, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_voorzetselSpecificatie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVoorzetselSpecificatie" ):
                listener.enterVoorzetselSpecificatie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVoorzetselSpecificatie" ):
                listener.exitVoorzetselSpecificatie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVoorzetselSpecificatie" ):
                return visitor.visitVoorzetselSpecificatie(self)
            else:
                return visitor.visitChildren(self)




    def voorzetselSpecificatie(self):

        localctx = RegelSpraakParser.VoorzetselSpecificatieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_voorzetselSpecificatie)
        self._la = 0 # Token type
        try:
            self.state = 461
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [6]:
                self.enterOuterAlt(localctx, 1)
                self.state = 454
                self.match(RegelSpraakParser.NA_HET_ATTRIBUUT_MET_VOORZETSEL)
                self.state = 455
                localctx.vz = self.voorzetsel()
                self.state = 456
                self.match(RegelSpraakParser.RPAREN)
                self.state = 458
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==265:
                    self.state = 457
                    self.match(RegelSpraakParser.COLON)


                pass
            elif token in [5]:
                self.enterOuterAlt(localctx, 2)
                self.state = 460
                self.match(RegelSpraakParser.VOOR_HET_ATTRIBUUT_ZONDER_VOORZETSEL)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LabelWaardeSpecificatieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.dimWaarde = None # IdentifierContext

        def NUMBER(self):
            return self.getToken(RegelSpraakParser.NUMBER, 0)

        def DOT(self):
            return self.getToken(RegelSpraakParser.DOT, 0)

        def identifier(self):
            return self.getTypedRuleContext(RegelSpraakParser.IdentifierContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_labelWaardeSpecificatie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLabelWaardeSpecificatie" ):
                listener.enterLabelWaardeSpecificatie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLabelWaardeSpecificatie" ):
                listener.exitLabelWaardeSpecificatie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLabelWaardeSpecificatie" ):
                return visitor.visitLabelWaardeSpecificatie(self)
            else:
                return visitor.visitChildren(self)




    def labelWaardeSpecificatie(self):

        localctx = RegelSpraakParser.LabelWaardeSpecificatieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_labelWaardeSpecificatie)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 463
            self.match(RegelSpraakParser.NUMBER)
            self.state = 464
            self.match(RegelSpraakParser.DOT)
            self.state = 465
            localctx.dimWaarde = self.identifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TijdlijnContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def VOOR_ELKE_DAG(self):
            return self.getToken(RegelSpraakParser.VOOR_ELKE_DAG, 0)

        def VOOR_ELKE_MAAND(self):
            return self.getToken(RegelSpraakParser.VOOR_ELKE_MAAND, 0)

        def VOOR_ELK_JAAR(self):
            return self.getToken(RegelSpraakParser.VOOR_ELK_JAAR, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_tijdlijn

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTijdlijn" ):
                listener.enterTijdlijn(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTijdlijn" ):
                listener.exitTijdlijn(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTijdlijn" ):
                return visitor.visitTijdlijn(self)
            else:
                return visitor.visitChildren(self)




    def tijdlijn(self):

        localctx = RegelSpraakParser.TijdlijnContext(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_tijdlijn)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 467
            _la = self._input.LA(1)
            if not(((((_la - 182)) & ~0x3f) == 0 and ((1 << (_la - 182)) & 7) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DimensieRefContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.name = None # Token

        def IDENTIFIER(self):
            return self.getToken(RegelSpraakParser.IDENTIFIER, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_dimensieRef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDimensieRef" ):
                listener.enterDimensieRef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDimensieRef" ):
                listener.exitDimensieRef(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDimensieRef" ):
                return visitor.visitDimensieRef(self)
            else:
                return visitor.visitChildren(self)




    def dimensieRef(self):

        localctx = RegelSpraakParser.DimensieRefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_dimensieRef)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 469
            localctx.name = self.match(RegelSpraakParser.IDENTIFIER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParameterDefinitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PARAMETER(self):
            return self.getToken(RegelSpraakParser.PARAMETER, 0)

        def parameterNamePhrase(self):
            return self.getTypedRuleContext(RegelSpraakParser.ParameterNamePhraseContext,0)


        def COLON(self):
            return self.getToken(RegelSpraakParser.COLON, 0)

        def SEMICOLON(self):
            return self.getToken(RegelSpraakParser.SEMICOLON, 0)

        def datatype(self):
            return self.getTypedRuleContext(RegelSpraakParser.DatatypeContext,0)


        def domeinRef(self):
            return self.getTypedRuleContext(RegelSpraakParser.DomeinRefContext,0)


        def MET_EENHEID(self):
            return self.getToken(RegelSpraakParser.MET_EENHEID, 0)

        def eenheidExpressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.EenheidExpressieContext,0)


        def tijdlijn(self):
            return self.getTypedRuleContext(RegelSpraakParser.TijdlijnContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_parameterDefinition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParameterDefinition" ):
                listener.enterParameterDefinition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParameterDefinition" ):
                listener.exitParameterDefinition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParameterDefinition" ):
                return visitor.visitParameterDefinition(self)
            else:
                return visitor.visitChildren(self)




    def parameterDefinition(self):

        localctx = RegelSpraakParser.ParameterDefinitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_parameterDefinition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 471
            self.match(RegelSpraakParser.PARAMETER)
            self.state = 472
            self.parameterNamePhrase()
            self.state = 473
            self.match(RegelSpraakParser.COLON)
            self.state = 476
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [7, 102, 161, 163, 176, 181]:
                self.state = 474
                self.datatype()
                pass
            elif token in [101]:
                self.state = 475
                self.domeinRef()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 480
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==172:
                self.state = 478
                self.match(RegelSpraakParser.MET_EENHEID)
                self.state = 479
                self.eenheidExpressie()


            self.state = 483
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 182)) & ~0x3f) == 0 and ((1 << (_la - 182)) & 7) != 0):
                self.state = 482
                self.tijdlijn()


            self.state = 485
            self.match(RegelSpraakParser.SEMICOLON)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParameterNamePhraseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DE(self):
            return self.getToken(RegelSpraakParser.DE, 0)

        def HET(self):
            return self.getToken(RegelSpraakParser.HET, 0)

        def IDENTIFIER(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.IDENTIFIER)
            else:
                return self.getToken(RegelSpraakParser.IDENTIFIER, i)

        def AANTAL(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.AANTAL)
            else:
                return self.getToken(RegelSpraakParser.AANTAL, i)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_parameterNamePhrase

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParameterNamePhrase" ):
                listener.enterParameterNamePhrase(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParameterNamePhrase" ):
                listener.exitParameterNamePhrase(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParameterNamePhrase" ):
                return visitor.visitParameterNamePhrase(self)
            else:
                return visitor.visitChildren(self)




    def parameterNamePhrase(self):

        localctx = RegelSpraakParser.ParameterNamePhraseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_parameterNamePhrase)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 488
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==206 or _la==211:
                self.state = 487
                _la = self._input.LA(1)
                if not(_la==206 or _la==211):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


            self.state = 491 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 490
                _la = self._input.LA(1)
                if not(_la==185 or _la==252):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 493 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==185 or _la==252):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParameterMetLidwoordContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_parameterMetLidwoord

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParameterMetLidwoord" ):
                listener.enterParameterMetLidwoord(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParameterMetLidwoord" ):
                listener.exitParameterMetLidwoord(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParameterMetLidwoord" ):
                return visitor.visitParameterMetLidwoord(self)
            else:
                return visitor.visitChildren(self)




    def parameterMetLidwoord(self):

        localctx = RegelSpraakParser.ParameterMetLidwoordContext(self, self._ctx, self.state)
        self.enterRule(localctx, 74, self.RULE_parameterMetLidwoord)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 495
            self.naamwoord()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FeitTypeDefinitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.subject = None # NaamwoordContext
            self.object_ = None # NaamwoordContext
            self.description = None # NaamwoordContext

        def rolSpecificatie(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.RolSpecificatieContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.RolSpecificatieContext,i)


        def WEDERKERIG_FEITTYPE(self):
            return self.getToken(RegelSpraakParser.WEDERKERIG_FEITTYPE, 0)

        def FEITTYPE(self):
            return self.getToken(RegelSpraakParser.FEITTYPE, 0)

        def naamwoord(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.NaamwoordContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,i)


        def HEEFT(self):
            return self.getToken(RegelSpraakParser.HEEFT, 0)

        def IS(self):
            return self.getToken(RegelSpraakParser.IS, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_feitTypeDefinition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFeitTypeDefinition" ):
                listener.enterFeitTypeDefinition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFeitTypeDefinition" ):
                listener.exitFeitTypeDefinition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFeitTypeDefinition" ):
                return visitor.visitFeitTypeDefinition(self)
            else:
                return visitor.visitChildren(self)




    def feitTypeDefinition(self):

        localctx = RegelSpraakParser.FeitTypeDefinitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 76, self.RULE_feitTypeDefinition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 497
            _la = self._input.LA(1)
            if not(_la==31 or _la==106):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 498
            localctx.subject = self.naamwoord()
            self.state = 503
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [111]:
                self.state = 499
                self.match(RegelSpraakParser.HEEFT)
                self.state = 500
                localctx.object_ = self.naamwoord()
                pass
            elif token in [113]:
                self.state = 501
                self.match(RegelSpraakParser.IS)
                self.state = 502
                localctx.description = self.naamwoord()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 505
            self.rolSpecificatie()
            self.state = 507 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 506
                self.rolSpecificatie()
                self.state = 509 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==5 or _la==6):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RolSpecificatieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def voorzetselSpecificatie(self):
            return self.getTypedRuleContext(RegelSpraakParser.VoorzetselSpecificatieContext,0)


        def identifier(self):
            return self.getTypedRuleContext(RegelSpraakParser.IdentifierContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_rolSpecificatie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRolSpecificatie" ):
                listener.enterRolSpecificatie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRolSpecificatie" ):
                listener.exitRolSpecificatie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRolSpecificatie" ):
                return visitor.visitRolSpecificatie(self)
            else:
                return visitor.visitChildren(self)




    def rolSpecificatie(self):

        localctx = RegelSpraakParser.RolSpecificatieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 78, self.RULE_rolSpecificatie)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 511
            self.voorzetselSpecificatie()
            self.state = 512
            self.identifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RegelContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def REGEL(self):
            return self.getToken(RegelSpraakParser.REGEL, 0)

        def regelName(self):
            return self.getTypedRuleContext(RegelSpraakParser.RegelNameContext,0)


        def regelVersie(self):
            return self.getTypedRuleContext(RegelSpraakParser.RegelVersieContext,0)


        def resultaatDeel(self):
            return self.getTypedRuleContext(RegelSpraakParser.ResultaatDeelContext,0)


        def NUMBER(self):
            return self.getToken(RegelSpraakParser.NUMBER, 0)

        def voorwaardeDeel(self):
            return self.getTypedRuleContext(RegelSpraakParser.VoorwaardeDeelContext,0)


        def DOT(self):
            return self.getToken(RegelSpraakParser.DOT, 0)

        def variabeleDeel(self):
            return self.getTypedRuleContext(RegelSpraakParser.VariabeleDeelContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_regel

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRegel" ):
                listener.enterRegel(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRegel" ):
                listener.exitRegel(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRegel" ):
                return visitor.visitRegel(self)
            else:
                return visitor.visitChildren(self)




    def regel(self):

        localctx = RegelSpraakParser.RegelContext(self, self._ctx, self.state)
        self.enterRule(localctx, 80, self.RULE_regel)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 514
            self.match(RegelSpraakParser.REGEL)
            self.state = 515
            self.regelName()
            self.state = 517
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==253:
                self.state = 516
                self.match(RegelSpraakParser.NUMBER)


            self.state = 519
            self.regelVersie()
            self.state = 520
            self.resultaatDeel()
            self.state = 526
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [112]:
                self.state = 521
                self.voorwaardeDeel()
                self.state = 523
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==264:
                    self.state = 522
                    self.match(RegelSpraakParser.DOT)


                pass
            elif token in [264]:
                self.state = 525
                self.match(RegelSpraakParser.DOT)
                pass
            elif token in [-1, 31, 97, 98, 99, 100, 101, 103, 104, 105, 106, 107, 108]:
                pass
            else:
                pass
            self.state = 529
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==108:
                self.state = 528
                self.variabeleDeel()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RegelNameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.IDENTIFIER)
            else:
                return self.getToken(RegelSpraakParser.IDENTIFIER, i)

        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def KENMERK(self):
            return self.getToken(RegelSpraakParser.KENMERK, 0)

        def ROL(self):
            return self.getToken(RegelSpraakParser.ROL, 0)

        def NIET(self):
            return self.getToken(RegelSpraakParser.NIET, 0)

        def KENMERKEN(self):
            return self.getToken(RegelSpraakParser.KENMERKEN, 0)

        def ROLLEN(self):
            return self.getToken(RegelSpraakParser.ROLLEN, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_regelName

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRegelName" ):
                listener.enterRegelName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRegelName" ):
                listener.exitRegelName(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRegelName" ):
                return visitor.visitRegelName(self)
            else:
                return visitor.visitChildren(self)




    def regelName(self):

        localctx = RegelSpraakParser.RegelNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 82, self.RULE_regelName)
        self._la = 0 # Token type
        try:
            self.state = 585
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,67,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 532 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 531
                    self.match(RegelSpraakParser.IDENTIFIER)
                    self.state = 534 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==252):
                        break

                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 536
                self.naamwoord()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 538 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 537
                    self.match(RegelSpraakParser.IDENTIFIER)
                    self.state = 540 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==252):
                        break

                self.state = 542
                self.match(RegelSpraakParser.KENMERK)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 544 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 543
                    self.match(RegelSpraakParser.IDENTIFIER)
                    self.state = 546 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==252):
                        break

                self.state = 548
                self.match(RegelSpraakParser.ROL)
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 550 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 549
                    self.match(RegelSpraakParser.IDENTIFIER)
                    self.state = 552 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==252):
                        break

                self.state = 554
                self.match(RegelSpraakParser.NIET)
                self.state = 555
                self.match(RegelSpraakParser.KENMERK)
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 557 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 556
                    self.match(RegelSpraakParser.IDENTIFIER)
                    self.state = 559 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==252):
                        break

                self.state = 561
                self.match(RegelSpraakParser.NIET)
                self.state = 562
                self.match(RegelSpraakParser.ROL)
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 564 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 563
                    self.match(RegelSpraakParser.IDENTIFIER)
                    self.state = 566 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==252):
                        break

                self.state = 568
                self.match(RegelSpraakParser.KENMERKEN)
                self.state = 570 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 569
                    self.match(RegelSpraakParser.IDENTIFIER)
                    self.state = 572 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==252):
                        break

                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 575 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 574
                    self.match(RegelSpraakParser.IDENTIFIER)
                    self.state = 577 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==252):
                        break

                self.state = 579
                self.match(RegelSpraakParser.ROLLEN)
                self.state = 581 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 580
                    self.match(RegelSpraakParser.IDENTIFIER)
                    self.state = 583 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==252):
                        break

                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RegelVersieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GELDIG(self):
            return self.getToken(RegelSpraakParser.GELDIG, 0)

        def versieGeldigheid(self):
            return self.getTypedRuleContext(RegelSpraakParser.VersieGeldigheidContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_regelVersie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRegelVersie" ):
                listener.enterRegelVersie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRegelVersie" ):
                listener.exitRegelVersie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRegelVersie" ):
                return visitor.visitRegelVersie(self)
            else:
                return visitor.visitChildren(self)




    def regelVersie(self):

        localctx = RegelSpraakParser.RegelVersieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 84, self.RULE_regelVersie)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 587
            self.match(RegelSpraakParser.GELDIG)
            self.state = 588
            self.versieGeldigheid()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VersieGeldigheidContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ALTIJD(self):
            return self.getToken(RegelSpraakParser.ALTIJD, 0)

        def VANAF(self):
            return self.getToken(RegelSpraakParser.VANAF, 0)

        def datumLiteral(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.DatumLiteralContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.DatumLiteralContext,i)


        def TM(self):
            return self.getToken(RegelSpraakParser.TM, 0)

        def TOT_EN_MET(self):
            return self.getToken(RegelSpraakParser.TOT_EN_MET, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_versieGeldigheid

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVersieGeldigheid" ):
                listener.enterVersieGeldigheid(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVersieGeldigheid" ):
                listener.exitVersieGeldigheid(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVersieGeldigheid" ):
                return visitor.visitVersieGeldigheid(self)
            else:
                return visitor.visitChildren(self)




    def versieGeldigheid(self):

        localctx = RegelSpraakParser.VersieGeldigheidContext(self, self._ctx, self.state)
        self.enterRule(localctx, 86, self.RULE_versieGeldigheid)
        self._la = 0 # Token type
        try:
            self.state = 597
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [202]:
                self.enterOuterAlt(localctx, 1)
                self.state = 590
                self.match(RegelSpraakParser.ALTIJD)
                pass
            elif token in [145]:
                self.enterOuterAlt(localctx, 2)
                self.state = 591
                self.match(RegelSpraakParser.VANAF)
                self.state = 592
                self.datumLiteral()
                self.state = 595
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==143 or _la==228:
                    self.state = 593
                    _la = self._input.LA(1)
                    if not(_la==143 or _la==228):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()
                    self.state = 594
                    self.datumLiteral()


                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ResultaatDeelContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_resultaatDeel

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class AantalDagenInResultaatContext(ResultaatDeelContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.ResultaatDeelContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def HET_AANTAL_DAGEN_IN(self):
            return self.getToken(RegelSpraakParser.HET_AANTAL_DAGEN_IN, 0)
        def MAAND(self):
            return self.getToken(RegelSpraakParser.MAAND, 0)
        def JAAR(self):
            return self.getToken(RegelSpraakParser.JAAR, 0)
        def WORDT_BEREKEND_ALS(self):
            return self.getToken(RegelSpraakParser.WORDT_BEREKEND_ALS, 0)
        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)

        def WORDT_GESTELD_OP(self):
            return self.getToken(RegelSpraakParser.WORDT_GESTELD_OP, 0)
        def WORDT_GEINITIALISEERD_OP(self):
            return self.getToken(RegelSpraakParser.WORDT_GEINITIALISEERD_OP, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAantalDagenInResultaat" ):
                listener.enterAantalDagenInResultaat(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAantalDagenInResultaat" ):
                listener.exitAantalDagenInResultaat(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAantalDagenInResultaat" ):
                return visitor.visitAantalDagenInResultaat(self)
            else:
                return visitor.visitChildren(self)


    class GelijkstellingResultaatContext(ResultaatDeelContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.ResultaatDeelContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)

        def attribuutReferentie(self):
            return self.getTypedRuleContext(RegelSpraakParser.AttribuutReferentieContext,0)

        def WORDT_BEREKEND_ALS(self):
            return self.getToken(RegelSpraakParser.WORDT_BEREKEND_ALS, 0)
        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)

        def WORDT_GESTELD_OP(self):
            return self.getToken(RegelSpraakParser.WORDT_GESTELD_OP, 0)
        def WORDT_GEINITIALISEERD_OP(self):
            return self.getToken(RegelSpraakParser.WORDT_GEINITIALISEERD_OP, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGelijkstellingResultaat" ):
                listener.enterGelijkstellingResultaat(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGelijkstellingResultaat" ):
                listener.exitGelijkstellingResultaat(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGelijkstellingResultaat" ):
                return visitor.visitGelijkstellingResultaat(self)
            else:
                return visitor.visitChildren(self)


    class CapitalizedGelijkstellingResultaatContext(ResultaatDeelContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.ResultaatDeelContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def WORDT_BEREKEND_ALS(self):
            return self.getToken(RegelSpraakParser.WORDT_BEREKEND_ALS, 0)
        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)

        def WORDT_GESTELD_OP(self):
            return self.getToken(RegelSpraakParser.WORDT_GESTELD_OP, 0)
        def WORDT_GEINITIALISEERD_OP(self):
            return self.getToken(RegelSpraakParser.WORDT_GEINITIALISEERD_OP, 0)
        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.IdentifierContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCapitalizedGelijkstellingResultaat" ):
                listener.enterCapitalizedGelijkstellingResultaat(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCapitalizedGelijkstellingResultaat" ):
                listener.exitCapitalizedGelijkstellingResultaat(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCapitalizedGelijkstellingResultaat" ):
                return visitor.visitCapitalizedGelijkstellingResultaat(self)
            else:
                return visitor.visitChildren(self)


    class SpecialPhraseResultaatContext(ResultaatDeelContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.ResultaatDeelContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def HET_KWARTAAL(self):
            return self.getToken(RegelSpraakParser.HET_KWARTAAL, 0)
        def HET_DEEL_PER_MAAND(self):
            return self.getToken(RegelSpraakParser.HET_DEEL_PER_MAAND, 0)
        def HET_DEEL_PER_JAAR(self):
            return self.getToken(RegelSpraakParser.HET_DEEL_PER_JAAR, 0)
        def WORDT_BEREKEND_ALS(self):
            return self.getToken(RegelSpraakParser.WORDT_BEREKEND_ALS, 0)
        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)

        def WORDT_GESTELD_OP(self):
            return self.getToken(RegelSpraakParser.WORDT_GESTELD_OP, 0)
        def WORDT_GEINITIALISEERD_OP(self):
            return self.getToken(RegelSpraakParser.WORDT_GEINITIALISEERD_OP, 0)
        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.IdentifierContext,i)

        def datumLiteral(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.DatumLiteralContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.DatumLiteralContext,i)

        def DOT(self):
            return self.getToken(RegelSpraakParser.DOT, 0)
        def VANAF(self):
            return self.getToken(RegelSpraakParser.VANAF, 0)
        def VAN(self):
            return self.getToken(RegelSpraakParser.VAN, 0)
        def TOT(self):
            return self.getToken(RegelSpraakParser.TOT, 0)
        def TOT_EN_MET(self):
            return self.getToken(RegelSpraakParser.TOT_EN_MET, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSpecialPhraseResultaat" ):
                listener.enterSpecialPhraseResultaat(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSpecialPhraseResultaat" ):
                listener.exitSpecialPhraseResultaat(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSpecialPhraseResultaat" ):
                return visitor.visitSpecialPhraseResultaat(self)
            else:
                return visitor.visitChildren(self)


    class KenmerkFeitResultaatContext(ResultaatDeelContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.ResultaatDeelContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def onderwerpReferentie(self):
            return self.getTypedRuleContext(RegelSpraakParser.OnderwerpReferentieContext,0)

        def kenmerkNaam(self):
            return self.getTypedRuleContext(RegelSpraakParser.KenmerkNaamContext,0)

        def IS(self):
            return self.getToken(RegelSpraakParser.IS, 0)
        def HEEFT(self):
            return self.getToken(RegelSpraakParser.HEEFT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterKenmerkFeitResultaat" ):
                listener.enterKenmerkFeitResultaat(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitKenmerkFeitResultaat" ):
                listener.exitKenmerkFeitResultaat(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitKenmerkFeitResultaat" ):
                return visitor.visitKenmerkFeitResultaat(self)
            else:
                return visitor.visitChildren(self)


    class ObjectCreatieActieContext(ResultaatDeelContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.ResultaatDeelContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def objectCreatie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ObjectCreatieContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterObjectCreatieActie" ):
                listener.enterObjectCreatieActie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitObjectCreatieActie" ):
                listener.exitObjectCreatieActie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitObjectCreatieActie" ):
                return visitor.visitObjectCreatieActie(self)
            else:
                return visitor.visitChildren(self)


    class FeitCreatieResultaatContext(ResultaatDeelContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.ResultaatDeelContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def onderwerpReferentie(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.OnderwerpReferentieContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.OnderwerpReferentieContext,i)

        def HEEFT(self):
            return self.getToken(RegelSpraakParser.HEEFT, 0)
        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)

        def MET(self):
            return self.getToken(RegelSpraakParser.MET, 0)
        def TOT(self):
            return self.getToken(RegelSpraakParser.TOT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFeitCreatieResultaat" ):
                listener.enterFeitCreatieResultaat(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFeitCreatieResultaat" ):
                listener.exitFeitCreatieResultaat(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFeitCreatieResultaat" ):
                return visitor.visitFeitCreatieResultaat(self)
            else:
                return visitor.visitChildren(self)



    def resultaatDeel(self):

        localctx = RegelSpraakParser.ResultaatDeelContext(self, self._ctx, self.state)
        self.enterRule(localctx, 88, self.RULE_resultaatDeel)
        self._la = 0 # Token type
        try:
            self.state = 670
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,79,self._ctx)
            if la_ == 1:
                localctx = RegelSpraakParser.GelijkstellingResultaatContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 601
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,70,self._ctx)
                if la_ == 1:
                    self.state = 599
                    self.naamwoord()
                    pass

                elif la_ == 2:
                    self.state = 600
                    self.attribuutReferentie()
                    pass


                self.state = 609
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [11]:
                    self.state = 603
                    self.match(RegelSpraakParser.WORDT_BEREKEND_ALS)
                    self.state = 604
                    self.expressie()
                    pass
                elif token in [12]:
                    self.state = 605
                    self.match(RegelSpraakParser.WORDT_GESTELD_OP)
                    self.state = 606
                    self.expressie()
                    pass
                elif token in [13]:
                    self.state = 607
                    self.match(RegelSpraakParser.WORDT_GEINITIALISEERD_OP)
                    self.state = 608
                    self.expressie()
                    pass
                else:
                    raise NoViableAltException(self)

                pass

            elif la_ == 2:
                localctx = RegelSpraakParser.KenmerkFeitResultaatContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 611
                self.onderwerpReferentie()
                self.state = 612
                _la = self._input.LA(1)
                if not(_la==111 or _la==113):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 613
                self.kenmerkNaam()
                pass

            elif la_ == 3:
                localctx = RegelSpraakParser.FeitCreatieResultaatContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 615
                self.onderwerpReferentie()
                self.state = 616
                self.match(RegelSpraakParser.HEEFT)
                self.state = 617
                self.naamwoord()
                self.state = 618
                _la = self._input.LA(1)
                if not(_la==141 or _la==171):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 619
                self.onderwerpReferentie()
                pass

            elif la_ == 4:
                localctx = RegelSpraakParser.CapitalizedGelijkstellingResultaatContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 622 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 621
                    self.identifier()
                    self.state = 624 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==252):
                        break

                self.state = 632
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [11]:
                    self.state = 626
                    self.match(RegelSpraakParser.WORDT_BEREKEND_ALS)
                    self.state = 627
                    self.expressie()
                    pass
                elif token in [12]:
                    self.state = 628
                    self.match(RegelSpraakParser.WORDT_GESTELD_OP)
                    self.state = 629
                    self.expressie()
                    pass
                elif token in [13]:
                    self.state = 630
                    self.match(RegelSpraakParser.WORDT_GEINITIALISEERD_OP)
                    self.state = 631
                    self.expressie()
                    pass
                else:
                    raise NoViableAltException(self)

                pass

            elif la_ == 5:
                localctx = RegelSpraakParser.SpecialPhraseResultaatContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 634
                _la = self._input.LA(1)
                if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 28) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 638
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==252:
                    self.state = 635
                    self.identifier()
                    self.state = 640
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 647
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [11]:
                    self.state = 641
                    self.match(RegelSpraakParser.WORDT_BEREKEND_ALS)
                    self.state = 642
                    self.expressie()
                    pass
                elif token in [12]:
                    self.state = 643
                    self.match(RegelSpraakParser.WORDT_GESTELD_OP)
                    self.state = 644
                    self.expressie()
                    pass
                elif token in [13]:
                    self.state = 645
                    self.match(RegelSpraakParser.WORDT_GEINITIALISEERD_OP)
                    self.state = 646
                    self.expressie()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 654
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==145 or _la==231:
                    self.state = 649
                    _la = self._input.LA(1)
                    if not(_la==145 or _la==231):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()
                    self.state = 650
                    self.datumLiteral()
                    self.state = 651
                    _la = self._input.LA(1)
                    if not(_la==141 or _la==143):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()
                    self.state = 652
                    self.datumLiteral()


                self.state = 657
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,77,self._ctx)
                if la_ == 1:
                    self.state = 656
                    self.match(RegelSpraakParser.DOT)


                pass

            elif la_ == 6:
                localctx = RegelSpraakParser.AantalDagenInResultaatContext(self, localctx)
                self.enterOuterAlt(localctx, 6)
                self.state = 659
                self.match(RegelSpraakParser.HET_AANTAL_DAGEN_IN)
                self.state = 660
                _la = self._input.LA(1)
                if not(_la==214 or _la==216):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 667
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [11]:
                    self.state = 661
                    self.match(RegelSpraakParser.WORDT_BEREKEND_ALS)
                    self.state = 662
                    self.expressie()
                    pass
                elif token in [12]:
                    self.state = 663
                    self.match(RegelSpraakParser.WORDT_GESTELD_OP)
                    self.state = 664
                    self.expressie()
                    pass
                elif token in [13]:
                    self.state = 665
                    self.match(RegelSpraakParser.WORDT_GEINITIALISEERD_OP)
                    self.state = 666
                    self.expressie()
                    pass
                else:
                    raise NoViableAltException(self)

                pass

            elif la_ == 7:
                localctx = RegelSpraakParser.ObjectCreatieActieContext(self, localctx)
                self.enterOuterAlt(localctx, 7)
                self.state = 669
                self.objectCreatie()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ObjectCreatieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.objectType = None # NaamwoordContext

        def ER_WORDT_EEN_NIEUW(self):
            return self.getToken(RegelSpraakParser.ER_WORDT_EEN_NIEUW, 0)

        def AANGEMAAKT(self):
            return self.getToken(RegelSpraakParser.AANGEMAAKT, 0)

        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def objectAttributeInit(self):
            return self.getTypedRuleContext(RegelSpraakParser.ObjectAttributeInitContext,0)


        def DOT(self):
            return self.getToken(RegelSpraakParser.DOT, 0)

        def CREEER(self):
            return self.getToken(RegelSpraakParser.CREEER, 0)

        def EEN(self):
            return self.getToken(RegelSpraakParser.EEN, 0)

        def NIEUWE(self):
            return self.getToken(RegelSpraakParser.NIEUWE, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_objectCreatie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterObjectCreatie" ):
                listener.enterObjectCreatie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitObjectCreatie" ):
                listener.exitObjectCreatie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitObjectCreatie" ):
                return visitor.visitObjectCreatie(self)
            else:
                return visitor.visitChildren(self)




    def objectCreatie(self):

        localctx = RegelSpraakParser.ObjectCreatieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 90, self.RULE_objectCreatie)
        self._la = 0 # Token type
        try:
            self.state = 691
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [44]:
                self.enterOuterAlt(localctx, 1)
                self.state = 672
                self.match(RegelSpraakParser.ER_WORDT_EEN_NIEUW)
                self.state = 673
                localctx.objectType = self.naamwoord()
                self.state = 674
                self.match(RegelSpraakParser.AANGEMAAKT)
                self.state = 676
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==171:
                    self.state = 675
                    self.objectAttributeInit()


                self.state = 679
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,81,self._ctx)
                if la_ == 1:
                    self.state = 678
                    self.match(RegelSpraakParser.DOT)


                pass
            elif token in [47]:
                self.enterOuterAlt(localctx, 2)
                self.state = 681
                self.match(RegelSpraakParser.CREEER)
                self.state = 682
                self.match(RegelSpraakParser.EEN)
                self.state = 683
                self.match(RegelSpraakParser.NIEUWE)
                self.state = 684
                localctx.objectType = self.naamwoord()
                self.state = 686
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==171:
                    self.state = 685
                    self.objectAttributeInit()


                self.state = 689
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,83,self._ctx)
                if la_ == 1:
                    self.state = 688
                    self.match(RegelSpraakParser.DOT)


                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ObjectAttributeInitContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.attribuut = None # NaamwoordContext
            self.waarde = None # ExpressieContext

        def MET(self):
            return self.getToken(RegelSpraakParser.MET, 0)

        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)


        def attributeInitVervolg(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.AttributeInitVervolgContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.AttributeInitVervolgContext,i)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_objectAttributeInit

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterObjectAttributeInit" ):
                listener.enterObjectAttributeInit(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitObjectAttributeInit" ):
                listener.exitObjectAttributeInit(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitObjectAttributeInit" ):
                return visitor.visitObjectAttributeInit(self)
            else:
                return visitor.visitChildren(self)




    def objectAttributeInit(self):

        localctx = RegelSpraakParser.ObjectAttributeInitContext(self, self._ctx, self.state)
        self.enterRule(localctx, 92, self.RULE_objectAttributeInit)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 693
            self.match(RegelSpraakParser.MET)
            self.state = 694
            localctx.attribuut = self.naamwoord()
            self.state = 695
            localctx.waarde = self.expressie()
            self.state = 699
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==210:
                self.state = 696
                self.attributeInitVervolg()
                self.state = 701
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AttributeInitVervolgContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.attribuut = None # NaamwoordContext
            self.waarde = None # ExpressieContext

        def EN(self):
            return self.getToken(RegelSpraakParser.EN, 0)

        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_attributeInitVervolg

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAttributeInitVervolg" ):
                listener.enterAttributeInitVervolg(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAttributeInitVervolg" ):
                listener.exitAttributeInitVervolg(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAttributeInitVervolg" ):
                return visitor.visitAttributeInitVervolg(self)
            else:
                return visitor.visitChildren(self)




    def attributeInitVervolg(self):

        localctx = RegelSpraakParser.AttributeInitVervolgContext(self, self._ctx, self.state)
        self.enterRule(localctx, 94, self.RULE_attributeInitVervolg)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 702
            self.match(RegelSpraakParser.EN)
            self.state = 703
            localctx.attribuut = self.naamwoord()
            self.state = 704
            localctx.waarde = self.expressie()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConsistentieregelContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CONSISTENTIEREGEL(self):
            return self.getToken(RegelSpraakParser.CONSISTENTIEREGEL, 0)

        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def uniekzijnResultaat(self):
            return self.getTypedRuleContext(RegelSpraakParser.UniekzijnResultaatContext,0)


        def inconsistentResultaat(self):
            return self.getTypedRuleContext(RegelSpraakParser.InconsistentResultaatContext,0)


        def voorwaardeDeel(self):
            return self.getTypedRuleContext(RegelSpraakParser.VoorwaardeDeelContext,0)


        def DOT(self):
            return self.getToken(RegelSpraakParser.DOT, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_consistentieregel

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConsistentieregel" ):
                listener.enterConsistentieregel(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConsistentieregel" ):
                listener.exitConsistentieregel(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConsistentieregel" ):
                return visitor.visitConsistentieregel(self)
            else:
                return visitor.visitChildren(self)




    def consistentieregel(self):

        localctx = RegelSpraakParser.ConsistentieregelContext(self, self._ctx, self.state)
        self.enterRule(localctx, 96, self.RULE_consistentieregel)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 706
            self.match(RegelSpraakParser.CONSISTENTIEREGEL)
            self.state = 707
            self.naamwoord()
            self.state = 717
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,88,self._ctx)
            if la_ == 1:
                self.state = 708
                self.uniekzijnResultaat()
                pass

            elif la_ == 2:
                self.state = 709
                self.inconsistentResultaat()
                self.state = 715
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [112]:
                    self.state = 710
                    self.voorwaardeDeel()
                    self.state = 712
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==264:
                        self.state = 711
                        self.match(RegelSpraakParser.DOT)


                    pass
                elif token in [264]:
                    self.state = 714
                    self.match(RegelSpraakParser.DOT)
                    pass
                elif token in [-1, 31, 97, 98, 99, 100, 101, 103, 104, 105, 106, 107]:
                    pass
                else:
                    pass
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UniekzijnResultaatContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def onderwerpReferentie(self):
            return self.getTypedRuleContext(RegelSpraakParser.OnderwerpReferentieContext,0)


        def MOETEN_UNIEK_ZIJN(self):
            return self.getToken(RegelSpraakParser.MOETEN_UNIEK_ZIJN, 0)

        def DOT(self):
            return self.getToken(RegelSpraakParser.DOT, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_uniekzijnResultaat

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUniekzijnResultaat" ):
                listener.enterUniekzijnResultaat(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUniekzijnResultaat" ):
                listener.exitUniekzijnResultaat(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUniekzijnResultaat" ):
                return visitor.visitUniekzijnResultaat(self)
            else:
                return visitor.visitChildren(self)




    def uniekzijnResultaat(self):

        localctx = RegelSpraakParser.UniekzijnResultaatContext(self, self._ctx, self.state)
        self.enterRule(localctx, 98, self.RULE_uniekzijnResultaat)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 719
            self.onderwerpReferentie()
            self.state = 720
            self.match(RegelSpraakParser.MOETEN_UNIEK_ZIJN)
            self.state = 722
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==264:
                self.state = 721
                self.match(RegelSpraakParser.DOT)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InconsistentResultaatContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def IS_INCONSISTENT(self):
            return self.getToken(RegelSpraakParser.IS_INCONSISTENT, 0)

        def DE(self):
            return self.getToken(RegelSpraakParser.DE, 0)

        def HET(self):
            return self.getToken(RegelSpraakParser.HET, 0)

        def ER(self):
            return self.getToken(RegelSpraakParser.ER, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_inconsistentResultaat

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInconsistentResultaat" ):
                listener.enterInconsistentResultaat(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInconsistentResultaat" ):
                listener.exitInconsistentResultaat(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInconsistentResultaat" ):
                return visitor.visitInconsistentResultaat(self)
            else:
                return visitor.visitChildren(self)




    def inconsistentResultaat(self):

        localctx = RegelSpraakParser.InconsistentResultaatContext(self, self._ctx, self.state)
        self.enterRule(localctx, 100, self.RULE_inconsistentResultaat)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 725
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,90,self._ctx)
            if la_ == 1:
                self.state = 724
                _la = self._input.LA(1)
                if not(((((_la - 206)) & ~0x3f) == 0 and ((1 << (_la - 206)) & 4294967329) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


            self.state = 727
            self.naamwoord()
            self.state = 728
            self.match(RegelSpraakParser.IS_INCONSISTENT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VoorwaardeDeelContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INDIEN(self):
            return self.getToken(RegelSpraakParser.INDIEN, 0)

        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)


        def toplevelSamengesteldeVoorwaarde(self):
            return self.getTypedRuleContext(RegelSpraakParser.ToplevelSamengesteldeVoorwaardeContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_voorwaardeDeel

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVoorwaardeDeel" ):
                listener.enterVoorwaardeDeel(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVoorwaardeDeel" ):
                listener.exitVoorwaardeDeel(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVoorwaardeDeel" ):
                return visitor.visitVoorwaardeDeel(self)
            else:
                return visitor.visitChildren(self)




    def voorwaardeDeel(self):

        localctx = RegelSpraakParser.VoorwaardeDeelContext(self, self._ctx, self.state)
        self.enterRule(localctx, 102, self.RULE_voorwaardeDeel)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 730
            self.match(RegelSpraakParser.INDIEN)
            self.state = 733
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,91,self._ctx)
            if la_ == 1:
                self.state = 731
                self.expressie()
                pass

            elif la_ == 2:
                self.state = 732
                self.toplevelSamengesteldeVoorwaarde()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ToplevelSamengesteldeVoorwaardeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ER_AAN(self):
            return self.getToken(RegelSpraakParser.ER_AAN, 0)

        def voorwaardeKwantificatie(self):
            return self.getTypedRuleContext(RegelSpraakParser.VoorwaardeKwantificatieContext,0)


        def WORDT_VOLDAAN(self):
            return self.getToken(RegelSpraakParser.WORDT_VOLDAAN, 0)

        def COLON(self):
            return self.getToken(RegelSpraakParser.COLON, 0)

        def VOLGENDE_VOORWAARDEN(self):
            return self.getToken(RegelSpraakParser.VOLGENDE_VOORWAARDEN, 0)

        def VOLGENDE_VOORWAARDE(self):
            return self.getToken(RegelSpraakParser.VOLGENDE_VOORWAARDE, 0)

        def samengesteldeVoorwaardeOnderdeel(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.SamengesteldeVoorwaardeOnderdeelContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.SamengesteldeVoorwaardeOnderdeelContext,i)


        def AAN(self):
            return self.getToken(RegelSpraakParser.AAN, 0)

        def VOLDOET(self):
            return self.getToken(RegelSpraakParser.VOLDOET, 0)

        def onderwerpReferentie(self):
            return self.getTypedRuleContext(RegelSpraakParser.OnderwerpReferentieContext,0)


        def HIJ(self):
            return self.getToken(RegelSpraakParser.HIJ, 0)

        def HET(self):
            return self.getToken(RegelSpraakParser.HET, 0)

        def ER(self):
            return self.getToken(RegelSpraakParser.ER, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_toplevelSamengesteldeVoorwaarde

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterToplevelSamengesteldeVoorwaarde" ):
                listener.enterToplevelSamengesteldeVoorwaarde(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitToplevelSamengesteldeVoorwaarde" ):
                listener.exitToplevelSamengesteldeVoorwaarde(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitToplevelSamengesteldeVoorwaarde" ):
                return visitor.visitToplevelSamengesteldeVoorwaarde(self)
            else:
                return visitor.visitChildren(self)




    def toplevelSamengesteldeVoorwaarde(self):

        localctx = RegelSpraakParser.ToplevelSamengesteldeVoorwaardeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 104, self.RULE_toplevelSamengesteldeVoorwaarde)
        self._la = 0 # Token type
        try:
            self.state = 777
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,97,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 735
                self.match(RegelSpraakParser.ER_AAN)
                self.state = 736
                self.voorwaardeKwantificatie()
                self.state = 737
                _la = self._input.LA(1)
                if not(_la==232 or _la==233):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 738
                self.match(RegelSpraakParser.WORDT_VOLDAAN)
                self.state = 739
                self.match(RegelSpraakParser.COLON)
                self.state = 741 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 740
                    self.samengesteldeVoorwaardeOnderdeel()
                    self.state = 743 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (((((_la - 269)) & ~0x3f) == 0 and ((1 << (_la - 269)) & 291) != 0)):
                        break

                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 749
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,93,self._ctx)
                if la_ == 1:
                    self.state = 745
                    self.onderwerpReferentie()
                    pass

                elif la_ == 2:
                    self.state = 746
                    self.match(RegelSpraakParser.HIJ)
                    pass

                elif la_ == 3:
                    self.state = 747
                    self.match(RegelSpraakParser.HET)
                    pass

                elif la_ == 4:
                    self.state = 748
                    self.match(RegelSpraakParser.ER)
                    pass


                self.state = 751
                self.match(RegelSpraakParser.AAN)
                self.state = 752
                self.voorwaardeKwantificatie()
                self.state = 753
                _la = self._input.LA(1)
                if not(_la==232 or _la==233):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 754
                self.match(RegelSpraakParser.VOLDOET)
                self.state = 755
                self.match(RegelSpraakParser.COLON)
                self.state = 757 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 756
                    self.samengesteldeVoorwaardeOnderdeel()
                    self.state = 759 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (((((_la - 269)) & ~0x3f) == 0 and ((1 << (_la - 269)) & 291) != 0)):
                        break

                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 765
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,95,self._ctx)
                if la_ == 1:
                    self.state = 761
                    self.onderwerpReferentie()
                    pass

                elif la_ == 2:
                    self.state = 762
                    self.match(RegelSpraakParser.HIJ)
                    pass

                elif la_ == 3:
                    self.state = 763
                    self.match(RegelSpraakParser.HET)
                    pass

                elif la_ == 4:
                    self.state = 764
                    self.match(RegelSpraakParser.ER)
                    pass


                self.state = 767
                self.match(RegelSpraakParser.VOLDOET)
                self.state = 768
                self.match(RegelSpraakParser.AAN)
                self.state = 769
                self.voorwaardeKwantificatie()
                self.state = 770
                _la = self._input.LA(1)
                if not(_la==232 or _la==233):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 771
                self.match(RegelSpraakParser.COLON)
                self.state = 773 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 772
                    self.samengesteldeVoorwaardeOnderdeel()
                    self.state = 775 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (((((_la - 269)) & ~0x3f) == 0 and ((1 << (_la - 269)) & 291) != 0)):
                        break

                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VoorwaardeKwantificatieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ALLE(self):
            return self.getToken(RegelSpraakParser.ALLE, 0)

        def GEEN(self):
            return self.getToken(RegelSpraakParser.GEEN, 0)

        def VAN(self):
            return self.getToken(RegelSpraakParser.VAN, 0)

        def DE(self):
            return self.getToken(RegelSpraakParser.DE, 0)

        def TEN_MINSTE(self):
            return self.getToken(RegelSpraakParser.TEN_MINSTE, 0)

        def TENMINSTE(self):
            return self.getToken(RegelSpraakParser.TENMINSTE, 0)

        def EEN(self):
            return self.getToken(RegelSpraakParser.EEN, 0)

        def EEN_TELWOORD(self):
            return self.getToken(RegelSpraakParser.EEN_TELWOORD, 0)

        def TWEE_TELWOORD(self):
            return self.getToken(RegelSpraakParser.TWEE_TELWOORD, 0)

        def DRIE_TELWOORD(self):
            return self.getToken(RegelSpraakParser.DRIE_TELWOORD, 0)

        def VIER_TELWOORD(self):
            return self.getToken(RegelSpraakParser.VIER_TELWOORD, 0)

        def TEN_HOOGSTE(self):
            return self.getToken(RegelSpraakParser.TEN_HOOGSTE, 0)

        def PRECIES(self):
            return self.getToken(RegelSpraakParser.PRECIES, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_voorwaardeKwantificatie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVoorwaardeKwantificatie" ):
                listener.enterVoorwaardeKwantificatie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVoorwaardeKwantificatie" ):
                listener.exitVoorwaardeKwantificatie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVoorwaardeKwantificatie" ):
                return visitor.visitVoorwaardeKwantificatie(self)
            else:
                return visitor.visitChildren(self)




    def voorwaardeKwantificatie(self):

        localctx = RegelSpraakParser.VoorwaardeKwantificatieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 106, self.RULE_voorwaardeKwantificatie)
        self._la = 0 # Token type
        try:
            self.state = 795
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [120]:
                self.enterOuterAlt(localctx, 1)
                self.state = 779
                self.match(RegelSpraakParser.ALLE)
                pass
            elif token in [199]:
                self.enterOuterAlt(localctx, 2)
                self.state = 780
                self.match(RegelSpraakParser.GEEN)
                self.state = 781
                self.match(RegelSpraakParser.VAN)
                self.state = 782
                self.match(RegelSpraakParser.DE)
                pass
            elif token in [152, 153]:
                self.enterOuterAlt(localctx, 3)
                self.state = 783
                _la = self._input.LA(1)
                if not(_la==152 or _la==153):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 784
                _la = self._input.LA(1)
                if not(((((_la - 196)) & ~0x3f) == 0 and ((1 << (_la - 196)) & 8243) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 785
                self.match(RegelSpraakParser.VAN)
                self.state = 786
                self.match(RegelSpraakParser.DE)
                pass
            elif token in [154]:
                self.enterOuterAlt(localctx, 4)
                self.state = 787
                self.match(RegelSpraakParser.TEN_HOOGSTE)
                self.state = 788
                _la = self._input.LA(1)
                if not(((((_la - 196)) & ~0x3f) == 0 and ((1 << (_la - 196)) & 8243) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 789
                self.match(RegelSpraakParser.VAN)
                self.state = 790
                self.match(RegelSpraakParser.DE)
                pass
            elif token in [155]:
                self.enterOuterAlt(localctx, 5)
                self.state = 791
                self.match(RegelSpraakParser.PRECIES)
                self.state = 792
                _la = self._input.LA(1)
                if not(((((_la - 196)) & ~0x3f) == 0 and ((1 << (_la - 196)) & 8243) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 793
                self.match(RegelSpraakParser.VAN)
                self.state = 794
                self.match(RegelSpraakParser.DE)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SamengesteldeVoorwaardeOnderdeelContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def bulletPrefix(self):
            return self.getTypedRuleContext(RegelSpraakParser.BulletPrefixContext,0)


        def elementaireVoorwaarde(self):
            return self.getTypedRuleContext(RegelSpraakParser.ElementaireVoorwaardeContext,0)


        def genesteSamengesteldeVoorwaarde(self):
            return self.getTypedRuleContext(RegelSpraakParser.GenesteSamengesteldeVoorwaardeContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_samengesteldeVoorwaardeOnderdeel

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSamengesteldeVoorwaardeOnderdeel" ):
                listener.enterSamengesteldeVoorwaardeOnderdeel(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSamengesteldeVoorwaardeOnderdeel" ):
                listener.exitSamengesteldeVoorwaardeOnderdeel(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSamengesteldeVoorwaardeOnderdeel" ):
                return visitor.visitSamengesteldeVoorwaardeOnderdeel(self)
            else:
                return visitor.visitChildren(self)




    def samengesteldeVoorwaardeOnderdeel(self):

        localctx = RegelSpraakParser.SamengesteldeVoorwaardeOnderdeelContext(self, self._ctx, self.state)
        self.enterRule(localctx, 108, self.RULE_samengesteldeVoorwaardeOnderdeel)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 797
            self.bulletPrefix()
            self.state = 800
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,99,self._ctx)
            if la_ == 1:
                self.state = 798
                self.elementaireVoorwaarde()
                pass

            elif la_ == 2:
                self.state = 799
                self.genesteSamengesteldeVoorwaarde()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BulletPrefixContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MINUS(self):
            return self.getToken(RegelSpraakParser.MINUS, 0)

        def DOUBLE_DOT(self):
            return self.getToken(RegelSpraakParser.DOUBLE_DOT, 0)

        def BULLET(self):
            return self.getToken(RegelSpraakParser.BULLET, 0)

        def ASTERISK(self):
            return self.getToken(RegelSpraakParser.ASTERISK, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_bulletPrefix

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBulletPrefix" ):
                listener.enterBulletPrefix(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBulletPrefix" ):
                listener.exitBulletPrefix(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBulletPrefix" ):
                return visitor.visitBulletPrefix(self)
            else:
                return visitor.visitChildren(self)




    def bulletPrefix(self):

        localctx = RegelSpraakParser.BulletPrefixContext(self, self._ctx, self.state)
        self.enterRule(localctx, 110, self.RULE_bulletPrefix)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 802
            _la = self._input.LA(1)
            if not(((((_la - 269)) & ~0x3f) == 0 and ((1 << (_la - 269)) & 291) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ElementaireVoorwaardeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_elementaireVoorwaarde

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterElementaireVoorwaarde" ):
                listener.enterElementaireVoorwaarde(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitElementaireVoorwaarde" ):
                listener.exitElementaireVoorwaarde(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitElementaireVoorwaarde" ):
                return visitor.visitElementaireVoorwaarde(self)
            else:
                return visitor.visitChildren(self)




    def elementaireVoorwaarde(self):

        localctx = RegelSpraakParser.ElementaireVoorwaardeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 112, self.RULE_elementaireVoorwaarde)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 804
            self.expressie()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GenesteSamengesteldeVoorwaardeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def VOLDOET(self):
            return self.getToken(RegelSpraakParser.VOLDOET, 0)

        def AAN(self):
            return self.getToken(RegelSpraakParser.AAN, 0)

        def voorwaardeKwantificatie(self):
            return self.getTypedRuleContext(RegelSpraakParser.VoorwaardeKwantificatieContext,0)


        def COLON(self):
            return self.getToken(RegelSpraakParser.COLON, 0)

        def VOLGENDE_VOORWAARDEN(self):
            return self.getToken(RegelSpraakParser.VOLGENDE_VOORWAARDEN, 0)

        def VOLGENDE_VOORWAARDE(self):
            return self.getToken(RegelSpraakParser.VOLGENDE_VOORWAARDE, 0)

        def onderwerpReferentie(self):
            return self.getTypedRuleContext(RegelSpraakParser.OnderwerpReferentieContext,0)


        def HIJ(self):
            return self.getToken(RegelSpraakParser.HIJ, 0)

        def ER(self):
            return self.getToken(RegelSpraakParser.ER, 0)

        def samengesteldeVoorwaardeOnderdeel(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.SamengesteldeVoorwaardeOnderdeelContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.SamengesteldeVoorwaardeOnderdeelContext,i)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_genesteSamengesteldeVoorwaarde

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGenesteSamengesteldeVoorwaarde" ):
                listener.enterGenesteSamengesteldeVoorwaarde(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGenesteSamengesteldeVoorwaarde" ):
                listener.exitGenesteSamengesteldeVoorwaarde(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGenesteSamengesteldeVoorwaarde" ):
                return visitor.visitGenesteSamengesteldeVoorwaarde(self)
            else:
                return visitor.visitChildren(self)




    def genesteSamengesteldeVoorwaarde(self):

        localctx = RegelSpraakParser.GenesteSamengesteldeVoorwaardeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 114, self.RULE_genesteSamengesteldeVoorwaarde)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 809
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,100,self._ctx)
            if la_ == 1:
                self.state = 806
                self.onderwerpReferentie()
                pass

            elif la_ == 2:
                self.state = 807
                self.match(RegelSpraakParser.HIJ)
                pass

            elif la_ == 3:
                self.state = 808
                self.match(RegelSpraakParser.ER)
                pass


            self.state = 811
            self.match(RegelSpraakParser.VOLDOET)
            self.state = 812
            self.match(RegelSpraakParser.AAN)
            self.state = 813
            self.voorwaardeKwantificatie()
            self.state = 814
            _la = self._input.LA(1)
            if not(_la==232 or _la==233):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 815
            self.match(RegelSpraakParser.COLON)
            self.state = 817 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 816
                    self.samengesteldeVoorwaardeOnderdeel()

                else:
                    raise NoViableAltException(self)
                self.state = 819 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,101,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OnderwerpReferentieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def basisOnderwerp(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.BasisOnderwerpContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.BasisOnderwerpContext,i)


        def voorzetsel(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.VoorzetselContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.VoorzetselContext,i)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_onderwerpReferentie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOnderwerpReferentie" ):
                listener.enterOnderwerpReferentie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOnderwerpReferentie" ):
                listener.exitOnderwerpReferentie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOnderwerpReferentie" ):
                return visitor.visitOnderwerpReferentie(self)
            else:
                return visitor.visitChildren(self)




    def onderwerpReferentie(self):

        localctx = RegelSpraakParser.OnderwerpReferentieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 116, self.RULE_onderwerpReferentie)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 821
            self.basisOnderwerp()
            self.state = 827
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,102,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 822
                    self.voorzetsel()
                    self.state = 823
                    self.basisOnderwerp() 
                self.state = 829
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,102,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BasisOnderwerpContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifierOrKeyword(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.IdentifierOrKeywordContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.IdentifierOrKeywordContext,i)


        def DE(self):
            return self.getToken(RegelSpraakParser.DE, 0)

        def HET(self):
            return self.getToken(RegelSpraakParser.HET, 0)

        def EEN(self):
            return self.getToken(RegelSpraakParser.EEN, 0)

        def ZIJN(self):
            return self.getToken(RegelSpraakParser.ZIJN, 0)

        def ALLE(self):
            return self.getToken(RegelSpraakParser.ALLE, 0)

        def HIJ(self):
            return self.getToken(RegelSpraakParser.HIJ, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_basisOnderwerp

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBasisOnderwerp" ):
                listener.enterBasisOnderwerp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBasisOnderwerp" ):
                listener.exitBasisOnderwerp(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBasisOnderwerp" ):
                return visitor.visitBasisOnderwerp(self)
            else:
                return visitor.visitChildren(self)




    def basisOnderwerp(self):

        localctx = RegelSpraakParser.BasisOnderwerpContext(self, self._ctx, self.state)
        self.enterRule(localctx, 118, self.RULE_basisOnderwerp)
        self._la = 0 # Token type
        try:
            self.state = 839
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [98, 117, 120, 156, 185, 204, 206, 209, 211, 214, 216, 223, 252]:
                self.enterOuterAlt(localctx, 1)
                self.state = 831
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==117 or _la==120 or ((((_la - 206)) & ~0x3f) == 0 and ((1 << (_la - 206)) & 41) != 0):
                    self.state = 830
                    _la = self._input.LA(1)
                    if not(_la==117 or _la==120 or ((((_la - 206)) & ~0x3f) == 0 and ((1 << (_la - 206)) & 41) != 0)):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                self.state = 834 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 833
                        self.identifierOrKeyword()

                    else:
                        raise NoViableAltException(self)
                    self.state = 836 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,104,self._ctx)

                pass
            elif token in [212]:
                self.enterOuterAlt(localctx, 2)
                self.state = 838
                self.match(RegelSpraakParser.HIJ)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AttribuutReferentieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def VAN(self):
            return self.getToken(RegelSpraakParser.VAN, 0)

        def onderwerpReferentie(self):
            return self.getTypedRuleContext(RegelSpraakParser.OnderwerpReferentieContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_attribuutReferentie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAttribuutReferentie" ):
                listener.enterAttribuutReferentie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAttribuutReferentie" ):
                listener.exitAttribuutReferentie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAttribuutReferentie" ):
                return visitor.visitAttribuutReferentie(self)
            else:
                return visitor.visitChildren(self)




    def attribuutReferentie(self):

        localctx = RegelSpraakParser.AttribuutReferentieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 120, self.RULE_attribuutReferentie)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 841
            self.naamwoord()
            self.state = 842
            self.match(RegelSpraakParser.VAN)
            self.state = 843
            self.onderwerpReferentie()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class KenmerkNaamContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def onderwerpReferentie(self):
            return self.getTypedRuleContext(RegelSpraakParser.OnderwerpReferentieContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_kenmerkNaam

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterKenmerkNaam" ):
                listener.enterKenmerkNaam(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitKenmerkNaam" ):
                listener.exitKenmerkNaam(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitKenmerkNaam" ):
                return visitor.visitKenmerkNaam(self)
            else:
                return visitor.visitChildren(self)




    def kenmerkNaam(self):

        localctx = RegelSpraakParser.KenmerkNaamContext(self, self._ctx, self.state)
        self.enterRule(localctx, 122, self.RULE_kenmerkNaam)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 845
            self.onderwerpReferentie()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BezieldeReferentieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ZIJN(self):
            return self.getToken(RegelSpraakParser.ZIJN, 0)

        def identifier(self):
            return self.getTypedRuleContext(RegelSpraakParser.IdentifierContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_bezieldeReferentie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBezieldeReferentie" ):
                listener.enterBezieldeReferentie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBezieldeReferentie" ):
                listener.exitBezieldeReferentie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBezieldeReferentie" ):
                return visitor.visitBezieldeReferentie(self)
            else:
                return visitor.visitChildren(self)




    def bezieldeReferentie(self):

        localctx = RegelSpraakParser.BezieldeReferentieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 124, self.RULE_bezieldeReferentie)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 847
            self.match(RegelSpraakParser.ZIJN)
            self.state = 848
            self.identifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VariabeleDeelContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DAARBIJ_GELDT(self):
            return self.getToken(RegelSpraakParser.DAARBIJ_GELDT, 0)

        def DOT(self):
            return self.getToken(RegelSpraakParser.DOT, 0)

        def variabeleToekenning(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.VariabeleToekenningContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.VariabeleToekenningContext,i)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_variabeleDeel

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVariabeleDeel" ):
                listener.enterVariabeleDeel(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVariabeleDeel" ):
                listener.exitVariabeleDeel(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVariabeleDeel" ):
                return visitor.visitVariabeleDeel(self)
            else:
                return visitor.visitChildren(self)




    def variabeleDeel(self):

        localctx = RegelSpraakParser.VariabeleDeelContext(self, self._ctx, self.state)
        self.enterRule(localctx, 126, self.RULE_variabeleDeel)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 850
            self.match(RegelSpraakParser.DAARBIJ_GELDT)
            self.state = 854
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==48 or ((((_la - 98)) & ~0x3f) == 0 and ((1 << (_la - 98)) & 288230651030142977) != 0) or ((((_la - 185)) & ~0x3f) == 0 and ((1 << (_la - 185)) & 277631991809) != 0) or _la==252:
                self.state = 851
                self.variabeleToekenning()
                self.state = 856
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 857
            self.match(RegelSpraakParser.DOT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VariabeleToekenningContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def IS(self):
            return self.getToken(RegelSpraakParser.IS, 0)

        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)


        def SEMICOLON(self):
            return self.getToken(RegelSpraakParser.SEMICOLON, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_variabeleToekenning

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVariabeleToekenning" ):
                listener.enterVariabeleToekenning(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVariabeleToekenning" ):
                listener.exitVariabeleToekenning(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVariabeleToekenning" ):
                return visitor.visitVariabeleToekenning(self)
            else:
                return visitor.visitChildren(self)




    def variabeleToekenning(self):

        localctx = RegelSpraakParser.VariabeleToekenningContext(self, self._ctx, self.state)
        self.enterRule(localctx, 128, self.RULE_variabeleToekenning)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 859
            self.naamwoord()
            self.state = 860
            self.match(RegelSpraakParser.IS)
            self.state = 861
            self.expressie()
            self.state = 863
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==266:
                self.state = 862
                self.match(RegelSpraakParser.SEMICOLON)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExpressieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def logicalExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.LogicalExpressionContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_expressie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpressie" ):
                listener.enterExpressie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpressie" ):
                listener.exitExpressie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExpressie" ):
                return visitor.visitExpressie(self)
            else:
                return visitor.visitChildren(self)




    def expressie(self):

        localctx = RegelSpraakParser.ExpressieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 130, self.RULE_expressie)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 865
            self.logicalExpression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LogicalExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_logicalExpression

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class LogicalExprContext(LogicalExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.LogicalExpressionContext
            super().__init__(parser)
            self.left = None # ComparisonExpressionContext
            self.op = None # Token
            self.right = None # LogicalExpressionContext
            self.copyFrom(ctx)

        def comparisonExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.ComparisonExpressionContext,0)

        def logicalExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.LogicalExpressionContext,0)

        def EN(self):
            return self.getToken(RegelSpraakParser.EN, 0)
        def OF(self):
            return self.getToken(RegelSpraakParser.OF, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLogicalExpr" ):
                listener.enterLogicalExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLogicalExpr" ):
                listener.exitLogicalExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLogicalExpr" ):
                return visitor.visitLogicalExpr(self)
            else:
                return visitor.visitChildren(self)



    def logicalExpression(self):

        localctx = RegelSpraakParser.LogicalExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 132, self.RULE_logicalExpression)
        self._la = 0 # Token type
        try:
            localctx = RegelSpraakParser.LogicalExprContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 867
            localctx.left = self.comparisonExpression()
            self.state = 870
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,108,self._ctx)
            if la_ == 1:
                self.state = 868
                localctx.op = self._input.LT(1)
                _la = self._input.LA(1)
                if not(_la==210 or _la==219):
                    localctx.op = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 869
                localctx.right = self.logicalExpression()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ComparisonExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_comparisonExpression

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class BinaryComparisonExprContext(ComparisonExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.ComparisonExpressionContext
            super().__init__(parser)
            self.left = None # AdditiveExpressionContext
            self.right = None # AdditiveExpressionContext
            self.copyFrom(ctx)

        def additiveExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.AdditiveExpressionContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.AdditiveExpressionContext,i)

        def comparisonOperator(self):
            return self.getTypedRuleContext(RegelSpraakParser.ComparisonOperatorContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBinaryComparisonExpr" ):
                listener.enterBinaryComparisonExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBinaryComparisonExpr" ):
                listener.exitBinaryComparisonExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBinaryComparisonExpr" ):
                return visitor.visitBinaryComparisonExpr(self)
            else:
                return visitor.visitChildren(self)


    class UnaryConditionExprContext(ComparisonExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.ComparisonExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def unaryCondition(self):
            return self.getTypedRuleContext(RegelSpraakParser.UnaryConditionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnaryConditionExpr" ):
                listener.enterUnaryConditionExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnaryConditionExpr" ):
                listener.exitUnaryConditionExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnaryConditionExpr" ):
                return visitor.visitUnaryConditionExpr(self)
            else:
                return visitor.visitChildren(self)


    class HeeftKenmerkExprContext(ComparisonExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.ComparisonExpressionContext
            super().__init__(parser)
            self.left = None # AdditiveExpressionContext
            self.copyFrom(ctx)

        def HEEFT(self):
            return self.getToken(RegelSpraakParser.HEEFT, 0)
        def identifier(self):
            return self.getTypedRuleContext(RegelSpraakParser.IdentifierContext,0)

        def additiveExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.AdditiveExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterHeeftKenmerkExpr" ):
                listener.enterHeeftKenmerkExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitHeeftKenmerkExpr" ):
                listener.exitHeeftKenmerkExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitHeeftKenmerkExpr" ):
                return visitor.visitHeeftKenmerkExpr(self)
            else:
                return visitor.visitChildren(self)


    class IsKenmerkExprContext(ComparisonExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.ComparisonExpressionContext
            super().__init__(parser)
            self.left = None # AdditiveExpressionContext
            self.copyFrom(ctx)

        def IS(self):
            return self.getToken(RegelSpraakParser.IS, 0)
        def identifier(self):
            return self.getTypedRuleContext(RegelSpraakParser.IdentifierContext,0)

        def additiveExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.AdditiveExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIsKenmerkExpr" ):
                listener.enterIsKenmerkExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIsKenmerkExpr" ):
                listener.exitIsKenmerkExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIsKenmerkExpr" ):
                return visitor.visitIsKenmerkExpr(self)
            else:
                return visitor.visitChildren(self)


    class RegelStatusConditionExprContext(ComparisonExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.ComparisonExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def regelStatusCondition(self):
            return self.getTypedRuleContext(RegelSpraakParser.RegelStatusConditionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRegelStatusConditionExpr" ):
                listener.enterRegelStatusConditionExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRegelStatusConditionExpr" ):
                listener.exitRegelStatusConditionExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRegelStatusConditionExpr" ):
                return visitor.visitRegelStatusConditionExpr(self)
            else:
                return visitor.visitChildren(self)



    def comparisonExpression(self):

        localctx = RegelSpraakParser.ComparisonExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 134, self.RULE_comparisonExpression)
        try:
            self.state = 888
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,110,self._ctx)
            if la_ == 1:
                localctx = RegelSpraakParser.IsKenmerkExprContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 872
                localctx.left = self.additiveExpression()
                self.state = 873
                self.match(RegelSpraakParser.IS)
                self.state = 874
                self.identifier()
                pass

            elif la_ == 2:
                localctx = RegelSpraakParser.HeeftKenmerkExprContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 876
                localctx.left = self.additiveExpression()
                self.state = 877
                self.match(RegelSpraakParser.HEEFT)
                self.state = 878
                self.identifier()
                pass

            elif la_ == 3:
                localctx = RegelSpraakParser.BinaryComparisonExprContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 880
                localctx.left = self.additiveExpression()
                self.state = 884
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,109,self._ctx)
                if la_ == 1:
                    self.state = 881
                    self.comparisonOperator()
                    self.state = 882
                    localctx.right = self.additiveExpression()


                pass

            elif la_ == 4:
                localctx = RegelSpraakParser.UnaryConditionExprContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 886
                self.unaryCondition()
                pass

            elif la_ == 5:
                localctx = RegelSpraakParser.RegelStatusConditionExprContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 887
                self.regelStatusCondition()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ComparisonOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.GELIJK_AAN, 0)

        def ONGELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.ONGELIJK_AAN, 0)

        def GROTER_DAN(self):
            return self.getToken(RegelSpraakParser.GROTER_DAN, 0)

        def GROTER_OF_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.GROTER_OF_GELIJK_AAN, 0)

        def KLEINER_DAN(self):
            return self.getToken(RegelSpraakParser.KLEINER_DAN, 0)

        def KLEINER_OF_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.KLEINER_OF_GELIJK_AAN, 0)

        def KLEINER_IS_DAN(self):
            return self.getToken(RegelSpraakParser.KLEINER_IS_DAN, 0)

        def GROTER_IS_DAN(self):
            return self.getToken(RegelSpraakParser.GROTER_IS_DAN, 0)

        def IS(self):
            return self.getToken(RegelSpraakParser.IS, 0)

        def IN(self):
            return self.getToken(RegelSpraakParser.IN, 0)

        def LATER_DAN(self):
            return self.getToken(RegelSpraakParser.LATER_DAN, 0)

        def LATER_OF_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.LATER_OF_GELIJK_AAN, 0)

        def EERDER_DAN(self):
            return self.getToken(RegelSpraakParser.EERDER_DAN, 0)

        def EERDER_OF_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.EERDER_OF_GELIJK_AAN, 0)

        def NIET(self):
            return self.getToken(RegelSpraakParser.NIET, 0)

        def IS_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.IS_GELIJK_AAN, 0)

        def IS_ONGELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.IS_ONGELIJK_AAN, 0)

        def IS_KLEINER_DAN(self):
            return self.getToken(RegelSpraakParser.IS_KLEINER_DAN, 0)

        def IS_KLEINER_OF_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.IS_KLEINER_OF_GELIJK_AAN, 0)

        def IS_GROTER_DAN(self):
            return self.getToken(RegelSpraakParser.IS_GROTER_DAN, 0)

        def IS_GROTER_OF_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.IS_GROTER_OF_GELIJK_AAN, 0)

        def ZIJN_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.ZIJN_GELIJK_AAN, 0)

        def ZIJN_ONGELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.ZIJN_ONGELIJK_AAN, 0)

        def ZIJN_KLEINER_DAN(self):
            return self.getToken(RegelSpraakParser.ZIJN_KLEINER_DAN, 0)

        def ZIJN_KLEINER_OF_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.ZIJN_KLEINER_OF_GELIJK_AAN, 0)

        def ZIJN_GROTER_DAN(self):
            return self.getToken(RegelSpraakParser.ZIJN_GROTER_DAN, 0)

        def ZIJN_GROTER_OF_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.ZIJN_GROTER_OF_GELIJK_AAN, 0)

        def IS_LATER_DAN(self):
            return self.getToken(RegelSpraakParser.IS_LATER_DAN, 0)

        def IS_LATER_OF_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.IS_LATER_OF_GELIJK_AAN, 0)

        def IS_EERDER_DAN(self):
            return self.getToken(RegelSpraakParser.IS_EERDER_DAN, 0)

        def IS_EERDER_OF_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.IS_EERDER_OF_GELIJK_AAN, 0)

        def ZIJN_LATER_DAN(self):
            return self.getToken(RegelSpraakParser.ZIJN_LATER_DAN, 0)

        def ZIJN_LATER_OF_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.ZIJN_LATER_OF_GELIJK_AAN, 0)

        def ZIJN_EERDER_DAN(self):
            return self.getToken(RegelSpraakParser.ZIJN_EERDER_DAN, 0)

        def ZIJN_EERDER_OF_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.ZIJN_EERDER_OF_GELIJK_AAN, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_comparisonOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterComparisonOperator" ):
                listener.enterComparisonOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitComparisonOperator" ):
                listener.exitComparisonOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitComparisonOperator" ):
                return visitor.visitComparisonOperator(self)
            else:
                return visitor.visitChildren(self)




    def comparisonOperator(self):

        localctx = RegelSpraakParser.ComparisonOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 136, self.RULE_comparisonOperator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 890
            _la = self._input.LA(1)
            if not(((((_la - 25)) & ~0x3f) == 0 and ((1 << (_la - 25)) & 35184338731023) != 0) or ((((_la - 113)) & ~0x3f) == 0 and ((1 << (_la - 113)) & 25381121) != 0) or _la==213):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AdditiveExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.left = None # MultiplicativeExpressionContext
            self.right = None # MultiplicativeExpressionContext

        def multiplicativeExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.MultiplicativeExpressionContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.MultiplicativeExpressionContext,i)


        def additiveOperator(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.AdditiveOperatorContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.AdditiveOperatorContext,i)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_additiveExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAdditiveExpression" ):
                listener.enterAdditiveExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAdditiveExpression" ):
                listener.exitAdditiveExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAdditiveExpression" ):
                return visitor.visitAdditiveExpression(self)
            else:
                return visitor.visitChildren(self)




    def additiveExpression(self):

        localctx = RegelSpraakParser.AdditiveExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 138, self.RULE_additiveExpression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 892
            localctx.left = self.multiplicativeExpression()
            self.state = 898
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,111,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 893
                    self.additiveOperator()
                    self.state = 894
                    localctx.right = self.multiplicativeExpression() 
                self.state = 900
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,111,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AdditiveOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PLUS(self):
            return self.getToken(RegelSpraakParser.PLUS, 0)

        def MIN(self):
            return self.getToken(RegelSpraakParser.MIN, 0)

        def VERMINDERD_MET(self):
            return self.getToken(RegelSpraakParser.VERMINDERD_MET, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_additiveOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAdditiveOperator" ):
                listener.enterAdditiveOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAdditiveOperator" ):
                listener.exitAdditiveOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAdditiveOperator" ):
                return visitor.visitAdditiveOperator(self)
            else:
                return visitor.visitChildren(self)




    def additiveOperator(self):

        localctx = RegelSpraakParser.AdditiveOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 140, self.RULE_additiveOperator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 901
            _la = self._input.LA(1)
            if not(((((_la - 133)) & ~0x3f) == 0 and ((1 << (_la - 133)) & 16417) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MultiplicativeExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.left = None # PowerExpressionContext
            self.right = None # PowerExpressionContext

        def powerExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.PowerExpressionContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.PowerExpressionContext,i)


        def multiplicativeOperator(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.MultiplicativeOperatorContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.MultiplicativeOperatorContext,i)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_multiplicativeExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMultiplicativeExpression" ):
                listener.enterMultiplicativeExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMultiplicativeExpression" ):
                listener.exitMultiplicativeExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMultiplicativeExpression" ):
                return visitor.visitMultiplicativeExpression(self)
            else:
                return visitor.visitChildren(self)




    def multiplicativeExpression(self):

        localctx = RegelSpraakParser.MultiplicativeExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 142, self.RULE_multiplicativeExpression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 903
            localctx.left = self.powerExpression()
            self.state = 909
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,112,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 904
                    self.multiplicativeOperator()
                    self.state = 905
                    localctx.right = self.powerExpression() 
                self.state = 911
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,112,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MultiplicativeOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MAAL(self):
            return self.getToken(RegelSpraakParser.MAAL, 0)

        def GEDEELD_DOOR(self):
            return self.getToken(RegelSpraakParser.GEDEELD_DOOR, 0)

        def GEDEELD_DOOR_ABS(self):
            return self.getToken(RegelSpraakParser.GEDEELD_DOOR_ABS, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_multiplicativeOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMultiplicativeOperator" ):
                listener.enterMultiplicativeOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMultiplicativeOperator" ):
                listener.exitMultiplicativeOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMultiplicativeOperator" ):
                return visitor.visitMultiplicativeOperator(self)
            else:
                return visitor.visitChildren(self)




    def multiplicativeOperator(self):

        localctx = RegelSpraakParser.MultiplicativeOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 144, self.RULE_multiplicativeOperator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 912
            _la = self._input.LA(1)
            if not(((((_la - 122)) & ~0x3f) == 0 and ((1 << (_la - 122)) & 1027) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PowerExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.left = None # PrimaryExpressionContext
            self.right = None # PrimaryExpressionContext

        def primaryExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.PrimaryExpressionContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,i)


        def powerOperator(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.PowerOperatorContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.PowerOperatorContext,i)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_powerExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPowerExpression" ):
                listener.enterPowerExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPowerExpression" ):
                listener.exitPowerExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPowerExpression" ):
                return visitor.visitPowerExpression(self)
            else:
                return visitor.visitChildren(self)




    def powerExpression(self):

        localctx = RegelSpraakParser.PowerExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 146, self.RULE_powerExpression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 914
            localctx.left = self.primaryExpression(0)
            self.state = 920
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,113,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 915
                    self.powerOperator()
                    self.state = 916
                    localctx.right = self.primaryExpression(0) 
                self.state = 922
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,113,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PowerOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TOT_DE_MACHT(self):
            return self.getToken(RegelSpraakParser.TOT_DE_MACHT, 0)

        def CARET(self):
            return self.getToken(RegelSpraakParser.CARET, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_powerOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPowerOperator" ):
                listener.enterPowerOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPowerOperator" ):
                listener.exitPowerOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPowerOperator" ):
                return visitor.visitPowerOperator(self)
            else:
                return visitor.visitChildren(self)




    def powerOperator(self):

        localctx = RegelSpraakParser.PowerOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 148, self.RULE_powerOperator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 923
            _la = self._input.LA(1)
            if not(_la==142 or _la==273):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PrimaryExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_primaryExpression

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)


    class WortelFuncExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def DE_WORTEL_VAN(self):
            return self.getToken(RegelSpraakParser.DE_WORTEL_VAN, 0)
        def primaryExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWortelFuncExpr" ):
                listener.enterWortelFuncExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWortelFuncExpr" ):
                listener.exitWortelFuncExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitWortelFuncExpr" ):
                return visitor.visitWortelFuncExpr(self)
            else:
                return visitor.visitChildren(self)


    class BooleanTrueLiteralExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def WAAR(self):
            return self.getToken(RegelSpraakParser.WAAR, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBooleanTrueLiteralExpr" ):
                listener.enterBooleanTrueLiteralExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBooleanTrueLiteralExpr" ):
                listener.exitBooleanTrueLiteralExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBooleanTrueLiteralExpr" ):
                return visitor.visitBooleanTrueLiteralExpr(self)
            else:
                return visitor.visitChildren(self)


    class DatumMetFuncExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def DE_DATUM_MET(self):
            return self.getToken(RegelSpraakParser.DE_DATUM_MET, 0)
        def LPAREN(self):
            return self.getToken(RegelSpraakParser.LPAREN, 0)
        def primaryExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.PrimaryExpressionContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,i)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.COMMA)
            else:
                return self.getToken(RegelSpraakParser.COMMA, i)
        def RPAREN(self):
            return self.getToken(RegelSpraakParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDatumMetFuncExpr" ):
                listener.enterDatumMetFuncExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDatumMetFuncExpr" ):
                listener.exitDatumMetFuncExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDatumMetFuncExpr" ):
                return visitor.visitDatumMetFuncExpr(self)
            else:
                return visitor.visitChildren(self)


    class StringLiteralExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def STRING_LITERAL(self):
            return self.getToken(RegelSpraakParser.STRING_LITERAL, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStringLiteralExpr" ):
                listener.enterStringLiteralExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStringLiteralExpr" ):
                listener.exitStringLiteralExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStringLiteralExpr" ):
                return visitor.visitStringLiteralExpr(self)
            else:
                return visitor.visitChildren(self)


    class AbsValFuncExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def DE_ABSOLUTE_WAARDE_VAN(self):
            return self.getToken(RegelSpraakParser.DE_ABSOLUTE_WAARDE_VAN, 0)
        def LPAREN(self):
            return self.getToken(RegelSpraakParser.LPAREN, 0)
        def primaryExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,0)

        def RPAREN(self):
            return self.getToken(RegelSpraakParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAbsValFuncExpr" ):
                listener.enterAbsValFuncExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAbsValFuncExpr" ):
                listener.exitAbsValFuncExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAbsValFuncExpr" ):
                return visitor.visitAbsValFuncExpr(self)
            else:
                return visitor.visitChildren(self)


    class MaxValFuncExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def DE_MAXIMALE_WAARDE_VAN(self):
            return self.getToken(RegelSpraakParser.DE_MAXIMALE_WAARDE_VAN, 0)
        def primaryExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.PrimaryExpressionContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,i)

        def EN(self):
            return self.getToken(RegelSpraakParser.EN, 0)
        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.COMMA)
            else:
                return self.getToken(RegelSpraakParser.COMMA, i)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMaxValFuncExpr" ):
                listener.enterMaxValFuncExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMaxValFuncExpr" ):
                listener.exitMaxValFuncExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMaxValFuncExpr" ):
                return visitor.visitMaxValFuncExpr(self)
            else:
                return visitor.visitChildren(self)


    class RekendatumKeywordExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def REKENDATUM(self):
            return self.getToken(RegelSpraakParser.REKENDATUM, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRekendatumKeywordExpr" ):
                listener.enterRekendatumKeywordExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRekendatumKeywordExpr" ):
                listener.exitRekendatumKeywordExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRekendatumKeywordExpr" ):
                return visitor.visitRekendatumKeywordExpr(self)
            else:
                return visitor.visitChildren(self)


    class PercentageFuncExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.p = None # Token
            self.copyFrom(ctx)

        def NUMBER(self):
            return self.getToken(RegelSpraakParser.NUMBER, 0)
        def VAN(self):
            return self.getToken(RegelSpraakParser.VAN, 0)
        def primaryExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,0)

        def PERCENT_SIGN(self):
            return self.getToken(RegelSpraakParser.PERCENT_SIGN, 0)
        def IDENTIFIER(self):
            return self.getToken(RegelSpraakParser.IDENTIFIER, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPercentageFuncExpr" ):
                listener.enterPercentageFuncExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPercentageFuncExpr" ):
                listener.exitPercentageFuncExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPercentageFuncExpr" ):
                return visitor.visitPercentageFuncExpr(self)
            else:
                return visitor.visitChildren(self)


    class EersteDatumFuncExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def EERSTE_VAN(self):
            return self.getToken(RegelSpraakParser.EERSTE_VAN, 0)
        def primaryExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.PrimaryExpressionContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,i)

        def EN(self):
            return self.getToken(RegelSpraakParser.EN, 0)
        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.COMMA)
            else:
                return self.getToken(RegelSpraakParser.COMMA, i)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEersteDatumFuncExpr" ):
                listener.enterEersteDatumFuncExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEersteDatumFuncExpr" ):
                listener.exitEersteDatumFuncExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEersteDatumFuncExpr" ):
                return visitor.visitEersteDatumFuncExpr(self)
            else:
                return visitor.visitChildren(self)


    class PasenFuncExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def DE_EERSTE_PAASDAG_VAN(self):
            return self.getToken(RegelSpraakParser.DE_EERSTE_PAASDAG_VAN, 0)
        def LPAREN(self):
            return self.getToken(RegelSpraakParser.LPAREN, 0)
        def primaryExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,0)

        def RPAREN(self):
            return self.getToken(RegelSpraakParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPasenFuncExpr" ):
                listener.enterPasenFuncExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPasenFuncExpr" ):
                listener.exitPasenFuncExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPasenFuncExpr" ):
                return visitor.visitPasenFuncExpr(self)
            else:
                return visitor.visitChildren(self)


    class EnumLiteralExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ENUM_LITERAL(self):
            return self.getToken(RegelSpraakParser.ENUM_LITERAL, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEnumLiteralExpr" ):
                listener.enterEnumLiteralExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEnumLiteralExpr" ):
                listener.exitEnumLiteralExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEnumLiteralExpr" ):
                return visitor.visitEnumLiteralExpr(self)
            else:
                return visitor.visitChildren(self)


    class NumberLiteralExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def NUMBER(self):
            return self.getToken(RegelSpraakParser.NUMBER, 0)
        def unitIdentifier(self):
            return self.getTypedRuleContext(RegelSpraakParser.UnitIdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumberLiteralExpr" ):
                listener.enterNumberLiteralExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumberLiteralExpr" ):
                listener.exitNumberLiteralExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNumberLiteralExpr" ):
                return visitor.visitNumberLiteralExpr(self)
            else:
                return visitor.visitChildren(self)


    class AbsTijdsduurFuncExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.unitName = None # Token
            self.copyFrom(ctx)

        def DE_ABSOLUTE_TIJDSDUUR_VAN(self):
            return self.getToken(RegelSpraakParser.DE_ABSOLUTE_TIJDSDUUR_VAN, 0)
        def primaryExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.PrimaryExpressionContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,i)

        def TOT(self):
            return self.getToken(RegelSpraakParser.TOT, 0)
        def IN_HELE(self):
            return self.getToken(RegelSpraakParser.IN_HELE, 0)
        def IDENTIFIER(self):
            return self.getToken(RegelSpraakParser.IDENTIFIER, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAbsTijdsduurFuncExpr" ):
                listener.enterAbsTijdsduurFuncExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAbsTijdsduurFuncExpr" ):
                listener.exitAbsTijdsduurFuncExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAbsTijdsduurFuncExpr" ):
                return visitor.visitAbsTijdsduurFuncExpr(self)
            else:
                return visitor.visitChildren(self)


    class MaandUitFuncExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def DE(self):
            return self.getToken(RegelSpraakParser.DE, 0)
        def MAAND(self):
            return self.getToken(RegelSpraakParser.MAAND, 0)
        def UIT(self):
            return self.getToken(RegelSpraakParser.UIT, 0)
        def primaryExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMaandUitFuncExpr" ):
                listener.enterMaandUitFuncExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMaandUitFuncExpr" ):
                listener.exitMaandUitFuncExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMaandUitFuncExpr" ):
                return visitor.visitMaandUitFuncExpr(self)
            else:
                return visitor.visitChildren(self)


    class CapitalizedTotaalVanExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.condition = None # ExpressieContext
            self.copyFrom(ctx)

        def HET_TOTAAL_VAN(self):
            return self.getToken(RegelSpraakParser.HET_TOTAAL_VAN, 0)
        def expressie(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.ExpressieContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,i)

        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.IdentifierContext,i)

        def GEDURENDE_DE_TIJD_DAT(self):
            return self.getToken(RegelSpraakParser.GEDURENDE_DE_TIJD_DAT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCapitalizedTotaalVanExpr" ):
                listener.enterCapitalizedTotaalVanExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCapitalizedTotaalVanExpr" ):
                listener.exitCapitalizedTotaalVanExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCapitalizedTotaalVanExpr" ):
                return visitor.visitCapitalizedTotaalVanExpr(self)
            else:
                return visitor.visitChildren(self)


    class IdentifierExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(RegelSpraakParser.IdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIdentifierExpr" ):
                listener.enterIdentifierExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIdentifierExpr" ):
                listener.exitIdentifierExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIdentifierExpr" ):
                return visitor.visitIdentifierExpr(self)
            else:
                return visitor.visitChildren(self)


    class DatumLiteralExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def datumLiteral(self):
            return self.getTypedRuleContext(RegelSpraakParser.DatumLiteralContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDatumLiteralExpr" ):
                listener.enterDatumLiteralExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDatumLiteralExpr" ):
                listener.exitDatumLiteralExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDatumLiteralExpr" ):
                return visitor.visitDatumLiteralExpr(self)
            else:
                return visitor.visitChildren(self)


    class DimensieAggExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def attribuutReferentie(self):
            return self.getTypedRuleContext(RegelSpraakParser.AttribuutReferentieContext,0)

        def dimensieSelectie(self):
            return self.getTypedRuleContext(RegelSpraakParser.DimensieSelectieContext,0)

        def getalAggregatieFunctie(self):
            return self.getTypedRuleContext(RegelSpraakParser.GetalAggregatieFunctieContext,0)

        def datumAggregatieFunctie(self):
            return self.getTypedRuleContext(RegelSpraakParser.DatumAggregatieFunctieContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDimensieAggExpr" ):
                listener.enterDimensieAggExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDimensieAggExpr" ):
                listener.exitDimensieAggExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDimensieAggExpr" ):
                return visitor.visitDimensieAggExpr(self)
            else:
                return visitor.visitChildren(self)


    class TijdsduurFuncExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.unitName = None # Token
            self.copyFrom(ctx)

        def TIJDSDUUR_VAN(self):
            return self.getToken(RegelSpraakParser.TIJDSDUUR_VAN, 0)
        def primaryExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.PrimaryExpressionContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,i)

        def TOT(self):
            return self.getToken(RegelSpraakParser.TOT, 0)
        def IN_HELE(self):
            return self.getToken(RegelSpraakParser.IN_HELE, 0)
        def IDENTIFIER(self):
            return self.getToken(RegelSpraakParser.IDENTIFIER, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTijdsduurFuncExpr" ):
                listener.enterTijdsduurFuncExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTijdsduurFuncExpr" ):
                listener.exitTijdsduurFuncExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTijdsduurFuncExpr" ):
                return visitor.visitTijdsduurFuncExpr(self)
            else:
                return visitor.visitChildren(self)


    class AantalFuncExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def AANTAL(self):
            return self.getToken(RegelSpraakParser.AANTAL, 0)
        def onderwerpReferentie(self):
            return self.getTypedRuleContext(RegelSpraakParser.OnderwerpReferentieContext,0)

        def HET(self):
            return self.getToken(RegelSpraakParser.HET, 0)
        def ALLE(self):
            return self.getToken(RegelSpraakParser.ALLE, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAantalFuncExpr" ):
                listener.enterAantalFuncExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAantalFuncExpr" ):
                listener.exitAantalFuncExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAantalFuncExpr" ):
                return visitor.visitAantalFuncExpr(self)
            else:
                return visitor.visitChildren(self)


    class UnaryNietExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def NIET(self):
            return self.getToken(RegelSpraakParser.NIET, 0)
        def primaryExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnaryNietExpr" ):
                listener.enterUnaryNietExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnaryNietExpr" ):
                listener.exitUnaryNietExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnaryNietExpr" ):
                return visitor.visitUnaryNietExpr(self)
            else:
                return visitor.visitChildren(self)


    class ConcatenatieExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def CONCATENATIE_VAN(self):
            return self.getToken(RegelSpraakParser.CONCATENATIE_VAN, 0)
        def primaryExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.PrimaryExpressionContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,i)

        def EN(self):
            return self.getToken(RegelSpraakParser.EN, 0)
        def OF(self):
            return self.getToken(RegelSpraakParser.OF, 0)
        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.COMMA)
            else:
                return self.getToken(RegelSpraakParser.COMMA, i)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConcatenatieExpr" ):
                listener.enterConcatenatieExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConcatenatieExpr" ):
                listener.exitConcatenatieExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConcatenatieExpr" ):
                return visitor.visitConcatenatieExpr(self)
            else:
                return visitor.visitChildren(self)


    class OnderwerpRefExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def onderwerpReferentie(self):
            return self.getTypedRuleContext(RegelSpraakParser.OnderwerpReferentieContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOnderwerpRefExpr" ):
                listener.enterOnderwerpRefExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOnderwerpRefExpr" ):
                listener.exitOnderwerpRefExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOnderwerpRefExpr" ):
                return visitor.visitOnderwerpRefExpr(self)
            else:
                return visitor.visitChildren(self)


    class SomFuncExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def SOM_VAN(self):
            return self.getToken(RegelSpraakParser.SOM_VAN, 0)
        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSomFuncExpr" ):
                listener.enterSomFuncExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSomFuncExpr" ):
                listener.exitSomFuncExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSomFuncExpr" ):
                return visitor.visitSomFuncExpr(self)
            else:
                return visitor.visitChildren(self)


    class AttrRefExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def attribuutReferentie(self):
            return self.getTypedRuleContext(RegelSpraakParser.AttribuutReferentieContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAttrRefExpr" ):
                listener.enterAttrRefExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAttrRefExpr" ):
                listener.exitAttrRefExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAttrRefExpr" ):
                return visitor.visitAttrRefExpr(self)
            else:
                return visitor.visitChildren(self)


    class DagUitFuncExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def DE(self):
            return self.getToken(RegelSpraakParser.DE, 0)
        def DAG(self):
            return self.getToken(RegelSpraakParser.DAG, 0)
        def UIT(self):
            return self.getToken(RegelSpraakParser.UIT, 0)
        def primaryExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDagUitFuncExpr" ):
                listener.enterDagUitFuncExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDagUitFuncExpr" ):
                listener.exitDagUitFuncExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDagUitFuncExpr" ):
                return visitor.visitDagUitFuncExpr(self)
            else:
                return visitor.visitChildren(self)


    class SimpleConcatenatieExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def primaryExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.PrimaryExpressionContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,i)

        def EN(self):
            return self.getToken(RegelSpraakParser.EN, 0)
        def OF(self):
            return self.getToken(RegelSpraakParser.OF, 0)
        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.COMMA)
            else:
                return self.getToken(RegelSpraakParser.COMMA, i)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSimpleConcatenatieExpr" ):
                listener.enterSimpleConcatenatieExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSimpleConcatenatieExpr" ):
                listener.exitSimpleConcatenatieExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSimpleConcatenatieExpr" ):
                return visitor.visitSimpleConcatenatieExpr(self)
            else:
                return visitor.visitChildren(self)


    class BegrenzingExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def primaryExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,0)

        def COMMA(self):
            return self.getToken(RegelSpraakParser.COMMA, 0)
        def begrenzing(self):
            return self.getTypedRuleContext(RegelSpraakParser.BegrenzingContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBegrenzingExpr" ):
                listener.enterBegrenzingExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBegrenzingExpr" ):
                listener.exitBegrenzingExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBegrenzingExpr" ):
                return visitor.visitBegrenzingExpr(self)
            else:
                return visitor.visitChildren(self)


    class NaamwoordExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNaamwoordExpr" ):
                listener.enterNaamwoordExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNaamwoordExpr" ):
                listener.exitNaamwoordExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNaamwoordExpr" ):
                return visitor.visitNaamwoordExpr(self)
            else:
                return visitor.visitChildren(self)


    class BooleanFalseLiteralExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ONWAAR(self):
            return self.getToken(RegelSpraakParser.ONWAAR, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBooleanFalseLiteralExpr" ):
                listener.enterBooleanFalseLiteralExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBooleanFalseLiteralExpr" ):
                listener.exitBooleanFalseLiteralExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBooleanFalseLiteralExpr" ):
                return visitor.visitBooleanFalseLiteralExpr(self)
            else:
                return visitor.visitChildren(self)


    class MinValFuncExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def DE_MINIMALE_WAARDE_VAN(self):
            return self.getToken(RegelSpraakParser.DE_MINIMALE_WAARDE_VAN, 0)
        def primaryExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.PrimaryExpressionContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,i)

        def EN(self):
            return self.getToken(RegelSpraakParser.EN, 0)
        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.COMMA)
            else:
                return self.getToken(RegelSpraakParser.COMMA, i)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMinValFuncExpr" ):
                listener.enterMinValFuncExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMinValFuncExpr" ):
                listener.exitMinValFuncExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMinValFuncExpr" ):
                return visitor.visitMinValFuncExpr(self)
            else:
                return visitor.visitChildren(self)


    class JaarUitFuncExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def HET(self):
            return self.getToken(RegelSpraakParser.HET, 0)
        def JAAR(self):
            return self.getToken(RegelSpraakParser.JAAR, 0)
        def UIT(self):
            return self.getToken(RegelSpraakParser.UIT, 0)
        def primaryExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterJaarUitFuncExpr" ):
                listener.enterJaarUitFuncExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitJaarUitFuncExpr" ):
                listener.exitJaarUitFuncExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitJaarUitFuncExpr" ):
                return visitor.visitJaarUitFuncExpr(self)
            else:
                return visitor.visitChildren(self)


    class BezieldeRefExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def bezieldeReferentie(self):
            return self.getTypedRuleContext(RegelSpraakParser.BezieldeReferentieContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBezieldeRefExpr" ):
                listener.enterBezieldeRefExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBezieldeRefExpr" ):
                listener.exitBezieldeRefExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBezieldeRefExpr" ):
                return visitor.visitBezieldeRefExpr(self)
            else:
                return visitor.visitChildren(self)


    class DateCalcExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def primaryExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.PrimaryExpressionContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,i)

        def identifier(self):
            return self.getTypedRuleContext(RegelSpraakParser.IdentifierContext,0)

        def PLUS(self):
            return self.getToken(RegelSpraakParser.PLUS, 0)
        def MIN(self):
            return self.getToken(RegelSpraakParser.MIN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDateCalcExpr" ):
                listener.enterDateCalcExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDateCalcExpr" ):
                listener.exitDateCalcExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDateCalcExpr" ):
                return visitor.visitDateCalcExpr(self)
            else:
                return visitor.visitChildren(self)


    class TotaalVanExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.condition = None # ExpressieContext
            self.copyFrom(ctx)

        def HET_TOTAAL_VAN(self):
            return self.getToken(RegelSpraakParser.HET_TOTAAL_VAN, 0)
        def expressie(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.ExpressieContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,i)

        def GEDURENDE_DE_TIJD_DAT(self):
            return self.getToken(RegelSpraakParser.GEDURENDE_DE_TIJD_DAT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTotaalVanExpr" ):
                listener.enterTotaalVanExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTotaalVanExpr" ):
                listener.exitTotaalVanExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTotaalVanExpr" ):
                return visitor.visitTotaalVanExpr(self)
            else:
                return visitor.visitChildren(self)


    class AfrondingExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def primaryExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,0)

        def afronding(self):
            return self.getTypedRuleContext(RegelSpraakParser.AfrondingContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAfrondingExpr" ):
                listener.enterAfrondingExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAfrondingExpr" ):
                listener.exitAfrondingExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAfrondingExpr" ):
                return visitor.visitAfrondingExpr(self)
            else:
                return visitor.visitChildren(self)


    class LaatsteDatumFuncExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LAATSTE_VAN(self):
            return self.getToken(RegelSpraakParser.LAATSTE_VAN, 0)
        def primaryExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.PrimaryExpressionContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,i)

        def EN(self):
            return self.getToken(RegelSpraakParser.EN, 0)
        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.COMMA)
            else:
                return self.getToken(RegelSpraakParser.COMMA, i)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLaatsteDatumFuncExpr" ):
                listener.enterLaatsteDatumFuncExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLaatsteDatumFuncExpr" ):
                listener.exitLaatsteDatumFuncExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLaatsteDatumFuncExpr" ):
                return visitor.visitLaatsteDatumFuncExpr(self)
            else:
                return visitor.visitChildren(self)


    class HetAantalDagenInExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def HET_AANTAL_DAGEN_IN(self):
            return self.getToken(RegelSpraakParser.HET_AANTAL_DAGEN_IN, 0)
        def DAT(self):
            return self.getToken(RegelSpraakParser.DAT, 0)
        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)

        def DE(self):
            return self.getToken(RegelSpraakParser.DE, 0)
        def MAAND(self):
            return self.getToken(RegelSpraakParser.MAAND, 0)
        def HET(self):
            return self.getToken(RegelSpraakParser.HET, 0)
        def JAAR(self):
            return self.getToken(RegelSpraakParser.JAAR, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterHetAantalDagenInExpr" ):
                listener.enterHetAantalDagenInExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitHetAantalDagenInExpr" ):
                listener.exitHetAantalDagenInExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitHetAantalDagenInExpr" ):
                return visitor.visitHetAantalDagenInExpr(self)
            else:
                return visitor.visitChildren(self)


    class TijdsevenredigDeelExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.condition = None # ExpressieContext
            self.copyFrom(ctx)

        def HET_TIJDSEVENREDIG_DEEL_PER(self):
            return self.getToken(RegelSpraakParser.HET_TIJDSEVENREDIG_DEEL_PER, 0)
        def VAN(self):
            return self.getToken(RegelSpraakParser.VAN, 0)
        def expressie(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.ExpressieContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,i)

        def MAAND(self):
            return self.getToken(RegelSpraakParser.MAAND, 0)
        def JAAR(self):
            return self.getToken(RegelSpraakParser.JAAR, 0)
        def GEDURENDE_DE_TIJD_DAT(self):
            return self.getToken(RegelSpraakParser.GEDURENDE_DE_TIJD_DAT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTijdsevenredigDeelExpr" ):
                listener.enterTijdsevenredigDeelExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTijdsevenredigDeelExpr" ):
                listener.exitTijdsevenredigDeelExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTijdsevenredigDeelExpr" ):
                return visitor.visitTijdsevenredigDeelExpr(self)
            else:
                return visitor.visitChildren(self)


    class CapitalizedTijdsevenredigDeelExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.condition = None # ExpressieContext
            self.copyFrom(ctx)

        def HET_TIJDSEVENREDIG_DEEL_PER(self):
            return self.getToken(RegelSpraakParser.HET_TIJDSEVENREDIG_DEEL_PER, 0)
        def VAN(self):
            return self.getToken(RegelSpraakParser.VAN, 0)
        def expressie(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.ExpressieContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,i)

        def MAAND(self):
            return self.getToken(RegelSpraakParser.MAAND, 0)
        def JAAR(self):
            return self.getToken(RegelSpraakParser.JAAR, 0)
        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.IdentifierContext,i)

        def GEDURENDE_DE_TIJD_DAT(self):
            return self.getToken(RegelSpraakParser.GEDURENDE_DE_TIJD_DAT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCapitalizedTijdsevenredigDeelExpr" ):
                listener.enterCapitalizedTijdsevenredigDeelExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCapitalizedTijdsevenredigDeelExpr" ):
                listener.exitCapitalizedTijdsevenredigDeelExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCapitalizedTijdsevenredigDeelExpr" ):
                return visitor.visitCapitalizedTijdsevenredigDeelExpr(self)
            else:
                return visitor.visitChildren(self)


    class ParenExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(RegelSpraakParser.LPAREN, 0)
        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)

        def RPAREN(self):
            return self.getToken(RegelSpraakParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParenExpr" ):
                listener.enterParenExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParenExpr" ):
                listener.exitParenExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParenExpr" ):
                return visitor.visitParenExpr(self)
            else:
                return visitor.visitChildren(self)


    class UnaryMinusExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def MIN(self):
            return self.getToken(RegelSpraakParser.MIN, 0)
        def primaryExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,0)

        def MINUS(self):
            return self.getToken(RegelSpraakParser.MINUS, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnaryMinusExpr" ):
                listener.enterUnaryMinusExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnaryMinusExpr" ):
                listener.exitUnaryMinusExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnaryMinusExpr" ):
                return visitor.visitUnaryMinusExpr(self)
            else:
                return visitor.visitChildren(self)


    class ParamRefExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def parameterMetLidwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.ParameterMetLidwoordContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParamRefExpr" ):
                listener.enterParamRefExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParamRefExpr" ):
                listener.exitParamRefExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParamRefExpr" ):
                return visitor.visitParamRefExpr(self)
            else:
                return visitor.visitChildren(self)


    class PronounExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def HIJ(self):
            return self.getToken(RegelSpraakParser.HIJ, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPronounExpr" ):
                listener.enterPronounExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPronounExpr" ):
                listener.exitPronounExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPronounExpr" ):
                return visitor.visitPronounExpr(self)
            else:
                return visitor.visitChildren(self)



    def primaryExpression(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = RegelSpraakParser.PrimaryExpressionContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 150
        self.enterRecursionRule(localctx, 150, self.RULE_primaryExpression, _p)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1133
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,133,self._ctx)
            if la_ == 1:
                localctx = RegelSpraakParser.UnaryMinusExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx

                self.state = 926
                self.match(RegelSpraakParser.MIN)
                self.state = 927
                self.primaryExpression(45)
                pass

            elif la_ == 2:
                localctx = RegelSpraakParser.UnaryMinusExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 928
                self.match(RegelSpraakParser.MINUS)
                self.state = 929
                self.primaryExpression(44)
                pass

            elif la_ == 3:
                localctx = RegelSpraakParser.UnaryNietExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 930
                self.match(RegelSpraakParser.NIET)
                self.state = 931
                self.primaryExpression(43)
                pass

            elif la_ == 4:
                localctx = RegelSpraakParser.AbsTijdsduurFuncExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 932
                self.match(RegelSpraakParser.DE_ABSOLUTE_TIJDSDUUR_VAN)
                self.state = 933
                self.primaryExpression(0)
                self.state = 934
                self.match(RegelSpraakParser.TOT)
                self.state = 935
                self.primaryExpression(0)
                self.state = 938
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,114,self._ctx)
                if la_ == 1:
                    self.state = 936
                    self.match(RegelSpraakParser.IN_HELE)
                    self.state = 937
                    localctx.unitName = self.match(RegelSpraakParser.IDENTIFIER)


                pass

            elif la_ == 5:
                localctx = RegelSpraakParser.TijdsduurFuncExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 940
                self.match(RegelSpraakParser.TIJDSDUUR_VAN)
                self.state = 941
                self.primaryExpression(0)
                self.state = 942
                self.match(RegelSpraakParser.TOT)
                self.state = 943
                self.primaryExpression(0)
                self.state = 946
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,115,self._ctx)
                if la_ == 1:
                    self.state = 944
                    self.match(RegelSpraakParser.IN_HELE)
                    self.state = 945
                    localctx.unitName = self.match(RegelSpraakParser.IDENTIFIER)


                pass

            elif la_ == 6:
                localctx = RegelSpraakParser.SomFuncExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 948
                self.match(RegelSpraakParser.SOM_VAN)
                self.state = 949
                self.expressie()
                pass

            elif la_ == 7:
                localctx = RegelSpraakParser.AantalFuncExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 951
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==211:
                    self.state = 950
                    self.match(RegelSpraakParser.HET)


                self.state = 953
                self.match(RegelSpraakParser.AANTAL)

                self.state = 955
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,117,self._ctx)
                if la_ == 1:
                    self.state = 954
                    self.match(RegelSpraakParser.ALLE)


                self.state = 957
                self.onderwerpReferentie()
                pass

            elif la_ == 8:
                localctx = RegelSpraakParser.PercentageFuncExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 958
                self.match(RegelSpraakParser.NUMBER)
                self.state = 961
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [268]:
                    self.state = 959
                    self.match(RegelSpraakParser.PERCENT_SIGN)
                    pass
                elif token in [252]:
                    self.state = 960
                    localctx.p = self.match(RegelSpraakParser.IDENTIFIER)
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 963
                self.match(RegelSpraakParser.VAN)
                self.state = 964
                self.primaryExpression(38)
                pass

            elif la_ == 9:
                localctx = RegelSpraakParser.ConcatenatieExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 965
                self.match(RegelSpraakParser.CONCATENATIE_VAN)
                self.state = 966
                self.primaryExpression(0)
                self.state = 971
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==263:
                    self.state = 967
                    self.match(RegelSpraakParser.COMMA)
                    self.state = 968
                    self.primaryExpression(0)
                    self.state = 973
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 974
                _la = self._input.LA(1)
                if not(_la==210 or _la==219):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 975
                self.primaryExpression(35)
                pass

            elif la_ == 10:
                localctx = RegelSpraakParser.WortelFuncExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 977
                self.match(RegelSpraakParser.DE_WORTEL_VAN)
                self.state = 978
                self.primaryExpression(33)
                pass

            elif la_ == 11:
                localctx = RegelSpraakParser.AbsValFuncExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 979
                self.match(RegelSpraakParser.DE_ABSOLUTE_WAARDE_VAN)
                self.state = 980
                self.match(RegelSpraakParser.LPAREN)
                self.state = 981
                self.primaryExpression(0)
                self.state = 982
                self.match(RegelSpraakParser.RPAREN)
                pass

            elif la_ == 12:
                localctx = RegelSpraakParser.MinValFuncExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 984
                self.match(RegelSpraakParser.DE_MINIMALE_WAARDE_VAN)
                self.state = 985
                self.primaryExpression(0)
                self.state = 990
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==263:
                    self.state = 986
                    self.match(RegelSpraakParser.COMMA)
                    self.state = 987
                    self.primaryExpression(0)
                    self.state = 992
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 993
                self.match(RegelSpraakParser.EN)
                self.state = 994
                self.primaryExpression(31)
                pass

            elif la_ == 13:
                localctx = RegelSpraakParser.MaxValFuncExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 996
                self.match(RegelSpraakParser.DE_MAXIMALE_WAARDE_VAN)
                self.state = 997
                self.primaryExpression(0)
                self.state = 1002
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==263:
                    self.state = 998
                    self.match(RegelSpraakParser.COMMA)
                    self.state = 999
                    self.primaryExpression(0)
                    self.state = 1004
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 1005
                self.match(RegelSpraakParser.EN)
                self.state = 1006
                self.primaryExpression(30)
                pass

            elif la_ == 14:
                localctx = RegelSpraakParser.JaarUitFuncExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1008
                self.match(RegelSpraakParser.HET)
                self.state = 1009
                self.match(RegelSpraakParser.JAAR)
                self.state = 1010
                self.match(RegelSpraakParser.UIT)
                self.state = 1011
                self.primaryExpression(29)
                pass

            elif la_ == 15:
                localctx = RegelSpraakParser.MaandUitFuncExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1012
                self.match(RegelSpraakParser.DE)
                self.state = 1013
                self.match(RegelSpraakParser.MAAND)
                self.state = 1014
                self.match(RegelSpraakParser.UIT)
                self.state = 1015
                self.primaryExpression(28)
                pass

            elif la_ == 16:
                localctx = RegelSpraakParser.DagUitFuncExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1016
                self.match(RegelSpraakParser.DE)
                self.state = 1017
                self.match(RegelSpraakParser.DAG)
                self.state = 1018
                self.match(RegelSpraakParser.UIT)
                self.state = 1019
                self.primaryExpression(27)
                pass

            elif la_ == 17:
                localctx = RegelSpraakParser.DatumMetFuncExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1020
                self.match(RegelSpraakParser.DE_DATUM_MET)
                self.state = 1021
                self.match(RegelSpraakParser.LPAREN)
                self.state = 1022
                self.primaryExpression(0)
                self.state = 1023
                self.match(RegelSpraakParser.COMMA)
                self.state = 1024
                self.primaryExpression(0)
                self.state = 1025
                self.match(RegelSpraakParser.COMMA)
                self.state = 1026
                self.primaryExpression(0)
                self.state = 1027
                self.match(RegelSpraakParser.RPAREN)
                pass

            elif la_ == 18:
                localctx = RegelSpraakParser.PasenFuncExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1029
                self.match(RegelSpraakParser.DE_EERSTE_PAASDAG_VAN)
                self.state = 1030
                self.match(RegelSpraakParser.LPAREN)
                self.state = 1031
                self.primaryExpression(0)
                self.state = 1032
                self.match(RegelSpraakParser.RPAREN)
                pass

            elif la_ == 19:
                localctx = RegelSpraakParser.EersteDatumFuncExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1034
                self.match(RegelSpraakParser.EERSTE_VAN)
                self.state = 1035
                self.primaryExpression(0)
                self.state = 1040
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==263:
                    self.state = 1036
                    self.match(RegelSpraakParser.COMMA)
                    self.state = 1037
                    self.primaryExpression(0)
                    self.state = 1042
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 1043
                self.match(RegelSpraakParser.EN)
                self.state = 1044
                self.primaryExpression(23)
                pass

            elif la_ == 20:
                localctx = RegelSpraakParser.LaatsteDatumFuncExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1046
                self.match(RegelSpraakParser.LAATSTE_VAN)
                self.state = 1047
                self.primaryExpression(0)
                self.state = 1052
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==263:
                    self.state = 1048
                    self.match(RegelSpraakParser.COMMA)
                    self.state = 1049
                    self.primaryExpression(0)
                    self.state = 1054
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 1055
                self.match(RegelSpraakParser.EN)
                self.state = 1056
                self.primaryExpression(22)
                pass

            elif la_ == 21:
                localctx = RegelSpraakParser.TotaalVanExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1058
                self.match(RegelSpraakParser.HET_TOTAAL_VAN)
                self.state = 1059
                self.expressie()
                self.state = 1062
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,124,self._ctx)
                if la_ == 1:
                    self.state = 1060
                    self.match(RegelSpraakParser.GEDURENDE_DE_TIJD_DAT)
                    self.state = 1061
                    localctx.condition = self.expressie()


                pass

            elif la_ == 22:
                localctx = RegelSpraakParser.HetAantalDagenInExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1064
                self.match(RegelSpraakParser.HET_AANTAL_DAGEN_IN)
                self.state = 1069
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [206]:
                    self.state = 1065
                    self.match(RegelSpraakParser.DE)
                    self.state = 1066
                    self.match(RegelSpraakParser.MAAND)
                    pass
                elif token in [211]:
                    self.state = 1067
                    self.match(RegelSpraakParser.HET)
                    self.state = 1068
                    self.match(RegelSpraakParser.JAAR)
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 1071
                self.match(RegelSpraakParser.DAT)
                self.state = 1072
                self.expressie()
                pass

            elif la_ == 23:
                localctx = RegelSpraakParser.CapitalizedTotaalVanExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1074 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 1073
                    self.identifier()
                    self.state = 1076 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==252):
                        break

                self.state = 1078
                self.match(RegelSpraakParser.HET_TOTAAL_VAN)
                self.state = 1079
                self.expressie()
                self.state = 1082
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,127,self._ctx)
                if la_ == 1:
                    self.state = 1080
                    self.match(RegelSpraakParser.GEDURENDE_DE_TIJD_DAT)
                    self.state = 1081
                    localctx.condition = self.expressie()


                pass

            elif la_ == 24:
                localctx = RegelSpraakParser.TijdsevenredigDeelExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1084
                self.match(RegelSpraakParser.HET_TIJDSEVENREDIG_DEEL_PER)
                self.state = 1085
                _la = self._input.LA(1)
                if not(_la==214 or _la==216):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1086
                self.match(RegelSpraakParser.VAN)
                self.state = 1087
                self.expressie()
                self.state = 1090
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,128,self._ctx)
                if la_ == 1:
                    self.state = 1088
                    self.match(RegelSpraakParser.GEDURENDE_DE_TIJD_DAT)
                    self.state = 1089
                    localctx.condition = self.expressie()


                pass

            elif la_ == 25:
                localctx = RegelSpraakParser.CapitalizedTijdsevenredigDeelExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1093 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 1092
                    self.identifier()
                    self.state = 1095 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==252):
                        break

                self.state = 1097
                self.match(RegelSpraakParser.HET_TIJDSEVENREDIG_DEEL_PER)
                self.state = 1098
                _la = self._input.LA(1)
                if not(_la==214 or _la==216):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1099
                self.match(RegelSpraakParser.VAN)
                self.state = 1100
                self.expressie()
                self.state = 1103
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,130,self._ctx)
                if la_ == 1:
                    self.state = 1101
                    self.match(RegelSpraakParser.GEDURENDE_DE_TIJD_DAT)
                    self.state = 1102
                    localctx.condition = self.expressie()


                pass

            elif la_ == 26:
                localctx = RegelSpraakParser.DimensieAggExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1107
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [16, 17, 185, 190, 211]:
                    self.state = 1105
                    self.getalAggregatieFunctie()
                    pass
                elif token in [186, 188]:
                    self.state = 1106
                    self.datumAggregatieFunctie()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 1109
                self.attribuutReferentie()
                self.state = 1110
                self.dimensieSelectie()
                pass

            elif la_ == 27:
                localctx = RegelSpraakParser.AttrRefExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1112
                self.attribuutReferentie()
                pass

            elif la_ == 28:
                localctx = RegelSpraakParser.BezieldeRefExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1113
                self.bezieldeReferentie()
                pass

            elif la_ == 29:
                localctx = RegelSpraakParser.OnderwerpRefExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1114
                self.onderwerpReferentie()
                pass

            elif la_ == 30:
                localctx = RegelSpraakParser.NaamwoordExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1115
                self.naamwoord()
                pass

            elif la_ == 31:
                localctx = RegelSpraakParser.ParamRefExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1116
                self.parameterMetLidwoord()
                pass

            elif la_ == 32:
                localctx = RegelSpraakParser.RekendatumKeywordExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1117
                self.match(RegelSpraakParser.REKENDATUM)
                pass

            elif la_ == 33:
                localctx = RegelSpraakParser.IdentifierExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1118
                self.identifier()
                pass

            elif la_ == 34:
                localctx = RegelSpraakParser.NumberLiteralExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1119
                self.match(RegelSpraakParser.NUMBER)
                self.state = 1121
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,132,self._ctx)
                if la_ == 1:
                    self.state = 1120
                    self.unitIdentifier()


                pass

            elif la_ == 35:
                localctx = RegelSpraakParser.StringLiteralExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1123
                self.match(RegelSpraakParser.STRING_LITERAL)
                pass

            elif la_ == 36:
                localctx = RegelSpraakParser.EnumLiteralExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1124
                self.match(RegelSpraakParser.ENUM_LITERAL)
                pass

            elif la_ == 37:
                localctx = RegelSpraakParser.DatumLiteralExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1125
                self.datumLiteral()
                pass

            elif la_ == 38:
                localctx = RegelSpraakParser.BooleanTrueLiteralExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1126
                self.match(RegelSpraakParser.WAAR)
                pass

            elif la_ == 39:
                localctx = RegelSpraakParser.BooleanFalseLiteralExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1127
                self.match(RegelSpraakParser.ONWAAR)
                pass

            elif la_ == 40:
                localctx = RegelSpraakParser.PronounExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1128
                self.match(RegelSpraakParser.HIJ)
                pass

            elif la_ == 41:
                localctx = RegelSpraakParser.ParenExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1129
                self.match(RegelSpraakParser.LPAREN)
                self.state = 1130
                self.expressie()
                self.state = 1131
                self.match(RegelSpraakParser.RPAREN)
                pass


            self._ctx.stop = self._input.LT(-1)
            self.state = 1157
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,136,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    self.state = 1155
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,135,self._ctx)
                    if la_ == 1:
                        localctx = RegelSpraakParser.SimpleConcatenatieExprContext(self, RegelSpraakParser.PrimaryExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_primaryExpression)
                        self.state = 1135
                        if not self.precpred(self._ctx, 34):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 34)")
                        self.state = 1138 
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        while True:
                            self.state = 1136
                            self.match(RegelSpraakParser.COMMA)
                            self.state = 1137
                            self.primaryExpression(0)
                            self.state = 1140 
                            self._errHandler.sync(self)
                            _la = self._input.LA(1)
                            if not (_la==263):
                                break

                        self.state = 1142
                        _la = self._input.LA(1)
                        if not(_la==210 or _la==219):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 1143
                        self.primaryExpression(35)
                        pass

                    elif la_ == 2:
                        localctx = RegelSpraakParser.AfrondingExprContext(self, RegelSpraakParser.PrimaryExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_primaryExpression)
                        self.state = 1145
                        if not self.precpred(self._ctx, 37):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 37)")
                        self.state = 1146
                        self.afronding()
                        pass

                    elif la_ == 3:
                        localctx = RegelSpraakParser.BegrenzingExprContext(self, RegelSpraakParser.PrimaryExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_primaryExpression)
                        self.state = 1147
                        if not self.precpred(self._ctx, 36):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 36)")
                        self.state = 1148
                        self.match(RegelSpraakParser.COMMA)
                        self.state = 1149
                        self.begrenzing()
                        pass

                    elif la_ == 4:
                        localctx = RegelSpraakParser.DateCalcExprContext(self, RegelSpraakParser.PrimaryExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_primaryExpression)
                        self.state = 1150
                        if not self.precpred(self._ctx, 24):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 24)")
                        self.state = 1151
                        _la = self._input.LA(1)
                        if not(_la==133 or _la==138):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 1152
                        self.primaryExpression(0)
                        self.state = 1153
                        self.identifier()
                        pass

             
                self.state = 1159
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,136,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class AfrondingContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def AFGEROND_OP(self):
            return self.getToken(RegelSpraakParser.AFGEROND_OP, 0)

        def NUMBER(self):
            return self.getToken(RegelSpraakParser.NUMBER, 0)

        def DECIMALEN(self):
            return self.getToken(RegelSpraakParser.DECIMALEN, 0)

        def NAAR_BENEDEN(self):
            return self.getToken(RegelSpraakParser.NAAR_BENEDEN, 0)

        def NAAR_BOVEN(self):
            return self.getToken(RegelSpraakParser.NAAR_BOVEN, 0)

        def REKENKUNDIG(self):
            return self.getToken(RegelSpraakParser.REKENKUNDIG, 0)

        def RICHTING_NUL(self):
            return self.getToken(RegelSpraakParser.RICHTING_NUL, 0)

        def WEG_VAN_NUL(self):
            return self.getToken(RegelSpraakParser.WEG_VAN_NUL, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_afronding

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAfronding" ):
                listener.enterAfronding(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAfronding" ):
                listener.exitAfronding(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAfronding" ):
                return visitor.visitAfronding(self)
            else:
                return visitor.visitChildren(self)




    def afronding(self):

        localctx = RegelSpraakParser.AfrondingContext(self, self._ctx, self.state)
        self.enterRule(localctx, 152, self.RULE_afronding)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1160
            _la = self._input.LA(1)
            if not(((((_la - 134)) & ~0x3f) == 0 and ((1 << (_la - 134)) & 65635) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 1161
            self.match(RegelSpraakParser.AFGEROND_OP)
            self.state = 1162
            self.match(RegelSpraakParser.NUMBER)
            self.state = 1163
            self.match(RegelSpraakParser.DECIMALEN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BegrenzingContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def begrenzingMinimum(self):
            return self.getTypedRuleContext(RegelSpraakParser.BegrenzingMinimumContext,0)


        def begrenzingMaximum(self):
            return self.getTypedRuleContext(RegelSpraakParser.BegrenzingMaximumContext,0)


        def EN(self):
            return self.getToken(RegelSpraakParser.EN, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_begrenzing

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBegrenzing" ):
                listener.enterBegrenzing(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBegrenzing" ):
                listener.exitBegrenzing(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBegrenzing" ):
                return visitor.visitBegrenzing(self)
            else:
                return visitor.visitChildren(self)




    def begrenzing(self):

        localctx = RegelSpraakParser.BegrenzingContext(self, self._ctx, self.state)
        self.enterRule(localctx, 154, self.RULE_begrenzing)
        try:
            self.state = 1171
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,137,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1165
                self.begrenzingMinimum()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1166
                self.begrenzingMaximum()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1167
                self.begrenzingMinimum()
                self.state = 1168
                self.match(RegelSpraakParser.EN)
                self.state = 1169
                self.begrenzingMaximum()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BegrenzingMinimumContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MET_EEN_MINIMUM_VAN(self):
            return self.getToken(RegelSpraakParser.MET_EEN_MINIMUM_VAN, 0)

        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_begrenzingMinimum

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBegrenzingMinimum" ):
                listener.enterBegrenzingMinimum(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBegrenzingMinimum" ):
                listener.exitBegrenzingMinimum(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBegrenzingMinimum" ):
                return visitor.visitBegrenzingMinimum(self)
            else:
                return visitor.visitChildren(self)




    def begrenzingMinimum(self):

        localctx = RegelSpraakParser.BegrenzingMinimumContext(self, self._ctx, self.state)
        self.enterRule(localctx, 156, self.RULE_begrenzingMinimum)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1173
            self.match(RegelSpraakParser.MET_EEN_MINIMUM_VAN)
            self.state = 1174
            self.expressie()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BegrenzingMaximumContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MET_EEN_MAXIMUM_VAN(self):
            return self.getToken(RegelSpraakParser.MET_EEN_MAXIMUM_VAN, 0)

        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_begrenzingMaximum

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBegrenzingMaximum" ):
                listener.enterBegrenzingMaximum(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBegrenzingMaximum" ):
                listener.exitBegrenzingMaximum(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBegrenzingMaximum" ):
                return visitor.visitBegrenzingMaximum(self)
            else:
                return visitor.visitChildren(self)




    def begrenzingMaximum(self):

        localctx = RegelSpraakParser.BegrenzingMaximumContext(self, self._ctx, self.state)
        self.enterRule(localctx, 158, self.RULE_begrenzingMaximum)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1176
            self.match(RegelSpraakParser.MET_EEN_MAXIMUM_VAN)
            self.state = 1177
            self.expressie()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConditieBijExpressieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.condition = None # ExpressieContext

        def GEDURENDE_DE_TIJD_DAT(self):
            return self.getToken(RegelSpraakParser.GEDURENDE_DE_TIJD_DAT, 0)

        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)


        def periodevergelijkingEnkelvoudig(self):
            return self.getTypedRuleContext(RegelSpraakParser.PeriodevergelijkingEnkelvoudigContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_conditieBijExpressie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConditieBijExpressie" ):
                listener.enterConditieBijExpressie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConditieBijExpressie" ):
                listener.exitConditieBijExpressie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConditieBijExpressie" ):
                return visitor.visitConditieBijExpressie(self)
            else:
                return visitor.visitChildren(self)




    def conditieBijExpressie(self):

        localctx = RegelSpraakParser.ConditieBijExpressieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 160, self.RULE_conditieBijExpressie)
        try:
            self.state = 1182
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [8]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1179
                self.match(RegelSpraakParser.GEDURENDE_DE_TIJD_DAT)
                self.state = 1180
                localctx.condition = self.expressie()
                pass
            elif token in [141, 143, 145, 231]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1181
                self.periodevergelijkingEnkelvoudig()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PeriodevergelijkingEnkelvoudigContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def VANAF(self):
            return self.getToken(RegelSpraakParser.VANAF, 0)

        def datumLiteral(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.DatumLiteralContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.DatumLiteralContext,i)


        def VAN(self):
            return self.getToken(RegelSpraakParser.VAN, 0)

        def TOT(self):
            return self.getToken(RegelSpraakParser.TOT, 0)

        def TOT_EN_MET(self):
            return self.getToken(RegelSpraakParser.TOT_EN_MET, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_periodevergelijkingEnkelvoudig

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPeriodevergelijkingEnkelvoudig" ):
                listener.enterPeriodevergelijkingEnkelvoudig(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPeriodevergelijkingEnkelvoudig" ):
                listener.exitPeriodevergelijkingEnkelvoudig(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPeriodevergelijkingEnkelvoudig" ):
                return visitor.visitPeriodevergelijkingEnkelvoudig(self)
            else:
                return visitor.visitChildren(self)




    def periodevergelijkingEnkelvoudig(self):

        localctx = RegelSpraakParser.PeriodevergelijkingEnkelvoudigContext(self, self._ctx, self.state)
        self.enterRule(localctx, 162, self.RULE_periodevergelijkingEnkelvoudig)
        try:
            self.state = 1200
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,139,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1184
                self.match(RegelSpraakParser.VANAF)
                self.state = 1185
                self.datumLiteral()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1186
                self.match(RegelSpraakParser.VAN)
                self.state = 1187
                self.datumLiteral()
                self.state = 1188
                self.match(RegelSpraakParser.TOT)
                self.state = 1189
                self.datumLiteral()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1191
                self.match(RegelSpraakParser.VAN)
                self.state = 1192
                self.datumLiteral()
                self.state = 1193
                self.match(RegelSpraakParser.TOT_EN_MET)
                self.state = 1194
                self.datumLiteral()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 1196
                self.match(RegelSpraakParser.TOT)
                self.state = 1197
                self.datumLiteral()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 1198
                self.match(RegelSpraakParser.TOT_EN_MET)
                self.state = 1199
                self.datumLiteral()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GetalAggregatieFunctieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def AANTAL(self):
            return self.getToken(RegelSpraakParser.AANTAL, 0)

        def HET(self):
            return self.getToken(RegelSpraakParser.HET, 0)

        def DE_MAXIMALE_WAARDE_VAN(self):
            return self.getToken(RegelSpraakParser.DE_MAXIMALE_WAARDE_VAN, 0)

        def DE_MINIMALE_WAARDE_VAN(self):
            return self.getToken(RegelSpraakParser.DE_MINIMALE_WAARDE_VAN, 0)

        def SOM_VAN(self):
            return self.getToken(RegelSpraakParser.SOM_VAN, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_getalAggregatieFunctie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGetalAggregatieFunctie" ):
                listener.enterGetalAggregatieFunctie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGetalAggregatieFunctie" ):
                listener.exitGetalAggregatieFunctie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGetalAggregatieFunctie" ):
                return visitor.visitGetalAggregatieFunctie(self)
            else:
                return visitor.visitChildren(self)




    def getalAggregatieFunctie(self):

        localctx = RegelSpraakParser.GetalAggregatieFunctieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 164, self.RULE_getalAggregatieFunctie)
        self._la = 0 # Token type
        try:
            self.state = 1209
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [185, 211]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1203
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==211:
                    self.state = 1202
                    self.match(RegelSpraakParser.HET)


                self.state = 1205
                self.match(RegelSpraakParser.AANTAL)
                pass
            elif token in [16]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1206
                self.match(RegelSpraakParser.DE_MAXIMALE_WAARDE_VAN)
                pass
            elif token in [17]:
                self.enterOuterAlt(localctx, 3)
                self.state = 1207
                self.match(RegelSpraakParser.DE_MINIMALE_WAARDE_VAN)
                pass
            elif token in [190]:
                self.enterOuterAlt(localctx, 4)
                self.state = 1208
                self.match(RegelSpraakParser.SOM_VAN)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DatumAggregatieFunctieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EERSTE_VAN(self):
            return self.getToken(RegelSpraakParser.EERSTE_VAN, 0)

        def LAATSTE_VAN(self):
            return self.getToken(RegelSpraakParser.LAATSTE_VAN, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_datumAggregatieFunctie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDatumAggregatieFunctie" ):
                listener.enterDatumAggregatieFunctie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDatumAggregatieFunctie" ):
                listener.exitDatumAggregatieFunctie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDatumAggregatieFunctie" ):
                return visitor.visitDatumAggregatieFunctie(self)
            else:
                return visitor.visitChildren(self)




    def datumAggregatieFunctie(self):

        localctx = RegelSpraakParser.DatumAggregatieFunctieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 166, self.RULE_datumAggregatieFunctie)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1211
            _la = self._input.LA(1)
            if not(_la==186 or _la==188):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DimensieSelectieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OVER(self):
            return self.getToken(RegelSpraakParser.OVER, 0)

        def DOT(self):
            return self.getToken(RegelSpraakParser.DOT, 0)

        def aggregerenOverAlleDimensies(self):
            return self.getTypedRuleContext(RegelSpraakParser.AggregerenOverAlleDimensiesContext,0)


        def aggregerenOverVerzameling(self):
            return self.getTypedRuleContext(RegelSpraakParser.AggregerenOverVerzamelingContext,0)


        def aggregerenOverBereik(self):
            return self.getTypedRuleContext(RegelSpraakParser.AggregerenOverBereikContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_dimensieSelectie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDimensieSelectie" ):
                listener.enterDimensieSelectie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDimensieSelectie" ):
                listener.exitDimensieSelectie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDimensieSelectie" ):
                return visitor.visitDimensieSelectie(self)
            else:
                return visitor.visitChildren(self)




    def dimensieSelectie(self):

        localctx = RegelSpraakParser.DimensieSelectieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 168, self.RULE_dimensieSelectie)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1213
            self.match(RegelSpraakParser.OVER)
            self.state = 1217
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,142,self._ctx)
            if la_ == 1:
                self.state = 1214
                self.aggregerenOverAlleDimensies()
                pass

            elif la_ == 2:
                self.state = 1215
                self.aggregerenOverVerzameling()
                pass

            elif la_ == 3:
                self.state = 1216
                self.aggregerenOverBereik()
                pass


            self.state = 1219
            self.match(RegelSpraakParser.DOT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AggregerenOverAlleDimensiesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ALLE(self):
            return self.getToken(RegelSpraakParser.ALLE, 0)

        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_aggregerenOverAlleDimensies

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAggregerenOverAlleDimensies" ):
                listener.enterAggregerenOverAlleDimensies(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAggregerenOverAlleDimensies" ):
                listener.exitAggregerenOverAlleDimensies(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAggregerenOverAlleDimensies" ):
                return visitor.visitAggregerenOverAlleDimensies(self)
            else:
                return visitor.visitChildren(self)




    def aggregerenOverAlleDimensies(self):

        localctx = RegelSpraakParser.AggregerenOverAlleDimensiesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 170, self.RULE_aggregerenOverAlleDimensies)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1221
            self.match(RegelSpraakParser.ALLE)
            self.state = 1222
            self.naamwoord()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AggregerenOverVerzamelingContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DE(self):
            return self.getToken(RegelSpraakParser.DE, 0)

        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def VANAF(self):
            return self.getToken(RegelSpraakParser.VANAF, 0)

        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.IdentifierContext,i)


        def TM(self):
            return self.getToken(RegelSpraakParser.TM, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_aggregerenOverVerzameling

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAggregerenOverVerzameling" ):
                listener.enterAggregerenOverVerzameling(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAggregerenOverVerzameling" ):
                listener.exitAggregerenOverVerzameling(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAggregerenOverVerzameling" ):
                return visitor.visitAggregerenOverVerzameling(self)
            else:
                return visitor.visitChildren(self)




    def aggregerenOverVerzameling(self):

        localctx = RegelSpraakParser.AggregerenOverVerzamelingContext(self, self._ctx, self.state)
        self.enterRule(localctx, 172, self.RULE_aggregerenOverVerzameling)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1224
            self.match(RegelSpraakParser.DE)
            self.state = 1225
            self.naamwoord()
            self.state = 1226
            self.match(RegelSpraakParser.VANAF)
            self.state = 1227
            self.identifier()
            self.state = 1228
            self.match(RegelSpraakParser.TM)
            self.state = 1229
            self.identifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AggregerenOverBereikContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DE(self):
            return self.getToken(RegelSpraakParser.DE, 0)

        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def IN(self):
            return self.getToken(RegelSpraakParser.IN, 0)

        def LBRACE(self):
            return self.getToken(RegelSpraakParser.LBRACE, 0)

        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.IdentifierContext,i)


        def EN(self):
            return self.getToken(RegelSpraakParser.EN, 0)

        def RBRACE(self):
            return self.getToken(RegelSpraakParser.RBRACE, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.COMMA)
            else:
                return self.getToken(RegelSpraakParser.COMMA, i)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_aggregerenOverBereik

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAggregerenOverBereik" ):
                listener.enterAggregerenOverBereik(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAggregerenOverBereik" ):
                listener.exitAggregerenOverBereik(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAggregerenOverBereik" ):
                return visitor.visitAggregerenOverBereik(self)
            else:
                return visitor.visitChildren(self)




    def aggregerenOverBereik(self):

        localctx = RegelSpraakParser.AggregerenOverBereikContext(self, self._ctx, self.state)
        self.enterRule(localctx, 174, self.RULE_aggregerenOverBereik)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1231
            self.match(RegelSpraakParser.DE)
            self.state = 1232
            self.naamwoord()
            self.state = 1233
            self.match(RegelSpraakParser.IN)
            self.state = 1234
            self.match(RegelSpraakParser.LBRACE)
            self.state = 1235
            self.identifier()
            self.state = 1240
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==263:
                self.state = 1236
                self.match(RegelSpraakParser.COMMA)
                self.state = 1237
                self.identifier()
                self.state = 1242
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1243
            self.match(RegelSpraakParser.EN)
            self.state = 1244
            self.identifier()
            self.state = 1245
            self.match(RegelSpraakParser.RBRACE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UnaryConditionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_unaryCondition

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class UnaryCheckConditionContext(UnaryConditionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.UnaryConditionContext
            super().__init__(parser)
            self.expr = None # PrimaryExpressionContext
            self.op = None # Token
            self.copyFrom(ctx)

        def primaryExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,0)

        def IS_LEEG(self):
            return self.getToken(RegelSpraakParser.IS_LEEG, 0)
        def IS_GEVULD(self):
            return self.getToken(RegelSpraakParser.IS_GEVULD, 0)
        def VOLDOET_AAN_DE_ELFPROEF(self):
            return self.getToken(RegelSpraakParser.VOLDOET_AAN_DE_ELFPROEF, 0)
        def VOLDOET_NIET_AAN_DE_ELFPROEF(self):
            return self.getToken(RegelSpraakParser.VOLDOET_NIET_AAN_DE_ELFPROEF, 0)
        def ZIJN_LEEG(self):
            return self.getToken(RegelSpraakParser.ZIJN_LEEG, 0)
        def ZIJN_GEVULD(self):
            return self.getToken(RegelSpraakParser.ZIJN_GEVULD, 0)
        def VOLDOEN_AAN_DE_ELFPROEF(self):
            return self.getToken(RegelSpraakParser.VOLDOEN_AAN_DE_ELFPROEF, 0)
        def VOLDOEN_NIET_AAN_DE_ELFPROEF(self):
            return self.getToken(RegelSpraakParser.VOLDOEN_NIET_AAN_DE_ELFPROEF, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnaryCheckCondition" ):
                listener.enterUnaryCheckCondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnaryCheckCondition" ):
                listener.exitUnaryCheckCondition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnaryCheckCondition" ):
                return visitor.visitUnaryCheckCondition(self)
            else:
                return visitor.visitChildren(self)


    class UnaryKenmerkConditionContext(UnaryConditionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.UnaryConditionContext
            super().__init__(parser)
            self.expr = None # PrimaryExpressionContext
            self.op = None # Token
            self.kenmerk = None # IdentifierContext
            self.copyFrom(ctx)

        def primaryExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,0)

        def identifier(self):
            return self.getTypedRuleContext(RegelSpraakParser.IdentifierContext,0)

        def IS_KENMERK(self):
            return self.getToken(RegelSpraakParser.IS_KENMERK, 0)
        def ZIJN_KENMERK(self):
            return self.getToken(RegelSpraakParser.ZIJN_KENMERK, 0)
        def IS_NIET_KENMERK(self):
            return self.getToken(RegelSpraakParser.IS_NIET_KENMERK, 0)
        def ZIJN_NIET_KENMERK(self):
            return self.getToken(RegelSpraakParser.ZIJN_NIET_KENMERK, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnaryKenmerkCondition" ):
                listener.enterUnaryKenmerkCondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnaryKenmerkCondition" ):
                listener.exitUnaryKenmerkCondition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnaryKenmerkCondition" ):
                return visitor.visitUnaryKenmerkCondition(self)
            else:
                return visitor.visitChildren(self)


    class UnaryNumeriekExactConditionContext(UnaryConditionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.UnaryConditionContext
            super().__init__(parser)
            self.expr = None # PrimaryExpressionContext
            self.op = None # Token
            self.copyFrom(ctx)

        def NUMBER(self):
            return self.getToken(RegelSpraakParser.NUMBER, 0)
        def CIJFERS(self):
            return self.getToken(RegelSpraakParser.CIJFERS, 0)
        def primaryExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,0)

        def IS_NUMERIEK_MET_EXACT(self):
            return self.getToken(RegelSpraakParser.IS_NUMERIEK_MET_EXACT, 0)
        def IS_NIET_NUMERIEK_MET_EXACT(self):
            return self.getToken(RegelSpraakParser.IS_NIET_NUMERIEK_MET_EXACT, 0)
        def ZIJN_NUMERIEK_MET_EXACT(self):
            return self.getToken(RegelSpraakParser.ZIJN_NUMERIEK_MET_EXACT, 0)
        def ZIJN_NIET_NUMERIEK_MET_EXACT(self):
            return self.getToken(RegelSpraakParser.ZIJN_NIET_NUMERIEK_MET_EXACT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnaryNumeriekExactCondition" ):
                listener.enterUnaryNumeriekExactCondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnaryNumeriekExactCondition" ):
                listener.exitUnaryNumeriekExactCondition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnaryNumeriekExactCondition" ):
                return visitor.visitUnaryNumeriekExactCondition(self)
            else:
                return visitor.visitChildren(self)


    class UnaryRolConditionContext(UnaryConditionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.UnaryConditionContext
            super().__init__(parser)
            self.expr = None # PrimaryExpressionContext
            self.op = None # Token
            self.rol = None # IdentifierContext
            self.copyFrom(ctx)

        def primaryExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,0)

        def identifier(self):
            return self.getTypedRuleContext(RegelSpraakParser.IdentifierContext,0)

        def IS_ROL(self):
            return self.getToken(RegelSpraakParser.IS_ROL, 0)
        def ZIJN_ROL(self):
            return self.getToken(RegelSpraakParser.ZIJN_ROL, 0)
        def IS_NIET_ROL(self):
            return self.getToken(RegelSpraakParser.IS_NIET_ROL, 0)
        def ZIJN_NIET_ROL(self):
            return self.getToken(RegelSpraakParser.ZIJN_NIET_ROL, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnaryRolCondition" ):
                listener.enterUnaryRolCondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnaryRolCondition" ):
                listener.exitUnaryRolCondition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnaryRolCondition" ):
                return visitor.visitUnaryRolCondition(self)
            else:
                return visitor.visitChildren(self)


    class UnaryDagsoortConditionContext(UnaryConditionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.UnaryConditionContext
            super().__init__(parser)
            self.expr = None # PrimaryExpressionContext
            self.op = None # Token
            self.dagsoort = None # IdentifierContext
            self.copyFrom(ctx)

        def primaryExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,0)

        def identifier(self):
            return self.getTypedRuleContext(RegelSpraakParser.IdentifierContext,0)

        def IS_EEN_DAGSOORT(self):
            return self.getToken(RegelSpraakParser.IS_EEN_DAGSOORT, 0)
        def ZIJN_EEN_DAGSOORT(self):
            return self.getToken(RegelSpraakParser.ZIJN_EEN_DAGSOORT, 0)
        def IS_GEEN_DAGSOORT(self):
            return self.getToken(RegelSpraakParser.IS_GEEN_DAGSOORT, 0)
        def ZIJN_GEEN_DAGSOORT(self):
            return self.getToken(RegelSpraakParser.ZIJN_GEEN_DAGSOORT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnaryDagsoortCondition" ):
                listener.enterUnaryDagsoortCondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnaryDagsoortCondition" ):
                listener.exitUnaryDagsoortCondition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnaryDagsoortCondition" ):
                return visitor.visitUnaryDagsoortCondition(self)
            else:
                return visitor.visitChildren(self)


    class UnaryInconsistentDataConditionContext(UnaryConditionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.UnaryConditionContext
            super().__init__(parser)
            self.expr = None # PrimaryExpressionContext
            self.copyFrom(ctx)

        def IS_INCONSISTENT(self):
            return self.getToken(RegelSpraakParser.IS_INCONSISTENT, 0)
        def primaryExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnaryInconsistentDataCondition" ):
                listener.enterUnaryInconsistentDataCondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnaryInconsistentDataCondition" ):
                listener.exitUnaryInconsistentDataCondition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnaryInconsistentDataCondition" ):
                return visitor.visitUnaryInconsistentDataCondition(self)
            else:
                return visitor.visitChildren(self)


    class UnaryUniekConditionContext(UnaryConditionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.UnaryConditionContext
            super().__init__(parser)
            self.ref = None # OnderwerpReferentieContext
            self.copyFrom(ctx)

        def MOETEN_UNIEK_ZIJN(self):
            return self.getToken(RegelSpraakParser.MOETEN_UNIEK_ZIJN, 0)
        def onderwerpReferentie(self):
            return self.getTypedRuleContext(RegelSpraakParser.OnderwerpReferentieContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnaryUniekCondition" ):
                listener.enterUnaryUniekCondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnaryUniekCondition" ):
                listener.exitUnaryUniekCondition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnaryUniekCondition" ):
                return visitor.visitUnaryUniekCondition(self)
            else:
                return visitor.visitChildren(self)



    def unaryCondition(self):

        localctx = RegelSpraakParser.UnaryConditionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 176, self.RULE_unaryCondition)
        self._la = 0 # Token type
        try:
            self.state = 1273
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,144,self._ctx)
            if la_ == 1:
                localctx = RegelSpraakParser.UnaryCheckConditionContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1247
                localctx.expr = self.primaryExpression(0)
                self.state = 1248
                localctx.op = self._input.LT(1)
                _la = self._input.LA(1)
                if not(((((_la - 70)) & ~0x3f) == 0 and ((1 << (_la - 70)) & 61455) != 0)):
                    localctx.op = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass

            elif la_ == 2:
                localctx = RegelSpraakParser.UnaryNumeriekExactConditionContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1250
                localctx.expr = self.primaryExpression(0)
                self.state = 1251
                localctx.op = self._input.LT(1)
                _la = self._input.LA(1)
                if not(((((_la - 86)) & ~0x3f) == 0 and ((1 << (_la - 86)) & 15) != 0)):
                    localctx.op = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1252
                self.match(RegelSpraakParser.NUMBER)
                self.state = 1253
                self.match(RegelSpraakParser.CIJFERS)
                pass

            elif la_ == 3:
                localctx = RegelSpraakParser.UnaryDagsoortConditionContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 1255
                localctx.expr = self.primaryExpression(0)
                self.state = 1256
                localctx.op = self._input.LT(1)
                _la = self._input.LA(1)
                if not(((((_la - 90)) & ~0x3f) == 0 and ((1 << (_la - 90)) & 15) != 0)):
                    localctx.op = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1257
                localctx.dagsoort = self.identifier()
                pass

            elif la_ == 4:
                localctx = RegelSpraakParser.UnaryKenmerkConditionContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 1259
                localctx.expr = self.primaryExpression(0)
                self.state = 1260
                localctx.op = self._input.LT(1)
                _la = self._input.LA(1)
                if not(((((_la - 74)) & ~0x3f) == 0 and ((1 << (_la - 74)) & 85) != 0)):
                    localctx.op = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1261
                localctx.kenmerk = self.identifier()
                pass

            elif la_ == 5:
                localctx = RegelSpraakParser.UnaryRolConditionContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 1263
                localctx.expr = self.primaryExpression(0)
                self.state = 1264
                localctx.op = self._input.LT(1)
                _la = self._input.LA(1)
                if not(((((_la - 75)) & ~0x3f) == 0 and ((1 << (_la - 75)) & 85) != 0)):
                    localctx.op = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1265
                localctx.rol = self.identifier()
                pass

            elif la_ == 6:
                localctx = RegelSpraakParser.UnaryUniekConditionContext(self, localctx)
                self.enterOuterAlt(localctx, 6)
                self.state = 1267
                localctx.ref = self.onderwerpReferentie()
                self.state = 1268
                self.match(RegelSpraakParser.MOETEN_UNIEK_ZIJN)
                pass

            elif la_ == 7:
                localctx = RegelSpraakParser.UnaryInconsistentDataConditionContext(self, localctx)
                self.enterOuterAlt(localctx, 7)
                self.state = 1270
                localctx.expr = self.primaryExpression(0)
                self.state = 1271
                self.match(RegelSpraakParser.IS_INCONSISTENT)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RegelStatusConditionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_regelStatusCondition

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class RegelStatusCheckContext(RegelStatusConditionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.RegelStatusConditionContext
            super().__init__(parser)
            self.name = None # NaamwoordContext
            self.op = None # Token
            self.copyFrom(ctx)

        def REGEL(self):
            return self.getToken(RegelSpraakParser.REGEL, 0)
        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)

        def IS_GEVUURD(self):
            return self.getToken(RegelSpraakParser.IS_GEVUURD, 0)
        def IS_INCONSISTENT(self):
            return self.getToken(RegelSpraakParser.IS_INCONSISTENT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRegelStatusCheck" ):
                listener.enterRegelStatusCheck(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRegelStatusCheck" ):
                listener.exitRegelStatusCheck(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRegelStatusCheck" ):
                return visitor.visitRegelStatusCheck(self)
            else:
                return visitor.visitChildren(self)



    def regelStatusCondition(self):

        localctx = RegelSpraakParser.RegelStatusConditionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 178, self.RULE_regelStatusCondition)
        self._la = 0 # Token type
        try:
            localctx = RegelSpraakParser.RegelStatusCheckContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 1275
            self.match(RegelSpraakParser.REGEL)
            self.state = 1276
            localctx.name = self.naamwoord()
            self.state = 1277
            localctx.op = self._input.LT(1)
            _la = self._input.LA(1)
            if not(_la==95 or _la==96):
                localctx.op = self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DagsoortDefinitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DAGSOORT(self):
            return self.getToken(RegelSpraakParser.DAGSOORT, 0)

        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def SEMICOLON(self):
            return self.getToken(RegelSpraakParser.SEMICOLON, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_dagsoortDefinition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDagsoortDefinition" ):
                listener.enterDagsoortDefinition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDagsoortDefinition" ):
                listener.exitDagsoortDefinition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDagsoortDefinition" ):
                return visitor.visitDagsoortDefinition(self)
            else:
                return visitor.visitChildren(self)




    def dagsoortDefinition(self):

        localctx = RegelSpraakParser.DagsoortDefinitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 180, self.RULE_dagsoortDefinition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1279
            self.match(RegelSpraakParser.DAGSOORT)
            self.state = 1280
            self.naamwoord()
            self.state = 1282
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==266:
                self.state = 1281
                self.match(RegelSpraakParser.SEMICOLON)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx



    def sempred(self, localctx:RuleContext, ruleIndex:int, predIndex:int):
        if self._predicates == None:
            self._predicates = dict()
        self._predicates[75] = self.primaryExpression_sempred
        pred = self._predicates.get(ruleIndex, None)
        if pred is None:
            raise Exception("No predicate with index:" + str(ruleIndex))
        else:
            return pred(localctx, predIndex)

    def primaryExpression_sempred(self, localctx:PrimaryExpressionContext, predIndex:int):
            if predIndex == 0:
                return self.precpred(self._ctx, 34)
         

            if predIndex == 1:
                return self.precpred(self._ctx, 37)
         

            if predIndex == 2:
                return self.precpred(self._ctx, 36)
         

            if predIndex == 3:
                return self.precpred(self._ctx, 24)
         




