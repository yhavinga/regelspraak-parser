# Generated from RegelSpraak.g4 by ANTLR 4.13.1
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO

def serializedATN():
    return [
        4,1,269,1209,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,
        7,6,2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,
        13,2,14,7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,
        20,7,20,2,21,7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,
        26,2,27,7,27,2,28,7,28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,
        33,7,33,2,34,7,34,2,35,7,35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,
        39,2,40,7,40,2,41,7,41,2,42,7,42,2,43,7,43,2,44,7,44,2,45,7,45,2,
        46,7,46,2,47,7,47,2,48,7,48,2,49,7,49,2,50,7,50,2,51,7,51,2,52,7,
        52,2,53,7,53,2,54,7,54,2,55,7,55,2,56,7,56,2,57,7,57,2,58,7,58,2,
        59,7,59,2,60,7,60,2,61,7,61,2,62,7,62,2,63,7,63,2,64,7,64,2,65,7,
        65,2,66,7,66,2,67,7,67,2,68,7,68,2,69,7,69,2,70,7,70,2,71,7,71,2,
        72,7,72,2,73,7,73,2,74,7,74,2,75,7,75,2,76,7,76,2,77,7,77,2,78,7,
        78,2,79,7,79,2,80,7,80,2,81,7,81,2,82,7,82,2,83,7,83,2,84,7,84,2,
        85,7,85,2,86,7,86,1,0,1,0,1,0,1,0,1,0,5,0,180,8,0,10,0,12,0,183,
        9,0,1,0,1,0,1,1,1,1,1,1,1,1,1,1,1,1,3,1,193,8,1,1,2,1,2,1,2,3,2,
        198,8,2,1,3,1,3,1,4,3,4,203,8,4,1,4,4,4,206,8,4,11,4,12,4,207,1,
        4,4,4,211,8,4,11,4,12,4,212,1,4,1,4,4,4,217,8,4,11,4,12,4,218,1,
        4,1,4,4,4,223,8,4,11,4,12,4,224,1,4,1,4,4,4,229,8,4,11,4,12,4,230,
        1,4,4,4,234,8,4,11,4,12,4,235,1,4,1,4,4,4,240,8,4,11,4,12,4,241,
        1,4,1,4,4,4,246,8,4,11,4,12,4,247,3,4,250,8,4,1,5,1,5,1,5,1,5,5,
        5,256,8,5,10,5,12,5,259,9,5,1,6,1,6,1,7,1,7,1,8,1,8,1,9,1,9,1,9,
        1,9,4,9,271,8,9,11,9,12,9,272,1,9,3,9,276,8,9,1,9,3,9,279,8,9,1,
        9,5,9,282,8,9,10,9,12,9,285,9,9,1,10,1,10,3,10,289,8,10,1,10,1,10,
        1,11,3,11,294,8,11,1,11,1,11,3,11,298,8,11,1,11,1,11,3,11,302,8,
        11,1,12,1,12,1,12,3,12,307,8,12,1,12,1,12,1,12,3,12,312,8,12,3,12,
        314,8,12,1,12,1,12,1,12,1,12,5,12,320,8,12,10,12,12,12,323,9,12,
        3,12,325,8,12,1,12,3,12,328,8,12,1,13,1,13,1,13,1,13,3,13,334,8,
        13,1,14,1,14,1,14,1,14,1,14,3,14,341,8,14,1,15,1,15,1,16,1,16,1,
        17,1,17,1,18,3,18,350,8,18,1,18,1,18,1,18,1,18,1,18,1,18,3,18,358,
        8,18,1,19,1,19,4,19,362,8,19,11,19,12,19,363,1,19,1,19,1,19,1,19,
        3,19,370,8,19,1,19,3,19,373,8,19,1,20,1,20,1,20,1,20,1,20,3,20,380,
        8,20,1,21,1,21,4,21,384,8,21,11,21,12,21,385,1,22,1,22,1,22,1,23,
        1,23,1,23,5,23,394,8,23,10,23,12,23,397,9,23,1,24,1,24,1,24,1,24,
        1,24,1,24,3,24,405,8,24,1,25,1,25,1,26,1,26,1,26,3,26,412,8,26,1,
        26,1,26,3,26,416,8,26,1,27,1,27,1,27,3,27,421,8,27,1,28,1,28,1,28,
        3,28,426,8,28,1,28,1,28,1,28,1,28,4,28,432,8,28,11,28,12,28,433,
        1,29,1,29,1,29,1,29,3,29,440,8,29,1,29,3,29,443,8,29,1,30,1,30,1,
        30,1,30,1,31,1,31,1,32,1,32,1,33,1,33,1,33,1,33,1,33,3,33,458,8,
        33,1,33,1,33,3,33,462,8,33,1,33,3,33,465,8,33,1,33,1,33,1,34,3,34,
        470,8,34,1,34,4,34,473,8,34,11,34,12,34,474,1,35,1,35,1,36,1,36,
        1,36,1,36,1,36,1,36,3,36,485,8,36,1,36,1,36,4,36,489,8,36,11,36,
        12,36,490,1,37,1,37,1,37,1,38,1,38,1,38,3,38,499,8,38,1,38,1,38,
        1,38,1,38,3,38,505,8,38,1,38,3,38,508,8,38,1,38,3,38,511,8,38,1,
        39,4,39,514,8,39,11,39,12,39,515,1,39,1,39,4,39,520,8,39,11,39,12,
        39,521,1,39,1,39,4,39,526,8,39,11,39,12,39,527,1,39,1,39,4,39,532,
        8,39,11,39,12,39,533,1,39,1,39,1,39,4,39,539,8,39,11,39,12,39,540,
        1,39,1,39,1,39,4,39,546,8,39,11,39,12,39,547,1,39,1,39,4,39,552,
        8,39,11,39,12,39,553,1,39,4,39,557,8,39,11,39,12,39,558,1,39,1,39,
        4,39,563,8,39,11,39,12,39,564,3,39,567,8,39,1,40,1,40,1,40,1,41,
        1,41,1,41,1,41,1,41,3,41,577,8,41,3,41,579,8,41,1,42,1,42,3,42,583,
        8,42,1,42,1,42,1,42,1,42,1,42,1,42,3,42,591,8,42,1,42,1,42,1,42,
        1,42,1,42,1,42,1,42,1,42,1,42,1,42,1,42,4,42,604,8,42,11,42,12,42,
        605,1,42,1,42,1,42,1,42,1,42,1,42,3,42,614,8,42,1,42,1,42,5,42,618,
        8,42,10,42,12,42,621,9,42,1,42,1,42,1,42,1,42,1,42,1,42,3,42,629,
        8,42,1,42,1,42,1,42,1,42,1,42,3,42,636,8,42,1,42,3,42,639,8,42,1,
        42,1,42,1,42,1,42,1,42,1,42,1,42,1,42,3,42,649,8,42,1,42,3,42,652,
        8,42,1,43,1,43,1,43,1,43,3,43,658,8,43,1,43,3,43,661,8,43,1,43,1,
        43,1,43,1,43,1,43,3,43,668,8,43,1,43,3,43,671,8,43,3,43,673,8,43,
        1,44,1,44,1,44,1,44,5,44,679,8,44,10,44,12,44,682,9,44,1,45,1,45,
        1,45,1,45,1,46,1,46,1,46,1,46,1,46,1,46,3,46,694,8,46,1,46,3,46,
        697,8,46,3,46,699,8,46,1,47,1,47,1,47,3,47,704,8,47,1,48,3,48,707,
        8,48,1,48,1,48,1,48,1,49,1,49,1,49,3,49,715,8,49,1,50,1,50,1,50,
        1,50,5,50,721,8,50,10,50,12,50,724,9,50,1,51,3,51,727,8,51,1,51,
        4,51,730,8,51,11,51,12,51,731,1,51,3,51,735,8,51,1,52,1,52,1,52,
        1,52,1,53,1,53,1,54,1,54,1,54,1,55,1,55,1,55,3,55,749,8,55,1,55,
        1,55,1,55,1,55,1,55,1,55,1,55,1,55,1,55,1,55,1,55,1,55,1,55,1,55,
        3,55,765,8,55,1,56,1,56,1,56,1,56,1,56,3,56,772,8,56,1,57,1,57,1,
        57,1,57,5,57,778,8,57,10,57,12,57,781,9,57,1,58,1,58,1,59,1,59,5,
        59,787,8,59,10,59,12,59,790,9,59,1,59,1,59,1,60,1,60,1,60,1,60,3,
        60,798,8,60,1,61,1,61,1,62,1,62,1,63,1,63,1,63,1,63,3,63,808,8,63,
        1,63,1,63,1,63,1,63,1,63,1,63,1,63,1,63,1,63,1,63,3,63,820,8,63,
        1,64,1,64,1,65,1,65,1,65,1,65,5,65,828,8,65,10,65,12,65,831,9,65,
        1,66,1,66,1,67,1,67,1,67,1,67,5,67,839,8,67,10,67,12,67,842,9,67,
        1,68,1,68,1,69,1,69,1,69,1,69,5,69,850,8,69,10,69,12,69,853,9,69,
        1,70,1,70,1,71,1,71,1,71,1,71,1,71,1,71,1,71,3,71,864,8,71,1,71,
        1,71,1,71,1,71,1,71,1,71,3,71,872,8,71,1,71,1,71,3,71,876,8,71,1,
        71,1,71,3,71,880,8,71,1,71,1,71,3,71,884,8,71,1,71,1,71,1,71,1,71,
        3,71,890,8,71,1,71,1,71,1,71,1,71,1,71,1,71,5,71,898,8,71,10,71,
        12,71,901,9,71,1,71,1,71,1,71,1,71,1,71,1,71,1,71,1,71,1,71,1,71,
        1,71,1,71,1,71,1,71,5,71,917,8,71,10,71,12,71,920,9,71,1,71,1,71,
        1,71,1,71,1,71,1,71,1,71,5,71,929,8,71,10,71,12,71,932,9,71,1,71,
        1,71,1,71,1,71,1,71,1,71,1,71,1,71,1,71,1,71,1,71,1,71,1,71,1,71,
        1,71,1,71,1,71,1,71,1,71,1,71,1,71,1,71,1,71,1,71,1,71,1,71,1,71,
        1,71,1,71,1,71,1,71,1,71,1,71,5,71,967,8,71,10,71,12,71,970,9,71,
        1,71,1,71,1,71,1,71,1,71,1,71,1,71,5,71,979,8,71,10,71,12,71,982,
        9,71,1,71,1,71,1,71,1,71,1,71,1,71,1,71,3,71,991,8,71,1,71,1,71,
        1,71,1,71,1,71,3,71,998,8,71,1,71,1,71,1,71,4,71,1003,8,71,11,71,
        12,71,1004,1,71,1,71,1,71,1,71,3,71,1011,8,71,1,71,1,71,1,71,1,71,
        1,71,1,71,3,71,1019,8,71,1,71,4,71,1022,8,71,11,71,12,71,1023,1,
        71,1,71,1,71,1,71,1,71,1,71,3,71,1032,8,71,1,71,1,71,3,71,1036,8,
        71,1,71,1,71,1,71,1,71,1,71,1,71,1,71,1,71,1,71,1,71,1,71,1,71,1,
        71,1,71,1,71,1,71,1,71,1,71,1,71,1,71,3,71,1058,8,71,1,71,1,71,1,
        71,4,71,1063,8,71,11,71,12,71,1064,1,71,1,71,1,71,1,71,1,71,1,71,
        1,71,1,71,1,71,1,71,1,71,1,71,1,71,5,71,1080,8,71,10,71,12,71,1083,
        9,71,1,72,1,72,1,72,1,72,1,72,1,73,1,73,1,73,1,73,1,73,1,73,3,73,
        1096,8,73,1,74,1,74,1,74,1,75,1,75,1,75,1,76,1,76,1,76,3,76,1107,
        8,76,1,77,1,77,1,77,1,77,1,77,1,77,1,77,1,77,1,77,1,77,1,77,1,77,
        1,77,1,77,1,77,1,77,3,77,1125,8,77,1,78,3,78,1128,8,78,1,78,1,78,
        1,78,1,78,3,78,1134,8,78,1,79,1,79,1,80,1,80,1,80,1,80,3,80,1142,
        8,80,1,80,1,80,1,81,1,81,1,81,1,82,1,82,1,82,1,82,1,82,1,82,1,82,
        1,83,1,83,1,83,1,83,1,83,1,83,1,83,5,83,1163,8,83,10,83,12,83,1166,
        9,83,1,83,1,83,1,83,1,83,1,84,1,84,1,84,1,84,1,84,1,84,1,84,1,84,
        1,84,1,84,1,84,1,84,1,84,1,84,1,84,1,84,1,84,1,84,1,84,1,84,1,84,
        1,84,1,84,1,84,1,84,1,84,3,84,1198,8,84,1,85,1,85,1,85,1,85,1,86,
        1,86,1,86,3,86,1207,8,86,1,86,0,1,142,87,0,2,4,6,8,10,12,14,16,18,
        20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,62,
        64,66,68,70,72,74,76,78,80,82,84,86,88,90,92,94,96,98,100,102,104,
        106,108,110,112,114,116,118,120,122,124,126,128,130,132,134,136,
        138,140,142,144,146,148,150,152,154,156,158,160,162,164,166,168,
        170,172,0,34,3,0,116,116,202,202,207,207,7,0,140,140,199,199,209,
        209,217,218,225,225,227,227,230,230,1,0,154,155,2,0,7,7,158,158,
        2,0,169,170,173,173,5,0,132,132,214,214,223,223,226,226,234,245,
        1,0,177,179,2,0,202,202,207,207,2,0,180,180,245,245,2,0,31,31,105,
        105,2,0,142,142,224,224,2,0,110,110,112,112,2,0,140,140,166,166,
        1,0,2,4,2,0,144,144,227,227,2,0,140,140,142,142,2,0,210,210,212,
        212,3,0,202,202,207,207,233,233,4,0,116,116,202,202,205,205,207,
        207,3,0,191,192,196,197,246,246,2,0,262,263,269,269,9,0,25,28,41,
        42,50,69,112,112,120,120,123,123,126,126,128,129,135,136,3,0,132,
        132,137,137,146,146,2,0,121,122,131,131,2,0,206,206,215,215,2,0,
        132,132,137,137,3,0,133,134,138,139,149,149,2,0,181,181,183,183,
        2,0,70,73,82,85,1,0,86,89,1,0,90,93,4,0,74,74,76,76,78,78,80,80,
        4,0,75,75,77,77,79,79,81,81,1,0,95,96,1348,0,181,1,0,0,0,2,192,1,
        0,0,0,4,194,1,0,0,0,6,199,1,0,0,0,8,249,1,0,0,0,10,251,1,0,0,0,12,
        260,1,0,0,0,14,262,1,0,0,0,16,264,1,0,0,0,18,266,1,0,0,0,20,288,
        1,0,0,0,22,297,1,0,0,0,24,303,1,0,0,0,26,333,1,0,0,0,28,335,1,0,
        0,0,30,342,1,0,0,0,32,344,1,0,0,0,34,346,1,0,0,0,36,349,1,0,0,0,
        38,359,1,0,0,0,40,379,1,0,0,0,42,381,1,0,0,0,44,387,1,0,0,0,46,390,
        1,0,0,0,48,398,1,0,0,0,50,406,1,0,0,0,52,415,1,0,0,0,54,417,1,0,
        0,0,56,422,1,0,0,0,58,442,1,0,0,0,60,444,1,0,0,0,62,448,1,0,0,0,
        64,450,1,0,0,0,66,452,1,0,0,0,68,469,1,0,0,0,70,476,1,0,0,0,72,478,
        1,0,0,0,74,492,1,0,0,0,76,495,1,0,0,0,78,566,1,0,0,0,80,568,1,0,
        0,0,82,578,1,0,0,0,84,651,1,0,0,0,86,672,1,0,0,0,88,674,1,0,0,0,
        90,683,1,0,0,0,92,687,1,0,0,0,94,700,1,0,0,0,96,706,1,0,0,0,98,711,
        1,0,0,0,100,716,1,0,0,0,102,734,1,0,0,0,104,736,1,0,0,0,106,740,
        1,0,0,0,108,742,1,0,0,0,110,764,1,0,0,0,112,771,1,0,0,0,114,773,
        1,0,0,0,116,782,1,0,0,0,118,784,1,0,0,0,120,793,1,0,0,0,122,799,
        1,0,0,0,124,801,1,0,0,0,126,819,1,0,0,0,128,821,1,0,0,0,130,823,
        1,0,0,0,132,832,1,0,0,0,134,834,1,0,0,0,136,843,1,0,0,0,138,845,
        1,0,0,0,140,854,1,0,0,0,142,1057,1,0,0,0,144,1084,1,0,0,0,146,1095,
        1,0,0,0,148,1097,1,0,0,0,150,1100,1,0,0,0,152,1106,1,0,0,0,154,1124,
        1,0,0,0,156,1133,1,0,0,0,158,1135,1,0,0,0,160,1137,1,0,0,0,162,1145,
        1,0,0,0,164,1148,1,0,0,0,166,1155,1,0,0,0,168,1197,1,0,0,0,170,1199,
        1,0,0,0,172,1203,1,0,0,0,174,180,3,2,1,0,175,180,3,76,38,0,176,180,
        3,4,2,0,177,180,3,92,46,0,178,180,3,46,23,0,179,174,1,0,0,0,179,
        175,1,0,0,0,179,176,1,0,0,0,179,177,1,0,0,0,179,178,1,0,0,0,180,
        183,1,0,0,0,181,179,1,0,0,0,181,182,1,0,0,0,182,184,1,0,0,0,183,
        181,1,0,0,0,184,185,5,0,0,1,185,1,1,0,0,0,186,193,3,18,9,0,187,193,
        3,38,19,0,188,193,3,66,33,0,189,193,3,56,28,0,190,193,3,72,36,0,
        191,193,3,172,86,0,192,186,1,0,0,0,192,187,1,0,0,0,192,188,1,0,0,
        0,192,189,1,0,0,0,192,190,1,0,0,0,192,191,1,0,0,0,193,3,1,0,0,0,
        194,195,5,99,0,0,195,197,3,10,5,0,196,198,3,80,40,0,197,196,1,0,
        0,0,197,198,1,0,0,0,198,5,1,0,0,0,199,200,5,245,0,0,200,7,1,0,0,
        0,201,203,7,0,0,0,202,201,1,0,0,0,202,203,1,0,0,0,203,205,1,0,0,
        0,204,206,5,245,0,0,205,204,1,0,0,0,206,207,1,0,0,0,207,205,1,0,
        0,0,207,208,1,0,0,0,208,250,1,0,0,0,209,211,3,6,3,0,210,209,1,0,
        0,0,211,212,1,0,0,0,212,210,1,0,0,0,212,213,1,0,0,0,213,250,1,0,
        0,0,214,216,5,48,0,0,215,217,5,245,0,0,216,215,1,0,0,0,217,218,1,
        0,0,0,218,216,1,0,0,0,218,219,1,0,0,0,219,250,1,0,0,0,220,222,5,
        48,0,0,221,223,5,245,0,0,222,221,1,0,0,0,223,224,1,0,0,0,224,222,
        1,0,0,0,224,225,1,0,0,0,225,226,1,0,0,0,226,228,5,166,0,0,227,229,
        5,245,0,0,228,227,1,0,0,0,229,230,1,0,0,0,230,228,1,0,0,0,230,231,
        1,0,0,0,231,250,1,0,0,0,232,234,3,6,3,0,233,232,1,0,0,0,234,235,
        1,0,0,0,235,233,1,0,0,0,235,236,1,0,0,0,236,237,1,0,0,0,237,239,
        5,166,0,0,238,240,3,6,3,0,239,238,1,0,0,0,240,241,1,0,0,0,241,239,
        1,0,0,0,241,242,1,0,0,0,242,250,1,0,0,0,243,245,5,135,0,0,244,246,
        5,245,0,0,245,244,1,0,0,0,246,247,1,0,0,0,247,245,1,0,0,0,247,248,
        1,0,0,0,248,250,1,0,0,0,249,202,1,0,0,0,249,210,1,0,0,0,249,214,
        1,0,0,0,249,220,1,0,0,0,249,233,1,0,0,0,249,243,1,0,0,0,250,9,1,
        0,0,0,251,257,3,8,4,0,252,253,3,12,6,0,253,254,3,8,4,0,254,256,1,
        0,0,0,255,252,1,0,0,0,256,259,1,0,0,0,257,255,1,0,0,0,257,258,1,
        0,0,0,258,11,1,0,0,0,259,257,1,0,0,0,260,261,7,1,0,0,261,13,1,0,
        0,0,262,263,5,248,0,0,263,15,1,0,0,0,264,265,5,245,0,0,265,17,1,
        0,0,0,266,267,5,100,0,0,267,275,3,10,5,0,268,270,5,168,0,0,269,271,
        5,245,0,0,270,269,1,0,0,0,271,272,1,0,0,0,272,270,1,0,0,0,272,273,
        1,0,0,0,273,274,1,0,0,0,274,276,5,253,0,0,275,268,1,0,0,0,275,276,
        1,0,0,0,276,278,1,0,0,0,277,279,5,153,0,0,278,277,1,0,0,0,278,279,
        1,0,0,0,279,283,1,0,0,0,280,282,3,20,10,0,281,280,1,0,0,0,282,285,
        1,0,0,0,283,281,1,0,0,0,283,284,1,0,0,0,284,19,1,0,0,0,285,283,1,
        0,0,0,286,289,3,22,11,0,287,289,3,24,12,0,288,286,1,0,0,0,288,287,
        1,0,0,0,289,290,1,0,0,0,290,291,5,259,0,0,291,21,1,0,0,0,292,294,
        5,112,0,0,293,292,1,0,0,0,293,294,1,0,0,0,294,295,1,0,0,0,295,298,
        3,6,3,0,296,298,3,10,5,0,297,293,1,0,0,0,297,296,1,0,0,0,298,299,
        1,0,0,0,299,301,5,164,0,0,300,302,7,2,0,0,301,300,1,0,0,0,301,302,
        1,0,0,0,302,23,1,0,0,0,303,306,3,10,5,0,304,307,3,26,13,0,305,307,
        3,44,22,0,306,304,1,0,0,0,306,305,1,0,0,0,307,313,1,0,0,0,308,311,
        5,167,0,0,309,312,5,245,0,0,310,312,5,261,0,0,311,309,1,0,0,0,311,
        310,1,0,0,0,312,314,1,0,0,0,313,308,1,0,0,0,313,314,1,0,0,0,314,
        324,1,0,0,0,315,316,5,161,0,0,316,321,3,64,32,0,317,318,5,206,0,
        0,318,320,3,64,32,0,319,317,1,0,0,0,320,323,1,0,0,0,321,319,1,0,
        0,0,321,322,1,0,0,0,322,325,1,0,0,0,323,321,1,0,0,0,324,315,1,0,
        0,0,324,325,1,0,0,0,325,327,1,0,0,0,326,328,3,62,31,0,327,326,1,
        0,0,0,327,328,1,0,0,0,328,25,1,0,0,0,329,334,3,28,14,0,330,334,3,
        30,15,0,331,334,3,32,16,0,332,334,3,34,17,0,333,329,1,0,0,0,333,
        330,1,0,0,0,333,331,1,0,0,0,333,332,1,0,0,0,334,27,1,0,0,0,335,340,
        5,171,0,0,336,337,5,252,0,0,337,338,3,36,18,0,338,339,5,253,0,0,
        339,341,1,0,0,0,340,336,1,0,0,0,340,341,1,0,0,0,341,29,1,0,0,0,342,
        343,5,176,0,0,343,31,1,0,0,0,344,345,5,156,0,0,345,33,1,0,0,0,346,
        347,7,3,0,0,347,35,1,0,0,0,348,350,7,4,0,0,349,348,1,0,0,0,349,350,
        1,0,0,0,350,357,1,0,0,0,351,358,5,162,0,0,352,353,5,163,0,0,353,
        354,5,166,0,0,354,355,5,246,0,0,355,358,5,159,0,0,356,358,5,163,
        0,0,357,351,1,0,0,0,357,352,1,0,0,0,357,356,1,0,0,0,358,37,1,0,0,
        0,359,361,5,101,0,0,360,362,5,245,0,0,361,360,1,0,0,0,362,363,1,
        0,0,0,363,361,1,0,0,0,363,364,1,0,0,0,364,365,1,0,0,0,365,366,5,
        32,0,0,366,369,3,40,20,0,367,368,5,167,0,0,368,370,3,52,26,0,369,
        367,1,0,0,0,369,370,1,0,0,0,370,372,1,0,0,0,371,373,5,259,0,0,372,
        371,1,0,0,0,372,373,1,0,0,0,373,39,1,0,0,0,374,380,3,42,21,0,375,
        380,3,28,14,0,376,380,3,30,15,0,377,380,3,32,16,0,378,380,3,34,17,
        0,379,374,1,0,0,0,379,375,1,0,0,0,379,376,1,0,0,0,379,377,1,0,0,
        0,379,378,1,0,0,0,380,41,1,0,0,0,381,383,5,160,0,0,382,384,5,251,
        0,0,383,382,1,0,0,0,384,385,1,0,0,0,385,383,1,0,0,0,385,386,1,0,
        0,0,386,43,1,0,0,0,387,388,5,101,0,0,388,389,5,245,0,0,389,45,1,
        0,0,0,390,391,5,103,0,0,391,395,3,6,3,0,392,394,3,48,24,0,393,392,
        1,0,0,0,394,397,1,0,0,0,395,393,1,0,0,0,395,396,1,0,0,0,396,47,1,
        0,0,0,397,395,1,0,0,0,398,399,5,202,0,0,399,400,3,50,25,0,400,404,
        3,50,25,0,401,402,5,247,0,0,402,403,5,246,0,0,403,405,3,50,25,0,
        404,401,1,0,0,0,404,405,1,0,0,0,405,49,1,0,0,0,406,407,7,5,0,0,407,
        51,1,0,0,0,408,411,3,54,27,0,409,410,5,260,0,0,410,412,3,54,27,0,
        411,409,1,0,0,0,411,412,1,0,0,0,412,416,1,0,0,0,413,416,5,246,0,
        0,414,416,5,261,0,0,415,408,1,0,0,0,415,413,1,0,0,0,415,414,1,0,
        0,0,416,53,1,0,0,0,417,420,3,50,25,0,418,419,5,266,0,0,419,421,5,
        246,0,0,420,418,1,0,0,0,420,421,1,0,0,0,421,55,1,0,0,0,422,423,5,
        102,0,0,423,425,3,10,5,0,424,426,5,256,0,0,425,424,1,0,0,0,425,426,
        1,0,0,0,426,427,1,0,0,0,427,428,5,30,0,0,428,429,3,10,5,0,429,431,
        3,58,29,0,430,432,3,60,30,0,431,430,1,0,0,0,432,433,1,0,0,0,433,
        431,1,0,0,0,433,434,1,0,0,0,434,57,1,0,0,0,435,436,5,6,0,0,436,437,
        3,12,6,0,437,439,5,253,0,0,438,440,5,258,0,0,439,438,1,0,0,0,439,
        440,1,0,0,0,440,443,1,0,0,0,441,443,5,5,0,0,442,435,1,0,0,0,442,
        441,1,0,0,0,443,59,1,0,0,0,444,445,5,246,0,0,445,446,5,257,0,0,446,
        447,3,6,3,0,447,61,1,0,0,0,448,449,7,6,0,0,449,63,1,0,0,0,450,451,
        5,245,0,0,451,65,1,0,0,0,452,453,5,104,0,0,453,454,3,68,34,0,454,
        457,5,258,0,0,455,458,3,26,13,0,456,458,3,44,22,0,457,455,1,0,0,
        0,457,456,1,0,0,0,458,461,1,0,0,0,459,460,5,167,0,0,460,462,3,52,
        26,0,461,459,1,0,0,0,461,462,1,0,0,0,462,464,1,0,0,0,463,465,3,62,
        31,0,464,463,1,0,0,0,464,465,1,0,0,0,465,466,1,0,0,0,466,467,5,259,
        0,0,467,67,1,0,0,0,468,470,7,7,0,0,469,468,1,0,0,0,469,470,1,0,0,
        0,470,472,1,0,0,0,471,473,7,8,0,0,472,471,1,0,0,0,473,474,1,0,0,
        0,474,472,1,0,0,0,474,475,1,0,0,0,475,69,1,0,0,0,476,477,3,10,5,
        0,477,71,1,0,0,0,478,479,7,9,0,0,479,484,3,10,5,0,480,481,5,110,
        0,0,481,485,3,10,5,0,482,483,5,112,0,0,483,485,3,10,5,0,484,480,
        1,0,0,0,484,482,1,0,0,0,485,486,1,0,0,0,486,488,3,74,37,0,487,489,
        3,74,37,0,488,487,1,0,0,0,489,490,1,0,0,0,490,488,1,0,0,0,490,491,
        1,0,0,0,491,73,1,0,0,0,492,493,3,58,29,0,493,494,3,6,3,0,494,75,
        1,0,0,0,495,496,5,98,0,0,496,498,3,78,39,0,497,499,5,246,0,0,498,
        497,1,0,0,0,498,499,1,0,0,0,499,500,1,0,0,0,500,501,3,80,40,0,501,
        507,3,84,42,0,502,504,3,98,49,0,503,505,5,257,0,0,504,503,1,0,0,
        0,504,505,1,0,0,0,505,508,1,0,0,0,506,508,5,257,0,0,507,502,1,0,
        0,0,507,506,1,0,0,0,507,508,1,0,0,0,508,510,1,0,0,0,509,511,3,118,
        59,0,510,509,1,0,0,0,510,511,1,0,0,0,511,77,1,0,0,0,512,514,5,245,
        0,0,513,512,1,0,0,0,514,515,1,0,0,0,515,513,1,0,0,0,515,516,1,0,
        0,0,516,567,1,0,0,0,517,567,3,10,5,0,518,520,5,245,0,0,519,518,1,
        0,0,0,520,521,1,0,0,0,521,519,1,0,0,0,521,522,1,0,0,0,522,523,1,
        0,0,0,523,567,5,164,0,0,524,526,5,245,0,0,525,524,1,0,0,0,526,527,
        1,0,0,0,527,525,1,0,0,0,527,528,1,0,0,0,528,529,1,0,0,0,529,567,
        5,174,0,0,530,532,5,245,0,0,531,530,1,0,0,0,532,533,1,0,0,0,533,
        531,1,0,0,0,533,534,1,0,0,0,534,535,1,0,0,0,535,536,5,135,0,0,536,
        567,5,164,0,0,537,539,5,245,0,0,538,537,1,0,0,0,539,540,1,0,0,0,
        540,538,1,0,0,0,540,541,1,0,0,0,541,542,1,0,0,0,542,543,5,135,0,
        0,543,567,5,174,0,0,544,546,5,245,0,0,545,544,1,0,0,0,546,547,1,
        0,0,0,547,545,1,0,0,0,547,548,1,0,0,0,548,549,1,0,0,0,549,551,5,
        165,0,0,550,552,5,245,0,0,551,550,1,0,0,0,552,553,1,0,0,0,553,551,
        1,0,0,0,553,554,1,0,0,0,554,567,1,0,0,0,555,557,5,245,0,0,556,555,
        1,0,0,0,557,558,1,0,0,0,558,556,1,0,0,0,558,559,1,0,0,0,559,560,
        1,0,0,0,560,562,5,175,0,0,561,563,5,245,0,0,562,561,1,0,0,0,563,
        564,1,0,0,0,564,562,1,0,0,0,564,565,1,0,0,0,565,567,1,0,0,0,566,
        513,1,0,0,0,566,517,1,0,0,0,566,519,1,0,0,0,566,525,1,0,0,0,566,
        531,1,0,0,0,566,538,1,0,0,0,566,545,1,0,0,0,566,556,1,0,0,0,567,
        79,1,0,0,0,568,569,5,108,0,0,569,570,3,82,41,0,570,81,1,0,0,0,571,
        579,5,198,0,0,572,573,5,144,0,0,573,576,3,14,7,0,574,575,7,10,0,
        0,575,577,3,14,7,0,576,574,1,0,0,0,576,577,1,0,0,0,577,579,1,0,0,
        0,578,571,1,0,0,0,578,572,1,0,0,0,579,83,1,0,0,0,580,583,3,10,5,
        0,581,583,3,104,52,0,582,580,1,0,0,0,582,581,1,0,0,0,583,590,1,0,
        0,0,584,585,5,11,0,0,585,591,3,122,61,0,586,587,5,12,0,0,587,591,
        3,122,61,0,588,589,5,13,0,0,589,591,3,122,61,0,590,584,1,0,0,0,590,
        586,1,0,0,0,590,588,1,0,0,0,591,652,1,0,0,0,592,593,3,100,50,0,593,
        594,7,11,0,0,594,595,3,106,53,0,595,652,1,0,0,0,596,597,3,100,50,
        0,597,598,5,110,0,0,598,599,3,10,5,0,599,600,7,12,0,0,600,601,3,
        100,50,0,601,652,1,0,0,0,602,604,3,6,3,0,603,602,1,0,0,0,604,605,
        1,0,0,0,605,603,1,0,0,0,605,606,1,0,0,0,606,613,1,0,0,0,607,608,
        5,11,0,0,608,614,3,122,61,0,609,610,5,12,0,0,610,614,3,122,61,0,
        611,612,5,13,0,0,612,614,3,122,61,0,613,607,1,0,0,0,613,609,1,0,
        0,0,613,611,1,0,0,0,614,652,1,0,0,0,615,619,7,13,0,0,616,618,3,6,
        3,0,617,616,1,0,0,0,618,621,1,0,0,0,619,617,1,0,0,0,619,620,1,0,
        0,0,620,628,1,0,0,0,621,619,1,0,0,0,622,623,5,11,0,0,623,629,3,122,
        61,0,624,625,5,12,0,0,625,629,3,122,61,0,626,627,5,13,0,0,627,629,
        3,122,61,0,628,622,1,0,0,0,628,624,1,0,0,0,628,626,1,0,0,0,629,635,
        1,0,0,0,630,631,7,14,0,0,631,632,3,14,7,0,632,633,7,15,0,0,633,634,
        3,14,7,0,634,636,1,0,0,0,635,630,1,0,0,0,635,636,1,0,0,0,636,638,
        1,0,0,0,637,639,5,257,0,0,638,637,1,0,0,0,638,639,1,0,0,0,639,652,
        1,0,0,0,640,641,5,1,0,0,641,648,7,16,0,0,642,643,5,11,0,0,643,649,
        3,122,61,0,644,645,5,12,0,0,645,649,3,122,61,0,646,647,5,13,0,0,
        647,649,3,122,61,0,648,642,1,0,0,0,648,644,1,0,0,0,648,646,1,0,0,
        0,649,652,1,0,0,0,650,652,3,86,43,0,651,582,1,0,0,0,651,592,1,0,
        0,0,651,596,1,0,0,0,651,603,1,0,0,0,651,615,1,0,0,0,651,640,1,0,
        0,0,651,650,1,0,0,0,652,85,1,0,0,0,653,654,5,44,0,0,654,655,3,10,
        5,0,655,657,5,46,0,0,656,658,3,88,44,0,657,656,1,0,0,0,657,658,1,
        0,0,0,658,660,1,0,0,0,659,661,5,257,0,0,660,659,1,0,0,0,660,661,
        1,0,0,0,661,673,1,0,0,0,662,663,5,47,0,0,663,664,5,205,0,0,664,665,
        5,48,0,0,665,667,3,10,5,0,666,668,3,88,44,0,667,666,1,0,0,0,667,
        668,1,0,0,0,668,670,1,0,0,0,669,671,5,257,0,0,670,669,1,0,0,0,670,
        671,1,0,0,0,671,673,1,0,0,0,672,653,1,0,0,0,672,662,1,0,0,0,673,
        87,1,0,0,0,674,675,5,166,0,0,675,676,3,10,5,0,676,680,3,122,61,0,
        677,679,3,90,45,0,678,677,1,0,0,0,679,682,1,0,0,0,680,678,1,0,0,
        0,680,681,1,0,0,0,681,89,1,0,0,0,682,680,1,0,0,0,683,684,5,206,0,
        0,684,685,3,10,5,0,685,686,3,122,61,0,686,91,1,0,0,0,687,688,5,97,
        0,0,688,698,3,10,5,0,689,699,3,94,47,0,690,696,3,96,48,0,691,693,
        3,98,49,0,692,694,5,257,0,0,693,692,1,0,0,0,693,694,1,0,0,0,694,
        697,1,0,0,0,695,697,5,257,0,0,696,691,1,0,0,0,696,695,1,0,0,0,696,
        697,1,0,0,0,697,699,1,0,0,0,698,689,1,0,0,0,698,690,1,0,0,0,699,
        93,1,0,0,0,700,701,3,100,50,0,701,703,5,94,0,0,702,704,5,257,0,0,
        703,702,1,0,0,0,703,704,1,0,0,0,704,95,1,0,0,0,705,707,7,17,0,0,
        706,705,1,0,0,0,706,707,1,0,0,0,707,708,1,0,0,0,708,709,3,10,5,0,
        709,710,5,96,0,0,710,97,1,0,0,0,711,714,5,111,0,0,712,715,3,122,
        61,0,713,715,3,110,55,0,714,712,1,0,0,0,714,713,1,0,0,0,715,99,1,
        0,0,0,716,722,3,102,51,0,717,718,3,12,6,0,718,719,3,102,51,0,719,
        721,1,0,0,0,720,717,1,0,0,0,721,724,1,0,0,0,722,720,1,0,0,0,722,
        723,1,0,0,0,723,101,1,0,0,0,724,722,1,0,0,0,725,727,7,18,0,0,726,
        725,1,0,0,0,726,727,1,0,0,0,727,729,1,0,0,0,728,730,5,245,0,0,729,
        728,1,0,0,0,730,731,1,0,0,0,731,729,1,0,0,0,731,732,1,0,0,0,732,
        735,1,0,0,0,733,735,5,208,0,0,734,726,1,0,0,0,734,733,1,0,0,0,735,
        103,1,0,0,0,736,737,3,10,5,0,737,738,5,227,0,0,738,739,3,100,50,
        0,739,105,1,0,0,0,740,741,3,100,50,0,741,107,1,0,0,0,742,743,5,116,
        0,0,743,744,3,6,3,0,744,109,1,0,0,0,745,749,5,208,0,0,746,749,5,
        207,0,0,747,749,3,100,50,0,748,745,1,0,0,0,748,746,1,0,0,0,748,747,
        1,0,0,0,749,750,1,0,0,0,750,751,5,117,0,0,751,752,3,112,56,0,752,
        753,5,229,0,0,753,754,5,148,0,0,754,755,5,258,0,0,755,756,3,114,
        57,0,756,765,1,0,0,0,757,758,5,49,0,0,758,759,3,112,56,0,759,760,
        5,229,0,0,760,761,5,43,0,0,761,762,5,258,0,0,762,763,3,114,57,0,
        763,765,1,0,0,0,764,748,1,0,0,0,764,757,1,0,0,0,765,111,1,0,0,0,
        766,772,5,119,0,0,767,768,5,151,0,0,768,769,7,19,0,0,769,770,5,227,
        0,0,770,772,5,202,0,0,771,766,1,0,0,0,771,767,1,0,0,0,772,113,1,
        0,0,0,773,774,7,20,0,0,774,779,3,116,58,0,775,776,7,20,0,0,776,778,
        3,116,58,0,777,775,1,0,0,0,778,781,1,0,0,0,779,777,1,0,0,0,779,780,
        1,0,0,0,780,115,1,0,0,0,781,779,1,0,0,0,782,783,3,122,61,0,783,117,
        1,0,0,0,784,788,5,107,0,0,785,787,3,120,60,0,786,785,1,0,0,0,787,
        790,1,0,0,0,788,786,1,0,0,0,788,789,1,0,0,0,789,791,1,0,0,0,790,
        788,1,0,0,0,791,792,5,257,0,0,792,119,1,0,0,0,793,794,3,10,5,0,794,
        795,5,112,0,0,795,797,3,122,61,0,796,798,5,259,0,0,797,796,1,0,0,
        0,797,798,1,0,0,0,798,121,1,0,0,0,799,800,3,124,62,0,800,123,1,0,
        0,0,801,802,3,126,63,0,802,125,1,0,0,0,803,807,3,130,65,0,804,805,
        3,128,64,0,805,806,3,130,65,0,806,808,1,0,0,0,807,804,1,0,0,0,807,
        808,1,0,0,0,808,820,1,0,0,0,809,820,3,168,84,0,810,820,3,170,85,
        0,811,812,3,130,65,0,812,813,5,112,0,0,813,814,3,6,3,0,814,820,1,
        0,0,0,815,816,3,130,65,0,816,817,5,110,0,0,817,818,3,6,3,0,818,820,
        1,0,0,0,819,803,1,0,0,0,819,809,1,0,0,0,819,810,1,0,0,0,819,811,
        1,0,0,0,819,815,1,0,0,0,820,127,1,0,0,0,821,822,7,21,0,0,822,129,
        1,0,0,0,823,829,3,134,67,0,824,825,3,132,66,0,825,826,3,134,67,0,
        826,828,1,0,0,0,827,824,1,0,0,0,828,831,1,0,0,0,829,827,1,0,0,0,
        829,830,1,0,0,0,830,131,1,0,0,0,831,829,1,0,0,0,832,833,7,22,0,0,
        833,133,1,0,0,0,834,840,3,138,69,0,835,836,3,136,68,0,836,837,3,
        138,69,0,837,839,1,0,0,0,838,835,1,0,0,0,839,842,1,0,0,0,840,838,
        1,0,0,0,840,841,1,0,0,0,841,135,1,0,0,0,842,840,1,0,0,0,843,844,
        7,23,0,0,844,137,1,0,0,0,845,851,3,142,71,0,846,847,3,140,70,0,847,
        848,3,142,71,0,848,850,1,0,0,0,849,846,1,0,0,0,850,853,1,0,0,0,851,
        849,1,0,0,0,851,852,1,0,0,0,852,139,1,0,0,0,853,851,1,0,0,0,854,
        855,5,141,0,0,855,141,1,0,0,0,856,857,6,71,-1,0,857,858,5,14,0,0,
        858,859,3,142,71,0,859,860,5,140,0,0,860,863,3,142,71,0,861,862,
        5,182,0,0,862,864,5,245,0,0,863,861,1,0,0,0,863,864,1,0,0,0,864,
        1058,1,0,0,0,865,866,5,186,0,0,866,867,3,142,71,0,867,868,5,140,
        0,0,868,871,3,142,71,0,869,870,5,182,0,0,870,872,5,245,0,0,871,869,
        1,0,0,0,871,872,1,0,0,0,872,1058,1,0,0,0,873,875,5,185,0,0,874,876,
        5,119,0,0,875,874,1,0,0,0,875,876,1,0,0,0,876,877,1,0,0,0,877,1058,
        3,100,50,0,878,880,5,207,0,0,879,878,1,0,0,0,879,880,1,0,0,0,880,
        881,1,0,0,0,881,883,5,180,0,0,882,884,5,119,0,0,883,882,1,0,0,0,
        883,884,1,0,0,0,884,885,1,0,0,0,885,1058,3,100,50,0,886,889,5,246,
        0,0,887,890,5,261,0,0,888,890,5,245,0,0,889,887,1,0,0,0,889,888,
        1,0,0,0,890,891,1,0,0,0,891,892,5,227,0,0,892,1058,3,142,71,37,893,
        894,5,33,0,0,894,899,3,142,71,0,895,896,5,256,0,0,896,898,3,142,
        71,0,897,895,1,0,0,0,898,901,1,0,0,0,899,897,1,0,0,0,899,900,1,0,
        0,0,900,902,1,0,0,0,901,899,1,0,0,0,902,903,7,24,0,0,903,904,3,142,
        71,34,904,1058,1,0,0,0,905,906,5,150,0,0,906,1058,3,142,71,32,907,
        908,5,15,0,0,908,909,5,252,0,0,909,910,3,142,71,0,910,911,5,253,
        0,0,911,1058,1,0,0,0,912,913,5,17,0,0,913,918,3,142,71,0,914,915,
        5,256,0,0,915,917,3,142,71,0,916,914,1,0,0,0,917,920,1,0,0,0,918,
        916,1,0,0,0,918,919,1,0,0,0,919,921,1,0,0,0,920,918,1,0,0,0,921,
        922,5,206,0,0,922,923,3,142,71,30,923,1058,1,0,0,0,924,925,5,16,
        0,0,925,930,3,142,71,0,926,927,5,256,0,0,927,929,3,142,71,0,928,
        926,1,0,0,0,929,932,1,0,0,0,930,928,1,0,0,0,930,931,1,0,0,0,931,
        933,1,0,0,0,932,930,1,0,0,0,933,934,5,206,0,0,934,935,3,142,71,29,
        935,1058,1,0,0,0,936,937,5,207,0,0,937,938,5,210,0,0,938,939,5,225,
        0,0,939,1058,3,142,71,28,940,941,5,202,0,0,941,942,5,212,0,0,942,
        943,5,225,0,0,943,1058,3,142,71,27,944,945,5,202,0,0,945,946,5,200,
        0,0,946,947,5,225,0,0,947,1058,3,142,71,26,948,949,5,20,0,0,949,
        950,5,252,0,0,950,951,3,142,71,0,951,952,5,256,0,0,952,953,3,142,
        71,0,953,954,5,256,0,0,954,955,3,142,71,0,955,956,5,253,0,0,956,
        1058,1,0,0,0,957,958,5,21,0,0,958,959,5,252,0,0,959,960,3,142,71,
        0,960,961,5,253,0,0,961,1058,1,0,0,0,962,963,5,181,0,0,963,968,3,
        142,71,0,964,965,5,256,0,0,965,967,3,142,71,0,966,964,1,0,0,0,967,
        970,1,0,0,0,968,966,1,0,0,0,968,969,1,0,0,0,969,971,1,0,0,0,970,
        968,1,0,0,0,971,972,5,206,0,0,972,973,3,142,71,22,973,1058,1,0,0,
        0,974,975,5,183,0,0,975,980,3,142,71,0,976,977,5,256,0,0,977,979,
        3,142,71,0,978,976,1,0,0,0,979,982,1,0,0,0,980,978,1,0,0,0,980,981,
        1,0,0,0,981,983,1,0,0,0,982,980,1,0,0,0,983,984,5,206,0,0,984,985,
        3,142,71,21,985,1058,1,0,0,0,986,987,5,18,0,0,987,990,3,122,61,0,
        988,989,5,8,0,0,989,991,3,122,61,0,990,988,1,0,0,0,990,991,1,0,0,
        0,991,1058,1,0,0,0,992,997,5,1,0,0,993,994,5,202,0,0,994,998,5,212,
        0,0,995,996,5,207,0,0,996,998,5,210,0,0,997,993,1,0,0,0,997,995,
        1,0,0,0,998,999,1,0,0,0,999,1000,5,201,0,0,1000,1058,3,122,61,0,
        1001,1003,3,6,3,0,1002,1001,1,0,0,0,1003,1004,1,0,0,0,1004,1002,
        1,0,0,0,1004,1005,1,0,0,0,1005,1006,1,0,0,0,1006,1007,5,18,0,0,1007,
        1010,3,122,61,0,1008,1009,5,8,0,0,1009,1011,3,122,61,0,1010,1008,
        1,0,0,0,1010,1011,1,0,0,0,1011,1058,1,0,0,0,1012,1013,5,19,0,0,1013,
        1014,7,16,0,0,1014,1015,5,227,0,0,1015,1018,3,122,61,0,1016,1017,
        5,8,0,0,1017,1019,3,122,61,0,1018,1016,1,0,0,0,1018,1019,1,0,0,0,
        1019,1058,1,0,0,0,1020,1022,3,6,3,0,1021,1020,1,0,0,0,1022,1023,
        1,0,0,0,1023,1021,1,0,0,0,1023,1024,1,0,0,0,1024,1025,1,0,0,0,1025,
        1026,5,19,0,0,1026,1027,7,16,0,0,1027,1028,5,227,0,0,1028,1031,3,
        122,61,0,1029,1030,5,8,0,0,1030,1032,3,122,61,0,1031,1029,1,0,0,
        0,1031,1032,1,0,0,0,1032,1058,1,0,0,0,1033,1036,3,156,78,0,1034,
        1036,3,158,79,0,1035,1033,1,0,0,0,1035,1034,1,0,0,0,1036,1037,1,
        0,0,0,1037,1038,3,104,52,0,1038,1039,3,160,80,0,1039,1058,1,0,0,
        0,1040,1058,3,104,52,0,1041,1058,3,108,54,0,1042,1058,3,10,5,0,1043,
        1058,3,70,35,0,1044,1058,5,220,0,0,1045,1058,3,6,3,0,1046,1058,5,
        246,0,0,1047,1058,5,250,0,0,1048,1058,5,251,0,0,1049,1058,3,14,7,
        0,1050,1058,5,231,0,0,1051,1058,5,216,0,0,1052,1058,5,208,0,0,1053,
        1054,5,252,0,0,1054,1055,3,122,61,0,1055,1056,5,253,0,0,1056,1058,
        1,0,0,0,1057,856,1,0,0,0,1057,865,1,0,0,0,1057,873,1,0,0,0,1057,
        879,1,0,0,0,1057,886,1,0,0,0,1057,893,1,0,0,0,1057,905,1,0,0,0,1057,
        907,1,0,0,0,1057,912,1,0,0,0,1057,924,1,0,0,0,1057,936,1,0,0,0,1057,
        940,1,0,0,0,1057,944,1,0,0,0,1057,948,1,0,0,0,1057,957,1,0,0,0,1057,
        962,1,0,0,0,1057,974,1,0,0,0,1057,986,1,0,0,0,1057,992,1,0,0,0,1057,
        1002,1,0,0,0,1057,1012,1,0,0,0,1057,1021,1,0,0,0,1057,1035,1,0,0,
        0,1057,1040,1,0,0,0,1057,1041,1,0,0,0,1057,1042,1,0,0,0,1057,1043,
        1,0,0,0,1057,1044,1,0,0,0,1057,1045,1,0,0,0,1057,1046,1,0,0,0,1057,
        1047,1,0,0,0,1057,1048,1,0,0,0,1057,1049,1,0,0,0,1057,1050,1,0,0,
        0,1057,1051,1,0,0,0,1057,1052,1,0,0,0,1057,1053,1,0,0,0,1058,1081,
        1,0,0,0,1059,1062,10,33,0,0,1060,1061,5,256,0,0,1061,1063,3,142,
        71,0,1062,1060,1,0,0,0,1063,1064,1,0,0,0,1064,1062,1,0,0,0,1064,
        1065,1,0,0,0,1065,1066,1,0,0,0,1066,1067,7,24,0,0,1067,1068,3,142,
        71,34,1068,1080,1,0,0,0,1069,1070,10,36,0,0,1070,1080,3,144,72,0,
        1071,1072,10,35,0,0,1072,1073,5,256,0,0,1073,1080,3,146,73,0,1074,
        1075,10,23,0,0,1075,1076,7,25,0,0,1076,1077,3,142,71,0,1077,1078,
        3,6,3,0,1078,1080,1,0,0,0,1079,1059,1,0,0,0,1079,1069,1,0,0,0,1079,
        1071,1,0,0,0,1079,1074,1,0,0,0,1080,1083,1,0,0,0,1081,1079,1,0,0,
        0,1081,1082,1,0,0,0,1082,143,1,0,0,0,1083,1081,1,0,0,0,1084,1085,
        7,26,0,0,1085,1086,5,118,0,0,1086,1087,5,246,0,0,1087,1088,5,159,
        0,0,1088,145,1,0,0,0,1089,1096,3,148,74,0,1090,1096,3,150,75,0,1091,
        1092,3,148,74,0,1092,1093,5,206,0,0,1093,1094,3,150,75,0,1094,1096,
        1,0,0,0,1095,1089,1,0,0,0,1095,1090,1,0,0,0,1095,1091,1,0,0,0,1096,
        147,1,0,0,0,1097,1098,5,23,0,0,1098,1099,3,122,61,0,1099,149,1,0,
        0,0,1100,1101,5,24,0,0,1101,1102,3,122,61,0,1102,151,1,0,0,0,1103,
        1104,5,8,0,0,1104,1107,3,122,61,0,1105,1107,3,154,77,0,1106,1103,
        1,0,0,0,1106,1105,1,0,0,0,1107,153,1,0,0,0,1108,1109,5,144,0,0,1109,
        1125,3,14,7,0,1110,1111,5,227,0,0,1111,1112,3,14,7,0,1112,1113,5,
        140,0,0,1113,1114,3,14,7,0,1114,1125,1,0,0,0,1115,1116,5,227,0,0,
        1116,1117,3,14,7,0,1117,1118,5,142,0,0,1118,1119,3,14,7,0,1119,1125,
        1,0,0,0,1120,1121,5,140,0,0,1121,1125,3,14,7,0,1122,1123,5,142,0,
        0,1123,1125,3,14,7,0,1124,1108,1,0,0,0,1124,1110,1,0,0,0,1124,1115,
        1,0,0,0,1124,1120,1,0,0,0,1124,1122,1,0,0,0,1125,155,1,0,0,0,1126,
        1128,5,207,0,0,1127,1126,1,0,0,0,1127,1128,1,0,0,0,1128,1129,1,0,
        0,0,1129,1134,5,180,0,0,1130,1134,5,16,0,0,1131,1134,5,17,0,0,1132,
        1134,5,185,0,0,1133,1127,1,0,0,0,1133,1130,1,0,0,0,1133,1131,1,0,
        0,0,1133,1132,1,0,0,0,1134,157,1,0,0,0,1135,1136,7,27,0,0,1136,159,
        1,0,0,0,1137,1141,5,218,0,0,1138,1142,3,162,81,0,1139,1142,3,164,
        82,0,1140,1142,3,166,83,0,1141,1138,1,0,0,0,1141,1139,1,0,0,0,1141,
        1140,1,0,0,0,1142,1143,1,0,0,0,1143,1144,5,257,0,0,1144,161,1,0,
        0,0,1145,1146,5,119,0,0,1146,1147,3,10,5,0,1147,163,1,0,0,0,1148,
        1149,5,202,0,0,1149,1150,3,10,5,0,1150,1151,5,144,0,0,1151,1152,
        3,6,3,0,1152,1153,5,224,0,0,1153,1154,3,6,3,0,1154,165,1,0,0,0,1155,
        1156,5,202,0,0,1156,1157,3,10,5,0,1157,1158,5,209,0,0,1158,1159,
        5,254,0,0,1159,1164,3,6,3,0,1160,1161,5,256,0,0,1161,1163,3,6,3,
        0,1162,1160,1,0,0,0,1163,1166,1,0,0,0,1164,1162,1,0,0,0,1164,1165,
        1,0,0,0,1165,1167,1,0,0,0,1166,1164,1,0,0,0,1167,1168,5,206,0,0,
        1168,1169,3,6,3,0,1169,1170,5,255,0,0,1170,167,1,0,0,0,1171,1172,
        3,142,71,0,1172,1173,7,28,0,0,1173,1198,1,0,0,0,1174,1175,3,142,
        71,0,1175,1176,7,29,0,0,1176,1177,5,246,0,0,1177,1178,5,157,0,0,
        1178,1198,1,0,0,0,1179,1180,3,142,71,0,1180,1181,7,30,0,0,1181,1182,
        3,6,3,0,1182,1198,1,0,0,0,1183,1184,3,142,71,0,1184,1185,7,31,0,
        0,1185,1186,3,6,3,0,1186,1198,1,0,0,0,1187,1188,3,142,71,0,1188,
        1189,7,32,0,0,1189,1190,3,6,3,0,1190,1198,1,0,0,0,1191,1192,3,100,
        50,0,1192,1193,5,94,0,0,1193,1198,1,0,0,0,1194,1195,3,142,71,0,1195,
        1196,5,96,0,0,1196,1198,1,0,0,0,1197,1171,1,0,0,0,1197,1174,1,0,
        0,0,1197,1179,1,0,0,0,1197,1183,1,0,0,0,1197,1187,1,0,0,0,1197,1191,
        1,0,0,0,1197,1194,1,0,0,0,1198,169,1,0,0,0,1199,1200,5,98,0,0,1200,
        1201,3,10,5,0,1201,1202,7,33,0,0,1202,171,1,0,0,0,1203,1204,5,106,
        0,0,1204,1206,3,10,5,0,1205,1207,5,259,0,0,1206,1205,1,0,0,0,1206,
        1207,1,0,0,0,1207,173,1,0,0,0,139,179,181,192,197,202,207,212,218,
        224,230,235,241,247,249,257,272,275,278,283,288,293,297,301,306,
        311,313,321,324,327,333,340,349,357,363,369,372,379,385,395,404,
        411,415,420,425,433,439,442,457,461,464,469,474,484,490,498,504,
        507,510,515,521,527,533,540,547,553,558,564,566,576,578,582,590,
        605,613,619,628,635,638,648,651,657,660,667,670,672,680,693,696,
        698,703,706,714,722,726,731,734,748,764,771,779,788,797,807,819,
        829,840,851,863,871,875,879,883,889,899,918,930,968,980,990,997,
        1004,1010,1018,1023,1031,1035,1057,1064,1079,1081,1095,1106,1124,
        1127,1133,1141,1164,1197,1206
    ]

class RegelSpraakParser ( Parser ):

    grammarFileName = "RegelSpraak.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'het aantal dagen in'", "'het kwartaal'", 
                     "'het deel per maand'", "'het deel per jaar'", "'(voor het attribuut zonder voorzetsel):'", 
                     "'(na het attribuut met voorzetsel'", "'Datum en tijd in millisecondes'", 
                     "'gedurende de tijd dat'", "'gedurende het gehele'", 
                     "'gedurende de gehele'", "'moet berekend worden als'", 
                     "'moet gesteld worden op'", "'moet ge\\u00EFnitialiseerd worden op'", 
                     "'de absolute tijdsduur van'", "'de absolute waarde van'", 
                     "'de maximale waarde van'", "'de minimale waarde van'", 
                     "'het totaal van'", "'het tijdsevenredig deel per'", 
                     "'de datum met jaar, maand en dag'", "'de eerste paasdag van'", 
                     "'Als onverdeelde rest blijft'", "'met een minimum van'", 
                     "'met een maximum van'", "'groter of gelijk aan'", 
                     "'kleiner of gelijk aan'", "'later of gelijk aan'", 
                     "'eerder of gelijk aan'", "', waarbij wordt verdeeld'", 
                     "', bestaande uit de'", "'Wederkerig feittype'", "'is van het type'", 
                     "'de concatenatie van'", "'het volgende criterium:'", 
                     "'volgende criteria:'", "'bij even groot criterium'", 
                     "'op volgorde van'", "'naar rato van'", "'numeriek met exact'", 
                     "'aan de elfproef'", "'groter is dan'", "'kleiner is dan'", 
                     "'wordt voldaan'", "<INVALID>", "'wordt een nieuw'", 
                     "'aangemaakt'", "'Cre\\u00EBer'", "'nieuwe'", "<INVALID>", 
                     "'is gelijk aan'", "'is ongelijk aan'", "'is kleiner dan'", 
                     "'is kleiner of gelijk aan'", "'is groter dan'", "'is groter of gelijk aan'", 
                     "'zijn gelijk aan'", "'zijn ongelijk aan'", "'zijn groter dan'", 
                     "'zijn groter of gelijk aan'", "'zijn kleiner dan'", 
                     "'zijn kleiner of gelijk aan'", "'is later dan'", "'is later of gelijk aan'", 
                     "'is eerder dan'", "'is eerder of gelijk aan'", "'zijn later dan'", 
                     "'zijn later of gelijk aan'", "'zijn eerder dan'", 
                     "'zijn eerder of gelijk aan'", "'is leeg'", "'is gevuld'", 
                     "'zijn leeg'", "'zijn gevuld'", "'is kenmerk'", "'is rol'", 
                     "'zijn kenmerk'", "'zijn rol'", "'is niet kenmerk'", 
                     "'is niet rol'", "'zijn niet kenmerk'", "'zijn niet rol'", 
                     "'voldoet aan de elfproef'", "'voldoen aan de elfproef'", 
                     "'voldoet niet aan de elfproef'", "'voldoen niet aan de elfproef'", 
                     "'is numeriek met exact'", "'is niet numeriek met exact'", 
                     "'zijn numeriek met exact'", "'zijn niet numeriek met exact'", 
                     "'is een dagsoort'", "'zijn een dagsoort'", "'is geen dagsoort'", 
                     "'zijn geen dagsoort'", "'moeten uniek zijn'", "'is gevuurd'", 
                     "'is inconsistent'", "'Consistentieregel'", "'Regel'", 
                     "'Beslistabel'", "'Objecttype'", "'Domein'", "'Dimensie'", 
                     "'Eenheidsysteem'", "'Parameter'", "'FeitType'", "'Dagsoort'", 
                     "'Daarbij geldt:'", "'geldig'", "'hebben'", "'heeft'", 
                     "'indien'", "'is'", "'moet'", "'moeten'", "'wordt verdeeld over'", 
                     "'zijn'", "'aan'", "'afgerond op'", "'alle'", "'eerder dan'", 
                     "'gedeeld door'", "'gedeeld door (ABS)'", "'gelijk aan'", 
                     "'gevuld'", "'gevuurd'", "'groter dan'", "'inconsistent'", 
                     "'kleiner dan'", "'later dan'", "'leeg'", "'maal'", 
                     "'min'", "'naar beneden'", "'naar boven'", "'niet'", 
                     "'ongelijk aan'", "'plus'", "'rekenkundig'", "'richting nul'", 
                     "'tot'", "'tot de macht'", "'tot en met'", "'uniek'", 
                     "'vanaf'", "'verenigd met'", "'verminderd met'", "'voldoen'", 
                     "'voldoet'", "'weg van nul'", "'de wortel van'", "'tenminste'", 
                     "'ten minste'", "'(bezield)'", "'(bezittelijk)'", "'(bijvoeglijk)'", 
                     "'Boolean'", "'cijfers'", "'Datum in dagen'", "'decimalen'", 
                     "'Enumeratie'", "'gedimensioneerd met'", "'geheel getal'", 
                     "'getal'", "'kenmerk'", "'kenmerken'", "'met'", "'met eenheid'", 
                     "'(mv:'", "'negatief'", "'niet-negatief'", "'Numeriek'", 
                     "'Percentage'", "'positief'", "'rol'", "'rollen'", 
                     "'Tekst'", "'voor elk jaar'", "'voor elke dag'", "'voor elke maand'", 
                     "'aantal'", "'de eerste van'", "'in hele'", "'de laatste van'", 
                     "'reeks van teksten en waarden'", "'de som van'", "'de tijdsduur van'", 
                     "'afnemende'", "'in gelijke delen'", "'over.'", "'toenemende'", 
                     "'drie'", "'\\u00E9\\u00E9n'", "'geen van de'", "'precies'", 
                     "'ten hoogste'", "'twee'", "'vier'", "'altijd'", "'bij'", 
                     "'dag'", "'dat'", "'de'", "'dd.'", "'die'", "'een'", 
                     "'en'", "'het'", "'hij'", "'in'", "'jaar'", "'kwartaal'", 
                     "'maand'", "'milliseconde'", "'minuut'", "'of'", "'onwaar'", 
                     "'op'", "'over'", "'periode'", "'Rekendatum'", "'Rekenjaar'", 
                     "'regelversie'", "'seconde'", "'t/m'", "'uit'", "'uur'", 
                     "'van'", "'volgende voorwaarde'", "'volgende voorwaarden'", 
                     "'voor'", "'waar'", "'week'", "'er'", "'meter'", "'kilogram'", 
                     "'voet'", "'pond'", "'mijl'", "'m'", "'kg'", "'s'", 
                     "'ft'", "'lb'", "'mi'", "<INVALID>", "<INVALID>", "'='", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "'('", "')'", "'{'", "'}'", "','", "'.'", "':'", "';'", 
                     "'/'", "'%'", "'\\u2022'", "'*'", "'\\u00AB'", "'\\u00BB'", 
                     "'^'", "<INVALID>", "<INVALID>", "'-'" ]

    symbolicNames = [ "<INVALID>", "HET_AANTAL_DAGEN_IN", "HET_KWARTAAL", 
                      "HET_DEEL_PER_MAAND", "HET_DEEL_PER_JAAR", "VOOR_HET_ATTRIBUUT_ZONDER_VOORZETSEL", 
                      "NA_HET_ATTRIBUUT_MET_VOORZETSEL", "DATUM_TIJD_MILLIS", 
                      "GEDURENDE_DE_TIJD_DAT", "GEDURENDE_HET_GEHELE", "GEDURENDE_DE_GEHELE", 
                      "WORDT_BEREKEND_ALS", "WORDT_GESTELD_OP", "WORDT_GEINITIALISEERD_OP", 
                      "DE_ABSOLUTE_TIJDSDUUR_VAN", "DE_ABSOLUTE_WAARDE_VAN", 
                      "DE_MAXIMALE_WAARDE_VAN", "DE_MINIMALE_WAARDE_VAN", 
                      "HET_TOTAAL_VAN", "HET_TIJDSEVENREDIG_DEEL_PER", "DE_DATUM_MET", 
                      "DE_EERSTE_PAASDAG_VAN", "ALS_ONVERDEELDE_REST_BLIJFT", 
                      "MET_EEN_MINIMUM_VAN", "MET_EEN_MAXIMUM_VAN", "GROTER_OF_GELIJK_AAN", 
                      "KLEINER_OF_GELIJK_AAN", "LATER_OF_GELIJK_AAN", "EERDER_OF_GELIJK_AAN", 
                      "WAARBIJ_WORDT_VERDEELD", "BESTAANDE_UIT", "WEDERKERIG_FEITTYPE", 
                      "IS_VAN_HET_TYPE", "CONCATENATIE_VAN", "VOLGEND_CRITERIUM", 
                      "VOLGENDE_CRITERIA", "BIJ_EVEN_GROOT_CRITERIUM", "OP_VOLGORDE_VAN", 
                      "NAAR_RATO_VAN", "NUMERIEK_MET_EXACT", "AAN_DE_ELFPROEF", 
                      "GROTER_IS_DAN", "KLEINER_IS_DAN", "WORDT_VOLDAAN", 
                      "ER_WORDT_EEN_NIEUW", "WORDT_EEN_NIEUW", "AANGEMAAKT", 
                      "CREEER", "NIEUWE", "ER_AAN", "IS_GELIJK_AAN", "IS_ONGELIJK_AAN", 
                      "IS_KLEINER_DAN", "IS_KLEINER_OF_GELIJK_AAN", "IS_GROTER_DAN", 
                      "IS_GROTER_OF_GELIJK_AAN", "ZIJN_GELIJK_AAN", "ZIJN_ONGELIJK_AAN", 
                      "ZIJN_GROTER_DAN", "ZIJN_GROTER_OF_GELIJK_AAN", "ZIJN_KLEINER_DAN", 
                      "ZIJN_KLEINER_OF_GELIJK_AAN", "IS_LATER_DAN", "IS_LATER_OF_GELIJK_AAN", 
                      "IS_EERDER_DAN", "IS_EERDER_OF_GELIJK_AAN", "ZIJN_LATER_DAN", 
                      "ZIJN_LATER_OF_GELIJK_AAN", "ZIJN_EERDER_DAN", "ZIJN_EERDER_OF_GELIJK_AAN", 
                      "IS_LEEG", "IS_GEVULD", "ZIJN_LEEG", "ZIJN_GEVULD", 
                      "IS_KENMERK", "IS_ROL", "ZIJN_KENMERK", "ZIJN_ROL", 
                      "IS_NIET_KENMERK", "IS_NIET_ROL", "ZIJN_NIET_KENMERK", 
                      "ZIJN_NIET_ROL", "VOLDOET_AAN_DE_ELFPROEF", "VOLDOEN_AAN_DE_ELFPROEF", 
                      "VOLDOET_NIET_AAN_DE_ELFPROEF", "VOLDOEN_NIET_AAN_DE_ELFPROEF", 
                      "IS_NUMERIEK_MET_EXACT", "IS_NIET_NUMERIEK_MET_EXACT", 
                      "ZIJN_NUMERIEK_MET_EXACT", "ZIJN_NIET_NUMERIEK_MET_EXACT", 
                      "IS_EEN_DAGSOORT", "ZIJN_EEN_DAGSOORT", "IS_GEEN_DAGSOORT", 
                      "ZIJN_GEEN_DAGSOORT", "MOETEN_UNIEK_ZIJN", "IS_GEVUURD", 
                      "IS_INCONSISTENT", "CONSISTENTIEREGEL", "REGEL", "BESLISTABEL", 
                      "OBJECTTYPE", "DOMEIN", "DIMENSIE", "EENHEIDSYSTEEM", 
                      "PARAMETER", "FEITTYPE", "DAGSOORT", "DAARBIJ_GELDT", 
                      "GELDIG", "HEBBEN", "HEEFT", "INDIEN", "IS", "MOET", 
                      "MOETEN", "WORDT_VERDEELD_OVER", "ZIJN", "AAN", "AFGEROND_OP", 
                      "ALLE", "EERDER_DAN", "GEDEELD_DOOR", "GEDEELD_DOOR_ABS", 
                      "GELIJK_AAN", "GEVULD", "GEVUURD", "GROTER_DAN", "INCONSISTENT", 
                      "KLEINER_DAN", "LATER_DAN", "LEEG", "MAAL", "MIN", 
                      "NAAR_BENEDEN", "NAAR_BOVEN", "NIET", "ONGELIJK_AAN", 
                      "PLUS", "REKENKUNDIG", "RICHTING_NUL", "TOT", "TOT_DE_MACHT", 
                      "TOT_EN_MET", "UNIEK", "VANAF", "VERENIGD_MET", "VERMINDERD_MET", 
                      "VOLDOEN", "VOLDOET", "WEG_VAN_NUL", "DE_WORTEL_VAN", 
                      "TENMINSTE", "TEN_MINSTE", "BEZIELD", "BEZITTELIJK", 
                      "BIJVOEGLIJK", "BOOLEAN", "CIJFERS", "DATUM_IN_DAGEN", 
                      "DECIMALEN", "ENUMERATIE", "GEDIMENSIONEERD_MET", 
                      "GEHEEL_GETAL", "GETAL", "KENMERK", "KENMERKEN", "MET", 
                      "MET_EENHEID", "MV_START", "NEGATIEF", "NIET_NEGATIEF", 
                      "NUMERIEK", "PERCENTAGE", "POSITIEF", "ROL", "ROLLEN", 
                      "TEKST", "VOOR_ELK_JAAR", "VOOR_ELKE_DAG", "VOOR_ELKE_MAAND", 
                      "AANTAL", "EERSTE_VAN", "IN_HELE", "LAATSTE_VAN", 
                      "REEKS_VAN_TEKSTEN_EN_WAARDEN", "SOM_VAN", "TIJDSDUUR_VAN", 
                      "AFNEMENDE", "IN_GELIJKE_DELEN", "OVER_VERDELING", 
                      "TOENEMENDE", "DRIE_TELWOORD", "EEN_TELWOORD", "GEEN_VAN_DE", 
                      "PRECIES", "TEN_HOOGSTE", "TWEE_TELWOORD", "VIER_TELWOORD", 
                      "ALTIJD", "BIJ", "DAG", "DAT", "DE", "DD_PUNT", "DIE", 
                      "EEN", "EN", "HET", "HIJ", "IN", "JAAR", "KWARTAAL", 
                      "MAAND", "MILLISECONDE", "MINUUT", "OF", "ONWAAR", 
                      "OP", "OVER", "PERIODE", "REKENDATUM", "REKENJAAR", 
                      "REGELVERSIE", "SECONDE", "TM", "UIT", "UUR", "VAN", 
                      "VOLGENDE_VOORWAARDE", "VOLGENDE_VOORWAARDEN", "VOOR", 
                      "WAAR", "WEEK", "ER", "METER", "KILOGRAM", "VOET", 
                      "POND", "MIJL", "M", "KG", "S", "FT", "LB", "MI", 
                      "IDENTIFIER", "NUMBER", "EQUALS", "DATE_TIME_LITERAL", 
                      "PERCENTAGE_LITERAL", "STRING_LITERAL", "ENUM_LITERAL", 
                      "LPAREN", "RPAREN", "LBRACE", "RBRACE", "COMMA", "DOT", 
                      "COLON", "SEMICOLON", "SLASH", "PERCENT_SIGN", "BULLET", 
                      "ASTERISK", "L_ANGLE_QUOTE", "R_ANGLE_QUOTE", "CARET", 
                      "WS", "LINE_COMMENT", "MINUS" ]

    RULE_regelSpraakDocument = 0
    RULE_definitie = 1
    RULE_beslistabel = 2
    RULE_identifier = 3
    RULE_naamPhrase = 4
    RULE_naamwoord = 5
    RULE_voorzetsel = 6
    RULE_datumLiteral = 7
    RULE_unit = 8
    RULE_objectTypeDefinition = 9
    RULE_objectTypeMember = 10
    RULE_kenmerkSpecificatie = 11
    RULE_attribuutSpecificatie = 12
    RULE_datatype = 13
    RULE_numeriekDatatype = 14
    RULE_tekstDatatype = 15
    RULE_booleanDatatype = 16
    RULE_datumTijdDatatype = 17
    RULE_getalSpecificatie = 18
    RULE_domeinDefinition = 19
    RULE_domeinType = 20
    RULE_enumeratieSpecificatie = 21
    RULE_domeinRef = 22
    RULE_eenheidsysteemDefinition = 23
    RULE_eenheidEntry = 24
    RULE_unitIdentifier = 25
    RULE_eenheidExpressie = 26
    RULE_eenheidMacht = 27
    RULE_dimensieDefinition = 28
    RULE_voorzetselSpecificatie = 29
    RULE_labelWaardeSpecificatie = 30
    RULE_tijdlijn = 31
    RULE_dimensieRef = 32
    RULE_parameterDefinition = 33
    RULE_parameterNamePhrase = 34
    RULE_parameterMetLidwoord = 35
    RULE_feitTypeDefinition = 36
    RULE_rolSpecificatie = 37
    RULE_regel = 38
    RULE_regelName = 39
    RULE_regelVersie = 40
    RULE_versieGeldigheid = 41
    RULE_resultaatDeel = 42
    RULE_objectCreatie = 43
    RULE_objectAttributeInit = 44
    RULE_attributeInitVervolg = 45
    RULE_consistentieregel = 46
    RULE_uniekzijnResultaat = 47
    RULE_inconsistentResultaat = 48
    RULE_voorwaardeDeel = 49
    RULE_onderwerpReferentie = 50
    RULE_basisOnderwerp = 51
    RULE_attribuutReferentie = 52
    RULE_kenmerkNaam = 53
    RULE_bezieldeReferentie = 54
    RULE_toplevelSamengesteldeVoorwaarde = 55
    RULE_voorwaardeKwantificatie = 56
    RULE_samengesteldeVoorwaardeOnderdeel = 57
    RULE_genesteVoorwaarde = 58
    RULE_variabeleDeel = 59
    RULE_variabeleToekenning = 60
    RULE_expressie = 61
    RULE_logicalExpression = 62
    RULE_comparisonExpression = 63
    RULE_comparisonOperator = 64
    RULE_additiveExpression = 65
    RULE_additiveOperator = 66
    RULE_multiplicativeExpression = 67
    RULE_multiplicativeOperator = 68
    RULE_powerExpression = 69
    RULE_powerOperator = 70
    RULE_primaryExpression = 71
    RULE_afronding = 72
    RULE_begrenzing = 73
    RULE_begrenzingMinimum = 74
    RULE_begrenzingMaximum = 75
    RULE_conditieBijExpressie = 76
    RULE_periodevergelijkingEnkelvoudig = 77
    RULE_getalAggregatieFunctie = 78
    RULE_datumAggregatieFunctie = 79
    RULE_dimensieSelectie = 80
    RULE_aggregerenOverAlleDimensies = 81
    RULE_aggregerenOverVerzameling = 82
    RULE_aggregerenOverBereik = 83
    RULE_unaryCondition = 84
    RULE_regelStatusCondition = 85
    RULE_dagsoortDefinition = 86

    ruleNames =  [ "regelSpraakDocument", "definitie", "beslistabel", "identifier", 
                   "naamPhrase", "naamwoord", "voorzetsel", "datumLiteral", 
                   "unit", "objectTypeDefinition", "objectTypeMember", "kenmerkSpecificatie", 
                   "attribuutSpecificatie", "datatype", "numeriekDatatype", 
                   "tekstDatatype", "booleanDatatype", "datumTijdDatatype", 
                   "getalSpecificatie", "domeinDefinition", "domeinType", 
                   "enumeratieSpecificatie", "domeinRef", "eenheidsysteemDefinition", 
                   "eenheidEntry", "unitIdentifier", "eenheidExpressie", 
                   "eenheidMacht", "dimensieDefinition", "voorzetselSpecificatie", 
                   "labelWaardeSpecificatie", "tijdlijn", "dimensieRef", 
                   "parameterDefinition", "parameterNamePhrase", "parameterMetLidwoord", 
                   "feitTypeDefinition", "rolSpecificatie", "regel", "regelName", 
                   "regelVersie", "versieGeldigheid", "resultaatDeel", "objectCreatie", 
                   "objectAttributeInit", "attributeInitVervolg", "consistentieregel", 
                   "uniekzijnResultaat", "inconsistentResultaat", "voorwaardeDeel", 
                   "onderwerpReferentie", "basisOnderwerp", "attribuutReferentie", 
                   "kenmerkNaam", "bezieldeReferentie", "toplevelSamengesteldeVoorwaarde", 
                   "voorwaardeKwantificatie", "samengesteldeVoorwaardeOnderdeel", 
                   "genesteVoorwaarde", "variabeleDeel", "variabeleToekenning", 
                   "expressie", "logicalExpression", "comparisonExpression", 
                   "comparisonOperator", "additiveExpression", "additiveOperator", 
                   "multiplicativeExpression", "multiplicativeOperator", 
                   "powerExpression", "powerOperator", "primaryExpression", 
                   "afronding", "begrenzing", "begrenzingMinimum", "begrenzingMaximum", 
                   "conditieBijExpressie", "periodevergelijkingEnkelvoudig", 
                   "getalAggregatieFunctie", "datumAggregatieFunctie", "dimensieSelectie", 
                   "aggregerenOverAlleDimensies", "aggregerenOverVerzameling", 
                   "aggregerenOverBereik", "unaryCondition", "regelStatusCondition", 
                   "dagsoortDefinition" ]

    EOF = Token.EOF
    HET_AANTAL_DAGEN_IN=1
    HET_KWARTAAL=2
    HET_DEEL_PER_MAAND=3
    HET_DEEL_PER_JAAR=4
    VOOR_HET_ATTRIBUUT_ZONDER_VOORZETSEL=5
    NA_HET_ATTRIBUUT_MET_VOORZETSEL=6
    DATUM_TIJD_MILLIS=7
    GEDURENDE_DE_TIJD_DAT=8
    GEDURENDE_HET_GEHELE=9
    GEDURENDE_DE_GEHELE=10
    WORDT_BEREKEND_ALS=11
    WORDT_GESTELD_OP=12
    WORDT_GEINITIALISEERD_OP=13
    DE_ABSOLUTE_TIJDSDUUR_VAN=14
    DE_ABSOLUTE_WAARDE_VAN=15
    DE_MAXIMALE_WAARDE_VAN=16
    DE_MINIMALE_WAARDE_VAN=17
    HET_TOTAAL_VAN=18
    HET_TIJDSEVENREDIG_DEEL_PER=19
    DE_DATUM_MET=20
    DE_EERSTE_PAASDAG_VAN=21
    ALS_ONVERDEELDE_REST_BLIJFT=22
    MET_EEN_MINIMUM_VAN=23
    MET_EEN_MAXIMUM_VAN=24
    GROTER_OF_GELIJK_AAN=25
    KLEINER_OF_GELIJK_AAN=26
    LATER_OF_GELIJK_AAN=27
    EERDER_OF_GELIJK_AAN=28
    WAARBIJ_WORDT_VERDEELD=29
    BESTAANDE_UIT=30
    WEDERKERIG_FEITTYPE=31
    IS_VAN_HET_TYPE=32
    CONCATENATIE_VAN=33
    VOLGEND_CRITERIUM=34
    VOLGENDE_CRITERIA=35
    BIJ_EVEN_GROOT_CRITERIUM=36
    OP_VOLGORDE_VAN=37
    NAAR_RATO_VAN=38
    NUMERIEK_MET_EXACT=39
    AAN_DE_ELFPROEF=40
    GROTER_IS_DAN=41
    KLEINER_IS_DAN=42
    WORDT_VOLDAAN=43
    ER_WORDT_EEN_NIEUW=44
    WORDT_EEN_NIEUW=45
    AANGEMAAKT=46
    CREEER=47
    NIEUWE=48
    ER_AAN=49
    IS_GELIJK_AAN=50
    IS_ONGELIJK_AAN=51
    IS_KLEINER_DAN=52
    IS_KLEINER_OF_GELIJK_AAN=53
    IS_GROTER_DAN=54
    IS_GROTER_OF_GELIJK_AAN=55
    ZIJN_GELIJK_AAN=56
    ZIJN_ONGELIJK_AAN=57
    ZIJN_GROTER_DAN=58
    ZIJN_GROTER_OF_GELIJK_AAN=59
    ZIJN_KLEINER_DAN=60
    ZIJN_KLEINER_OF_GELIJK_AAN=61
    IS_LATER_DAN=62
    IS_LATER_OF_GELIJK_AAN=63
    IS_EERDER_DAN=64
    IS_EERDER_OF_GELIJK_AAN=65
    ZIJN_LATER_DAN=66
    ZIJN_LATER_OF_GELIJK_AAN=67
    ZIJN_EERDER_DAN=68
    ZIJN_EERDER_OF_GELIJK_AAN=69
    IS_LEEG=70
    IS_GEVULD=71
    ZIJN_LEEG=72
    ZIJN_GEVULD=73
    IS_KENMERK=74
    IS_ROL=75
    ZIJN_KENMERK=76
    ZIJN_ROL=77
    IS_NIET_KENMERK=78
    IS_NIET_ROL=79
    ZIJN_NIET_KENMERK=80
    ZIJN_NIET_ROL=81
    VOLDOET_AAN_DE_ELFPROEF=82
    VOLDOEN_AAN_DE_ELFPROEF=83
    VOLDOET_NIET_AAN_DE_ELFPROEF=84
    VOLDOEN_NIET_AAN_DE_ELFPROEF=85
    IS_NUMERIEK_MET_EXACT=86
    IS_NIET_NUMERIEK_MET_EXACT=87
    ZIJN_NUMERIEK_MET_EXACT=88
    ZIJN_NIET_NUMERIEK_MET_EXACT=89
    IS_EEN_DAGSOORT=90
    ZIJN_EEN_DAGSOORT=91
    IS_GEEN_DAGSOORT=92
    ZIJN_GEEN_DAGSOORT=93
    MOETEN_UNIEK_ZIJN=94
    IS_GEVUURD=95
    IS_INCONSISTENT=96
    CONSISTENTIEREGEL=97
    REGEL=98
    BESLISTABEL=99
    OBJECTTYPE=100
    DOMEIN=101
    DIMENSIE=102
    EENHEIDSYSTEEM=103
    PARAMETER=104
    FEITTYPE=105
    DAGSOORT=106
    DAARBIJ_GELDT=107
    GELDIG=108
    HEBBEN=109
    HEEFT=110
    INDIEN=111
    IS=112
    MOET=113
    MOETEN=114
    WORDT_VERDEELD_OVER=115
    ZIJN=116
    AAN=117
    AFGEROND_OP=118
    ALLE=119
    EERDER_DAN=120
    GEDEELD_DOOR=121
    GEDEELD_DOOR_ABS=122
    GELIJK_AAN=123
    GEVULD=124
    GEVUURD=125
    GROTER_DAN=126
    INCONSISTENT=127
    KLEINER_DAN=128
    LATER_DAN=129
    LEEG=130
    MAAL=131
    MIN=132
    NAAR_BENEDEN=133
    NAAR_BOVEN=134
    NIET=135
    ONGELIJK_AAN=136
    PLUS=137
    REKENKUNDIG=138
    RICHTING_NUL=139
    TOT=140
    TOT_DE_MACHT=141
    TOT_EN_MET=142
    UNIEK=143
    VANAF=144
    VERENIGD_MET=145
    VERMINDERD_MET=146
    VOLDOEN=147
    VOLDOET=148
    WEG_VAN_NUL=149
    DE_WORTEL_VAN=150
    TENMINSTE=151
    TEN_MINSTE=152
    BEZIELD=153
    BEZITTELIJK=154
    BIJVOEGLIJK=155
    BOOLEAN=156
    CIJFERS=157
    DATUM_IN_DAGEN=158
    DECIMALEN=159
    ENUMERATIE=160
    GEDIMENSIONEERD_MET=161
    GEHEEL_GETAL=162
    GETAL=163
    KENMERK=164
    KENMERKEN=165
    MET=166
    MET_EENHEID=167
    MV_START=168
    NEGATIEF=169
    NIET_NEGATIEF=170
    NUMERIEK=171
    PERCENTAGE=172
    POSITIEF=173
    ROL=174
    ROLLEN=175
    TEKST=176
    VOOR_ELK_JAAR=177
    VOOR_ELKE_DAG=178
    VOOR_ELKE_MAAND=179
    AANTAL=180
    EERSTE_VAN=181
    IN_HELE=182
    LAATSTE_VAN=183
    REEKS_VAN_TEKSTEN_EN_WAARDEN=184
    SOM_VAN=185
    TIJDSDUUR_VAN=186
    AFNEMENDE=187
    IN_GELIJKE_DELEN=188
    OVER_VERDELING=189
    TOENEMENDE=190
    DRIE_TELWOORD=191
    EEN_TELWOORD=192
    GEEN_VAN_DE=193
    PRECIES=194
    TEN_HOOGSTE=195
    TWEE_TELWOORD=196
    VIER_TELWOORD=197
    ALTIJD=198
    BIJ=199
    DAG=200
    DAT=201
    DE=202
    DD_PUNT=203
    DIE=204
    EEN=205
    EN=206
    HET=207
    HIJ=208
    IN=209
    JAAR=210
    KWARTAAL=211
    MAAND=212
    MILLISECONDE=213
    MINUUT=214
    OF=215
    ONWAAR=216
    OP=217
    OVER=218
    PERIODE=219
    REKENDATUM=220
    REKENJAAR=221
    REGELVERSIE=222
    SECONDE=223
    TM=224
    UIT=225
    UUR=226
    VAN=227
    VOLGENDE_VOORWAARDE=228
    VOLGENDE_VOORWAARDEN=229
    VOOR=230
    WAAR=231
    WEEK=232
    ER=233
    METER=234
    KILOGRAM=235
    VOET=236
    POND=237
    MIJL=238
    M=239
    KG=240
    S=241
    FT=242
    LB=243
    MI=244
    IDENTIFIER=245
    NUMBER=246
    EQUALS=247
    DATE_TIME_LITERAL=248
    PERCENTAGE_LITERAL=249
    STRING_LITERAL=250
    ENUM_LITERAL=251
    LPAREN=252
    RPAREN=253
    LBRACE=254
    RBRACE=255
    COMMA=256
    DOT=257
    COLON=258
    SEMICOLON=259
    SLASH=260
    PERCENT_SIGN=261
    BULLET=262
    ASTERISK=263
    L_ANGLE_QUOTE=264
    R_ANGLE_QUOTE=265
    CARET=266
    WS=267
    LINE_COMMENT=268
    MINUS=269

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.13.1")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class RegelSpraakDocumentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOF(self):
            return self.getToken(RegelSpraakParser.EOF, 0)

        def definitie(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.DefinitieContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.DefinitieContext,i)


        def regel(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.RegelContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.RegelContext,i)


        def beslistabel(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.BeslistabelContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.BeslistabelContext,i)


        def consistentieregel(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.ConsistentieregelContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.ConsistentieregelContext,i)


        def eenheidsysteemDefinition(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.EenheidsysteemDefinitionContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.EenheidsysteemDefinitionContext,i)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_regelSpraakDocument

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRegelSpraakDocument" ):
                listener.enterRegelSpraakDocument(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRegelSpraakDocument" ):
                listener.exitRegelSpraakDocument(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRegelSpraakDocument" ):
                return visitor.visitRegelSpraakDocument(self)
            else:
                return visitor.visitChildren(self)




    def regelSpraakDocument(self):

        localctx = RegelSpraakParser.RegelSpraakDocumentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_regelSpraakDocument)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 181
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==31 or ((((_la - 97)) & ~0x3f) == 0 and ((1 << (_la - 97)) & 1023) != 0):
                self.state = 179
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [31, 100, 101, 102, 104, 105, 106]:
                    self.state = 174
                    self.definitie()
                    pass
                elif token in [98]:
                    self.state = 175
                    self.regel()
                    pass
                elif token in [99]:
                    self.state = 176
                    self.beslistabel()
                    pass
                elif token in [97]:
                    self.state = 177
                    self.consistentieregel()
                    pass
                elif token in [103]:
                    self.state = 178
                    self.eenheidsysteemDefinition()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 183
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 184
            self.match(RegelSpraakParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DefinitieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def objectTypeDefinition(self):
            return self.getTypedRuleContext(RegelSpraakParser.ObjectTypeDefinitionContext,0)


        def domeinDefinition(self):
            return self.getTypedRuleContext(RegelSpraakParser.DomeinDefinitionContext,0)


        def parameterDefinition(self):
            return self.getTypedRuleContext(RegelSpraakParser.ParameterDefinitionContext,0)


        def dimensieDefinition(self):
            return self.getTypedRuleContext(RegelSpraakParser.DimensieDefinitionContext,0)


        def feitTypeDefinition(self):
            return self.getTypedRuleContext(RegelSpraakParser.FeitTypeDefinitionContext,0)


        def dagsoortDefinition(self):
            return self.getTypedRuleContext(RegelSpraakParser.DagsoortDefinitionContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_definitie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDefinitie" ):
                listener.enterDefinitie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDefinitie" ):
                listener.exitDefinitie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDefinitie" ):
                return visitor.visitDefinitie(self)
            else:
                return visitor.visitChildren(self)




    def definitie(self):

        localctx = RegelSpraakParser.DefinitieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_definitie)
        try:
            self.state = 192
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [100]:
                self.enterOuterAlt(localctx, 1)
                self.state = 186
                self.objectTypeDefinition()
                pass
            elif token in [101]:
                self.enterOuterAlt(localctx, 2)
                self.state = 187
                self.domeinDefinition()
                pass
            elif token in [104]:
                self.enterOuterAlt(localctx, 3)
                self.state = 188
                self.parameterDefinition()
                pass
            elif token in [102]:
                self.enterOuterAlt(localctx, 4)
                self.state = 189
                self.dimensieDefinition()
                pass
            elif token in [31, 105]:
                self.enterOuterAlt(localctx, 5)
                self.state = 190
                self.feitTypeDefinition()
                pass
            elif token in [106]:
                self.enterOuterAlt(localctx, 6)
                self.state = 191
                self.dagsoortDefinition()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BeslistabelContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BESLISTABEL(self):
            return self.getToken(RegelSpraakParser.BESLISTABEL, 0)

        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def regelVersie(self):
            return self.getTypedRuleContext(RegelSpraakParser.RegelVersieContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_beslistabel

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBeslistabel" ):
                listener.enterBeslistabel(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBeslistabel" ):
                listener.exitBeslistabel(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBeslistabel" ):
                return visitor.visitBeslistabel(self)
            else:
                return visitor.visitChildren(self)




    def beslistabel(self):

        localctx = RegelSpraakParser.BeslistabelContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_beslistabel)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 194
            self.match(RegelSpraakParser.BESLISTABEL)
            self.state = 195
            self.naamwoord()
            self.state = 197
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==108:
                self.state = 196
                self.regelVersie()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IdentifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(RegelSpraakParser.IDENTIFIER, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_identifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIdentifier" ):
                listener.enterIdentifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIdentifier" ):
                listener.exitIdentifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIdentifier" ):
                return visitor.visitIdentifier(self)
            else:
                return visitor.visitChildren(self)




    def identifier(self):

        localctx = RegelSpraakParser.IdentifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_identifier)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 199
            self.match(RegelSpraakParser.IDENTIFIER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NaamPhraseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.IDENTIFIER)
            else:
                return self.getToken(RegelSpraakParser.IDENTIFIER, i)

        def DE(self):
            return self.getToken(RegelSpraakParser.DE, 0)

        def HET(self):
            return self.getToken(RegelSpraakParser.HET, 0)

        def ZIJN(self):
            return self.getToken(RegelSpraakParser.ZIJN, 0)

        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.IdentifierContext,i)


        def NIEUWE(self):
            return self.getToken(RegelSpraakParser.NIEUWE, 0)

        def MET(self):
            return self.getToken(RegelSpraakParser.MET, 0)

        def NIET(self):
            return self.getToken(RegelSpraakParser.NIET, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_naamPhrase

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNaamPhrase" ):
                listener.enterNaamPhrase(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNaamPhrase" ):
                listener.exitNaamPhrase(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNaamPhrase" ):
                return visitor.visitNaamPhrase(self)
            else:
                return visitor.visitChildren(self)




    def naamPhrase(self):

        localctx = RegelSpraakParser.NaamPhraseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_naamPhrase)
        self._la = 0 # Token type
        try:
            self.state = 249
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,13,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 202
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==116 or _la==202 or _la==207:
                    self.state = 201
                    _la = self._input.LA(1)
                    if not(_la==116 or _la==202 or _la==207):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                self.state = 205 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 204
                        self.match(RegelSpraakParser.IDENTIFIER)

                    else:
                        raise NoViableAltException(self)
                    self.state = 207 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,5,self._ctx)

                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 210 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 209
                        self.identifier()

                    else:
                        raise NoViableAltException(self)
                    self.state = 212 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,6,self._ctx)

                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 214
                self.match(RegelSpraakParser.NIEUWE)
                self.state = 216 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 215
                        self.match(RegelSpraakParser.IDENTIFIER)

                    else:
                        raise NoViableAltException(self)
                    self.state = 218 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,7,self._ctx)

                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 220
                self.match(RegelSpraakParser.NIEUWE)
                self.state = 222 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 221
                    self.match(RegelSpraakParser.IDENTIFIER)
                    self.state = 224 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==245):
                        break

                self.state = 226
                self.match(RegelSpraakParser.MET)
                self.state = 228 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 227
                        self.match(RegelSpraakParser.IDENTIFIER)

                    else:
                        raise NoViableAltException(self)
                    self.state = 230 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,9,self._ctx)

                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 233 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 232
                    self.identifier()
                    self.state = 235 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==245):
                        break

                self.state = 237
                self.match(RegelSpraakParser.MET)
                self.state = 239 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 238
                        self.identifier()

                    else:
                        raise NoViableAltException(self)
                    self.state = 241 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,11,self._ctx)

                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 243
                self.match(RegelSpraakParser.NIET)
                self.state = 245 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 244
                        self.match(RegelSpraakParser.IDENTIFIER)

                    else:
                        raise NoViableAltException(self)
                    self.state = 247 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,12,self._ctx)

                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NaamwoordContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def naamPhrase(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.NaamPhraseContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.NaamPhraseContext,i)


        def voorzetsel(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.VoorzetselContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.VoorzetselContext,i)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_naamwoord

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNaamwoord" ):
                listener.enterNaamwoord(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNaamwoord" ):
                listener.exitNaamwoord(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNaamwoord" ):
                return visitor.visitNaamwoord(self)
            else:
                return visitor.visitChildren(self)




    def naamwoord(self):

        localctx = RegelSpraakParser.NaamwoordContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_naamwoord)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 251
            self.naamPhrase()
            self.state = 257
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,14,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 252
                    self.voorzetsel()
                    self.state = 253
                    self.naamPhrase() 
                self.state = 259
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,14,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VoorzetselContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def VAN(self):
            return self.getToken(RegelSpraakParser.VAN, 0)

        def IN(self):
            return self.getToken(RegelSpraakParser.IN, 0)

        def VOOR(self):
            return self.getToken(RegelSpraakParser.VOOR, 0)

        def OVER(self):
            return self.getToken(RegelSpraakParser.OVER, 0)

        def OP(self):
            return self.getToken(RegelSpraakParser.OP, 0)

        def BIJ(self):
            return self.getToken(RegelSpraakParser.BIJ, 0)

        def UIT(self):
            return self.getToken(RegelSpraakParser.UIT, 0)

        def TOT(self):
            return self.getToken(RegelSpraakParser.TOT, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_voorzetsel

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVoorzetsel" ):
                listener.enterVoorzetsel(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVoorzetsel" ):
                listener.exitVoorzetsel(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVoorzetsel" ):
                return visitor.visitVoorzetsel(self)
            else:
                return visitor.visitChildren(self)




    def voorzetsel(self):

        localctx = RegelSpraakParser.VoorzetselContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_voorzetsel)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 260
            _la = self._input.LA(1)
            if not(_la==140 or _la==199 or ((((_la - 209)) & ~0x3f) == 0 and ((1 << (_la - 209)) & 2425601) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DatumLiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DATE_TIME_LITERAL(self):
            return self.getToken(RegelSpraakParser.DATE_TIME_LITERAL, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_datumLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDatumLiteral" ):
                listener.enterDatumLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDatumLiteral" ):
                listener.exitDatumLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDatumLiteral" ):
                return visitor.visitDatumLiteral(self)
            else:
                return visitor.visitChildren(self)




    def datumLiteral(self):

        localctx = RegelSpraakParser.DatumLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_datumLiteral)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 262
            self.match(RegelSpraakParser.DATE_TIME_LITERAL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UnitContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(RegelSpraakParser.IDENTIFIER, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_unit

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnit" ):
                listener.enterUnit(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnit" ):
                listener.exitUnit(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnit" ):
                return visitor.visitUnit(self)
            else:
                return visitor.visitChildren(self)




    def unit(self):

        localctx = RegelSpraakParser.UnitContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_unit)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 264
            self.match(RegelSpraakParser.IDENTIFIER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ObjectTypeDefinitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self._IDENTIFIER = None # Token
            self.plural = list() # of Tokens

        def OBJECTTYPE(self):
            return self.getToken(RegelSpraakParser.OBJECTTYPE, 0)

        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def MV_START(self):
            return self.getToken(RegelSpraakParser.MV_START, 0)

        def RPAREN(self):
            return self.getToken(RegelSpraakParser.RPAREN, 0)

        def BEZIELD(self):
            return self.getToken(RegelSpraakParser.BEZIELD, 0)

        def objectTypeMember(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.ObjectTypeMemberContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.ObjectTypeMemberContext,i)


        def IDENTIFIER(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.IDENTIFIER)
            else:
                return self.getToken(RegelSpraakParser.IDENTIFIER, i)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_objectTypeDefinition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterObjectTypeDefinition" ):
                listener.enterObjectTypeDefinition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitObjectTypeDefinition" ):
                listener.exitObjectTypeDefinition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitObjectTypeDefinition" ):
                return visitor.visitObjectTypeDefinition(self)
            else:
                return visitor.visitChildren(self)




    def objectTypeDefinition(self):

        localctx = RegelSpraakParser.ObjectTypeDefinitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_objectTypeDefinition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 266
            self.match(RegelSpraakParser.OBJECTTYPE)
            self.state = 267
            self.naamwoord()
            self.state = 275
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==168:
                self.state = 268
                self.match(RegelSpraakParser.MV_START)
                self.state = 270 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 269
                    localctx._IDENTIFIER = self.match(RegelSpraakParser.IDENTIFIER)
                    localctx.plural.append(localctx._IDENTIFIER)
                    self.state = 272 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==245):
                        break

                self.state = 274
                self.match(RegelSpraakParser.RPAREN)


            self.state = 278
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==153:
                self.state = 277
                self.match(RegelSpraakParser.BEZIELD)


            self.state = 283
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==48 or ((((_la - 112)) & ~0x3f) == 0 and ((1 << (_la - 112)) & 8388625) != 0) or ((((_la - 202)) & ~0x3f) == 0 and ((1 << (_la - 202)) & 8796093022241) != 0):
                self.state = 280
                self.objectTypeMember()
                self.state = 285
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ObjectTypeMemberContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SEMICOLON(self):
            return self.getToken(RegelSpraakParser.SEMICOLON, 0)

        def kenmerkSpecificatie(self):
            return self.getTypedRuleContext(RegelSpraakParser.KenmerkSpecificatieContext,0)


        def attribuutSpecificatie(self):
            return self.getTypedRuleContext(RegelSpraakParser.AttribuutSpecificatieContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_objectTypeMember

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterObjectTypeMember" ):
                listener.enterObjectTypeMember(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitObjectTypeMember" ):
                listener.exitObjectTypeMember(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitObjectTypeMember" ):
                return visitor.visitObjectTypeMember(self)
            else:
                return visitor.visitChildren(self)




    def objectTypeMember(self):

        localctx = RegelSpraakParser.ObjectTypeMemberContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_objectTypeMember)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 288
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,19,self._ctx)
            if la_ == 1:
                self.state = 286
                self.kenmerkSpecificatie()
                pass

            elif la_ == 2:
                self.state = 287
                self.attribuutSpecificatie()
                pass


            self.state = 290
            self.match(RegelSpraakParser.SEMICOLON)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class KenmerkSpecificatieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KENMERK(self):
            return self.getToken(RegelSpraakParser.KENMERK, 0)

        def identifier(self):
            return self.getTypedRuleContext(RegelSpraakParser.IdentifierContext,0)


        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def BIJVOEGLIJK(self):
            return self.getToken(RegelSpraakParser.BIJVOEGLIJK, 0)

        def BEZITTELIJK(self):
            return self.getToken(RegelSpraakParser.BEZITTELIJK, 0)

        def IS(self):
            return self.getToken(RegelSpraakParser.IS, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_kenmerkSpecificatie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterKenmerkSpecificatie" ):
                listener.enterKenmerkSpecificatie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitKenmerkSpecificatie" ):
                listener.exitKenmerkSpecificatie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitKenmerkSpecificatie" ):
                return visitor.visitKenmerkSpecificatie(self)
            else:
                return visitor.visitChildren(self)




    def kenmerkSpecificatie(self):

        localctx = RegelSpraakParser.KenmerkSpecificatieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_kenmerkSpecificatie)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 297
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,21,self._ctx)
            if la_ == 1:
                self.state = 293
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==112:
                    self.state = 292
                    self.match(RegelSpraakParser.IS)


                self.state = 295
                self.identifier()
                pass

            elif la_ == 2:
                self.state = 296
                self.naamwoord()
                pass


            self.state = 299
            self.match(RegelSpraakParser.KENMERK)
            self.state = 301
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==154 or _la==155:
                self.state = 300
                _la = self._input.LA(1)
                if not(_la==154 or _la==155):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AttribuutSpecificatieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.unitName = None # Token

        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def datatype(self):
            return self.getTypedRuleContext(RegelSpraakParser.DatatypeContext,0)


        def domeinRef(self):
            return self.getTypedRuleContext(RegelSpraakParser.DomeinRefContext,0)


        def MET_EENHEID(self):
            return self.getToken(RegelSpraakParser.MET_EENHEID, 0)

        def GEDIMENSIONEERD_MET(self):
            return self.getToken(RegelSpraakParser.GEDIMENSIONEERD_MET, 0)

        def dimensieRef(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.DimensieRefContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.DimensieRefContext,i)


        def tijdlijn(self):
            return self.getTypedRuleContext(RegelSpraakParser.TijdlijnContext,0)


        def PERCENT_SIGN(self):
            return self.getToken(RegelSpraakParser.PERCENT_SIGN, 0)

        def IDENTIFIER(self):
            return self.getToken(RegelSpraakParser.IDENTIFIER, 0)

        def EN(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.EN)
            else:
                return self.getToken(RegelSpraakParser.EN, i)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_attribuutSpecificatie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAttribuutSpecificatie" ):
                listener.enterAttribuutSpecificatie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAttribuutSpecificatie" ):
                listener.exitAttribuutSpecificatie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAttribuutSpecificatie" ):
                return visitor.visitAttribuutSpecificatie(self)
            else:
                return visitor.visitChildren(self)




    def attribuutSpecificatie(self):

        localctx = RegelSpraakParser.AttribuutSpecificatieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_attribuutSpecificatie)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 303
            self.naamwoord()
            self.state = 306
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [7, 156, 158, 171, 176]:
                self.state = 304
                self.datatype()
                pass
            elif token in [101]:
                self.state = 305
                self.domeinRef()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 313
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==167:
                self.state = 308
                self.match(RegelSpraakParser.MET_EENHEID)
                self.state = 311
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [245]:
                    self.state = 309
                    localctx.unitName = self.match(RegelSpraakParser.IDENTIFIER)
                    pass
                elif token in [261]:
                    self.state = 310
                    self.match(RegelSpraakParser.PERCENT_SIGN)
                    pass
                else:
                    raise NoViableAltException(self)



            self.state = 324
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==161:
                self.state = 315
                self.match(RegelSpraakParser.GEDIMENSIONEERD_MET)
                self.state = 316
                self.dimensieRef()
                self.state = 321
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==206:
                    self.state = 317
                    self.match(RegelSpraakParser.EN)
                    self.state = 318
                    self.dimensieRef()
                    self.state = 323
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)



            self.state = 327
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 177)) & ~0x3f) == 0 and ((1 << (_la - 177)) & 7) != 0):
                self.state = 326
                self.tijdlijn()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DatatypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def numeriekDatatype(self):
            return self.getTypedRuleContext(RegelSpraakParser.NumeriekDatatypeContext,0)


        def tekstDatatype(self):
            return self.getTypedRuleContext(RegelSpraakParser.TekstDatatypeContext,0)


        def booleanDatatype(self):
            return self.getTypedRuleContext(RegelSpraakParser.BooleanDatatypeContext,0)


        def datumTijdDatatype(self):
            return self.getTypedRuleContext(RegelSpraakParser.DatumTijdDatatypeContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_datatype

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDatatype" ):
                listener.enterDatatype(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDatatype" ):
                listener.exitDatatype(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDatatype" ):
                return visitor.visitDatatype(self)
            else:
                return visitor.visitChildren(self)




    def datatype(self):

        localctx = RegelSpraakParser.DatatypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_datatype)
        try:
            self.state = 333
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [171]:
                self.enterOuterAlt(localctx, 1)
                self.state = 329
                self.numeriekDatatype()
                pass
            elif token in [176]:
                self.enterOuterAlt(localctx, 2)
                self.state = 330
                self.tekstDatatype()
                pass
            elif token in [156]:
                self.enterOuterAlt(localctx, 3)
                self.state = 331
                self.booleanDatatype()
                pass
            elif token in [7, 158]:
                self.enterOuterAlt(localctx, 4)
                self.state = 332
                self.datumTijdDatatype()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NumeriekDatatypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NUMERIEK(self):
            return self.getToken(RegelSpraakParser.NUMERIEK, 0)

        def LPAREN(self):
            return self.getToken(RegelSpraakParser.LPAREN, 0)

        def getalSpecificatie(self):
            return self.getTypedRuleContext(RegelSpraakParser.GetalSpecificatieContext,0)


        def RPAREN(self):
            return self.getToken(RegelSpraakParser.RPAREN, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_numeriekDatatype

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumeriekDatatype" ):
                listener.enterNumeriekDatatype(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumeriekDatatype" ):
                listener.exitNumeriekDatatype(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNumeriekDatatype" ):
                return visitor.visitNumeriekDatatype(self)
            else:
                return visitor.visitChildren(self)




    def numeriekDatatype(self):

        localctx = RegelSpraakParser.NumeriekDatatypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_numeriekDatatype)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 335
            self.match(RegelSpraakParser.NUMERIEK)
            self.state = 340
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==252:
                self.state = 336
                self.match(RegelSpraakParser.LPAREN)
                self.state = 337
                self.getalSpecificatie()
                self.state = 338
                self.match(RegelSpraakParser.RPAREN)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TekstDatatypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TEKST(self):
            return self.getToken(RegelSpraakParser.TEKST, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_tekstDatatype

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTekstDatatype" ):
                listener.enterTekstDatatype(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTekstDatatype" ):
                listener.exitTekstDatatype(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTekstDatatype" ):
                return visitor.visitTekstDatatype(self)
            else:
                return visitor.visitChildren(self)




    def tekstDatatype(self):

        localctx = RegelSpraakParser.TekstDatatypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_tekstDatatype)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 342
            self.match(RegelSpraakParser.TEKST)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BooleanDatatypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BOOLEAN(self):
            return self.getToken(RegelSpraakParser.BOOLEAN, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_booleanDatatype

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBooleanDatatype" ):
                listener.enterBooleanDatatype(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBooleanDatatype" ):
                listener.exitBooleanDatatype(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBooleanDatatype" ):
                return visitor.visitBooleanDatatype(self)
            else:
                return visitor.visitChildren(self)




    def booleanDatatype(self):

        localctx = RegelSpraakParser.BooleanDatatypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_booleanDatatype)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 344
            self.match(RegelSpraakParser.BOOLEAN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DatumTijdDatatypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DATUM_IN_DAGEN(self):
            return self.getToken(RegelSpraakParser.DATUM_IN_DAGEN, 0)

        def DATUM_TIJD_MILLIS(self):
            return self.getToken(RegelSpraakParser.DATUM_TIJD_MILLIS, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_datumTijdDatatype

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDatumTijdDatatype" ):
                listener.enterDatumTijdDatatype(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDatumTijdDatatype" ):
                listener.exitDatumTijdDatatype(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDatumTijdDatatype" ):
                return visitor.visitDatumTijdDatatype(self)
            else:
                return visitor.visitChildren(self)




    def datumTijdDatatype(self):

        localctx = RegelSpraakParser.DatumTijdDatatypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_datumTijdDatatype)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 346
            _la = self._input.LA(1)
            if not(_la==7 or _la==158):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GetalSpecificatieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GEHEEL_GETAL(self):
            return self.getToken(RegelSpraakParser.GEHEEL_GETAL, 0)

        def GETAL(self):
            return self.getToken(RegelSpraakParser.GETAL, 0)

        def NEGATIEF(self):
            return self.getToken(RegelSpraakParser.NEGATIEF, 0)

        def NIET_NEGATIEF(self):
            return self.getToken(RegelSpraakParser.NIET_NEGATIEF, 0)

        def POSITIEF(self):
            return self.getToken(RegelSpraakParser.POSITIEF, 0)

        def MET(self):
            return self.getToken(RegelSpraakParser.MET, 0)

        def NUMBER(self):
            return self.getToken(RegelSpraakParser.NUMBER, 0)

        def DECIMALEN(self):
            return self.getToken(RegelSpraakParser.DECIMALEN, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_getalSpecificatie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGetalSpecificatie" ):
                listener.enterGetalSpecificatie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGetalSpecificatie" ):
                listener.exitGetalSpecificatie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGetalSpecificatie" ):
                return visitor.visitGetalSpecificatie(self)
            else:
                return visitor.visitChildren(self)




    def getalSpecificatie(self):

        localctx = RegelSpraakParser.GetalSpecificatieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_getalSpecificatie)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 349
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 169)) & ~0x3f) == 0 and ((1 << (_la - 169)) & 19) != 0):
                self.state = 348
                _la = self._input.LA(1)
                if not(((((_la - 169)) & ~0x3f) == 0 and ((1 << (_la - 169)) & 19) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


            self.state = 357
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,32,self._ctx)
            if la_ == 1:
                self.state = 351
                self.match(RegelSpraakParser.GEHEEL_GETAL)
                pass

            elif la_ == 2:
                self.state = 352
                self.match(RegelSpraakParser.GETAL)
                self.state = 353
                self.match(RegelSpraakParser.MET)
                self.state = 354
                self.match(RegelSpraakParser.NUMBER)
                self.state = 355
                self.match(RegelSpraakParser.DECIMALEN)
                pass

            elif la_ == 3:
                self.state = 356
                self.match(RegelSpraakParser.GETAL)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DomeinDefinitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self._IDENTIFIER = None # Token
            self.name = list() # of Tokens

        def DOMEIN(self):
            return self.getToken(RegelSpraakParser.DOMEIN, 0)

        def IS_VAN_HET_TYPE(self):
            return self.getToken(RegelSpraakParser.IS_VAN_HET_TYPE, 0)

        def domeinType(self):
            return self.getTypedRuleContext(RegelSpraakParser.DomeinTypeContext,0)


        def MET_EENHEID(self):
            return self.getToken(RegelSpraakParser.MET_EENHEID, 0)

        def eenheidExpressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.EenheidExpressieContext,0)


        def SEMICOLON(self):
            return self.getToken(RegelSpraakParser.SEMICOLON, 0)

        def IDENTIFIER(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.IDENTIFIER)
            else:
                return self.getToken(RegelSpraakParser.IDENTIFIER, i)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_domeinDefinition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDomeinDefinition" ):
                listener.enterDomeinDefinition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDomeinDefinition" ):
                listener.exitDomeinDefinition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDomeinDefinition" ):
                return visitor.visitDomeinDefinition(self)
            else:
                return visitor.visitChildren(self)




    def domeinDefinition(self):

        localctx = RegelSpraakParser.DomeinDefinitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_domeinDefinition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 359
            self.match(RegelSpraakParser.DOMEIN)
            self.state = 361 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 360
                localctx._IDENTIFIER = self.match(RegelSpraakParser.IDENTIFIER)
                localctx.name.append(localctx._IDENTIFIER)
                self.state = 363 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==245):
                    break

            self.state = 365
            self.match(RegelSpraakParser.IS_VAN_HET_TYPE)
            self.state = 366
            self.domeinType()
            self.state = 369
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==167:
                self.state = 367
                self.match(RegelSpraakParser.MET_EENHEID)
                self.state = 368
                self.eenheidExpressie()


            self.state = 372
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==259:
                self.state = 371
                self.match(RegelSpraakParser.SEMICOLON)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DomeinTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def enumeratieSpecificatie(self):
            return self.getTypedRuleContext(RegelSpraakParser.EnumeratieSpecificatieContext,0)


        def numeriekDatatype(self):
            return self.getTypedRuleContext(RegelSpraakParser.NumeriekDatatypeContext,0)


        def tekstDatatype(self):
            return self.getTypedRuleContext(RegelSpraakParser.TekstDatatypeContext,0)


        def booleanDatatype(self):
            return self.getTypedRuleContext(RegelSpraakParser.BooleanDatatypeContext,0)


        def datumTijdDatatype(self):
            return self.getTypedRuleContext(RegelSpraakParser.DatumTijdDatatypeContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_domeinType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDomeinType" ):
                listener.enterDomeinType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDomeinType" ):
                listener.exitDomeinType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDomeinType" ):
                return visitor.visitDomeinType(self)
            else:
                return visitor.visitChildren(self)




    def domeinType(self):

        localctx = RegelSpraakParser.DomeinTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_domeinType)
        try:
            self.state = 379
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [160]:
                self.enterOuterAlt(localctx, 1)
                self.state = 374
                self.enumeratieSpecificatie()
                pass
            elif token in [171]:
                self.enterOuterAlt(localctx, 2)
                self.state = 375
                self.numeriekDatatype()
                pass
            elif token in [176]:
                self.enterOuterAlt(localctx, 3)
                self.state = 376
                self.tekstDatatype()
                pass
            elif token in [156]:
                self.enterOuterAlt(localctx, 4)
                self.state = 377
                self.booleanDatatype()
                pass
            elif token in [7, 158]:
                self.enterOuterAlt(localctx, 5)
                self.state = 378
                self.datumTijdDatatype()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EnumeratieSpecificatieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ENUMERATIE(self):
            return self.getToken(RegelSpraakParser.ENUMERATIE, 0)

        def ENUM_LITERAL(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.ENUM_LITERAL)
            else:
                return self.getToken(RegelSpraakParser.ENUM_LITERAL, i)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_enumeratieSpecificatie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEnumeratieSpecificatie" ):
                listener.enterEnumeratieSpecificatie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEnumeratieSpecificatie" ):
                listener.exitEnumeratieSpecificatie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEnumeratieSpecificatie" ):
                return visitor.visitEnumeratieSpecificatie(self)
            else:
                return visitor.visitChildren(self)




    def enumeratieSpecificatie(self):

        localctx = RegelSpraakParser.EnumeratieSpecificatieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_enumeratieSpecificatie)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 381
            self.match(RegelSpraakParser.ENUMERATIE)
            self.state = 383 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 382
                self.match(RegelSpraakParser.ENUM_LITERAL)
                self.state = 385 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==251):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DomeinRefContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.name = None # Token

        def DOMEIN(self):
            return self.getToken(RegelSpraakParser.DOMEIN, 0)

        def IDENTIFIER(self):
            return self.getToken(RegelSpraakParser.IDENTIFIER, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_domeinRef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDomeinRef" ):
                listener.enterDomeinRef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDomeinRef" ):
                listener.exitDomeinRef(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDomeinRef" ):
                return visitor.visitDomeinRef(self)
            else:
                return visitor.visitChildren(self)




    def domeinRef(self):

        localctx = RegelSpraakParser.DomeinRefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_domeinRef)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 387
            self.match(RegelSpraakParser.DOMEIN)
            self.state = 388
            localctx.name = self.match(RegelSpraakParser.IDENTIFIER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EenheidsysteemDefinitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.name = None # IdentifierContext

        def EENHEIDSYSTEEM(self):
            return self.getToken(RegelSpraakParser.EENHEIDSYSTEEM, 0)

        def identifier(self):
            return self.getTypedRuleContext(RegelSpraakParser.IdentifierContext,0)


        def eenheidEntry(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.EenheidEntryContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.EenheidEntryContext,i)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_eenheidsysteemDefinition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEenheidsysteemDefinition" ):
                listener.enterEenheidsysteemDefinition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEenheidsysteemDefinition" ):
                listener.exitEenheidsysteemDefinition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEenheidsysteemDefinition" ):
                return visitor.visitEenheidsysteemDefinition(self)
            else:
                return visitor.visitChildren(self)




    def eenheidsysteemDefinition(self):

        localctx = RegelSpraakParser.EenheidsysteemDefinitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_eenheidsysteemDefinition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 390
            self.match(RegelSpraakParser.EENHEIDSYSTEEM)
            self.state = 391
            localctx.name = self.identifier()
            self.state = 395
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==202:
                self.state = 392
                self.eenheidEntry()
                self.state = 397
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EenheidEntryContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.unitName = None # UnitIdentifierContext
            self.abbrev = None # UnitIdentifierContext
            self.value = None # Token
            self.targetUnit = None # UnitIdentifierContext

        def DE(self):
            return self.getToken(RegelSpraakParser.DE, 0)

        def unitIdentifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.UnitIdentifierContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.UnitIdentifierContext,i)


        def EQUALS(self):
            return self.getToken(RegelSpraakParser.EQUALS, 0)

        def NUMBER(self):
            return self.getToken(RegelSpraakParser.NUMBER, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_eenheidEntry

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEenheidEntry" ):
                listener.enterEenheidEntry(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEenheidEntry" ):
                listener.exitEenheidEntry(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEenheidEntry" ):
                return visitor.visitEenheidEntry(self)
            else:
                return visitor.visitChildren(self)




    def eenheidEntry(self):

        localctx = RegelSpraakParser.EenheidEntryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_eenheidEntry)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 398
            self.match(RegelSpraakParser.DE)
            self.state = 399
            localctx.unitName = self.unitIdentifier()
            self.state = 400
            localctx.abbrev = self.unitIdentifier()
            self.state = 404
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==247:
                self.state = 401
                self.match(RegelSpraakParser.EQUALS)
                self.state = 402
                localctx.value = self.match(RegelSpraakParser.NUMBER)
                self.state = 403
                localctx.targetUnit = self.unitIdentifier()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UnitIdentifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(RegelSpraakParser.IDENTIFIER, 0)

        def METER(self):
            return self.getToken(RegelSpraakParser.METER, 0)

        def KILOGRAM(self):
            return self.getToken(RegelSpraakParser.KILOGRAM, 0)

        def SECONDE(self):
            return self.getToken(RegelSpraakParser.SECONDE, 0)

        def MINUUT(self):
            return self.getToken(RegelSpraakParser.MINUUT, 0)

        def UUR(self):
            return self.getToken(RegelSpraakParser.UUR, 0)

        def VOET(self):
            return self.getToken(RegelSpraakParser.VOET, 0)

        def POND(self):
            return self.getToken(RegelSpraakParser.POND, 0)

        def MIJL(self):
            return self.getToken(RegelSpraakParser.MIJL, 0)

        def M(self):
            return self.getToken(RegelSpraakParser.M, 0)

        def KG(self):
            return self.getToken(RegelSpraakParser.KG, 0)

        def S(self):
            return self.getToken(RegelSpraakParser.S, 0)

        def FT(self):
            return self.getToken(RegelSpraakParser.FT, 0)

        def LB(self):
            return self.getToken(RegelSpraakParser.LB, 0)

        def MIN(self):
            return self.getToken(RegelSpraakParser.MIN, 0)

        def MI(self):
            return self.getToken(RegelSpraakParser.MI, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_unitIdentifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnitIdentifier" ):
                listener.enterUnitIdentifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnitIdentifier" ):
                listener.exitUnitIdentifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnitIdentifier" ):
                return visitor.visitUnitIdentifier(self)
            else:
                return visitor.visitChildren(self)




    def unitIdentifier(self):

        localctx = RegelSpraakParser.UnitIdentifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_unitIdentifier)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 406
            _la = self._input.LA(1)
            if not(_la==132 or ((((_la - 214)) & ~0x3f) == 0 and ((1 << (_la - 214)) & 4293923329) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EenheidExpressieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def eenheidMacht(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.EenheidMachtContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.EenheidMachtContext,i)


        def SLASH(self):
            return self.getToken(RegelSpraakParser.SLASH, 0)

        def NUMBER(self):
            return self.getToken(RegelSpraakParser.NUMBER, 0)

        def PERCENT_SIGN(self):
            return self.getToken(RegelSpraakParser.PERCENT_SIGN, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_eenheidExpressie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEenheidExpressie" ):
                listener.enterEenheidExpressie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEenheidExpressie" ):
                listener.exitEenheidExpressie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEenheidExpressie" ):
                return visitor.visitEenheidExpressie(self)
            else:
                return visitor.visitChildren(self)




    def eenheidExpressie(self):

        localctx = RegelSpraakParser.EenheidExpressieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_eenheidExpressie)
        self._la = 0 # Token type
        try:
            self.state = 415
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [132, 214, 223, 226, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245]:
                self.enterOuterAlt(localctx, 1)
                self.state = 408
                self.eenheidMacht()
                self.state = 411
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==260:
                    self.state = 409
                    self.match(RegelSpraakParser.SLASH)
                    self.state = 410
                    self.eenheidMacht()


                pass
            elif token in [246]:
                self.enterOuterAlt(localctx, 2)
                self.state = 413
                self.match(RegelSpraakParser.NUMBER)
                pass
            elif token in [261]:
                self.enterOuterAlt(localctx, 3)
                self.state = 414
                self.match(RegelSpraakParser.PERCENT_SIGN)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EenheidMachtContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def unitIdentifier(self):
            return self.getTypedRuleContext(RegelSpraakParser.UnitIdentifierContext,0)


        def CARET(self):
            return self.getToken(RegelSpraakParser.CARET, 0)

        def NUMBER(self):
            return self.getToken(RegelSpraakParser.NUMBER, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_eenheidMacht

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEenheidMacht" ):
                listener.enterEenheidMacht(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEenheidMacht" ):
                listener.exitEenheidMacht(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEenheidMacht" ):
                return visitor.visitEenheidMacht(self)
            else:
                return visitor.visitChildren(self)




    def eenheidMacht(self):

        localctx = RegelSpraakParser.EenheidMachtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_eenheidMacht)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 417
            self.unitIdentifier()
            self.state = 420
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==266:
                self.state = 418
                self.match(RegelSpraakParser.CARET)
                self.state = 419
                self.match(RegelSpraakParser.NUMBER)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DimensieDefinitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.dimensieNaamMeervoud = None # NaamwoordContext

        def DIMENSIE(self):
            return self.getToken(RegelSpraakParser.DIMENSIE, 0)

        def naamwoord(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.NaamwoordContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,i)


        def BESTAANDE_UIT(self):
            return self.getToken(RegelSpraakParser.BESTAANDE_UIT, 0)

        def voorzetselSpecificatie(self):
            return self.getTypedRuleContext(RegelSpraakParser.VoorzetselSpecificatieContext,0)


        def COMMA(self):
            return self.getToken(RegelSpraakParser.COMMA, 0)

        def labelWaardeSpecificatie(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.LabelWaardeSpecificatieContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.LabelWaardeSpecificatieContext,i)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_dimensieDefinition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDimensieDefinition" ):
                listener.enterDimensieDefinition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDimensieDefinition" ):
                listener.exitDimensieDefinition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDimensieDefinition" ):
                return visitor.visitDimensieDefinition(self)
            else:
                return visitor.visitChildren(self)




    def dimensieDefinition(self):

        localctx = RegelSpraakParser.DimensieDefinitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_dimensieDefinition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 422
            self.match(RegelSpraakParser.DIMENSIE)
            self.state = 423
            self.naamwoord()
            self.state = 425
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==256:
                self.state = 424
                self.match(RegelSpraakParser.COMMA)


            self.state = 427
            self.match(RegelSpraakParser.BESTAANDE_UIT)
            self.state = 428
            localctx.dimensieNaamMeervoud = self.naamwoord()
            self.state = 429
            self.voorzetselSpecificatie()
            self.state = 431 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 430
                self.labelWaardeSpecificatie()
                self.state = 433 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==246):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VoorzetselSpecificatieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.vz = None # VoorzetselContext

        def NA_HET_ATTRIBUUT_MET_VOORZETSEL(self):
            return self.getToken(RegelSpraakParser.NA_HET_ATTRIBUUT_MET_VOORZETSEL, 0)

        def RPAREN(self):
            return self.getToken(RegelSpraakParser.RPAREN, 0)

        def voorzetsel(self):
            return self.getTypedRuleContext(RegelSpraakParser.VoorzetselContext,0)


        def COLON(self):
            return self.getToken(RegelSpraakParser.COLON, 0)

        def VOOR_HET_ATTRIBUUT_ZONDER_VOORZETSEL(self):
            return self.getToken(RegelSpraakParser.VOOR_HET_ATTRIBUUT_ZONDER_VOORZETSEL, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_voorzetselSpecificatie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVoorzetselSpecificatie" ):
                listener.enterVoorzetselSpecificatie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVoorzetselSpecificatie" ):
                listener.exitVoorzetselSpecificatie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVoorzetselSpecificatie" ):
                return visitor.visitVoorzetselSpecificatie(self)
            else:
                return visitor.visitChildren(self)




    def voorzetselSpecificatie(self):

        localctx = RegelSpraakParser.VoorzetselSpecificatieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_voorzetselSpecificatie)
        self._la = 0 # Token type
        try:
            self.state = 442
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [6]:
                self.enterOuterAlt(localctx, 1)
                self.state = 435
                self.match(RegelSpraakParser.NA_HET_ATTRIBUUT_MET_VOORZETSEL)
                self.state = 436
                localctx.vz = self.voorzetsel()
                self.state = 437
                self.match(RegelSpraakParser.RPAREN)
                self.state = 439
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==258:
                    self.state = 438
                    self.match(RegelSpraakParser.COLON)


                pass
            elif token in [5]:
                self.enterOuterAlt(localctx, 2)
                self.state = 441
                self.match(RegelSpraakParser.VOOR_HET_ATTRIBUUT_ZONDER_VOORZETSEL)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LabelWaardeSpecificatieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.dimWaarde = None # IdentifierContext

        def NUMBER(self):
            return self.getToken(RegelSpraakParser.NUMBER, 0)

        def DOT(self):
            return self.getToken(RegelSpraakParser.DOT, 0)

        def identifier(self):
            return self.getTypedRuleContext(RegelSpraakParser.IdentifierContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_labelWaardeSpecificatie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLabelWaardeSpecificatie" ):
                listener.enterLabelWaardeSpecificatie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLabelWaardeSpecificatie" ):
                listener.exitLabelWaardeSpecificatie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLabelWaardeSpecificatie" ):
                return visitor.visitLabelWaardeSpecificatie(self)
            else:
                return visitor.visitChildren(self)




    def labelWaardeSpecificatie(self):

        localctx = RegelSpraakParser.LabelWaardeSpecificatieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_labelWaardeSpecificatie)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 444
            self.match(RegelSpraakParser.NUMBER)
            self.state = 445
            self.match(RegelSpraakParser.DOT)
            self.state = 446
            localctx.dimWaarde = self.identifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TijdlijnContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def VOOR_ELKE_DAG(self):
            return self.getToken(RegelSpraakParser.VOOR_ELKE_DAG, 0)

        def VOOR_ELKE_MAAND(self):
            return self.getToken(RegelSpraakParser.VOOR_ELKE_MAAND, 0)

        def VOOR_ELK_JAAR(self):
            return self.getToken(RegelSpraakParser.VOOR_ELK_JAAR, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_tijdlijn

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTijdlijn" ):
                listener.enterTijdlijn(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTijdlijn" ):
                listener.exitTijdlijn(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTijdlijn" ):
                return visitor.visitTijdlijn(self)
            else:
                return visitor.visitChildren(self)




    def tijdlijn(self):

        localctx = RegelSpraakParser.TijdlijnContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_tijdlijn)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 448
            _la = self._input.LA(1)
            if not(((((_la - 177)) & ~0x3f) == 0 and ((1 << (_la - 177)) & 7) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DimensieRefContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.name = None # Token

        def IDENTIFIER(self):
            return self.getToken(RegelSpraakParser.IDENTIFIER, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_dimensieRef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDimensieRef" ):
                listener.enterDimensieRef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDimensieRef" ):
                listener.exitDimensieRef(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDimensieRef" ):
                return visitor.visitDimensieRef(self)
            else:
                return visitor.visitChildren(self)




    def dimensieRef(self):

        localctx = RegelSpraakParser.DimensieRefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_dimensieRef)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 450
            localctx.name = self.match(RegelSpraakParser.IDENTIFIER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParameterDefinitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PARAMETER(self):
            return self.getToken(RegelSpraakParser.PARAMETER, 0)

        def parameterNamePhrase(self):
            return self.getTypedRuleContext(RegelSpraakParser.ParameterNamePhraseContext,0)


        def COLON(self):
            return self.getToken(RegelSpraakParser.COLON, 0)

        def SEMICOLON(self):
            return self.getToken(RegelSpraakParser.SEMICOLON, 0)

        def datatype(self):
            return self.getTypedRuleContext(RegelSpraakParser.DatatypeContext,0)


        def domeinRef(self):
            return self.getTypedRuleContext(RegelSpraakParser.DomeinRefContext,0)


        def MET_EENHEID(self):
            return self.getToken(RegelSpraakParser.MET_EENHEID, 0)

        def eenheidExpressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.EenheidExpressieContext,0)


        def tijdlijn(self):
            return self.getTypedRuleContext(RegelSpraakParser.TijdlijnContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_parameterDefinition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParameterDefinition" ):
                listener.enterParameterDefinition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParameterDefinition" ):
                listener.exitParameterDefinition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParameterDefinition" ):
                return visitor.visitParameterDefinition(self)
            else:
                return visitor.visitChildren(self)




    def parameterDefinition(self):

        localctx = RegelSpraakParser.ParameterDefinitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_parameterDefinition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 452
            self.match(RegelSpraakParser.PARAMETER)
            self.state = 453
            self.parameterNamePhrase()
            self.state = 454
            self.match(RegelSpraakParser.COLON)
            self.state = 457
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [7, 156, 158, 171, 176]:
                self.state = 455
                self.datatype()
                pass
            elif token in [101]:
                self.state = 456
                self.domeinRef()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 461
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==167:
                self.state = 459
                self.match(RegelSpraakParser.MET_EENHEID)
                self.state = 460
                self.eenheidExpressie()


            self.state = 464
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 177)) & ~0x3f) == 0 and ((1 << (_la - 177)) & 7) != 0):
                self.state = 463
                self.tijdlijn()


            self.state = 466
            self.match(RegelSpraakParser.SEMICOLON)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParameterNamePhraseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DE(self):
            return self.getToken(RegelSpraakParser.DE, 0)

        def HET(self):
            return self.getToken(RegelSpraakParser.HET, 0)

        def IDENTIFIER(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.IDENTIFIER)
            else:
                return self.getToken(RegelSpraakParser.IDENTIFIER, i)

        def AANTAL(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.AANTAL)
            else:
                return self.getToken(RegelSpraakParser.AANTAL, i)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_parameterNamePhrase

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParameterNamePhrase" ):
                listener.enterParameterNamePhrase(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParameterNamePhrase" ):
                listener.exitParameterNamePhrase(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParameterNamePhrase" ):
                return visitor.visitParameterNamePhrase(self)
            else:
                return visitor.visitChildren(self)




    def parameterNamePhrase(self):

        localctx = RegelSpraakParser.ParameterNamePhraseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_parameterNamePhrase)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 469
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==202 or _la==207:
                self.state = 468
                _la = self._input.LA(1)
                if not(_la==202 or _la==207):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


            self.state = 472 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 471
                _la = self._input.LA(1)
                if not(_la==180 or _la==245):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 474 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==180 or _la==245):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParameterMetLidwoordContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_parameterMetLidwoord

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParameterMetLidwoord" ):
                listener.enterParameterMetLidwoord(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParameterMetLidwoord" ):
                listener.exitParameterMetLidwoord(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParameterMetLidwoord" ):
                return visitor.visitParameterMetLidwoord(self)
            else:
                return visitor.visitChildren(self)




    def parameterMetLidwoord(self):

        localctx = RegelSpraakParser.ParameterMetLidwoordContext(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_parameterMetLidwoord)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 476
            self.naamwoord()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FeitTypeDefinitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.subject = None # NaamwoordContext
            self.object_ = None # NaamwoordContext
            self.description = None # NaamwoordContext

        def rolSpecificatie(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.RolSpecificatieContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.RolSpecificatieContext,i)


        def WEDERKERIG_FEITTYPE(self):
            return self.getToken(RegelSpraakParser.WEDERKERIG_FEITTYPE, 0)

        def FEITTYPE(self):
            return self.getToken(RegelSpraakParser.FEITTYPE, 0)

        def naamwoord(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.NaamwoordContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,i)


        def HEEFT(self):
            return self.getToken(RegelSpraakParser.HEEFT, 0)

        def IS(self):
            return self.getToken(RegelSpraakParser.IS, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_feitTypeDefinition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFeitTypeDefinition" ):
                listener.enterFeitTypeDefinition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFeitTypeDefinition" ):
                listener.exitFeitTypeDefinition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFeitTypeDefinition" ):
                return visitor.visitFeitTypeDefinition(self)
            else:
                return visitor.visitChildren(self)




    def feitTypeDefinition(self):

        localctx = RegelSpraakParser.FeitTypeDefinitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_feitTypeDefinition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 478
            _la = self._input.LA(1)
            if not(_la==31 or _la==105):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 479
            localctx.subject = self.naamwoord()
            self.state = 484
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [110]:
                self.state = 480
                self.match(RegelSpraakParser.HEEFT)
                self.state = 481
                localctx.object_ = self.naamwoord()
                pass
            elif token in [112]:
                self.state = 482
                self.match(RegelSpraakParser.IS)
                self.state = 483
                localctx.description = self.naamwoord()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 486
            self.rolSpecificatie()
            self.state = 488 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 487
                self.rolSpecificatie()
                self.state = 490 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==5 or _la==6):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RolSpecificatieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def voorzetselSpecificatie(self):
            return self.getTypedRuleContext(RegelSpraakParser.VoorzetselSpecificatieContext,0)


        def identifier(self):
            return self.getTypedRuleContext(RegelSpraakParser.IdentifierContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_rolSpecificatie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRolSpecificatie" ):
                listener.enterRolSpecificatie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRolSpecificatie" ):
                listener.exitRolSpecificatie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRolSpecificatie" ):
                return visitor.visitRolSpecificatie(self)
            else:
                return visitor.visitChildren(self)




    def rolSpecificatie(self):

        localctx = RegelSpraakParser.RolSpecificatieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 74, self.RULE_rolSpecificatie)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 492
            self.voorzetselSpecificatie()
            self.state = 493
            self.identifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RegelContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def REGEL(self):
            return self.getToken(RegelSpraakParser.REGEL, 0)

        def regelName(self):
            return self.getTypedRuleContext(RegelSpraakParser.RegelNameContext,0)


        def regelVersie(self):
            return self.getTypedRuleContext(RegelSpraakParser.RegelVersieContext,0)


        def resultaatDeel(self):
            return self.getTypedRuleContext(RegelSpraakParser.ResultaatDeelContext,0)


        def NUMBER(self):
            return self.getToken(RegelSpraakParser.NUMBER, 0)

        def voorwaardeDeel(self):
            return self.getTypedRuleContext(RegelSpraakParser.VoorwaardeDeelContext,0)


        def DOT(self):
            return self.getToken(RegelSpraakParser.DOT, 0)

        def variabeleDeel(self):
            return self.getTypedRuleContext(RegelSpraakParser.VariabeleDeelContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_regel

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRegel" ):
                listener.enterRegel(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRegel" ):
                listener.exitRegel(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRegel" ):
                return visitor.visitRegel(self)
            else:
                return visitor.visitChildren(self)




    def regel(self):

        localctx = RegelSpraakParser.RegelContext(self, self._ctx, self.state)
        self.enterRule(localctx, 76, self.RULE_regel)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 495
            self.match(RegelSpraakParser.REGEL)
            self.state = 496
            self.regelName()
            self.state = 498
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==246:
                self.state = 497
                self.match(RegelSpraakParser.NUMBER)


            self.state = 500
            self.regelVersie()
            self.state = 501
            self.resultaatDeel()
            self.state = 507
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [111]:
                self.state = 502
                self.voorwaardeDeel()
                self.state = 504
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==257:
                    self.state = 503
                    self.match(RegelSpraakParser.DOT)


                pass
            elif token in [257]:
                self.state = 506
                self.match(RegelSpraakParser.DOT)
                pass
            elif token in [-1, 31, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107]:
                pass
            else:
                pass
            self.state = 510
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==107:
                self.state = 509
                self.variabeleDeel()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RegelNameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.IDENTIFIER)
            else:
                return self.getToken(RegelSpraakParser.IDENTIFIER, i)

        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def KENMERK(self):
            return self.getToken(RegelSpraakParser.KENMERK, 0)

        def ROL(self):
            return self.getToken(RegelSpraakParser.ROL, 0)

        def NIET(self):
            return self.getToken(RegelSpraakParser.NIET, 0)

        def KENMERKEN(self):
            return self.getToken(RegelSpraakParser.KENMERKEN, 0)

        def ROLLEN(self):
            return self.getToken(RegelSpraakParser.ROLLEN, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_regelName

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRegelName" ):
                listener.enterRegelName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRegelName" ):
                listener.exitRegelName(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRegelName" ):
                return visitor.visitRegelName(self)
            else:
                return visitor.visitChildren(self)




    def regelName(self):

        localctx = RegelSpraakParser.RegelNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 78, self.RULE_regelName)
        self._la = 0 # Token type
        try:
            self.state = 566
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,67,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 513 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 512
                    self.match(RegelSpraakParser.IDENTIFIER)
                    self.state = 515 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==245):
                        break

                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 517
                self.naamwoord()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 519 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 518
                    self.match(RegelSpraakParser.IDENTIFIER)
                    self.state = 521 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==245):
                        break

                self.state = 523
                self.match(RegelSpraakParser.KENMERK)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 525 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 524
                    self.match(RegelSpraakParser.IDENTIFIER)
                    self.state = 527 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==245):
                        break

                self.state = 529
                self.match(RegelSpraakParser.ROL)
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 531 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 530
                    self.match(RegelSpraakParser.IDENTIFIER)
                    self.state = 533 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==245):
                        break

                self.state = 535
                self.match(RegelSpraakParser.NIET)
                self.state = 536
                self.match(RegelSpraakParser.KENMERK)
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 538 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 537
                    self.match(RegelSpraakParser.IDENTIFIER)
                    self.state = 540 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==245):
                        break

                self.state = 542
                self.match(RegelSpraakParser.NIET)
                self.state = 543
                self.match(RegelSpraakParser.ROL)
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 545 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 544
                    self.match(RegelSpraakParser.IDENTIFIER)
                    self.state = 547 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==245):
                        break

                self.state = 549
                self.match(RegelSpraakParser.KENMERKEN)
                self.state = 551 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 550
                    self.match(RegelSpraakParser.IDENTIFIER)
                    self.state = 553 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==245):
                        break

                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 556 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 555
                    self.match(RegelSpraakParser.IDENTIFIER)
                    self.state = 558 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==245):
                        break

                self.state = 560
                self.match(RegelSpraakParser.ROLLEN)
                self.state = 562 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 561
                    self.match(RegelSpraakParser.IDENTIFIER)
                    self.state = 564 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==245):
                        break

                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RegelVersieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GELDIG(self):
            return self.getToken(RegelSpraakParser.GELDIG, 0)

        def versieGeldigheid(self):
            return self.getTypedRuleContext(RegelSpraakParser.VersieGeldigheidContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_regelVersie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRegelVersie" ):
                listener.enterRegelVersie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRegelVersie" ):
                listener.exitRegelVersie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRegelVersie" ):
                return visitor.visitRegelVersie(self)
            else:
                return visitor.visitChildren(self)




    def regelVersie(self):

        localctx = RegelSpraakParser.RegelVersieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 80, self.RULE_regelVersie)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 568
            self.match(RegelSpraakParser.GELDIG)
            self.state = 569
            self.versieGeldigheid()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VersieGeldigheidContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ALTIJD(self):
            return self.getToken(RegelSpraakParser.ALTIJD, 0)

        def VANAF(self):
            return self.getToken(RegelSpraakParser.VANAF, 0)

        def datumLiteral(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.DatumLiteralContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.DatumLiteralContext,i)


        def TM(self):
            return self.getToken(RegelSpraakParser.TM, 0)

        def TOT_EN_MET(self):
            return self.getToken(RegelSpraakParser.TOT_EN_MET, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_versieGeldigheid

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVersieGeldigheid" ):
                listener.enterVersieGeldigheid(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVersieGeldigheid" ):
                listener.exitVersieGeldigheid(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVersieGeldigheid" ):
                return visitor.visitVersieGeldigheid(self)
            else:
                return visitor.visitChildren(self)




    def versieGeldigheid(self):

        localctx = RegelSpraakParser.VersieGeldigheidContext(self, self._ctx, self.state)
        self.enterRule(localctx, 82, self.RULE_versieGeldigheid)
        self._la = 0 # Token type
        try:
            self.state = 578
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [198]:
                self.enterOuterAlt(localctx, 1)
                self.state = 571
                self.match(RegelSpraakParser.ALTIJD)
                pass
            elif token in [144]:
                self.enterOuterAlt(localctx, 2)
                self.state = 572
                self.match(RegelSpraakParser.VANAF)
                self.state = 573
                self.datumLiteral()
                self.state = 576
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==142 or _la==224:
                    self.state = 574
                    _la = self._input.LA(1)
                    if not(_la==142 or _la==224):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()
                    self.state = 575
                    self.datumLiteral()


                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ResultaatDeelContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_resultaatDeel

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class AantalDagenInResultaatContext(ResultaatDeelContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.ResultaatDeelContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def HET_AANTAL_DAGEN_IN(self):
            return self.getToken(RegelSpraakParser.HET_AANTAL_DAGEN_IN, 0)
        def MAAND(self):
            return self.getToken(RegelSpraakParser.MAAND, 0)
        def JAAR(self):
            return self.getToken(RegelSpraakParser.JAAR, 0)
        def WORDT_BEREKEND_ALS(self):
            return self.getToken(RegelSpraakParser.WORDT_BEREKEND_ALS, 0)
        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)

        def WORDT_GESTELD_OP(self):
            return self.getToken(RegelSpraakParser.WORDT_GESTELD_OP, 0)
        def WORDT_GEINITIALISEERD_OP(self):
            return self.getToken(RegelSpraakParser.WORDT_GEINITIALISEERD_OP, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAantalDagenInResultaat" ):
                listener.enterAantalDagenInResultaat(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAantalDagenInResultaat" ):
                listener.exitAantalDagenInResultaat(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAantalDagenInResultaat" ):
                return visitor.visitAantalDagenInResultaat(self)
            else:
                return visitor.visitChildren(self)


    class GelijkstellingResultaatContext(ResultaatDeelContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.ResultaatDeelContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)

        def attribuutReferentie(self):
            return self.getTypedRuleContext(RegelSpraakParser.AttribuutReferentieContext,0)

        def WORDT_BEREKEND_ALS(self):
            return self.getToken(RegelSpraakParser.WORDT_BEREKEND_ALS, 0)
        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)

        def WORDT_GESTELD_OP(self):
            return self.getToken(RegelSpraakParser.WORDT_GESTELD_OP, 0)
        def WORDT_GEINITIALISEERD_OP(self):
            return self.getToken(RegelSpraakParser.WORDT_GEINITIALISEERD_OP, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGelijkstellingResultaat" ):
                listener.enterGelijkstellingResultaat(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGelijkstellingResultaat" ):
                listener.exitGelijkstellingResultaat(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGelijkstellingResultaat" ):
                return visitor.visitGelijkstellingResultaat(self)
            else:
                return visitor.visitChildren(self)


    class CapitalizedGelijkstellingResultaatContext(ResultaatDeelContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.ResultaatDeelContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def WORDT_BEREKEND_ALS(self):
            return self.getToken(RegelSpraakParser.WORDT_BEREKEND_ALS, 0)
        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)

        def WORDT_GESTELD_OP(self):
            return self.getToken(RegelSpraakParser.WORDT_GESTELD_OP, 0)
        def WORDT_GEINITIALISEERD_OP(self):
            return self.getToken(RegelSpraakParser.WORDT_GEINITIALISEERD_OP, 0)
        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.IdentifierContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCapitalizedGelijkstellingResultaat" ):
                listener.enterCapitalizedGelijkstellingResultaat(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCapitalizedGelijkstellingResultaat" ):
                listener.exitCapitalizedGelijkstellingResultaat(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCapitalizedGelijkstellingResultaat" ):
                return visitor.visitCapitalizedGelijkstellingResultaat(self)
            else:
                return visitor.visitChildren(self)


    class SpecialPhraseResultaatContext(ResultaatDeelContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.ResultaatDeelContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def HET_KWARTAAL(self):
            return self.getToken(RegelSpraakParser.HET_KWARTAAL, 0)
        def HET_DEEL_PER_MAAND(self):
            return self.getToken(RegelSpraakParser.HET_DEEL_PER_MAAND, 0)
        def HET_DEEL_PER_JAAR(self):
            return self.getToken(RegelSpraakParser.HET_DEEL_PER_JAAR, 0)
        def WORDT_BEREKEND_ALS(self):
            return self.getToken(RegelSpraakParser.WORDT_BEREKEND_ALS, 0)
        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)

        def WORDT_GESTELD_OP(self):
            return self.getToken(RegelSpraakParser.WORDT_GESTELD_OP, 0)
        def WORDT_GEINITIALISEERD_OP(self):
            return self.getToken(RegelSpraakParser.WORDT_GEINITIALISEERD_OP, 0)
        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.IdentifierContext,i)

        def datumLiteral(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.DatumLiteralContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.DatumLiteralContext,i)

        def DOT(self):
            return self.getToken(RegelSpraakParser.DOT, 0)
        def VANAF(self):
            return self.getToken(RegelSpraakParser.VANAF, 0)
        def VAN(self):
            return self.getToken(RegelSpraakParser.VAN, 0)
        def TOT(self):
            return self.getToken(RegelSpraakParser.TOT, 0)
        def TOT_EN_MET(self):
            return self.getToken(RegelSpraakParser.TOT_EN_MET, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSpecialPhraseResultaat" ):
                listener.enterSpecialPhraseResultaat(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSpecialPhraseResultaat" ):
                listener.exitSpecialPhraseResultaat(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSpecialPhraseResultaat" ):
                return visitor.visitSpecialPhraseResultaat(self)
            else:
                return visitor.visitChildren(self)


    class KenmerkFeitResultaatContext(ResultaatDeelContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.ResultaatDeelContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def onderwerpReferentie(self):
            return self.getTypedRuleContext(RegelSpraakParser.OnderwerpReferentieContext,0)

        def kenmerkNaam(self):
            return self.getTypedRuleContext(RegelSpraakParser.KenmerkNaamContext,0)

        def IS(self):
            return self.getToken(RegelSpraakParser.IS, 0)
        def HEEFT(self):
            return self.getToken(RegelSpraakParser.HEEFT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterKenmerkFeitResultaat" ):
                listener.enterKenmerkFeitResultaat(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitKenmerkFeitResultaat" ):
                listener.exitKenmerkFeitResultaat(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitKenmerkFeitResultaat" ):
                return visitor.visitKenmerkFeitResultaat(self)
            else:
                return visitor.visitChildren(self)


    class ObjectCreatieActieContext(ResultaatDeelContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.ResultaatDeelContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def objectCreatie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ObjectCreatieContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterObjectCreatieActie" ):
                listener.enterObjectCreatieActie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitObjectCreatieActie" ):
                listener.exitObjectCreatieActie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitObjectCreatieActie" ):
                return visitor.visitObjectCreatieActie(self)
            else:
                return visitor.visitChildren(self)


    class FeitCreatieResultaatContext(ResultaatDeelContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.ResultaatDeelContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def onderwerpReferentie(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.OnderwerpReferentieContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.OnderwerpReferentieContext,i)

        def HEEFT(self):
            return self.getToken(RegelSpraakParser.HEEFT, 0)
        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)

        def MET(self):
            return self.getToken(RegelSpraakParser.MET, 0)
        def TOT(self):
            return self.getToken(RegelSpraakParser.TOT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFeitCreatieResultaat" ):
                listener.enterFeitCreatieResultaat(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFeitCreatieResultaat" ):
                listener.exitFeitCreatieResultaat(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFeitCreatieResultaat" ):
                return visitor.visitFeitCreatieResultaat(self)
            else:
                return visitor.visitChildren(self)



    def resultaatDeel(self):

        localctx = RegelSpraakParser.ResultaatDeelContext(self, self._ctx, self.state)
        self.enterRule(localctx, 84, self.RULE_resultaatDeel)
        self._la = 0 # Token type
        try:
            self.state = 651
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,79,self._ctx)
            if la_ == 1:
                localctx = RegelSpraakParser.GelijkstellingResultaatContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 582
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,70,self._ctx)
                if la_ == 1:
                    self.state = 580
                    self.naamwoord()
                    pass

                elif la_ == 2:
                    self.state = 581
                    self.attribuutReferentie()
                    pass


                self.state = 590
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [11]:
                    self.state = 584
                    self.match(RegelSpraakParser.WORDT_BEREKEND_ALS)
                    self.state = 585
                    self.expressie()
                    pass
                elif token in [12]:
                    self.state = 586
                    self.match(RegelSpraakParser.WORDT_GESTELD_OP)
                    self.state = 587
                    self.expressie()
                    pass
                elif token in [13]:
                    self.state = 588
                    self.match(RegelSpraakParser.WORDT_GEINITIALISEERD_OP)
                    self.state = 589
                    self.expressie()
                    pass
                else:
                    raise NoViableAltException(self)

                pass

            elif la_ == 2:
                localctx = RegelSpraakParser.KenmerkFeitResultaatContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 592
                self.onderwerpReferentie()
                self.state = 593
                _la = self._input.LA(1)
                if not(_la==110 or _la==112):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 594
                self.kenmerkNaam()
                pass

            elif la_ == 3:
                localctx = RegelSpraakParser.FeitCreatieResultaatContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 596
                self.onderwerpReferentie()
                self.state = 597
                self.match(RegelSpraakParser.HEEFT)
                self.state = 598
                self.naamwoord()
                self.state = 599
                _la = self._input.LA(1)
                if not(_la==140 or _la==166):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 600
                self.onderwerpReferentie()
                pass

            elif la_ == 4:
                localctx = RegelSpraakParser.CapitalizedGelijkstellingResultaatContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 603 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 602
                    self.identifier()
                    self.state = 605 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==245):
                        break

                self.state = 613
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [11]:
                    self.state = 607
                    self.match(RegelSpraakParser.WORDT_BEREKEND_ALS)
                    self.state = 608
                    self.expressie()
                    pass
                elif token in [12]:
                    self.state = 609
                    self.match(RegelSpraakParser.WORDT_GESTELD_OP)
                    self.state = 610
                    self.expressie()
                    pass
                elif token in [13]:
                    self.state = 611
                    self.match(RegelSpraakParser.WORDT_GEINITIALISEERD_OP)
                    self.state = 612
                    self.expressie()
                    pass
                else:
                    raise NoViableAltException(self)

                pass

            elif la_ == 5:
                localctx = RegelSpraakParser.SpecialPhraseResultaatContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 615
                _la = self._input.LA(1)
                if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 28) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 619
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==245:
                    self.state = 616
                    self.identifier()
                    self.state = 621
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 628
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [11]:
                    self.state = 622
                    self.match(RegelSpraakParser.WORDT_BEREKEND_ALS)
                    self.state = 623
                    self.expressie()
                    pass
                elif token in [12]:
                    self.state = 624
                    self.match(RegelSpraakParser.WORDT_GESTELD_OP)
                    self.state = 625
                    self.expressie()
                    pass
                elif token in [13]:
                    self.state = 626
                    self.match(RegelSpraakParser.WORDT_GEINITIALISEERD_OP)
                    self.state = 627
                    self.expressie()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 635
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==144 or _la==227:
                    self.state = 630
                    _la = self._input.LA(1)
                    if not(_la==144 or _la==227):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()
                    self.state = 631
                    self.datumLiteral()
                    self.state = 632
                    _la = self._input.LA(1)
                    if not(_la==140 or _la==142):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()
                    self.state = 633
                    self.datumLiteral()


                self.state = 638
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,77,self._ctx)
                if la_ == 1:
                    self.state = 637
                    self.match(RegelSpraakParser.DOT)


                pass

            elif la_ == 6:
                localctx = RegelSpraakParser.AantalDagenInResultaatContext(self, localctx)
                self.enterOuterAlt(localctx, 6)
                self.state = 640
                self.match(RegelSpraakParser.HET_AANTAL_DAGEN_IN)
                self.state = 641
                _la = self._input.LA(1)
                if not(_la==210 or _la==212):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 648
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [11]:
                    self.state = 642
                    self.match(RegelSpraakParser.WORDT_BEREKEND_ALS)
                    self.state = 643
                    self.expressie()
                    pass
                elif token in [12]:
                    self.state = 644
                    self.match(RegelSpraakParser.WORDT_GESTELD_OP)
                    self.state = 645
                    self.expressie()
                    pass
                elif token in [13]:
                    self.state = 646
                    self.match(RegelSpraakParser.WORDT_GEINITIALISEERD_OP)
                    self.state = 647
                    self.expressie()
                    pass
                else:
                    raise NoViableAltException(self)

                pass

            elif la_ == 7:
                localctx = RegelSpraakParser.ObjectCreatieActieContext(self, localctx)
                self.enterOuterAlt(localctx, 7)
                self.state = 650
                self.objectCreatie()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ObjectCreatieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.objectType = None # NaamwoordContext

        def ER_WORDT_EEN_NIEUW(self):
            return self.getToken(RegelSpraakParser.ER_WORDT_EEN_NIEUW, 0)

        def AANGEMAAKT(self):
            return self.getToken(RegelSpraakParser.AANGEMAAKT, 0)

        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def objectAttributeInit(self):
            return self.getTypedRuleContext(RegelSpraakParser.ObjectAttributeInitContext,0)


        def DOT(self):
            return self.getToken(RegelSpraakParser.DOT, 0)

        def CREEER(self):
            return self.getToken(RegelSpraakParser.CREEER, 0)

        def EEN(self):
            return self.getToken(RegelSpraakParser.EEN, 0)

        def NIEUWE(self):
            return self.getToken(RegelSpraakParser.NIEUWE, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_objectCreatie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterObjectCreatie" ):
                listener.enterObjectCreatie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitObjectCreatie" ):
                listener.exitObjectCreatie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitObjectCreatie" ):
                return visitor.visitObjectCreatie(self)
            else:
                return visitor.visitChildren(self)




    def objectCreatie(self):

        localctx = RegelSpraakParser.ObjectCreatieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 86, self.RULE_objectCreatie)
        self._la = 0 # Token type
        try:
            self.state = 672
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [44]:
                self.enterOuterAlt(localctx, 1)
                self.state = 653
                self.match(RegelSpraakParser.ER_WORDT_EEN_NIEUW)
                self.state = 654
                localctx.objectType = self.naamwoord()
                self.state = 655
                self.match(RegelSpraakParser.AANGEMAAKT)
                self.state = 657
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==166:
                    self.state = 656
                    self.objectAttributeInit()


                self.state = 660
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,81,self._ctx)
                if la_ == 1:
                    self.state = 659
                    self.match(RegelSpraakParser.DOT)


                pass
            elif token in [47]:
                self.enterOuterAlt(localctx, 2)
                self.state = 662
                self.match(RegelSpraakParser.CREEER)
                self.state = 663
                self.match(RegelSpraakParser.EEN)
                self.state = 664
                self.match(RegelSpraakParser.NIEUWE)
                self.state = 665
                localctx.objectType = self.naamwoord()
                self.state = 667
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==166:
                    self.state = 666
                    self.objectAttributeInit()


                self.state = 670
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,83,self._ctx)
                if la_ == 1:
                    self.state = 669
                    self.match(RegelSpraakParser.DOT)


                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ObjectAttributeInitContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.attribuut = None # NaamwoordContext
            self.waarde = None # ExpressieContext

        def MET(self):
            return self.getToken(RegelSpraakParser.MET, 0)

        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)


        def attributeInitVervolg(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.AttributeInitVervolgContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.AttributeInitVervolgContext,i)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_objectAttributeInit

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterObjectAttributeInit" ):
                listener.enterObjectAttributeInit(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitObjectAttributeInit" ):
                listener.exitObjectAttributeInit(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitObjectAttributeInit" ):
                return visitor.visitObjectAttributeInit(self)
            else:
                return visitor.visitChildren(self)




    def objectAttributeInit(self):

        localctx = RegelSpraakParser.ObjectAttributeInitContext(self, self._ctx, self.state)
        self.enterRule(localctx, 88, self.RULE_objectAttributeInit)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 674
            self.match(RegelSpraakParser.MET)
            self.state = 675
            localctx.attribuut = self.naamwoord()
            self.state = 676
            localctx.waarde = self.expressie()
            self.state = 680
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==206:
                self.state = 677
                self.attributeInitVervolg()
                self.state = 682
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AttributeInitVervolgContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.attribuut = None # NaamwoordContext
            self.waarde = None # ExpressieContext

        def EN(self):
            return self.getToken(RegelSpraakParser.EN, 0)

        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_attributeInitVervolg

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAttributeInitVervolg" ):
                listener.enterAttributeInitVervolg(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAttributeInitVervolg" ):
                listener.exitAttributeInitVervolg(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAttributeInitVervolg" ):
                return visitor.visitAttributeInitVervolg(self)
            else:
                return visitor.visitChildren(self)




    def attributeInitVervolg(self):

        localctx = RegelSpraakParser.AttributeInitVervolgContext(self, self._ctx, self.state)
        self.enterRule(localctx, 90, self.RULE_attributeInitVervolg)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 683
            self.match(RegelSpraakParser.EN)
            self.state = 684
            localctx.attribuut = self.naamwoord()
            self.state = 685
            localctx.waarde = self.expressie()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConsistentieregelContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CONSISTENTIEREGEL(self):
            return self.getToken(RegelSpraakParser.CONSISTENTIEREGEL, 0)

        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def uniekzijnResultaat(self):
            return self.getTypedRuleContext(RegelSpraakParser.UniekzijnResultaatContext,0)


        def inconsistentResultaat(self):
            return self.getTypedRuleContext(RegelSpraakParser.InconsistentResultaatContext,0)


        def voorwaardeDeel(self):
            return self.getTypedRuleContext(RegelSpraakParser.VoorwaardeDeelContext,0)


        def DOT(self):
            return self.getToken(RegelSpraakParser.DOT, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_consistentieregel

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConsistentieregel" ):
                listener.enterConsistentieregel(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConsistentieregel" ):
                listener.exitConsistentieregel(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConsistentieregel" ):
                return visitor.visitConsistentieregel(self)
            else:
                return visitor.visitChildren(self)




    def consistentieregel(self):

        localctx = RegelSpraakParser.ConsistentieregelContext(self, self._ctx, self.state)
        self.enterRule(localctx, 92, self.RULE_consistentieregel)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 687
            self.match(RegelSpraakParser.CONSISTENTIEREGEL)
            self.state = 688
            self.naamwoord()
            self.state = 698
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,88,self._ctx)
            if la_ == 1:
                self.state = 689
                self.uniekzijnResultaat()
                pass

            elif la_ == 2:
                self.state = 690
                self.inconsistentResultaat()
                self.state = 696
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [111]:
                    self.state = 691
                    self.voorwaardeDeel()
                    self.state = 693
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==257:
                        self.state = 692
                        self.match(RegelSpraakParser.DOT)


                    pass
                elif token in [257]:
                    self.state = 695
                    self.match(RegelSpraakParser.DOT)
                    pass
                elif token in [-1, 31, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106]:
                    pass
                else:
                    pass
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UniekzijnResultaatContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def onderwerpReferentie(self):
            return self.getTypedRuleContext(RegelSpraakParser.OnderwerpReferentieContext,0)


        def MOETEN_UNIEK_ZIJN(self):
            return self.getToken(RegelSpraakParser.MOETEN_UNIEK_ZIJN, 0)

        def DOT(self):
            return self.getToken(RegelSpraakParser.DOT, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_uniekzijnResultaat

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUniekzijnResultaat" ):
                listener.enterUniekzijnResultaat(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUniekzijnResultaat" ):
                listener.exitUniekzijnResultaat(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUniekzijnResultaat" ):
                return visitor.visitUniekzijnResultaat(self)
            else:
                return visitor.visitChildren(self)




    def uniekzijnResultaat(self):

        localctx = RegelSpraakParser.UniekzijnResultaatContext(self, self._ctx, self.state)
        self.enterRule(localctx, 94, self.RULE_uniekzijnResultaat)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 700
            self.onderwerpReferentie()
            self.state = 701
            self.match(RegelSpraakParser.MOETEN_UNIEK_ZIJN)
            self.state = 703
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==257:
                self.state = 702
                self.match(RegelSpraakParser.DOT)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InconsistentResultaatContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def IS_INCONSISTENT(self):
            return self.getToken(RegelSpraakParser.IS_INCONSISTENT, 0)

        def DE(self):
            return self.getToken(RegelSpraakParser.DE, 0)

        def HET(self):
            return self.getToken(RegelSpraakParser.HET, 0)

        def ER(self):
            return self.getToken(RegelSpraakParser.ER, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_inconsistentResultaat

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInconsistentResultaat" ):
                listener.enterInconsistentResultaat(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInconsistentResultaat" ):
                listener.exitInconsistentResultaat(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInconsistentResultaat" ):
                return visitor.visitInconsistentResultaat(self)
            else:
                return visitor.visitChildren(self)




    def inconsistentResultaat(self):

        localctx = RegelSpraakParser.InconsistentResultaatContext(self, self._ctx, self.state)
        self.enterRule(localctx, 96, self.RULE_inconsistentResultaat)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 706
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,90,self._ctx)
            if la_ == 1:
                self.state = 705
                _la = self._input.LA(1)
                if not(((((_la - 202)) & ~0x3f) == 0 and ((1 << (_la - 202)) & 2147483681) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


            self.state = 708
            self.naamwoord()
            self.state = 709
            self.match(RegelSpraakParser.IS_INCONSISTENT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VoorwaardeDeelContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INDIEN(self):
            return self.getToken(RegelSpraakParser.INDIEN, 0)

        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)


        def toplevelSamengesteldeVoorwaarde(self):
            return self.getTypedRuleContext(RegelSpraakParser.ToplevelSamengesteldeVoorwaardeContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_voorwaardeDeel

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVoorwaardeDeel" ):
                listener.enterVoorwaardeDeel(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVoorwaardeDeel" ):
                listener.exitVoorwaardeDeel(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVoorwaardeDeel" ):
                return visitor.visitVoorwaardeDeel(self)
            else:
                return visitor.visitChildren(self)




    def voorwaardeDeel(self):

        localctx = RegelSpraakParser.VoorwaardeDeelContext(self, self._ctx, self.state)
        self.enterRule(localctx, 98, self.RULE_voorwaardeDeel)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 711
            self.match(RegelSpraakParser.INDIEN)
            self.state = 714
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,91,self._ctx)
            if la_ == 1:
                self.state = 712
                self.expressie()
                pass

            elif la_ == 2:
                self.state = 713
                self.toplevelSamengesteldeVoorwaarde()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OnderwerpReferentieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def basisOnderwerp(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.BasisOnderwerpContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.BasisOnderwerpContext,i)


        def voorzetsel(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.VoorzetselContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.VoorzetselContext,i)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_onderwerpReferentie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOnderwerpReferentie" ):
                listener.enterOnderwerpReferentie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOnderwerpReferentie" ):
                listener.exitOnderwerpReferentie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOnderwerpReferentie" ):
                return visitor.visitOnderwerpReferentie(self)
            else:
                return visitor.visitChildren(self)




    def onderwerpReferentie(self):

        localctx = RegelSpraakParser.OnderwerpReferentieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 100, self.RULE_onderwerpReferentie)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 716
            self.basisOnderwerp()
            self.state = 722
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,92,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 717
                    self.voorzetsel()
                    self.state = 718
                    self.basisOnderwerp() 
                self.state = 724
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,92,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BasisOnderwerpContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.IDENTIFIER)
            else:
                return self.getToken(RegelSpraakParser.IDENTIFIER, i)

        def DE(self):
            return self.getToken(RegelSpraakParser.DE, 0)

        def HET(self):
            return self.getToken(RegelSpraakParser.HET, 0)

        def EEN(self):
            return self.getToken(RegelSpraakParser.EEN, 0)

        def ZIJN(self):
            return self.getToken(RegelSpraakParser.ZIJN, 0)

        def HIJ(self):
            return self.getToken(RegelSpraakParser.HIJ, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_basisOnderwerp

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBasisOnderwerp" ):
                listener.enterBasisOnderwerp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBasisOnderwerp" ):
                listener.exitBasisOnderwerp(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBasisOnderwerp" ):
                return visitor.visitBasisOnderwerp(self)
            else:
                return visitor.visitChildren(self)




    def basisOnderwerp(self):

        localctx = RegelSpraakParser.BasisOnderwerpContext(self, self._ctx, self.state)
        self.enterRule(localctx, 102, self.RULE_basisOnderwerp)
        self._la = 0 # Token type
        try:
            self.state = 734
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [116, 202, 205, 207, 245]:
                self.enterOuterAlt(localctx, 1)
                self.state = 726
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==116 or ((((_la - 202)) & ~0x3f) == 0 and ((1 << (_la - 202)) & 41) != 0):
                    self.state = 725
                    _la = self._input.LA(1)
                    if not(_la==116 or ((((_la - 202)) & ~0x3f) == 0 and ((1 << (_la - 202)) & 41) != 0)):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                self.state = 729 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 728
                        self.match(RegelSpraakParser.IDENTIFIER)

                    else:
                        raise NoViableAltException(self)
                    self.state = 731 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,94,self._ctx)

                pass
            elif token in [208]:
                self.enterOuterAlt(localctx, 2)
                self.state = 733
                self.match(RegelSpraakParser.HIJ)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AttribuutReferentieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def VAN(self):
            return self.getToken(RegelSpraakParser.VAN, 0)

        def onderwerpReferentie(self):
            return self.getTypedRuleContext(RegelSpraakParser.OnderwerpReferentieContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_attribuutReferentie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAttribuutReferentie" ):
                listener.enterAttribuutReferentie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAttribuutReferentie" ):
                listener.exitAttribuutReferentie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAttribuutReferentie" ):
                return visitor.visitAttribuutReferentie(self)
            else:
                return visitor.visitChildren(self)




    def attribuutReferentie(self):

        localctx = RegelSpraakParser.AttribuutReferentieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 104, self.RULE_attribuutReferentie)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 736
            self.naamwoord()
            self.state = 737
            self.match(RegelSpraakParser.VAN)
            self.state = 738
            self.onderwerpReferentie()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class KenmerkNaamContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def onderwerpReferentie(self):
            return self.getTypedRuleContext(RegelSpraakParser.OnderwerpReferentieContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_kenmerkNaam

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterKenmerkNaam" ):
                listener.enterKenmerkNaam(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitKenmerkNaam" ):
                listener.exitKenmerkNaam(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitKenmerkNaam" ):
                return visitor.visitKenmerkNaam(self)
            else:
                return visitor.visitChildren(self)




    def kenmerkNaam(self):

        localctx = RegelSpraakParser.KenmerkNaamContext(self, self._ctx, self.state)
        self.enterRule(localctx, 106, self.RULE_kenmerkNaam)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 740
            self.onderwerpReferentie()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BezieldeReferentieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ZIJN(self):
            return self.getToken(RegelSpraakParser.ZIJN, 0)

        def identifier(self):
            return self.getTypedRuleContext(RegelSpraakParser.IdentifierContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_bezieldeReferentie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBezieldeReferentie" ):
                listener.enterBezieldeReferentie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBezieldeReferentie" ):
                listener.exitBezieldeReferentie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBezieldeReferentie" ):
                return visitor.visitBezieldeReferentie(self)
            else:
                return visitor.visitChildren(self)




    def bezieldeReferentie(self):

        localctx = RegelSpraakParser.BezieldeReferentieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 108, self.RULE_bezieldeReferentie)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 742
            self.match(RegelSpraakParser.ZIJN)
            self.state = 743
            self.identifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ToplevelSamengesteldeVoorwaardeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def AAN(self):
            return self.getToken(RegelSpraakParser.AAN, 0)

        def voorwaardeKwantificatie(self):
            return self.getTypedRuleContext(RegelSpraakParser.VoorwaardeKwantificatieContext,0)


        def VOLGENDE_VOORWAARDEN(self):
            return self.getToken(RegelSpraakParser.VOLGENDE_VOORWAARDEN, 0)

        def VOLDOET(self):
            return self.getToken(RegelSpraakParser.VOLDOET, 0)

        def COLON(self):
            return self.getToken(RegelSpraakParser.COLON, 0)

        def samengesteldeVoorwaardeOnderdeel(self):
            return self.getTypedRuleContext(RegelSpraakParser.SamengesteldeVoorwaardeOnderdeelContext,0)


        def HIJ(self):
            return self.getToken(RegelSpraakParser.HIJ, 0)

        def HET(self):
            return self.getToken(RegelSpraakParser.HET, 0)

        def onderwerpReferentie(self):
            return self.getTypedRuleContext(RegelSpraakParser.OnderwerpReferentieContext,0)


        def ER_AAN(self):
            return self.getToken(RegelSpraakParser.ER_AAN, 0)

        def WORDT_VOLDAAN(self):
            return self.getToken(RegelSpraakParser.WORDT_VOLDAAN, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_toplevelSamengesteldeVoorwaarde

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterToplevelSamengesteldeVoorwaarde" ):
                listener.enterToplevelSamengesteldeVoorwaarde(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitToplevelSamengesteldeVoorwaarde" ):
                listener.exitToplevelSamengesteldeVoorwaarde(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitToplevelSamengesteldeVoorwaarde" ):
                return visitor.visitToplevelSamengesteldeVoorwaarde(self)
            else:
                return visitor.visitChildren(self)




    def toplevelSamengesteldeVoorwaarde(self):

        localctx = RegelSpraakParser.ToplevelSamengesteldeVoorwaardeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 110, self.RULE_toplevelSamengesteldeVoorwaarde)
        try:
            self.state = 764
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [116, 202, 205, 207, 208, 245]:
                self.enterOuterAlt(localctx, 1)
                self.state = 748
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,96,self._ctx)
                if la_ == 1:
                    self.state = 745
                    self.match(RegelSpraakParser.HIJ)
                    pass

                elif la_ == 2:
                    self.state = 746
                    self.match(RegelSpraakParser.HET)
                    pass

                elif la_ == 3:
                    self.state = 747
                    self.onderwerpReferentie()
                    pass


                self.state = 750
                self.match(RegelSpraakParser.AAN)
                self.state = 751
                self.voorwaardeKwantificatie()
                self.state = 752
                self.match(RegelSpraakParser.VOLGENDE_VOORWAARDEN)
                self.state = 753
                self.match(RegelSpraakParser.VOLDOET)
                self.state = 754
                self.match(RegelSpraakParser.COLON)
                self.state = 755
                self.samengesteldeVoorwaardeOnderdeel()
                pass
            elif token in [49]:
                self.enterOuterAlt(localctx, 2)
                self.state = 757
                self.match(RegelSpraakParser.ER_AAN)
                self.state = 758
                self.voorwaardeKwantificatie()
                self.state = 759
                self.match(RegelSpraakParser.VOLGENDE_VOORWAARDEN)
                self.state = 760
                self.match(RegelSpraakParser.WORDT_VOLDAAN)
                self.state = 761
                self.match(RegelSpraakParser.COLON)
                self.state = 762
                self.samengesteldeVoorwaardeOnderdeel()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VoorwaardeKwantificatieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ALLE(self):
            return self.getToken(RegelSpraakParser.ALLE, 0)

        def TENMINSTE(self):
            return self.getToken(RegelSpraakParser.TENMINSTE, 0)

        def VAN(self):
            return self.getToken(RegelSpraakParser.VAN, 0)

        def DE(self):
            return self.getToken(RegelSpraakParser.DE, 0)

        def EEN_TELWOORD(self):
            return self.getToken(RegelSpraakParser.EEN_TELWOORD, 0)

        def TWEE_TELWOORD(self):
            return self.getToken(RegelSpraakParser.TWEE_TELWOORD, 0)

        def DRIE_TELWOORD(self):
            return self.getToken(RegelSpraakParser.DRIE_TELWOORD, 0)

        def VIER_TELWOORD(self):
            return self.getToken(RegelSpraakParser.VIER_TELWOORD, 0)

        def NUMBER(self):
            return self.getToken(RegelSpraakParser.NUMBER, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_voorwaardeKwantificatie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVoorwaardeKwantificatie" ):
                listener.enterVoorwaardeKwantificatie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVoorwaardeKwantificatie" ):
                listener.exitVoorwaardeKwantificatie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVoorwaardeKwantificatie" ):
                return visitor.visitVoorwaardeKwantificatie(self)
            else:
                return visitor.visitChildren(self)




    def voorwaardeKwantificatie(self):

        localctx = RegelSpraakParser.VoorwaardeKwantificatieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 112, self.RULE_voorwaardeKwantificatie)
        self._la = 0 # Token type
        try:
            self.state = 771
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [119]:
                self.enterOuterAlt(localctx, 1)
                self.state = 766
                self.match(RegelSpraakParser.ALLE)
                pass
            elif token in [151]:
                self.enterOuterAlt(localctx, 2)
                self.state = 767
                self.match(RegelSpraakParser.TENMINSTE)
                self.state = 768
                _la = self._input.LA(1)
                if not(((((_la - 191)) & ~0x3f) == 0 and ((1 << (_la - 191)) & 36028797018964067) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 769
                self.match(RegelSpraakParser.VAN)
                self.state = 770
                self.match(RegelSpraakParser.DE)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SamengesteldeVoorwaardeOnderdeelContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def genesteVoorwaarde(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.GenesteVoorwaardeContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.GenesteVoorwaardeContext,i)


        def BULLET(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.BULLET)
            else:
                return self.getToken(RegelSpraakParser.BULLET, i)

        def MINUS(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.MINUS)
            else:
                return self.getToken(RegelSpraakParser.MINUS, i)

        def ASTERISK(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.ASTERISK)
            else:
                return self.getToken(RegelSpraakParser.ASTERISK, i)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_samengesteldeVoorwaardeOnderdeel

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSamengesteldeVoorwaardeOnderdeel" ):
                listener.enterSamengesteldeVoorwaardeOnderdeel(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSamengesteldeVoorwaardeOnderdeel" ):
                listener.exitSamengesteldeVoorwaardeOnderdeel(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSamengesteldeVoorwaardeOnderdeel" ):
                return visitor.visitSamengesteldeVoorwaardeOnderdeel(self)
            else:
                return visitor.visitChildren(self)




    def samengesteldeVoorwaardeOnderdeel(self):

        localctx = RegelSpraakParser.SamengesteldeVoorwaardeOnderdeelContext(self, self._ctx, self.state)
        self.enterRule(localctx, 114, self.RULE_samengesteldeVoorwaardeOnderdeel)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 773
            _la = self._input.LA(1)
            if not(((((_la - 262)) & ~0x3f) == 0 and ((1 << (_la - 262)) & 131) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 774
            self.genesteVoorwaarde()
            self.state = 779
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((((_la - 262)) & ~0x3f) == 0 and ((1 << (_la - 262)) & 131) != 0):
                self.state = 775
                _la = self._input.LA(1)
                if not(((((_la - 262)) & ~0x3f) == 0 and ((1 << (_la - 262)) & 131) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 776
                self.genesteVoorwaarde()
                self.state = 781
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GenesteVoorwaardeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_genesteVoorwaarde

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGenesteVoorwaarde" ):
                listener.enterGenesteVoorwaarde(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGenesteVoorwaarde" ):
                listener.exitGenesteVoorwaarde(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGenesteVoorwaarde" ):
                return visitor.visitGenesteVoorwaarde(self)
            else:
                return visitor.visitChildren(self)




    def genesteVoorwaarde(self):

        localctx = RegelSpraakParser.GenesteVoorwaardeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 116, self.RULE_genesteVoorwaarde)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 782
            self.expressie()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VariabeleDeelContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DAARBIJ_GELDT(self):
            return self.getToken(RegelSpraakParser.DAARBIJ_GELDT, 0)

        def DOT(self):
            return self.getToken(RegelSpraakParser.DOT, 0)

        def variabeleToekenning(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.VariabeleToekenningContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.VariabeleToekenningContext,i)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_variabeleDeel

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVariabeleDeel" ):
                listener.enterVariabeleDeel(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVariabeleDeel" ):
                listener.exitVariabeleDeel(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVariabeleDeel" ):
                return visitor.visitVariabeleDeel(self)
            else:
                return visitor.visitChildren(self)




    def variabeleDeel(self):

        localctx = RegelSpraakParser.VariabeleDeelContext(self, self._ctx, self.state)
        self.enterRule(localctx, 118, self.RULE_variabeleDeel)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 784
            self.match(RegelSpraakParser.DAARBIJ_GELDT)
            self.state = 788
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==48 or _la==116 or _la==135 or ((((_la - 202)) & ~0x3f) == 0 and ((1 << (_la - 202)) & 8796093022241) != 0):
                self.state = 785
                self.variabeleToekenning()
                self.state = 790
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 791
            self.match(RegelSpraakParser.DOT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VariabeleToekenningContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def IS(self):
            return self.getToken(RegelSpraakParser.IS, 0)

        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)


        def SEMICOLON(self):
            return self.getToken(RegelSpraakParser.SEMICOLON, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_variabeleToekenning

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVariabeleToekenning" ):
                listener.enterVariabeleToekenning(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVariabeleToekenning" ):
                listener.exitVariabeleToekenning(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVariabeleToekenning" ):
                return visitor.visitVariabeleToekenning(self)
            else:
                return visitor.visitChildren(self)




    def variabeleToekenning(self):

        localctx = RegelSpraakParser.VariabeleToekenningContext(self, self._ctx, self.state)
        self.enterRule(localctx, 120, self.RULE_variabeleToekenning)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 793
            self.naamwoord()
            self.state = 794
            self.match(RegelSpraakParser.IS)
            self.state = 795
            self.expressie()
            self.state = 797
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==259:
                self.state = 796
                self.match(RegelSpraakParser.SEMICOLON)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExpressieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def logicalExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.LogicalExpressionContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_expressie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpressie" ):
                listener.enterExpressie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpressie" ):
                listener.exitExpressie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExpressie" ):
                return visitor.visitExpressie(self)
            else:
                return visitor.visitChildren(self)




    def expressie(self):

        localctx = RegelSpraakParser.ExpressieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 122, self.RULE_expressie)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 799
            self.logicalExpression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LogicalExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def comparisonExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.ComparisonExpressionContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_logicalExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLogicalExpression" ):
                listener.enterLogicalExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLogicalExpression" ):
                listener.exitLogicalExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLogicalExpression" ):
                return visitor.visitLogicalExpression(self)
            else:
                return visitor.visitChildren(self)




    def logicalExpression(self):

        localctx = RegelSpraakParser.LogicalExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 124, self.RULE_logicalExpression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 801
            self.comparisonExpression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ComparisonExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_comparisonExpression

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class BinaryComparisonExprContext(ComparisonExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.ComparisonExpressionContext
            super().__init__(parser)
            self.left = None # AdditiveExpressionContext
            self.right = None # AdditiveExpressionContext
            self.copyFrom(ctx)

        def additiveExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.AdditiveExpressionContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.AdditiveExpressionContext,i)

        def comparisonOperator(self):
            return self.getTypedRuleContext(RegelSpraakParser.ComparisonOperatorContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBinaryComparisonExpr" ):
                listener.enterBinaryComparisonExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBinaryComparisonExpr" ):
                listener.exitBinaryComparisonExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBinaryComparisonExpr" ):
                return visitor.visitBinaryComparisonExpr(self)
            else:
                return visitor.visitChildren(self)


    class UnaryConditionExprContext(ComparisonExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.ComparisonExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def unaryCondition(self):
            return self.getTypedRuleContext(RegelSpraakParser.UnaryConditionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnaryConditionExpr" ):
                listener.enterUnaryConditionExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnaryConditionExpr" ):
                listener.exitUnaryConditionExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnaryConditionExpr" ):
                return visitor.visitUnaryConditionExpr(self)
            else:
                return visitor.visitChildren(self)


    class HeeftKenmerkExprContext(ComparisonExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.ComparisonExpressionContext
            super().__init__(parser)
            self.left = None # AdditiveExpressionContext
            self.copyFrom(ctx)

        def HEEFT(self):
            return self.getToken(RegelSpraakParser.HEEFT, 0)
        def identifier(self):
            return self.getTypedRuleContext(RegelSpraakParser.IdentifierContext,0)

        def additiveExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.AdditiveExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterHeeftKenmerkExpr" ):
                listener.enterHeeftKenmerkExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitHeeftKenmerkExpr" ):
                listener.exitHeeftKenmerkExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitHeeftKenmerkExpr" ):
                return visitor.visitHeeftKenmerkExpr(self)
            else:
                return visitor.visitChildren(self)


    class RegelStatusConditionExprContext(ComparisonExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.ComparisonExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def regelStatusCondition(self):
            return self.getTypedRuleContext(RegelSpraakParser.RegelStatusConditionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRegelStatusConditionExpr" ):
                listener.enterRegelStatusConditionExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRegelStatusConditionExpr" ):
                listener.exitRegelStatusConditionExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRegelStatusConditionExpr" ):
                return visitor.visitRegelStatusConditionExpr(self)
            else:
                return visitor.visitChildren(self)


    class IsKenmerkExprContext(ComparisonExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.ComparisonExpressionContext
            super().__init__(parser)
            self.left = None # AdditiveExpressionContext
            self.copyFrom(ctx)

        def IS(self):
            return self.getToken(RegelSpraakParser.IS, 0)
        def identifier(self):
            return self.getTypedRuleContext(RegelSpraakParser.IdentifierContext,0)

        def additiveExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.AdditiveExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIsKenmerkExpr" ):
                listener.enterIsKenmerkExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIsKenmerkExpr" ):
                listener.exitIsKenmerkExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIsKenmerkExpr" ):
                return visitor.visitIsKenmerkExpr(self)
            else:
                return visitor.visitChildren(self)



    def comparisonExpression(self):

        localctx = RegelSpraakParser.ComparisonExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 126, self.RULE_comparisonExpression)
        try:
            self.state = 819
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,103,self._ctx)
            if la_ == 1:
                localctx = RegelSpraakParser.BinaryComparisonExprContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 803
                localctx.left = self.additiveExpression()
                self.state = 807
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,102,self._ctx)
                if la_ == 1:
                    self.state = 804
                    self.comparisonOperator()
                    self.state = 805
                    localctx.right = self.additiveExpression()


                pass

            elif la_ == 2:
                localctx = RegelSpraakParser.UnaryConditionExprContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 809
                self.unaryCondition()
                pass

            elif la_ == 3:
                localctx = RegelSpraakParser.RegelStatusConditionExprContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 810
                self.regelStatusCondition()
                pass

            elif la_ == 4:
                localctx = RegelSpraakParser.IsKenmerkExprContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 811
                localctx.left = self.additiveExpression()
                self.state = 812
                self.match(RegelSpraakParser.IS)
                self.state = 813
                self.identifier()
                pass

            elif la_ == 5:
                localctx = RegelSpraakParser.HeeftKenmerkExprContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 815
                localctx.left = self.additiveExpression()
                self.state = 816
                self.match(RegelSpraakParser.HEEFT)
                self.state = 817
                self.identifier()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ComparisonOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.GELIJK_AAN, 0)

        def ONGELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.ONGELIJK_AAN, 0)

        def GROTER_DAN(self):
            return self.getToken(RegelSpraakParser.GROTER_DAN, 0)

        def GROTER_OF_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.GROTER_OF_GELIJK_AAN, 0)

        def KLEINER_DAN(self):
            return self.getToken(RegelSpraakParser.KLEINER_DAN, 0)

        def KLEINER_OF_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.KLEINER_OF_GELIJK_AAN, 0)

        def KLEINER_IS_DAN(self):
            return self.getToken(RegelSpraakParser.KLEINER_IS_DAN, 0)

        def GROTER_IS_DAN(self):
            return self.getToken(RegelSpraakParser.GROTER_IS_DAN, 0)

        def IS(self):
            return self.getToken(RegelSpraakParser.IS, 0)

        def LATER_DAN(self):
            return self.getToken(RegelSpraakParser.LATER_DAN, 0)

        def LATER_OF_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.LATER_OF_GELIJK_AAN, 0)

        def EERDER_DAN(self):
            return self.getToken(RegelSpraakParser.EERDER_DAN, 0)

        def EERDER_OF_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.EERDER_OF_GELIJK_AAN, 0)

        def NIET(self):
            return self.getToken(RegelSpraakParser.NIET, 0)

        def IS_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.IS_GELIJK_AAN, 0)

        def IS_ONGELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.IS_ONGELIJK_AAN, 0)

        def IS_KLEINER_DAN(self):
            return self.getToken(RegelSpraakParser.IS_KLEINER_DAN, 0)

        def IS_KLEINER_OF_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.IS_KLEINER_OF_GELIJK_AAN, 0)

        def IS_GROTER_DAN(self):
            return self.getToken(RegelSpraakParser.IS_GROTER_DAN, 0)

        def IS_GROTER_OF_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.IS_GROTER_OF_GELIJK_AAN, 0)

        def ZIJN_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.ZIJN_GELIJK_AAN, 0)

        def ZIJN_ONGELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.ZIJN_ONGELIJK_AAN, 0)

        def ZIJN_KLEINER_DAN(self):
            return self.getToken(RegelSpraakParser.ZIJN_KLEINER_DAN, 0)

        def ZIJN_KLEINER_OF_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.ZIJN_KLEINER_OF_GELIJK_AAN, 0)

        def ZIJN_GROTER_DAN(self):
            return self.getToken(RegelSpraakParser.ZIJN_GROTER_DAN, 0)

        def ZIJN_GROTER_OF_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.ZIJN_GROTER_OF_GELIJK_AAN, 0)

        def IS_LATER_DAN(self):
            return self.getToken(RegelSpraakParser.IS_LATER_DAN, 0)

        def IS_LATER_OF_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.IS_LATER_OF_GELIJK_AAN, 0)

        def IS_EERDER_DAN(self):
            return self.getToken(RegelSpraakParser.IS_EERDER_DAN, 0)

        def IS_EERDER_OF_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.IS_EERDER_OF_GELIJK_AAN, 0)

        def ZIJN_LATER_DAN(self):
            return self.getToken(RegelSpraakParser.ZIJN_LATER_DAN, 0)

        def ZIJN_LATER_OF_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.ZIJN_LATER_OF_GELIJK_AAN, 0)

        def ZIJN_EERDER_DAN(self):
            return self.getToken(RegelSpraakParser.ZIJN_EERDER_DAN, 0)

        def ZIJN_EERDER_OF_GELIJK_AAN(self):
            return self.getToken(RegelSpraakParser.ZIJN_EERDER_OF_GELIJK_AAN, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_comparisonOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterComparisonOperator" ):
                listener.enterComparisonOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitComparisonOperator" ):
                listener.exitComparisonOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitComparisonOperator" ):
                return visitor.visitComparisonOperator(self)
            else:
                return visitor.visitChildren(self)




    def comparisonOperator(self):

        localctx = RegelSpraakParser.ComparisonOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 128, self.RULE_comparisonOperator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 821
            _la = self._input.LA(1)
            if not(((((_la - 25)) & ~0x3f) == 0 and ((1 << (_la - 25)) & 35184338731023) != 0) or ((((_la - 112)) & ~0x3f) == 0 and ((1 << (_la - 112)) & 25381121) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AdditiveExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.left = None # MultiplicativeExpressionContext
            self.right = None # MultiplicativeExpressionContext

        def multiplicativeExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.MultiplicativeExpressionContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.MultiplicativeExpressionContext,i)


        def additiveOperator(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.AdditiveOperatorContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.AdditiveOperatorContext,i)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_additiveExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAdditiveExpression" ):
                listener.enterAdditiveExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAdditiveExpression" ):
                listener.exitAdditiveExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAdditiveExpression" ):
                return visitor.visitAdditiveExpression(self)
            else:
                return visitor.visitChildren(self)




    def additiveExpression(self):

        localctx = RegelSpraakParser.AdditiveExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 130, self.RULE_additiveExpression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 823
            localctx.left = self.multiplicativeExpression()
            self.state = 829
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,104,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 824
                    self.additiveOperator()
                    self.state = 825
                    localctx.right = self.multiplicativeExpression() 
                self.state = 831
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,104,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AdditiveOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PLUS(self):
            return self.getToken(RegelSpraakParser.PLUS, 0)

        def MIN(self):
            return self.getToken(RegelSpraakParser.MIN, 0)

        def VERMINDERD_MET(self):
            return self.getToken(RegelSpraakParser.VERMINDERD_MET, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_additiveOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAdditiveOperator" ):
                listener.enterAdditiveOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAdditiveOperator" ):
                listener.exitAdditiveOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAdditiveOperator" ):
                return visitor.visitAdditiveOperator(self)
            else:
                return visitor.visitChildren(self)




    def additiveOperator(self):

        localctx = RegelSpraakParser.AdditiveOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 132, self.RULE_additiveOperator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 832
            _la = self._input.LA(1)
            if not(((((_la - 132)) & ~0x3f) == 0 and ((1 << (_la - 132)) & 16417) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MultiplicativeExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.left = None # PowerExpressionContext
            self.right = None # PowerExpressionContext

        def powerExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.PowerExpressionContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.PowerExpressionContext,i)


        def multiplicativeOperator(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.MultiplicativeOperatorContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.MultiplicativeOperatorContext,i)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_multiplicativeExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMultiplicativeExpression" ):
                listener.enterMultiplicativeExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMultiplicativeExpression" ):
                listener.exitMultiplicativeExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMultiplicativeExpression" ):
                return visitor.visitMultiplicativeExpression(self)
            else:
                return visitor.visitChildren(self)




    def multiplicativeExpression(self):

        localctx = RegelSpraakParser.MultiplicativeExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 134, self.RULE_multiplicativeExpression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 834
            localctx.left = self.powerExpression()
            self.state = 840
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,105,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 835
                    self.multiplicativeOperator()
                    self.state = 836
                    localctx.right = self.powerExpression() 
                self.state = 842
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,105,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MultiplicativeOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MAAL(self):
            return self.getToken(RegelSpraakParser.MAAL, 0)

        def GEDEELD_DOOR(self):
            return self.getToken(RegelSpraakParser.GEDEELD_DOOR, 0)

        def GEDEELD_DOOR_ABS(self):
            return self.getToken(RegelSpraakParser.GEDEELD_DOOR_ABS, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_multiplicativeOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMultiplicativeOperator" ):
                listener.enterMultiplicativeOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMultiplicativeOperator" ):
                listener.exitMultiplicativeOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMultiplicativeOperator" ):
                return visitor.visitMultiplicativeOperator(self)
            else:
                return visitor.visitChildren(self)




    def multiplicativeOperator(self):

        localctx = RegelSpraakParser.MultiplicativeOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 136, self.RULE_multiplicativeOperator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 843
            _la = self._input.LA(1)
            if not(((((_la - 121)) & ~0x3f) == 0 and ((1 << (_la - 121)) & 1027) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PowerExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.left = None # PrimaryExpressionContext
            self.right = None # PrimaryExpressionContext

        def primaryExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.PrimaryExpressionContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,i)


        def powerOperator(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.PowerOperatorContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.PowerOperatorContext,i)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_powerExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPowerExpression" ):
                listener.enterPowerExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPowerExpression" ):
                listener.exitPowerExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPowerExpression" ):
                return visitor.visitPowerExpression(self)
            else:
                return visitor.visitChildren(self)




    def powerExpression(self):

        localctx = RegelSpraakParser.PowerExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 138, self.RULE_powerExpression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 845
            localctx.left = self.primaryExpression(0)
            self.state = 851
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,106,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 846
                    self.powerOperator()
                    self.state = 847
                    localctx.right = self.primaryExpression(0) 
                self.state = 853
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,106,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PowerOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TOT_DE_MACHT(self):
            return self.getToken(RegelSpraakParser.TOT_DE_MACHT, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_powerOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPowerOperator" ):
                listener.enterPowerOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPowerOperator" ):
                listener.exitPowerOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPowerOperator" ):
                return visitor.visitPowerOperator(self)
            else:
                return visitor.visitChildren(self)




    def powerOperator(self):

        localctx = RegelSpraakParser.PowerOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 140, self.RULE_powerOperator)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 854
            self.match(RegelSpraakParser.TOT_DE_MACHT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PrimaryExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_primaryExpression

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)


    class WortelFuncExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def DE_WORTEL_VAN(self):
            return self.getToken(RegelSpraakParser.DE_WORTEL_VAN, 0)
        def primaryExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWortelFuncExpr" ):
                listener.enterWortelFuncExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWortelFuncExpr" ):
                listener.exitWortelFuncExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitWortelFuncExpr" ):
                return visitor.visitWortelFuncExpr(self)
            else:
                return visitor.visitChildren(self)


    class BooleanTrueLiteralExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def WAAR(self):
            return self.getToken(RegelSpraakParser.WAAR, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBooleanTrueLiteralExpr" ):
                listener.enterBooleanTrueLiteralExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBooleanTrueLiteralExpr" ):
                listener.exitBooleanTrueLiteralExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBooleanTrueLiteralExpr" ):
                return visitor.visitBooleanTrueLiteralExpr(self)
            else:
                return visitor.visitChildren(self)


    class DatumMetFuncExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def DE_DATUM_MET(self):
            return self.getToken(RegelSpraakParser.DE_DATUM_MET, 0)
        def LPAREN(self):
            return self.getToken(RegelSpraakParser.LPAREN, 0)
        def primaryExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.PrimaryExpressionContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,i)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.COMMA)
            else:
                return self.getToken(RegelSpraakParser.COMMA, i)
        def RPAREN(self):
            return self.getToken(RegelSpraakParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDatumMetFuncExpr" ):
                listener.enterDatumMetFuncExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDatumMetFuncExpr" ):
                listener.exitDatumMetFuncExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDatumMetFuncExpr" ):
                return visitor.visitDatumMetFuncExpr(self)
            else:
                return visitor.visitChildren(self)


    class StringLiteralExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def STRING_LITERAL(self):
            return self.getToken(RegelSpraakParser.STRING_LITERAL, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStringLiteralExpr" ):
                listener.enterStringLiteralExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStringLiteralExpr" ):
                listener.exitStringLiteralExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStringLiteralExpr" ):
                return visitor.visitStringLiteralExpr(self)
            else:
                return visitor.visitChildren(self)


    class AbsValFuncExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def DE_ABSOLUTE_WAARDE_VAN(self):
            return self.getToken(RegelSpraakParser.DE_ABSOLUTE_WAARDE_VAN, 0)
        def LPAREN(self):
            return self.getToken(RegelSpraakParser.LPAREN, 0)
        def primaryExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,0)

        def RPAREN(self):
            return self.getToken(RegelSpraakParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAbsValFuncExpr" ):
                listener.enterAbsValFuncExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAbsValFuncExpr" ):
                listener.exitAbsValFuncExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAbsValFuncExpr" ):
                return visitor.visitAbsValFuncExpr(self)
            else:
                return visitor.visitChildren(self)


    class MaxValFuncExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def DE_MAXIMALE_WAARDE_VAN(self):
            return self.getToken(RegelSpraakParser.DE_MAXIMALE_WAARDE_VAN, 0)
        def primaryExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.PrimaryExpressionContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,i)

        def EN(self):
            return self.getToken(RegelSpraakParser.EN, 0)
        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.COMMA)
            else:
                return self.getToken(RegelSpraakParser.COMMA, i)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMaxValFuncExpr" ):
                listener.enterMaxValFuncExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMaxValFuncExpr" ):
                listener.exitMaxValFuncExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMaxValFuncExpr" ):
                return visitor.visitMaxValFuncExpr(self)
            else:
                return visitor.visitChildren(self)


    class RekendatumKeywordExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def REKENDATUM(self):
            return self.getToken(RegelSpraakParser.REKENDATUM, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRekendatumKeywordExpr" ):
                listener.enterRekendatumKeywordExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRekendatumKeywordExpr" ):
                listener.exitRekendatumKeywordExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRekendatumKeywordExpr" ):
                return visitor.visitRekendatumKeywordExpr(self)
            else:
                return visitor.visitChildren(self)


    class PercentageFuncExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.p = None # Token
            self.copyFrom(ctx)

        def NUMBER(self):
            return self.getToken(RegelSpraakParser.NUMBER, 0)
        def VAN(self):
            return self.getToken(RegelSpraakParser.VAN, 0)
        def primaryExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,0)

        def PERCENT_SIGN(self):
            return self.getToken(RegelSpraakParser.PERCENT_SIGN, 0)
        def IDENTIFIER(self):
            return self.getToken(RegelSpraakParser.IDENTIFIER, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPercentageFuncExpr" ):
                listener.enterPercentageFuncExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPercentageFuncExpr" ):
                listener.exitPercentageFuncExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPercentageFuncExpr" ):
                return visitor.visitPercentageFuncExpr(self)
            else:
                return visitor.visitChildren(self)


    class EersteDatumFuncExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def EERSTE_VAN(self):
            return self.getToken(RegelSpraakParser.EERSTE_VAN, 0)
        def primaryExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.PrimaryExpressionContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,i)

        def EN(self):
            return self.getToken(RegelSpraakParser.EN, 0)
        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.COMMA)
            else:
                return self.getToken(RegelSpraakParser.COMMA, i)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEersteDatumFuncExpr" ):
                listener.enterEersteDatumFuncExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEersteDatumFuncExpr" ):
                listener.exitEersteDatumFuncExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEersteDatumFuncExpr" ):
                return visitor.visitEersteDatumFuncExpr(self)
            else:
                return visitor.visitChildren(self)


    class PasenFuncExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def DE_EERSTE_PAASDAG_VAN(self):
            return self.getToken(RegelSpraakParser.DE_EERSTE_PAASDAG_VAN, 0)
        def LPAREN(self):
            return self.getToken(RegelSpraakParser.LPAREN, 0)
        def primaryExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,0)

        def RPAREN(self):
            return self.getToken(RegelSpraakParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPasenFuncExpr" ):
                listener.enterPasenFuncExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPasenFuncExpr" ):
                listener.exitPasenFuncExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPasenFuncExpr" ):
                return visitor.visitPasenFuncExpr(self)
            else:
                return visitor.visitChildren(self)


    class EnumLiteralExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ENUM_LITERAL(self):
            return self.getToken(RegelSpraakParser.ENUM_LITERAL, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEnumLiteralExpr" ):
                listener.enterEnumLiteralExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEnumLiteralExpr" ):
                listener.exitEnumLiteralExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEnumLiteralExpr" ):
                return visitor.visitEnumLiteralExpr(self)
            else:
                return visitor.visitChildren(self)


    class NumberLiteralExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def NUMBER(self):
            return self.getToken(RegelSpraakParser.NUMBER, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumberLiteralExpr" ):
                listener.enterNumberLiteralExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumberLiteralExpr" ):
                listener.exitNumberLiteralExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNumberLiteralExpr" ):
                return visitor.visitNumberLiteralExpr(self)
            else:
                return visitor.visitChildren(self)


    class AbsTijdsduurFuncExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.unitName = None # Token
            self.copyFrom(ctx)

        def DE_ABSOLUTE_TIJDSDUUR_VAN(self):
            return self.getToken(RegelSpraakParser.DE_ABSOLUTE_TIJDSDUUR_VAN, 0)
        def primaryExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.PrimaryExpressionContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,i)

        def TOT(self):
            return self.getToken(RegelSpraakParser.TOT, 0)
        def IN_HELE(self):
            return self.getToken(RegelSpraakParser.IN_HELE, 0)
        def IDENTIFIER(self):
            return self.getToken(RegelSpraakParser.IDENTIFIER, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAbsTijdsduurFuncExpr" ):
                listener.enterAbsTijdsduurFuncExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAbsTijdsduurFuncExpr" ):
                listener.exitAbsTijdsduurFuncExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAbsTijdsduurFuncExpr" ):
                return visitor.visitAbsTijdsduurFuncExpr(self)
            else:
                return visitor.visitChildren(self)


    class MaandUitFuncExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def DE(self):
            return self.getToken(RegelSpraakParser.DE, 0)
        def MAAND(self):
            return self.getToken(RegelSpraakParser.MAAND, 0)
        def UIT(self):
            return self.getToken(RegelSpraakParser.UIT, 0)
        def primaryExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMaandUitFuncExpr" ):
                listener.enterMaandUitFuncExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMaandUitFuncExpr" ):
                listener.exitMaandUitFuncExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMaandUitFuncExpr" ):
                return visitor.visitMaandUitFuncExpr(self)
            else:
                return visitor.visitChildren(self)


    class CapitalizedTotaalVanExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.condition = None # ExpressieContext
            self.copyFrom(ctx)

        def HET_TOTAAL_VAN(self):
            return self.getToken(RegelSpraakParser.HET_TOTAAL_VAN, 0)
        def expressie(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.ExpressieContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,i)

        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.IdentifierContext,i)

        def GEDURENDE_DE_TIJD_DAT(self):
            return self.getToken(RegelSpraakParser.GEDURENDE_DE_TIJD_DAT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCapitalizedTotaalVanExpr" ):
                listener.enterCapitalizedTotaalVanExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCapitalizedTotaalVanExpr" ):
                listener.exitCapitalizedTotaalVanExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCapitalizedTotaalVanExpr" ):
                return visitor.visitCapitalizedTotaalVanExpr(self)
            else:
                return visitor.visitChildren(self)


    class IdentifierExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(RegelSpraakParser.IdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIdentifierExpr" ):
                listener.enterIdentifierExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIdentifierExpr" ):
                listener.exitIdentifierExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIdentifierExpr" ):
                return visitor.visitIdentifierExpr(self)
            else:
                return visitor.visitChildren(self)


    class DatumLiteralExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def datumLiteral(self):
            return self.getTypedRuleContext(RegelSpraakParser.DatumLiteralContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDatumLiteralExpr" ):
                listener.enterDatumLiteralExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDatumLiteralExpr" ):
                listener.exitDatumLiteralExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDatumLiteralExpr" ):
                return visitor.visitDatumLiteralExpr(self)
            else:
                return visitor.visitChildren(self)


    class DimensieAggExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def attribuutReferentie(self):
            return self.getTypedRuleContext(RegelSpraakParser.AttribuutReferentieContext,0)

        def dimensieSelectie(self):
            return self.getTypedRuleContext(RegelSpraakParser.DimensieSelectieContext,0)

        def getalAggregatieFunctie(self):
            return self.getTypedRuleContext(RegelSpraakParser.GetalAggregatieFunctieContext,0)

        def datumAggregatieFunctie(self):
            return self.getTypedRuleContext(RegelSpraakParser.DatumAggregatieFunctieContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDimensieAggExpr" ):
                listener.enterDimensieAggExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDimensieAggExpr" ):
                listener.exitDimensieAggExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDimensieAggExpr" ):
                return visitor.visitDimensieAggExpr(self)
            else:
                return visitor.visitChildren(self)


    class TijdsduurFuncExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.unitName = None # Token
            self.copyFrom(ctx)

        def TIJDSDUUR_VAN(self):
            return self.getToken(RegelSpraakParser.TIJDSDUUR_VAN, 0)
        def primaryExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.PrimaryExpressionContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,i)

        def TOT(self):
            return self.getToken(RegelSpraakParser.TOT, 0)
        def IN_HELE(self):
            return self.getToken(RegelSpraakParser.IN_HELE, 0)
        def IDENTIFIER(self):
            return self.getToken(RegelSpraakParser.IDENTIFIER, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTijdsduurFuncExpr" ):
                listener.enterTijdsduurFuncExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTijdsduurFuncExpr" ):
                listener.exitTijdsduurFuncExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTijdsduurFuncExpr" ):
                return visitor.visitTijdsduurFuncExpr(self)
            else:
                return visitor.visitChildren(self)


    class AantalFuncExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def AANTAL(self):
            return self.getToken(RegelSpraakParser.AANTAL, 0)
        def onderwerpReferentie(self):
            return self.getTypedRuleContext(RegelSpraakParser.OnderwerpReferentieContext,0)

        def HET(self):
            return self.getToken(RegelSpraakParser.HET, 0)
        def ALLE(self):
            return self.getToken(RegelSpraakParser.ALLE, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAantalFuncExpr" ):
                listener.enterAantalFuncExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAantalFuncExpr" ):
                listener.exitAantalFuncExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAantalFuncExpr" ):
                return visitor.visitAantalFuncExpr(self)
            else:
                return visitor.visitChildren(self)


    class ConcatenatieExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def CONCATENATIE_VAN(self):
            return self.getToken(RegelSpraakParser.CONCATENATIE_VAN, 0)
        def primaryExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.PrimaryExpressionContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,i)

        def EN(self):
            return self.getToken(RegelSpraakParser.EN, 0)
        def OF(self):
            return self.getToken(RegelSpraakParser.OF, 0)
        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.COMMA)
            else:
                return self.getToken(RegelSpraakParser.COMMA, i)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConcatenatieExpr" ):
                listener.enterConcatenatieExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConcatenatieExpr" ):
                listener.exitConcatenatieExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConcatenatieExpr" ):
                return visitor.visitConcatenatieExpr(self)
            else:
                return visitor.visitChildren(self)


    class SomFuncExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def SOM_VAN(self):
            return self.getToken(RegelSpraakParser.SOM_VAN, 0)
        def onderwerpReferentie(self):
            return self.getTypedRuleContext(RegelSpraakParser.OnderwerpReferentieContext,0)

        def ALLE(self):
            return self.getToken(RegelSpraakParser.ALLE, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSomFuncExpr" ):
                listener.enterSomFuncExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSomFuncExpr" ):
                listener.exitSomFuncExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSomFuncExpr" ):
                return visitor.visitSomFuncExpr(self)
            else:
                return visitor.visitChildren(self)


    class AttrRefExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def attribuutReferentie(self):
            return self.getTypedRuleContext(RegelSpraakParser.AttribuutReferentieContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAttrRefExpr" ):
                listener.enterAttrRefExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAttrRefExpr" ):
                listener.exitAttrRefExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAttrRefExpr" ):
                return visitor.visitAttrRefExpr(self)
            else:
                return visitor.visitChildren(self)


    class DagUitFuncExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def DE(self):
            return self.getToken(RegelSpraakParser.DE, 0)
        def DAG(self):
            return self.getToken(RegelSpraakParser.DAG, 0)
        def UIT(self):
            return self.getToken(RegelSpraakParser.UIT, 0)
        def primaryExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDagUitFuncExpr" ):
                listener.enterDagUitFuncExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDagUitFuncExpr" ):
                listener.exitDagUitFuncExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDagUitFuncExpr" ):
                return visitor.visitDagUitFuncExpr(self)
            else:
                return visitor.visitChildren(self)


    class SimpleConcatenatieExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def primaryExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.PrimaryExpressionContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,i)

        def EN(self):
            return self.getToken(RegelSpraakParser.EN, 0)
        def OF(self):
            return self.getToken(RegelSpraakParser.OF, 0)
        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.COMMA)
            else:
                return self.getToken(RegelSpraakParser.COMMA, i)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSimpleConcatenatieExpr" ):
                listener.enterSimpleConcatenatieExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSimpleConcatenatieExpr" ):
                listener.exitSimpleConcatenatieExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSimpleConcatenatieExpr" ):
                return visitor.visitSimpleConcatenatieExpr(self)
            else:
                return visitor.visitChildren(self)


    class BegrenzingExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def primaryExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,0)

        def COMMA(self):
            return self.getToken(RegelSpraakParser.COMMA, 0)
        def begrenzing(self):
            return self.getTypedRuleContext(RegelSpraakParser.BegrenzingContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBegrenzingExpr" ):
                listener.enterBegrenzingExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBegrenzingExpr" ):
                listener.exitBegrenzingExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBegrenzingExpr" ):
                return visitor.visitBegrenzingExpr(self)
            else:
                return visitor.visitChildren(self)


    class NaamwoordExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNaamwoordExpr" ):
                listener.enterNaamwoordExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNaamwoordExpr" ):
                listener.exitNaamwoordExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNaamwoordExpr" ):
                return visitor.visitNaamwoordExpr(self)
            else:
                return visitor.visitChildren(self)


    class BooleanFalseLiteralExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ONWAAR(self):
            return self.getToken(RegelSpraakParser.ONWAAR, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBooleanFalseLiteralExpr" ):
                listener.enterBooleanFalseLiteralExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBooleanFalseLiteralExpr" ):
                listener.exitBooleanFalseLiteralExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBooleanFalseLiteralExpr" ):
                return visitor.visitBooleanFalseLiteralExpr(self)
            else:
                return visitor.visitChildren(self)


    class MinValFuncExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def DE_MINIMALE_WAARDE_VAN(self):
            return self.getToken(RegelSpraakParser.DE_MINIMALE_WAARDE_VAN, 0)
        def primaryExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.PrimaryExpressionContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,i)

        def EN(self):
            return self.getToken(RegelSpraakParser.EN, 0)
        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.COMMA)
            else:
                return self.getToken(RegelSpraakParser.COMMA, i)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMinValFuncExpr" ):
                listener.enterMinValFuncExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMinValFuncExpr" ):
                listener.exitMinValFuncExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMinValFuncExpr" ):
                return visitor.visitMinValFuncExpr(self)
            else:
                return visitor.visitChildren(self)


    class JaarUitFuncExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def HET(self):
            return self.getToken(RegelSpraakParser.HET, 0)
        def JAAR(self):
            return self.getToken(RegelSpraakParser.JAAR, 0)
        def UIT(self):
            return self.getToken(RegelSpraakParser.UIT, 0)
        def primaryExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterJaarUitFuncExpr" ):
                listener.enterJaarUitFuncExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitJaarUitFuncExpr" ):
                listener.exitJaarUitFuncExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitJaarUitFuncExpr" ):
                return visitor.visitJaarUitFuncExpr(self)
            else:
                return visitor.visitChildren(self)


    class BezieldeRefExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def bezieldeReferentie(self):
            return self.getTypedRuleContext(RegelSpraakParser.BezieldeReferentieContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBezieldeRefExpr" ):
                listener.enterBezieldeRefExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBezieldeRefExpr" ):
                listener.exitBezieldeRefExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBezieldeRefExpr" ):
                return visitor.visitBezieldeRefExpr(self)
            else:
                return visitor.visitChildren(self)


    class DateCalcExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def primaryExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.PrimaryExpressionContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,i)

        def identifier(self):
            return self.getTypedRuleContext(RegelSpraakParser.IdentifierContext,0)

        def PLUS(self):
            return self.getToken(RegelSpraakParser.PLUS, 0)
        def MIN(self):
            return self.getToken(RegelSpraakParser.MIN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDateCalcExpr" ):
                listener.enterDateCalcExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDateCalcExpr" ):
                listener.exitDateCalcExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDateCalcExpr" ):
                return visitor.visitDateCalcExpr(self)
            else:
                return visitor.visitChildren(self)


    class TotaalVanExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.condition = None # ExpressieContext
            self.copyFrom(ctx)

        def HET_TOTAAL_VAN(self):
            return self.getToken(RegelSpraakParser.HET_TOTAAL_VAN, 0)
        def expressie(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.ExpressieContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,i)

        def GEDURENDE_DE_TIJD_DAT(self):
            return self.getToken(RegelSpraakParser.GEDURENDE_DE_TIJD_DAT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTotaalVanExpr" ):
                listener.enterTotaalVanExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTotaalVanExpr" ):
                listener.exitTotaalVanExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTotaalVanExpr" ):
                return visitor.visitTotaalVanExpr(self)
            else:
                return visitor.visitChildren(self)


    class AfrondingExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def primaryExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,0)

        def afronding(self):
            return self.getTypedRuleContext(RegelSpraakParser.AfrondingContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAfrondingExpr" ):
                listener.enterAfrondingExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAfrondingExpr" ):
                listener.exitAfrondingExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAfrondingExpr" ):
                return visitor.visitAfrondingExpr(self)
            else:
                return visitor.visitChildren(self)


    class LaatsteDatumFuncExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LAATSTE_VAN(self):
            return self.getToken(RegelSpraakParser.LAATSTE_VAN, 0)
        def primaryExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.PrimaryExpressionContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,i)

        def EN(self):
            return self.getToken(RegelSpraakParser.EN, 0)
        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.COMMA)
            else:
                return self.getToken(RegelSpraakParser.COMMA, i)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLaatsteDatumFuncExpr" ):
                listener.enterLaatsteDatumFuncExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLaatsteDatumFuncExpr" ):
                listener.exitLaatsteDatumFuncExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLaatsteDatumFuncExpr" ):
                return visitor.visitLaatsteDatumFuncExpr(self)
            else:
                return visitor.visitChildren(self)


    class HetAantalDagenInExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def HET_AANTAL_DAGEN_IN(self):
            return self.getToken(RegelSpraakParser.HET_AANTAL_DAGEN_IN, 0)
        def DAT(self):
            return self.getToken(RegelSpraakParser.DAT, 0)
        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)

        def DE(self):
            return self.getToken(RegelSpraakParser.DE, 0)
        def MAAND(self):
            return self.getToken(RegelSpraakParser.MAAND, 0)
        def HET(self):
            return self.getToken(RegelSpraakParser.HET, 0)
        def JAAR(self):
            return self.getToken(RegelSpraakParser.JAAR, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterHetAantalDagenInExpr" ):
                listener.enterHetAantalDagenInExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitHetAantalDagenInExpr" ):
                listener.exitHetAantalDagenInExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitHetAantalDagenInExpr" ):
                return visitor.visitHetAantalDagenInExpr(self)
            else:
                return visitor.visitChildren(self)


    class TijdsevenredigDeelExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.condition = None # ExpressieContext
            self.copyFrom(ctx)

        def HET_TIJDSEVENREDIG_DEEL_PER(self):
            return self.getToken(RegelSpraakParser.HET_TIJDSEVENREDIG_DEEL_PER, 0)
        def VAN(self):
            return self.getToken(RegelSpraakParser.VAN, 0)
        def expressie(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.ExpressieContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,i)

        def MAAND(self):
            return self.getToken(RegelSpraakParser.MAAND, 0)
        def JAAR(self):
            return self.getToken(RegelSpraakParser.JAAR, 0)
        def GEDURENDE_DE_TIJD_DAT(self):
            return self.getToken(RegelSpraakParser.GEDURENDE_DE_TIJD_DAT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTijdsevenredigDeelExpr" ):
                listener.enterTijdsevenredigDeelExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTijdsevenredigDeelExpr" ):
                listener.exitTijdsevenredigDeelExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTijdsevenredigDeelExpr" ):
                return visitor.visitTijdsevenredigDeelExpr(self)
            else:
                return visitor.visitChildren(self)


    class CapitalizedTijdsevenredigDeelExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.condition = None # ExpressieContext
            self.copyFrom(ctx)

        def HET_TIJDSEVENREDIG_DEEL_PER(self):
            return self.getToken(RegelSpraakParser.HET_TIJDSEVENREDIG_DEEL_PER, 0)
        def VAN(self):
            return self.getToken(RegelSpraakParser.VAN, 0)
        def expressie(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.ExpressieContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,i)

        def MAAND(self):
            return self.getToken(RegelSpraakParser.MAAND, 0)
        def JAAR(self):
            return self.getToken(RegelSpraakParser.JAAR, 0)
        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.IdentifierContext,i)

        def GEDURENDE_DE_TIJD_DAT(self):
            return self.getToken(RegelSpraakParser.GEDURENDE_DE_TIJD_DAT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCapitalizedTijdsevenredigDeelExpr" ):
                listener.enterCapitalizedTijdsevenredigDeelExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCapitalizedTijdsevenredigDeelExpr" ):
                listener.exitCapitalizedTijdsevenredigDeelExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCapitalizedTijdsevenredigDeelExpr" ):
                return visitor.visitCapitalizedTijdsevenredigDeelExpr(self)
            else:
                return visitor.visitChildren(self)


    class ParenExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(RegelSpraakParser.LPAREN, 0)
        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)

        def RPAREN(self):
            return self.getToken(RegelSpraakParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParenExpr" ):
                listener.enterParenExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParenExpr" ):
                listener.exitParenExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParenExpr" ):
                return visitor.visitParenExpr(self)
            else:
                return visitor.visitChildren(self)


    class ParamRefExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def parameterMetLidwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.ParameterMetLidwoordContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParamRefExpr" ):
                listener.enterParamRefExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParamRefExpr" ):
                listener.exitParamRefExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParamRefExpr" ):
                return visitor.visitParamRefExpr(self)
            else:
                return visitor.visitChildren(self)


    class PronounExprContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def HIJ(self):
            return self.getToken(RegelSpraakParser.HIJ, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPronounExpr" ):
                listener.enterPronounExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPronounExpr" ):
                listener.exitPronounExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPronounExpr" ):
                return visitor.visitPronounExpr(self)
            else:
                return visitor.visitChildren(self)



    def primaryExpression(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = RegelSpraakParser.PrimaryExpressionContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 142
        self.enterRecursionRule(localctx, 142, self.RULE_primaryExpression, _p)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1057
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,126,self._ctx)
            if la_ == 1:
                localctx = RegelSpraakParser.AbsTijdsduurFuncExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx

                self.state = 857
                self.match(RegelSpraakParser.DE_ABSOLUTE_TIJDSDUUR_VAN)
                self.state = 858
                self.primaryExpression(0)
                self.state = 859
                self.match(RegelSpraakParser.TOT)
                self.state = 860
                self.primaryExpression(0)
                self.state = 863
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,107,self._ctx)
                if la_ == 1:
                    self.state = 861
                    self.match(RegelSpraakParser.IN_HELE)
                    self.state = 862
                    localctx.unitName = self.match(RegelSpraakParser.IDENTIFIER)


                pass

            elif la_ == 2:
                localctx = RegelSpraakParser.TijdsduurFuncExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 865
                self.match(RegelSpraakParser.TIJDSDUUR_VAN)
                self.state = 866
                self.primaryExpression(0)
                self.state = 867
                self.match(RegelSpraakParser.TOT)
                self.state = 868
                self.primaryExpression(0)
                self.state = 871
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,108,self._ctx)
                if la_ == 1:
                    self.state = 869
                    self.match(RegelSpraakParser.IN_HELE)
                    self.state = 870
                    localctx.unitName = self.match(RegelSpraakParser.IDENTIFIER)


                pass

            elif la_ == 3:
                localctx = RegelSpraakParser.SomFuncExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 873
                self.match(RegelSpraakParser.SOM_VAN)

                self.state = 875
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==119:
                    self.state = 874
                    self.match(RegelSpraakParser.ALLE)


                self.state = 877
                self.onderwerpReferentie()
                pass

            elif la_ == 4:
                localctx = RegelSpraakParser.AantalFuncExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 879
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==207:
                    self.state = 878
                    self.match(RegelSpraakParser.HET)


                self.state = 881
                self.match(RegelSpraakParser.AANTAL)

                self.state = 883
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==119:
                    self.state = 882
                    self.match(RegelSpraakParser.ALLE)


                self.state = 885
                self.onderwerpReferentie()
                pass

            elif la_ == 5:
                localctx = RegelSpraakParser.PercentageFuncExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 886
                self.match(RegelSpraakParser.NUMBER)
                self.state = 889
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [261]:
                    self.state = 887
                    self.match(RegelSpraakParser.PERCENT_SIGN)
                    pass
                elif token in [245]:
                    self.state = 888
                    localctx.p = self.match(RegelSpraakParser.IDENTIFIER)
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 891
                self.match(RegelSpraakParser.VAN)
                self.state = 892
                self.primaryExpression(37)
                pass

            elif la_ == 6:
                localctx = RegelSpraakParser.ConcatenatieExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 893
                self.match(RegelSpraakParser.CONCATENATIE_VAN)
                self.state = 894
                self.primaryExpression(0)
                self.state = 899
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==256:
                    self.state = 895
                    self.match(RegelSpraakParser.COMMA)
                    self.state = 896
                    self.primaryExpression(0)
                    self.state = 901
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 902
                _la = self._input.LA(1)
                if not(_la==206 or _la==215):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 903
                self.primaryExpression(34)
                pass

            elif la_ == 7:
                localctx = RegelSpraakParser.WortelFuncExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 905
                self.match(RegelSpraakParser.DE_WORTEL_VAN)
                self.state = 906
                self.primaryExpression(32)
                pass

            elif la_ == 8:
                localctx = RegelSpraakParser.AbsValFuncExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 907
                self.match(RegelSpraakParser.DE_ABSOLUTE_WAARDE_VAN)
                self.state = 908
                self.match(RegelSpraakParser.LPAREN)
                self.state = 909
                self.primaryExpression(0)
                self.state = 910
                self.match(RegelSpraakParser.RPAREN)
                pass

            elif la_ == 9:
                localctx = RegelSpraakParser.MinValFuncExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 912
                self.match(RegelSpraakParser.DE_MINIMALE_WAARDE_VAN)
                self.state = 913
                self.primaryExpression(0)
                self.state = 918
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==256:
                    self.state = 914
                    self.match(RegelSpraakParser.COMMA)
                    self.state = 915
                    self.primaryExpression(0)
                    self.state = 920
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 921
                self.match(RegelSpraakParser.EN)
                self.state = 922
                self.primaryExpression(30)
                pass

            elif la_ == 10:
                localctx = RegelSpraakParser.MaxValFuncExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 924
                self.match(RegelSpraakParser.DE_MAXIMALE_WAARDE_VAN)
                self.state = 925
                self.primaryExpression(0)
                self.state = 930
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==256:
                    self.state = 926
                    self.match(RegelSpraakParser.COMMA)
                    self.state = 927
                    self.primaryExpression(0)
                    self.state = 932
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 933
                self.match(RegelSpraakParser.EN)
                self.state = 934
                self.primaryExpression(29)
                pass

            elif la_ == 11:
                localctx = RegelSpraakParser.JaarUitFuncExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 936
                self.match(RegelSpraakParser.HET)
                self.state = 937
                self.match(RegelSpraakParser.JAAR)
                self.state = 938
                self.match(RegelSpraakParser.UIT)
                self.state = 939
                self.primaryExpression(28)
                pass

            elif la_ == 12:
                localctx = RegelSpraakParser.MaandUitFuncExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 940
                self.match(RegelSpraakParser.DE)
                self.state = 941
                self.match(RegelSpraakParser.MAAND)
                self.state = 942
                self.match(RegelSpraakParser.UIT)
                self.state = 943
                self.primaryExpression(27)
                pass

            elif la_ == 13:
                localctx = RegelSpraakParser.DagUitFuncExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 944
                self.match(RegelSpraakParser.DE)
                self.state = 945
                self.match(RegelSpraakParser.DAG)
                self.state = 946
                self.match(RegelSpraakParser.UIT)
                self.state = 947
                self.primaryExpression(26)
                pass

            elif la_ == 14:
                localctx = RegelSpraakParser.DatumMetFuncExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 948
                self.match(RegelSpraakParser.DE_DATUM_MET)
                self.state = 949
                self.match(RegelSpraakParser.LPAREN)
                self.state = 950
                self.primaryExpression(0)
                self.state = 951
                self.match(RegelSpraakParser.COMMA)
                self.state = 952
                self.primaryExpression(0)
                self.state = 953
                self.match(RegelSpraakParser.COMMA)
                self.state = 954
                self.primaryExpression(0)
                self.state = 955
                self.match(RegelSpraakParser.RPAREN)
                pass

            elif la_ == 15:
                localctx = RegelSpraakParser.PasenFuncExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 957
                self.match(RegelSpraakParser.DE_EERSTE_PAASDAG_VAN)
                self.state = 958
                self.match(RegelSpraakParser.LPAREN)
                self.state = 959
                self.primaryExpression(0)
                self.state = 960
                self.match(RegelSpraakParser.RPAREN)
                pass

            elif la_ == 16:
                localctx = RegelSpraakParser.EersteDatumFuncExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 962
                self.match(RegelSpraakParser.EERSTE_VAN)
                self.state = 963
                self.primaryExpression(0)
                self.state = 968
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==256:
                    self.state = 964
                    self.match(RegelSpraakParser.COMMA)
                    self.state = 965
                    self.primaryExpression(0)
                    self.state = 970
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 971
                self.match(RegelSpraakParser.EN)
                self.state = 972
                self.primaryExpression(22)
                pass

            elif la_ == 17:
                localctx = RegelSpraakParser.LaatsteDatumFuncExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 974
                self.match(RegelSpraakParser.LAATSTE_VAN)
                self.state = 975
                self.primaryExpression(0)
                self.state = 980
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==256:
                    self.state = 976
                    self.match(RegelSpraakParser.COMMA)
                    self.state = 977
                    self.primaryExpression(0)
                    self.state = 982
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 983
                self.match(RegelSpraakParser.EN)
                self.state = 984
                self.primaryExpression(21)
                pass

            elif la_ == 18:
                localctx = RegelSpraakParser.TotaalVanExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 986
                self.match(RegelSpraakParser.HET_TOTAAL_VAN)
                self.state = 987
                self.expressie()
                self.state = 990
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,118,self._ctx)
                if la_ == 1:
                    self.state = 988
                    self.match(RegelSpraakParser.GEDURENDE_DE_TIJD_DAT)
                    self.state = 989
                    localctx.condition = self.expressie()


                pass

            elif la_ == 19:
                localctx = RegelSpraakParser.HetAantalDagenInExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 992
                self.match(RegelSpraakParser.HET_AANTAL_DAGEN_IN)
                self.state = 997
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [202]:
                    self.state = 993
                    self.match(RegelSpraakParser.DE)
                    self.state = 994
                    self.match(RegelSpraakParser.MAAND)
                    pass
                elif token in [207]:
                    self.state = 995
                    self.match(RegelSpraakParser.HET)
                    self.state = 996
                    self.match(RegelSpraakParser.JAAR)
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 999
                self.match(RegelSpraakParser.DAT)
                self.state = 1000
                self.expressie()
                pass

            elif la_ == 20:
                localctx = RegelSpraakParser.CapitalizedTotaalVanExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1002 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 1001
                    self.identifier()
                    self.state = 1004 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==245):
                        break

                self.state = 1006
                self.match(RegelSpraakParser.HET_TOTAAL_VAN)
                self.state = 1007
                self.expressie()
                self.state = 1010
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,121,self._ctx)
                if la_ == 1:
                    self.state = 1008
                    self.match(RegelSpraakParser.GEDURENDE_DE_TIJD_DAT)
                    self.state = 1009
                    localctx.condition = self.expressie()


                pass

            elif la_ == 21:
                localctx = RegelSpraakParser.TijdsevenredigDeelExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1012
                self.match(RegelSpraakParser.HET_TIJDSEVENREDIG_DEEL_PER)
                self.state = 1013
                _la = self._input.LA(1)
                if not(_la==210 or _la==212):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1014
                self.match(RegelSpraakParser.VAN)
                self.state = 1015
                self.expressie()
                self.state = 1018
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,122,self._ctx)
                if la_ == 1:
                    self.state = 1016
                    self.match(RegelSpraakParser.GEDURENDE_DE_TIJD_DAT)
                    self.state = 1017
                    localctx.condition = self.expressie()


                pass

            elif la_ == 22:
                localctx = RegelSpraakParser.CapitalizedTijdsevenredigDeelExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1021 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 1020
                    self.identifier()
                    self.state = 1023 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==245):
                        break

                self.state = 1025
                self.match(RegelSpraakParser.HET_TIJDSEVENREDIG_DEEL_PER)
                self.state = 1026
                _la = self._input.LA(1)
                if not(_la==210 or _la==212):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1027
                self.match(RegelSpraakParser.VAN)
                self.state = 1028
                self.expressie()
                self.state = 1031
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,124,self._ctx)
                if la_ == 1:
                    self.state = 1029
                    self.match(RegelSpraakParser.GEDURENDE_DE_TIJD_DAT)
                    self.state = 1030
                    localctx.condition = self.expressie()


                pass

            elif la_ == 23:
                localctx = RegelSpraakParser.DimensieAggExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1035
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [16, 17, 180, 185, 207]:
                    self.state = 1033
                    self.getalAggregatieFunctie()
                    pass
                elif token in [181, 183]:
                    self.state = 1034
                    self.datumAggregatieFunctie()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 1037
                self.attribuutReferentie()
                self.state = 1038
                self.dimensieSelectie()
                pass

            elif la_ == 24:
                localctx = RegelSpraakParser.AttrRefExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1040
                self.attribuutReferentie()
                pass

            elif la_ == 25:
                localctx = RegelSpraakParser.BezieldeRefExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1041
                self.bezieldeReferentie()
                pass

            elif la_ == 26:
                localctx = RegelSpraakParser.NaamwoordExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1042
                self.naamwoord()
                pass

            elif la_ == 27:
                localctx = RegelSpraakParser.ParamRefExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1043
                self.parameterMetLidwoord()
                pass

            elif la_ == 28:
                localctx = RegelSpraakParser.RekendatumKeywordExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1044
                self.match(RegelSpraakParser.REKENDATUM)
                pass

            elif la_ == 29:
                localctx = RegelSpraakParser.IdentifierExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1045
                self.identifier()
                pass

            elif la_ == 30:
                localctx = RegelSpraakParser.NumberLiteralExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1046
                self.match(RegelSpraakParser.NUMBER)
                pass

            elif la_ == 31:
                localctx = RegelSpraakParser.StringLiteralExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1047
                self.match(RegelSpraakParser.STRING_LITERAL)
                pass

            elif la_ == 32:
                localctx = RegelSpraakParser.EnumLiteralExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1048
                self.match(RegelSpraakParser.ENUM_LITERAL)
                pass

            elif la_ == 33:
                localctx = RegelSpraakParser.DatumLiteralExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1049
                self.datumLiteral()
                pass

            elif la_ == 34:
                localctx = RegelSpraakParser.BooleanTrueLiteralExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1050
                self.match(RegelSpraakParser.WAAR)
                pass

            elif la_ == 35:
                localctx = RegelSpraakParser.BooleanFalseLiteralExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1051
                self.match(RegelSpraakParser.ONWAAR)
                pass

            elif la_ == 36:
                localctx = RegelSpraakParser.PronounExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1052
                self.match(RegelSpraakParser.HIJ)
                pass

            elif la_ == 37:
                localctx = RegelSpraakParser.ParenExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1053
                self.match(RegelSpraakParser.LPAREN)
                self.state = 1054
                self.expressie()
                self.state = 1055
                self.match(RegelSpraakParser.RPAREN)
                pass


            self._ctx.stop = self._input.LT(-1)
            self.state = 1081
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,129,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    self.state = 1079
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,128,self._ctx)
                    if la_ == 1:
                        localctx = RegelSpraakParser.SimpleConcatenatieExprContext(self, RegelSpraakParser.PrimaryExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_primaryExpression)
                        self.state = 1059
                        if not self.precpred(self._ctx, 33):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 33)")
                        self.state = 1062 
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        while True:
                            self.state = 1060
                            self.match(RegelSpraakParser.COMMA)
                            self.state = 1061
                            self.primaryExpression(0)
                            self.state = 1064 
                            self._errHandler.sync(self)
                            _la = self._input.LA(1)
                            if not (_la==256):
                                break

                        self.state = 1066
                        _la = self._input.LA(1)
                        if not(_la==206 or _la==215):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 1067
                        self.primaryExpression(34)
                        pass

                    elif la_ == 2:
                        localctx = RegelSpraakParser.AfrondingExprContext(self, RegelSpraakParser.PrimaryExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_primaryExpression)
                        self.state = 1069
                        if not self.precpred(self._ctx, 36):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 36)")
                        self.state = 1070
                        self.afronding()
                        pass

                    elif la_ == 3:
                        localctx = RegelSpraakParser.BegrenzingExprContext(self, RegelSpraakParser.PrimaryExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_primaryExpression)
                        self.state = 1071
                        if not self.precpred(self._ctx, 35):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 35)")
                        self.state = 1072
                        self.match(RegelSpraakParser.COMMA)
                        self.state = 1073
                        self.begrenzing()
                        pass

                    elif la_ == 4:
                        localctx = RegelSpraakParser.DateCalcExprContext(self, RegelSpraakParser.PrimaryExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_primaryExpression)
                        self.state = 1074
                        if not self.precpred(self._ctx, 23):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 23)")
                        self.state = 1075
                        _la = self._input.LA(1)
                        if not(_la==132 or _la==137):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 1076
                        self.primaryExpression(0)
                        self.state = 1077
                        self.identifier()
                        pass

             
                self.state = 1083
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,129,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class AfrondingContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def AFGEROND_OP(self):
            return self.getToken(RegelSpraakParser.AFGEROND_OP, 0)

        def NUMBER(self):
            return self.getToken(RegelSpraakParser.NUMBER, 0)

        def DECIMALEN(self):
            return self.getToken(RegelSpraakParser.DECIMALEN, 0)

        def NAAR_BENEDEN(self):
            return self.getToken(RegelSpraakParser.NAAR_BENEDEN, 0)

        def NAAR_BOVEN(self):
            return self.getToken(RegelSpraakParser.NAAR_BOVEN, 0)

        def REKENKUNDIG(self):
            return self.getToken(RegelSpraakParser.REKENKUNDIG, 0)

        def RICHTING_NUL(self):
            return self.getToken(RegelSpraakParser.RICHTING_NUL, 0)

        def WEG_VAN_NUL(self):
            return self.getToken(RegelSpraakParser.WEG_VAN_NUL, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_afronding

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAfronding" ):
                listener.enterAfronding(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAfronding" ):
                listener.exitAfronding(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAfronding" ):
                return visitor.visitAfronding(self)
            else:
                return visitor.visitChildren(self)




    def afronding(self):

        localctx = RegelSpraakParser.AfrondingContext(self, self._ctx, self.state)
        self.enterRule(localctx, 144, self.RULE_afronding)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1084
            _la = self._input.LA(1)
            if not(((((_la - 133)) & ~0x3f) == 0 and ((1 << (_la - 133)) & 65635) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 1085
            self.match(RegelSpraakParser.AFGEROND_OP)
            self.state = 1086
            self.match(RegelSpraakParser.NUMBER)
            self.state = 1087
            self.match(RegelSpraakParser.DECIMALEN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BegrenzingContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def begrenzingMinimum(self):
            return self.getTypedRuleContext(RegelSpraakParser.BegrenzingMinimumContext,0)


        def begrenzingMaximum(self):
            return self.getTypedRuleContext(RegelSpraakParser.BegrenzingMaximumContext,0)


        def EN(self):
            return self.getToken(RegelSpraakParser.EN, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_begrenzing

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBegrenzing" ):
                listener.enterBegrenzing(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBegrenzing" ):
                listener.exitBegrenzing(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBegrenzing" ):
                return visitor.visitBegrenzing(self)
            else:
                return visitor.visitChildren(self)




    def begrenzing(self):

        localctx = RegelSpraakParser.BegrenzingContext(self, self._ctx, self.state)
        self.enterRule(localctx, 146, self.RULE_begrenzing)
        try:
            self.state = 1095
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,130,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1089
                self.begrenzingMinimum()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1090
                self.begrenzingMaximum()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1091
                self.begrenzingMinimum()
                self.state = 1092
                self.match(RegelSpraakParser.EN)
                self.state = 1093
                self.begrenzingMaximum()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BegrenzingMinimumContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MET_EEN_MINIMUM_VAN(self):
            return self.getToken(RegelSpraakParser.MET_EEN_MINIMUM_VAN, 0)

        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_begrenzingMinimum

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBegrenzingMinimum" ):
                listener.enterBegrenzingMinimum(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBegrenzingMinimum" ):
                listener.exitBegrenzingMinimum(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBegrenzingMinimum" ):
                return visitor.visitBegrenzingMinimum(self)
            else:
                return visitor.visitChildren(self)




    def begrenzingMinimum(self):

        localctx = RegelSpraakParser.BegrenzingMinimumContext(self, self._ctx, self.state)
        self.enterRule(localctx, 148, self.RULE_begrenzingMinimum)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1097
            self.match(RegelSpraakParser.MET_EEN_MINIMUM_VAN)
            self.state = 1098
            self.expressie()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BegrenzingMaximumContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MET_EEN_MAXIMUM_VAN(self):
            return self.getToken(RegelSpraakParser.MET_EEN_MAXIMUM_VAN, 0)

        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_begrenzingMaximum

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBegrenzingMaximum" ):
                listener.enterBegrenzingMaximum(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBegrenzingMaximum" ):
                listener.exitBegrenzingMaximum(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBegrenzingMaximum" ):
                return visitor.visitBegrenzingMaximum(self)
            else:
                return visitor.visitChildren(self)




    def begrenzingMaximum(self):

        localctx = RegelSpraakParser.BegrenzingMaximumContext(self, self._ctx, self.state)
        self.enterRule(localctx, 150, self.RULE_begrenzingMaximum)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1100
            self.match(RegelSpraakParser.MET_EEN_MAXIMUM_VAN)
            self.state = 1101
            self.expressie()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConditieBijExpressieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.condition = None # ExpressieContext

        def GEDURENDE_DE_TIJD_DAT(self):
            return self.getToken(RegelSpraakParser.GEDURENDE_DE_TIJD_DAT, 0)

        def expressie(self):
            return self.getTypedRuleContext(RegelSpraakParser.ExpressieContext,0)


        def periodevergelijkingEnkelvoudig(self):
            return self.getTypedRuleContext(RegelSpraakParser.PeriodevergelijkingEnkelvoudigContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_conditieBijExpressie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConditieBijExpressie" ):
                listener.enterConditieBijExpressie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConditieBijExpressie" ):
                listener.exitConditieBijExpressie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConditieBijExpressie" ):
                return visitor.visitConditieBijExpressie(self)
            else:
                return visitor.visitChildren(self)




    def conditieBijExpressie(self):

        localctx = RegelSpraakParser.ConditieBijExpressieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 152, self.RULE_conditieBijExpressie)
        try:
            self.state = 1106
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [8]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1103
                self.match(RegelSpraakParser.GEDURENDE_DE_TIJD_DAT)
                self.state = 1104
                localctx.condition = self.expressie()
                pass
            elif token in [140, 142, 144, 227]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1105
                self.periodevergelijkingEnkelvoudig()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PeriodevergelijkingEnkelvoudigContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def VANAF(self):
            return self.getToken(RegelSpraakParser.VANAF, 0)

        def datumLiteral(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.DatumLiteralContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.DatumLiteralContext,i)


        def VAN(self):
            return self.getToken(RegelSpraakParser.VAN, 0)

        def TOT(self):
            return self.getToken(RegelSpraakParser.TOT, 0)

        def TOT_EN_MET(self):
            return self.getToken(RegelSpraakParser.TOT_EN_MET, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_periodevergelijkingEnkelvoudig

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPeriodevergelijkingEnkelvoudig" ):
                listener.enterPeriodevergelijkingEnkelvoudig(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPeriodevergelijkingEnkelvoudig" ):
                listener.exitPeriodevergelijkingEnkelvoudig(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPeriodevergelijkingEnkelvoudig" ):
                return visitor.visitPeriodevergelijkingEnkelvoudig(self)
            else:
                return visitor.visitChildren(self)




    def periodevergelijkingEnkelvoudig(self):

        localctx = RegelSpraakParser.PeriodevergelijkingEnkelvoudigContext(self, self._ctx, self.state)
        self.enterRule(localctx, 154, self.RULE_periodevergelijkingEnkelvoudig)
        try:
            self.state = 1124
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,132,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1108
                self.match(RegelSpraakParser.VANAF)
                self.state = 1109
                self.datumLiteral()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1110
                self.match(RegelSpraakParser.VAN)
                self.state = 1111
                self.datumLiteral()
                self.state = 1112
                self.match(RegelSpraakParser.TOT)
                self.state = 1113
                self.datumLiteral()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1115
                self.match(RegelSpraakParser.VAN)
                self.state = 1116
                self.datumLiteral()
                self.state = 1117
                self.match(RegelSpraakParser.TOT_EN_MET)
                self.state = 1118
                self.datumLiteral()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 1120
                self.match(RegelSpraakParser.TOT)
                self.state = 1121
                self.datumLiteral()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 1122
                self.match(RegelSpraakParser.TOT_EN_MET)
                self.state = 1123
                self.datumLiteral()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GetalAggregatieFunctieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def AANTAL(self):
            return self.getToken(RegelSpraakParser.AANTAL, 0)

        def HET(self):
            return self.getToken(RegelSpraakParser.HET, 0)

        def DE_MAXIMALE_WAARDE_VAN(self):
            return self.getToken(RegelSpraakParser.DE_MAXIMALE_WAARDE_VAN, 0)

        def DE_MINIMALE_WAARDE_VAN(self):
            return self.getToken(RegelSpraakParser.DE_MINIMALE_WAARDE_VAN, 0)

        def SOM_VAN(self):
            return self.getToken(RegelSpraakParser.SOM_VAN, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_getalAggregatieFunctie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGetalAggregatieFunctie" ):
                listener.enterGetalAggregatieFunctie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGetalAggregatieFunctie" ):
                listener.exitGetalAggregatieFunctie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGetalAggregatieFunctie" ):
                return visitor.visitGetalAggregatieFunctie(self)
            else:
                return visitor.visitChildren(self)




    def getalAggregatieFunctie(self):

        localctx = RegelSpraakParser.GetalAggregatieFunctieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 156, self.RULE_getalAggregatieFunctie)
        self._la = 0 # Token type
        try:
            self.state = 1133
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [180, 207]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1127
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==207:
                    self.state = 1126
                    self.match(RegelSpraakParser.HET)


                self.state = 1129
                self.match(RegelSpraakParser.AANTAL)
                pass
            elif token in [16]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1130
                self.match(RegelSpraakParser.DE_MAXIMALE_WAARDE_VAN)
                pass
            elif token in [17]:
                self.enterOuterAlt(localctx, 3)
                self.state = 1131
                self.match(RegelSpraakParser.DE_MINIMALE_WAARDE_VAN)
                pass
            elif token in [185]:
                self.enterOuterAlt(localctx, 4)
                self.state = 1132
                self.match(RegelSpraakParser.SOM_VAN)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DatumAggregatieFunctieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EERSTE_VAN(self):
            return self.getToken(RegelSpraakParser.EERSTE_VAN, 0)

        def LAATSTE_VAN(self):
            return self.getToken(RegelSpraakParser.LAATSTE_VAN, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_datumAggregatieFunctie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDatumAggregatieFunctie" ):
                listener.enterDatumAggregatieFunctie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDatumAggregatieFunctie" ):
                listener.exitDatumAggregatieFunctie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDatumAggregatieFunctie" ):
                return visitor.visitDatumAggregatieFunctie(self)
            else:
                return visitor.visitChildren(self)




    def datumAggregatieFunctie(self):

        localctx = RegelSpraakParser.DatumAggregatieFunctieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 158, self.RULE_datumAggregatieFunctie)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1135
            _la = self._input.LA(1)
            if not(_la==181 or _la==183):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DimensieSelectieContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OVER(self):
            return self.getToken(RegelSpraakParser.OVER, 0)

        def DOT(self):
            return self.getToken(RegelSpraakParser.DOT, 0)

        def aggregerenOverAlleDimensies(self):
            return self.getTypedRuleContext(RegelSpraakParser.AggregerenOverAlleDimensiesContext,0)


        def aggregerenOverVerzameling(self):
            return self.getTypedRuleContext(RegelSpraakParser.AggregerenOverVerzamelingContext,0)


        def aggregerenOverBereik(self):
            return self.getTypedRuleContext(RegelSpraakParser.AggregerenOverBereikContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_dimensieSelectie

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDimensieSelectie" ):
                listener.enterDimensieSelectie(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDimensieSelectie" ):
                listener.exitDimensieSelectie(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDimensieSelectie" ):
                return visitor.visitDimensieSelectie(self)
            else:
                return visitor.visitChildren(self)




    def dimensieSelectie(self):

        localctx = RegelSpraakParser.DimensieSelectieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 160, self.RULE_dimensieSelectie)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1137
            self.match(RegelSpraakParser.OVER)
            self.state = 1141
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,135,self._ctx)
            if la_ == 1:
                self.state = 1138
                self.aggregerenOverAlleDimensies()
                pass

            elif la_ == 2:
                self.state = 1139
                self.aggregerenOverVerzameling()
                pass

            elif la_ == 3:
                self.state = 1140
                self.aggregerenOverBereik()
                pass


            self.state = 1143
            self.match(RegelSpraakParser.DOT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AggregerenOverAlleDimensiesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ALLE(self):
            return self.getToken(RegelSpraakParser.ALLE, 0)

        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_aggregerenOverAlleDimensies

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAggregerenOverAlleDimensies" ):
                listener.enterAggregerenOverAlleDimensies(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAggregerenOverAlleDimensies" ):
                listener.exitAggregerenOverAlleDimensies(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAggregerenOverAlleDimensies" ):
                return visitor.visitAggregerenOverAlleDimensies(self)
            else:
                return visitor.visitChildren(self)




    def aggregerenOverAlleDimensies(self):

        localctx = RegelSpraakParser.AggregerenOverAlleDimensiesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 162, self.RULE_aggregerenOverAlleDimensies)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1145
            self.match(RegelSpraakParser.ALLE)
            self.state = 1146
            self.naamwoord()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AggregerenOverVerzamelingContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DE(self):
            return self.getToken(RegelSpraakParser.DE, 0)

        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def VANAF(self):
            return self.getToken(RegelSpraakParser.VANAF, 0)

        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.IdentifierContext,i)


        def TM(self):
            return self.getToken(RegelSpraakParser.TM, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_aggregerenOverVerzameling

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAggregerenOverVerzameling" ):
                listener.enterAggregerenOverVerzameling(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAggregerenOverVerzameling" ):
                listener.exitAggregerenOverVerzameling(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAggregerenOverVerzameling" ):
                return visitor.visitAggregerenOverVerzameling(self)
            else:
                return visitor.visitChildren(self)




    def aggregerenOverVerzameling(self):

        localctx = RegelSpraakParser.AggregerenOverVerzamelingContext(self, self._ctx, self.state)
        self.enterRule(localctx, 164, self.RULE_aggregerenOverVerzameling)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1148
            self.match(RegelSpraakParser.DE)
            self.state = 1149
            self.naamwoord()
            self.state = 1150
            self.match(RegelSpraakParser.VANAF)
            self.state = 1151
            self.identifier()
            self.state = 1152
            self.match(RegelSpraakParser.TM)
            self.state = 1153
            self.identifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AggregerenOverBereikContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DE(self):
            return self.getToken(RegelSpraakParser.DE, 0)

        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def IN(self):
            return self.getToken(RegelSpraakParser.IN, 0)

        def LBRACE(self):
            return self.getToken(RegelSpraakParser.LBRACE, 0)

        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RegelSpraakParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(RegelSpraakParser.IdentifierContext,i)


        def EN(self):
            return self.getToken(RegelSpraakParser.EN, 0)

        def RBRACE(self):
            return self.getToken(RegelSpraakParser.RBRACE, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(RegelSpraakParser.COMMA)
            else:
                return self.getToken(RegelSpraakParser.COMMA, i)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_aggregerenOverBereik

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAggregerenOverBereik" ):
                listener.enterAggregerenOverBereik(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAggregerenOverBereik" ):
                listener.exitAggregerenOverBereik(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAggregerenOverBereik" ):
                return visitor.visitAggregerenOverBereik(self)
            else:
                return visitor.visitChildren(self)




    def aggregerenOverBereik(self):

        localctx = RegelSpraakParser.AggregerenOverBereikContext(self, self._ctx, self.state)
        self.enterRule(localctx, 166, self.RULE_aggregerenOverBereik)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1155
            self.match(RegelSpraakParser.DE)
            self.state = 1156
            self.naamwoord()
            self.state = 1157
            self.match(RegelSpraakParser.IN)
            self.state = 1158
            self.match(RegelSpraakParser.LBRACE)
            self.state = 1159
            self.identifier()
            self.state = 1164
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==256:
                self.state = 1160
                self.match(RegelSpraakParser.COMMA)
                self.state = 1161
                self.identifier()
                self.state = 1166
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1167
            self.match(RegelSpraakParser.EN)
            self.state = 1168
            self.identifier()
            self.state = 1169
            self.match(RegelSpraakParser.RBRACE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UnaryConditionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_unaryCondition

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class UnaryCheckConditionContext(UnaryConditionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.UnaryConditionContext
            super().__init__(parser)
            self.expr = None # PrimaryExpressionContext
            self.op = None # Token
            self.copyFrom(ctx)

        def primaryExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,0)

        def IS_LEEG(self):
            return self.getToken(RegelSpraakParser.IS_LEEG, 0)
        def IS_GEVULD(self):
            return self.getToken(RegelSpraakParser.IS_GEVULD, 0)
        def VOLDOET_AAN_DE_ELFPROEF(self):
            return self.getToken(RegelSpraakParser.VOLDOET_AAN_DE_ELFPROEF, 0)
        def VOLDOET_NIET_AAN_DE_ELFPROEF(self):
            return self.getToken(RegelSpraakParser.VOLDOET_NIET_AAN_DE_ELFPROEF, 0)
        def ZIJN_LEEG(self):
            return self.getToken(RegelSpraakParser.ZIJN_LEEG, 0)
        def ZIJN_GEVULD(self):
            return self.getToken(RegelSpraakParser.ZIJN_GEVULD, 0)
        def VOLDOEN_AAN_DE_ELFPROEF(self):
            return self.getToken(RegelSpraakParser.VOLDOEN_AAN_DE_ELFPROEF, 0)
        def VOLDOEN_NIET_AAN_DE_ELFPROEF(self):
            return self.getToken(RegelSpraakParser.VOLDOEN_NIET_AAN_DE_ELFPROEF, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnaryCheckCondition" ):
                listener.enterUnaryCheckCondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnaryCheckCondition" ):
                listener.exitUnaryCheckCondition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnaryCheckCondition" ):
                return visitor.visitUnaryCheckCondition(self)
            else:
                return visitor.visitChildren(self)


    class UnaryKenmerkConditionContext(UnaryConditionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.UnaryConditionContext
            super().__init__(parser)
            self.expr = None # PrimaryExpressionContext
            self.op = None # Token
            self.kenmerk = None # IdentifierContext
            self.copyFrom(ctx)

        def primaryExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,0)

        def identifier(self):
            return self.getTypedRuleContext(RegelSpraakParser.IdentifierContext,0)

        def IS_KENMERK(self):
            return self.getToken(RegelSpraakParser.IS_KENMERK, 0)
        def ZIJN_KENMERK(self):
            return self.getToken(RegelSpraakParser.ZIJN_KENMERK, 0)
        def IS_NIET_KENMERK(self):
            return self.getToken(RegelSpraakParser.IS_NIET_KENMERK, 0)
        def ZIJN_NIET_KENMERK(self):
            return self.getToken(RegelSpraakParser.ZIJN_NIET_KENMERK, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnaryKenmerkCondition" ):
                listener.enterUnaryKenmerkCondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnaryKenmerkCondition" ):
                listener.exitUnaryKenmerkCondition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnaryKenmerkCondition" ):
                return visitor.visitUnaryKenmerkCondition(self)
            else:
                return visitor.visitChildren(self)


    class UnaryNumeriekExactConditionContext(UnaryConditionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.UnaryConditionContext
            super().__init__(parser)
            self.expr = None # PrimaryExpressionContext
            self.op = None # Token
            self.copyFrom(ctx)

        def NUMBER(self):
            return self.getToken(RegelSpraakParser.NUMBER, 0)
        def CIJFERS(self):
            return self.getToken(RegelSpraakParser.CIJFERS, 0)
        def primaryExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,0)

        def IS_NUMERIEK_MET_EXACT(self):
            return self.getToken(RegelSpraakParser.IS_NUMERIEK_MET_EXACT, 0)
        def IS_NIET_NUMERIEK_MET_EXACT(self):
            return self.getToken(RegelSpraakParser.IS_NIET_NUMERIEK_MET_EXACT, 0)
        def ZIJN_NUMERIEK_MET_EXACT(self):
            return self.getToken(RegelSpraakParser.ZIJN_NUMERIEK_MET_EXACT, 0)
        def ZIJN_NIET_NUMERIEK_MET_EXACT(self):
            return self.getToken(RegelSpraakParser.ZIJN_NIET_NUMERIEK_MET_EXACT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnaryNumeriekExactCondition" ):
                listener.enterUnaryNumeriekExactCondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnaryNumeriekExactCondition" ):
                listener.exitUnaryNumeriekExactCondition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnaryNumeriekExactCondition" ):
                return visitor.visitUnaryNumeriekExactCondition(self)
            else:
                return visitor.visitChildren(self)


    class UnaryRolConditionContext(UnaryConditionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.UnaryConditionContext
            super().__init__(parser)
            self.expr = None # PrimaryExpressionContext
            self.op = None # Token
            self.rol = None # IdentifierContext
            self.copyFrom(ctx)

        def primaryExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,0)

        def identifier(self):
            return self.getTypedRuleContext(RegelSpraakParser.IdentifierContext,0)

        def IS_ROL(self):
            return self.getToken(RegelSpraakParser.IS_ROL, 0)
        def ZIJN_ROL(self):
            return self.getToken(RegelSpraakParser.ZIJN_ROL, 0)
        def IS_NIET_ROL(self):
            return self.getToken(RegelSpraakParser.IS_NIET_ROL, 0)
        def ZIJN_NIET_ROL(self):
            return self.getToken(RegelSpraakParser.ZIJN_NIET_ROL, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnaryRolCondition" ):
                listener.enterUnaryRolCondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnaryRolCondition" ):
                listener.exitUnaryRolCondition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnaryRolCondition" ):
                return visitor.visitUnaryRolCondition(self)
            else:
                return visitor.visitChildren(self)


    class UnaryDagsoortConditionContext(UnaryConditionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.UnaryConditionContext
            super().__init__(parser)
            self.expr = None # PrimaryExpressionContext
            self.op = None # Token
            self.dagsoort = None # IdentifierContext
            self.copyFrom(ctx)

        def primaryExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,0)

        def identifier(self):
            return self.getTypedRuleContext(RegelSpraakParser.IdentifierContext,0)

        def IS_EEN_DAGSOORT(self):
            return self.getToken(RegelSpraakParser.IS_EEN_DAGSOORT, 0)
        def ZIJN_EEN_DAGSOORT(self):
            return self.getToken(RegelSpraakParser.ZIJN_EEN_DAGSOORT, 0)
        def IS_GEEN_DAGSOORT(self):
            return self.getToken(RegelSpraakParser.IS_GEEN_DAGSOORT, 0)
        def ZIJN_GEEN_DAGSOORT(self):
            return self.getToken(RegelSpraakParser.ZIJN_GEEN_DAGSOORT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnaryDagsoortCondition" ):
                listener.enterUnaryDagsoortCondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnaryDagsoortCondition" ):
                listener.exitUnaryDagsoortCondition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnaryDagsoortCondition" ):
                return visitor.visitUnaryDagsoortCondition(self)
            else:
                return visitor.visitChildren(self)


    class UnaryInconsistentDataConditionContext(UnaryConditionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.UnaryConditionContext
            super().__init__(parser)
            self.expr = None # PrimaryExpressionContext
            self.copyFrom(ctx)

        def IS_INCONSISTENT(self):
            return self.getToken(RegelSpraakParser.IS_INCONSISTENT, 0)
        def primaryExpression(self):
            return self.getTypedRuleContext(RegelSpraakParser.PrimaryExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnaryInconsistentDataCondition" ):
                listener.enterUnaryInconsistentDataCondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnaryInconsistentDataCondition" ):
                listener.exitUnaryInconsistentDataCondition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnaryInconsistentDataCondition" ):
                return visitor.visitUnaryInconsistentDataCondition(self)
            else:
                return visitor.visitChildren(self)


    class UnaryUniekConditionContext(UnaryConditionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.UnaryConditionContext
            super().__init__(parser)
            self.ref = None # OnderwerpReferentieContext
            self.copyFrom(ctx)

        def MOETEN_UNIEK_ZIJN(self):
            return self.getToken(RegelSpraakParser.MOETEN_UNIEK_ZIJN, 0)
        def onderwerpReferentie(self):
            return self.getTypedRuleContext(RegelSpraakParser.OnderwerpReferentieContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnaryUniekCondition" ):
                listener.enterUnaryUniekCondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnaryUniekCondition" ):
                listener.exitUnaryUniekCondition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnaryUniekCondition" ):
                return visitor.visitUnaryUniekCondition(self)
            else:
                return visitor.visitChildren(self)



    def unaryCondition(self):

        localctx = RegelSpraakParser.UnaryConditionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 168, self.RULE_unaryCondition)
        self._la = 0 # Token type
        try:
            self.state = 1197
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,137,self._ctx)
            if la_ == 1:
                localctx = RegelSpraakParser.UnaryCheckConditionContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1171
                localctx.expr = self.primaryExpression(0)
                self.state = 1172
                localctx.op = self._input.LT(1)
                _la = self._input.LA(1)
                if not(((((_la - 70)) & ~0x3f) == 0 and ((1 << (_la - 70)) & 61455) != 0)):
                    localctx.op = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass

            elif la_ == 2:
                localctx = RegelSpraakParser.UnaryNumeriekExactConditionContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1174
                localctx.expr = self.primaryExpression(0)
                self.state = 1175
                localctx.op = self._input.LT(1)
                _la = self._input.LA(1)
                if not(((((_la - 86)) & ~0x3f) == 0 and ((1 << (_la - 86)) & 15) != 0)):
                    localctx.op = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1176
                self.match(RegelSpraakParser.NUMBER)
                self.state = 1177
                self.match(RegelSpraakParser.CIJFERS)
                pass

            elif la_ == 3:
                localctx = RegelSpraakParser.UnaryDagsoortConditionContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 1179
                localctx.expr = self.primaryExpression(0)
                self.state = 1180
                localctx.op = self._input.LT(1)
                _la = self._input.LA(1)
                if not(((((_la - 90)) & ~0x3f) == 0 and ((1 << (_la - 90)) & 15) != 0)):
                    localctx.op = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1181
                localctx.dagsoort = self.identifier()
                pass

            elif la_ == 4:
                localctx = RegelSpraakParser.UnaryKenmerkConditionContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 1183
                localctx.expr = self.primaryExpression(0)
                self.state = 1184
                localctx.op = self._input.LT(1)
                _la = self._input.LA(1)
                if not(((((_la - 74)) & ~0x3f) == 0 and ((1 << (_la - 74)) & 85) != 0)):
                    localctx.op = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1185
                localctx.kenmerk = self.identifier()
                pass

            elif la_ == 5:
                localctx = RegelSpraakParser.UnaryRolConditionContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 1187
                localctx.expr = self.primaryExpression(0)
                self.state = 1188
                localctx.op = self._input.LT(1)
                _la = self._input.LA(1)
                if not(((((_la - 75)) & ~0x3f) == 0 and ((1 << (_la - 75)) & 85) != 0)):
                    localctx.op = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1189
                localctx.rol = self.identifier()
                pass

            elif la_ == 6:
                localctx = RegelSpraakParser.UnaryUniekConditionContext(self, localctx)
                self.enterOuterAlt(localctx, 6)
                self.state = 1191
                localctx.ref = self.onderwerpReferentie()
                self.state = 1192
                self.match(RegelSpraakParser.MOETEN_UNIEK_ZIJN)
                pass

            elif la_ == 7:
                localctx = RegelSpraakParser.UnaryInconsistentDataConditionContext(self, localctx)
                self.enterOuterAlt(localctx, 7)
                self.state = 1194
                localctx.expr = self.primaryExpression(0)
                self.state = 1195
                self.match(RegelSpraakParser.IS_INCONSISTENT)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RegelStatusConditionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return RegelSpraakParser.RULE_regelStatusCondition

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class RegelStatusCheckContext(RegelStatusConditionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RegelSpraakParser.RegelStatusConditionContext
            super().__init__(parser)
            self.name = None # NaamwoordContext
            self.op = None # Token
            self.copyFrom(ctx)

        def REGEL(self):
            return self.getToken(RegelSpraakParser.REGEL, 0)
        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)

        def IS_GEVUURD(self):
            return self.getToken(RegelSpraakParser.IS_GEVUURD, 0)
        def IS_INCONSISTENT(self):
            return self.getToken(RegelSpraakParser.IS_INCONSISTENT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRegelStatusCheck" ):
                listener.enterRegelStatusCheck(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRegelStatusCheck" ):
                listener.exitRegelStatusCheck(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRegelStatusCheck" ):
                return visitor.visitRegelStatusCheck(self)
            else:
                return visitor.visitChildren(self)



    def regelStatusCondition(self):

        localctx = RegelSpraakParser.RegelStatusConditionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 170, self.RULE_regelStatusCondition)
        self._la = 0 # Token type
        try:
            localctx = RegelSpraakParser.RegelStatusCheckContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 1199
            self.match(RegelSpraakParser.REGEL)
            self.state = 1200
            localctx.name = self.naamwoord()
            self.state = 1201
            localctx.op = self._input.LT(1)
            _la = self._input.LA(1)
            if not(_la==95 or _la==96):
                localctx.op = self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DagsoortDefinitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DAGSOORT(self):
            return self.getToken(RegelSpraakParser.DAGSOORT, 0)

        def naamwoord(self):
            return self.getTypedRuleContext(RegelSpraakParser.NaamwoordContext,0)


        def SEMICOLON(self):
            return self.getToken(RegelSpraakParser.SEMICOLON, 0)

        def getRuleIndex(self):
            return RegelSpraakParser.RULE_dagsoortDefinition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDagsoortDefinition" ):
                listener.enterDagsoortDefinition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDagsoortDefinition" ):
                listener.exitDagsoortDefinition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDagsoortDefinition" ):
                return visitor.visitDagsoortDefinition(self)
            else:
                return visitor.visitChildren(self)




    def dagsoortDefinition(self):

        localctx = RegelSpraakParser.DagsoortDefinitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 172, self.RULE_dagsoortDefinition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1203
            self.match(RegelSpraakParser.DAGSOORT)
            self.state = 1204
            self.naamwoord()
            self.state = 1206
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==259:
                self.state = 1205
                self.match(RegelSpraakParser.SEMICOLON)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx



    def sempred(self, localctx:RuleContext, ruleIndex:int, predIndex:int):
        if self._predicates == None:
            self._predicates = dict()
        self._predicates[71] = self.primaryExpression_sempred
        pred = self._predicates.get(ruleIndex, None)
        if pred is None:
            raise Exception("No predicate with index:" + str(ruleIndex))
        else:
            return pred(localctx, predIndex)

    def primaryExpression_sempred(self, localctx:PrimaryExpressionContext, predIndex:int):
            if predIndex == 0:
                return self.precpred(self._ctx, 33)
         

            if predIndex == 1:
                return self.precpred(self._ctx, 36)
         

            if predIndex == 2:
                return self.precpred(self._ctx, 35)
         

            if predIndex == 3:
                return self.precpred(self._ctx, 23)
         




