---
description: Guidance on handling complex and ambiguous constructs in the RegelSpraak v2.1.0 grammar implementation
globs: ["*.g4"]
alwaysApply: false
---
# RegelSpraak v2.1.0 ANTLR Grammar - Specific Constructs & Challenges

**Purpose:**
Provide guidance on handling specific complex or ambiguous parts of the RegelSpraak grammar when implementing the ANTLR `.g4` file.

**Instructions:**
Consider these points while refining the lexer and parser rules. Some issues might require careful grammar design, while others might need semantic checks after parsing.

**File Pattern:**
pattern: *.g4

**Specific Constructs & Considerations:**

1.  **Identifiers with Spaces/Hyphens:**
    *   **Context:** The current `IDENTIFIER` lexer rule (`LETTER_PROPERTY (LETTER_PROPERTY | DIGIT_PROPERTY | '-' | ' ')* LETTER_PROPERTY | LETTER_PROPERTY`) allows internal spaces and hyphens (e.g., `Natuurlijk persoon`, `belasting op basis van afstand`).
    *   **Challenge:** This can create ambiguity with keyword sequences (e.g., is `is gelijk aan` an identifier or keywords?).
    *   **Guidance:** Ensure keywords are defined *before* the `IDENTIFIER` rule in the lexer section of the `.g4` file so they get matched first. Test thoroughly. If ambiguity persists, consider requiring quotes for identifiers with spaces/hyphens or enforcing `CamelCase`/`snake_case` (though less true to the spec's examples). For now, proceed with the flexible `IDENTIFIER`, assuming careful parsing and potential post-parse checks.

2.  **Expression Precedence:**
    *   **Context:** Arithmetic and logical expressions require correct operator precedence (e.g., `*` before `+`).
    *   **Guidance:** Use ANTLR's standard left-recursive expression rule structure with labels (`# LabelName`) to handle precedence implicitly. Define alternatives in the `getalExpressie` (and other expression rules) from lowest to highest precedence, or group explicitly.
    *   **Expected Order (Highest First):** `()` (parentheses), `^` (power), `sqrt`, `abs`, `*`, `/`, `%`, `+`, `-`. Ensure functions like `WORTEL_VAN`, `ABSOLUTE_WAARDE_VAN`, `TOT_DE_MACHT` are placed correctly relative to operators.

3.  **Ambiguity (`zijn`, `is`, etc.):**
    *   **Context:** Natural language reuse leads to ambiguity. `zijn` can be a plural verb or a possessive pronoun. `is` is a verb but also part of multi-word keywords like `is gelijk aan`.
    *   **Guidance:** The parser's structure (context) should resolve most cases (e.g., `... IS GELIJK_AAN ...` vs. `... IS kenmerkNaam`). For `zijn`, distinguishing the possessive pronoun `zijn` from the verb `zijn` might be difficult lexically. Rely on parser context (e.g., expecting a noun/attribute after possessive `zijn`, expecting a predicate/comparison after verb `zijn`). If needed, semantic analysis might be required post-parsing.

4.  **Time Dependency & Constructs:**
    *   **Syntax vs. Semantics:** The grammar should parse the *syntax* for defining time dependencies (`tijdlijn` rule: `voor elke dag`, etc.) and the specific time-related *expressions* (`TOTAAL_VAN`, `AANTAL_DAGEN_IN`, `TIJDSEVENREDIG_DEEL_PER`).
    *   **Guidance:** Implement parser rules for these specific expressions based on the EBNF in Chapter 13.4.16 (items 51-53). The *semantic meaning* (how "knips" affect calculations, aggregation logic over time) is handled by the code using the parse tree, not the grammar itself. Ensure the `conditieBijExpressie` rule is correctly defined and used by these time expressions.

5.  **Verdeling Complexity:**
    *   **Context:** The `verdeling` rule (§9.7, §13.4.10) is highly complex with multiple optional clauses for grouping, ordering, maxima, rounding, and remainders.
    *   **Guidance:** The placeholder `verdeling` rule in `03-parser-rules.mdc` needs to be fully expanded by meticulously translating the EBNF from §13.4.10. Pay close attention to the optional (`[...]`) and alternative (`|`) parts. Test each variation (e.g., simple equal parts, ratio, grouping by attribute, using maximums, rounding).

6.  **Beslistabellen:**
    *   **Context:** These are tabular representations (§12).
    *   **Guidance:** The ANTLR grammar should focus on parsing the RegelSpraak language *fragments found within* the table cells (e.g., an `expressie` in a conclusion cell, a `voorwaardeVergelijking` fragment in a condition cell). Do *not* attempt to parse the Markdown/HTML/other table structure itself within this grammar. Assume that cell content is extracted and fed to the parser, or handle table structure parsing separately (e.g., via pre-processing or a dedicated table grammar). The `beslistabel` rule is primarily a placeholder acknowledging the construct exists.

7.  **EBNF Completeness:**
    *   **Context:** The provided parser rules cover the core structure but may miss details or variations from the full EBNF in Chapter 13.
    *   **Guidance:** Systematically review *all* EBNF rules in Chapter 13 and ensure they are represented in the ANTLR grammar. Pay special attention to predicate variations (§13.4.14), consistentieRegel details (§13.4.8), and all expression function variants (§13.4.16).

8.  **Unicode Support:**
    *   **Context:** RegelSpraak uses Dutch and potentially other Unicode characters.
    *   **Guidance:** Ensure the ANTLR setup (e.g., file encoding, target language capabilities) and the lexer fragments (`LETTER_PROPERTY`, `DIGIT_PROPERTY`, `STRING_LITERAL`) correctly handle the necessary Unicode ranges.

9. **Recursie Concept:**
    *   **Context:** Section 9.9 describes recursion applying to *groups* of rules, marked externally.
    * **Guidance:** This is a meta-level concept about rule execution and grouping, not directly representable in the ANTLR syntax for individual rules. The grammar parses the rules themselves; identifying and handling recursive groups happens *outside* the parser, likely in the application logic that uses the parse tree or rule engine.