{
  "version": 3,
  "sources": ["../../src/semantic-analyzer.ts"],
  "sourcesContent": ["import { DomainModel } from './ast/domain-model';\nimport { ObjectTypeDefinition, AttributeSpecification, KenmerkSpecification } from './ast/object-types';\nimport { ParameterDefinition } from './ast/parameters';\nimport { Rule, RegelGroep, Gelijkstelling, Kenmerktoekenning, ObjectCreation } from './ast/rules';\nimport { \n  Expression, \n  Literal, \n  AttributeReference, \n  VariableReference, \n  ParameterReference,\n  BinaryExpression, \n  UnaryExpression, \n  FunctionCall,\n  SubselectieExpression \n} from './ast/expressions';\nimport { DecisionTable } from './ast/decision-tables';\nimport { Dimension } from './ast/dimensions';\nimport { DagsoortDefinitie } from './ast/dagsoort';\n// TODO: Implement FeitCreatie when visitor supports it\n\nexport interface ValidationError {\n  message: string;\n  location?: any;\n  severity: 'error' | 'warning';\n}\n\nexport enum SymbolKind {\n  PARAMETER = 'parameter',\n  OBJECT_TYPE = 'object_type',\n  ATTRIBUTE = 'attribute',\n  KENMERK = 'kenmerk',\n  VARIABLE = 'variable',\n  RULE = 'rule',\n  REGELGROEP = 'regelgroep',\n  DOMAIN = 'domain',\n  FEITTYPE = 'feittype',\n  DIMENSION = 'dimension',\n  DAGSOORT = 'dagsoort'\n}\n\nexport interface Symbol {\n  name: string;\n  kind: SymbolKind;\n  datatype?: string;\n  definition: any;\n}\n\nexport class SymbolTable {\n  private symbols: Map<string, Symbol> = new Map();\n  private parent?: SymbolTable;\n\n  constructor(parent?: SymbolTable) {\n    this.parent = parent;\n  }\n\n  define(name: string, symbol: Symbol): void {\n    this.symbols.set(name, symbol);\n  }\n\n  lookup(name: string): Symbol | undefined {\n    const localSymbol = this.symbols.get(name);\n    if (localSymbol) return localSymbol;\n    return this.parent?.lookup(name);\n  }\n\n  lookupLocal(name: string): Symbol | undefined {\n    return this.symbols.get(name);\n  }\n}\n\nexport class SemanticAnalyzer {\n  private errors: ValidationError[] = [];\n  private globalScope: SymbolTable = new SymbolTable();\n  private currentScope: SymbolTable = this.globalScope;\n  private objectTypes: Map<string, ObjectTypeDefinition> = new Map();\n  private parameters: Map<string, ParameterDefinition> = new Map();\n  private dimensions: Map<string, Dimension> = new Map();\n\n  analyze(model: DomainModel): ValidationError[] {\n    this.errors = [];\n    this.globalScope = new SymbolTable();\n    this.currentScope = this.globalScope;\n    this.objectTypes.clear();\n    this.parameters.clear();\n    this.dimensions.clear();\n\n    // First pass: collect all definitions\n    this.collectDefinitions(model);\n\n    // Second pass: validate references and type checking\n    this.validateModel(model);\n\n    return this.errors;\n  }\n\n  private collectDefinitions(model: DomainModel): void {\n    // Collect parameters\n    for (const param of model.parameters || []) {\n      this.parameters.set(param.name, param);\n      this.globalScope.define(param.name, {\n        name: param.name,\n        kind: SymbolKind.PARAMETER,\n        datatype: param.datatype,\n        definition: param\n      });\n    }\n\n    // Collect object types and their attributes/kenmerken\n    for (const objectType of model.objectTypes || []) {\n      this.objectTypes.set(objectType.name, objectType);\n      this.globalScope.define(objectType.name, {\n        name: objectType.name,\n        kind: SymbolKind.OBJECT_TYPE,\n        definition: objectType\n      });\n\n      // Create a scope for the object type\n      const objectScope = new SymbolTable(this.globalScope);\n      \n      // Add attributes and kenmerken from members\n      for (const member of objectType.members) {\n        if (member.type === 'AttributeSpecification') {\n          const attr = member as AttributeSpecification;\n          objectScope.define(attr.name, {\n            name: attr.name,\n            kind: SymbolKind.ATTRIBUTE,\n            datatype: this.getDataTypeString(attr.dataType),\n            definition: attr\n          });\n        } else if (member.type === 'KenmerkSpecification') {\n          const kenmerk = member as KenmerkSpecification;\n          objectScope.define(kenmerk.name, {\n            name: kenmerk.name,\n            kind: SymbolKind.KENMERK,\n            datatype: 'Boolean',\n            definition: kenmerk\n          });\n        }\n      }\n    }\n\n    // Collect dimensions\n    for (const dimension of model.dimensions || []) {\n      this.dimensions.set(dimension.name, dimension);\n      this.globalScope.define(dimension.name, {\n        name: dimension.name,\n        kind: SymbolKind.DIMENSION,\n        definition: dimension\n      });\n    }\n\n    // Collect rules\n    for (const regel of model.regels || []) {\n      this.globalScope.define(regel.name, {\n        name: regel.name,\n        kind: SymbolKind.RULE,\n        definition: regel\n      });\n    }\n\n    // Collect rule groups\n    for (const regelGroep of model.regelGroepen || []) {\n      this.globalScope.define(regelGroep.name, {\n        name: regelGroep.name,\n        kind: SymbolKind.REGELGROEP,\n        definition: regelGroep\n      });\n    }\n\n    // Collect dagsoort definitions\n    for (const dagsoort of model.dagsoortDefinities || []) {\n      this.globalScope.define(dagsoort.name, {\n        name: dagsoort.name,\n        kind: SymbolKind.DAGSOORT,\n        definition: dagsoort\n      });\n    }\n  }\n\n  private validateModel(model: DomainModel): void {\n    // Validate rules\n    for (const regel of model.regels || []) {\n      this.validateRegel(regel);\n    }\n\n    // Validate rule groups\n    for (const regelGroep of model.regelGroepen || []) {\n      for (const regel of regelGroep.regels) {\n        this.validateRegel(regel);\n      }\n    }\n\n    // Validate decision tables\n    for (const beslistabel of model.beslistabels || []) {\n      this.validateBeslistabel(beslistabel);\n    }\n  }\n\n  private validateRegel(regel: Rule): void {\n    // Check if regel has a result property with the actual rule content\n    if ('result' in regel && regel.result) {\n      const result = regel.result;\n      if (result.type === 'Gelijkstelling') {\n        this.validateGelijkstelling(result as Gelijkstelling);\n      } else if (result.type === 'Kenmerktoekenning') {\n        this.validateKenmerkToekenning(result as Kenmerktoekenning);\n      } else if (result.type === 'ObjectCreation') {\n        this.validateObjectCreatie(result as ObjectCreation);\n      }\n    }\n    // TODO: Implement FeitCreatie validation when visitor supports it\n  }\n\n  private validateGelijkstelling(regel: Gelijkstelling): void {\n    // Validate target exists and expression type matches\n    if (regel.target.type === 'AttributeReference') {\n      const attrRef = regel.target as AttributeReference;\n      this.validateAttributeReference(attrRef);\n    }\n    \n    // Validate expression\n    if (regel.expression) {\n      this.validateExpression(regel.expression);\n    }\n  }\n\n  private validateKenmerkToekenning(regel: Kenmerktoekenning): void {\n    // Validate kenmerk exists on the object type\n    // The subject is an Expression, typically a VariableReference with the object type name\n    let objectTypeName: string | undefined;\n    \n    \n    if (regel.subject.type === 'VariableReference') {\n      const varRef = regel.subject as VariableReference;\n      objectTypeName = varRef.name || (varRef as any).variableName;\n    } else if (regel.subject.type === 'NavigationExpression') {\n      // Handle \"Een Persoon\" which might be parsed as NavigationExpression\n      const navExpr = regel.subject as any;\n      if (navExpr.base?.type === 'VariableReference') {\n        objectTypeName = navExpr.base.name;\n      }\n    } else {\n      // Handle other expression types if needed\n      this.addError(`Complex subject expressions in kenmerk assignment not yet supported (got ${regel.subject.type})`);\n      return;\n    }\n    \n    const kenmerkName = regel.characteristic;\n    \n    const objectType = this.objectTypes.get(objectTypeName);\n    if (!objectType) {\n      this.addError(`Unknown object type: ${objectTypeName}`);\n      return;\n    }\n\n    const kenmerk = objectType.members.find(m => \n      m.type === 'KenmerkSpecification' && m.name === kenmerkName\n    ) as KenmerkSpecification | undefined;\n    if (!kenmerk) {\n      this.addError(`Kenmerk '${kenmerkName}' not defined for object type '${objectTypeName}'`);\n    }\n\n    // Validate condition if present\n    if ('condition' in regel && regel.condition) {\n      this.validateExpression(regel.condition);\n    }\n  }\n\n  private validateObjectCreatie(regel: ObjectCreation): void {\n    // Validate object type exists\n    const objectTypeName = regel.objectType;\n    const objectType = this.objectTypes.get(objectTypeName);\n    \n    if (!objectType) {\n      this.addError(`Unknown object type: ${objectTypeName}`);\n      return;\n    }\n\n    // Validate attributes being initialized\n    for (const init of regel.attributeInits) {\n      const attr = objectType.members.find(m => m.type === 'AttributeSpecification' && m.name === init.attribute) as AttributeSpecification | undefined;\n      if (!attr) {\n        this.addError(`Attribute '${init.attribute}' not defined for object type '${objectTypeName}'`);\n      } else {\n        // Validate type of initialization value\n        if (init.value) {\n          const valueType = this.getExpressionType(init.value);\n          const attrType = this.getDataTypeString(attr.dataType);\n          if (!this.isTypeCompatible(valueType, attrType)) {\n            this.addError(`Type mismatch: cannot assign ${valueType} to attribute '${init.attribute}' of type ${attrType}`);\n          }\n        }\n      }\n    }\n  }\n\n  // TODO: Implement FeitCreatie validation when visitor supports it\n\n  private validateBeslistabel(beslistabel: DecisionTable): void {\n    // Validate expressions in decision table\n    for (const row of beslistabel.rows) {\n      if (row.result) {\n        this.validateExpression(row.result);\n      }\n    }\n  }\n\n  private validateAttributeReference(attrRef: AttributeReference): void {\n    // Validate attribute path\n    if (attrRef.path.length === 0) {\n      this.addError('Empty attribute reference path');\n      return;\n    }\n\n    // Complex path validation would go here\n    // For now, just check if the attribute exists on known object types\n  }\n\n  private validateExpression(expr: Expression): void {\n    switch (expr.type) {\n      case 'Literal':\n        // Literals are always valid\n        break;\n      \n      case 'AttributeReference':\n        this.validateAttributeReference(expr as AttributeReference);\n        break;\n      \n      case 'ParameterReference':\n        const paramRef = expr as ParameterReference;\n        const paramName = paramRef.name || (paramRef as any).parameterName;\n        if (!this.parameters.has(paramName)) {\n          this.addError(`Unknown parameter: ${paramName}`);\n        }\n        break;\n      \n      case 'VariableReference':\n        // In RegelSpraak, parameters are often referenced like variables with articles\n        const varRef = expr as VariableReference;\n        const varName = varRef.name || (varRef as any).variableName;\n        \n        // Check if it's a parameter reference\n        if (!this.parameters.has(varName) && !this.objectTypes.has(varName)) {\n          // It's not a known parameter or object type\n          this.addError(`Unknown parameter: ${varName}`);\n        }\n        break;\n      \n      case 'BinaryExpression':\n        const binExpr = expr as BinaryExpression;\n        this.validateExpression(binExpr.left);\n        this.validateExpression(binExpr.right);\n        // Type checking for operators would go here\n        break;\n      \n      case 'UnaryExpression':\n        const unExpr = expr as UnaryExpression;\n        this.validateExpression(unExpr.operand);\n        break;\n      \n      case 'FunctionCall':\n        const funcCall = expr as FunctionCall;\n        // Validate function exists and arguments\n        for (const arg of funcCall.arguments) {\n          this.validateExpression(arg);\n        }\n        break;\n      \n      case 'SubselectieExpression':\n        const subselectie = expr as SubselectieExpression;\n        this.validateExpression(subselectie.collection);\n        // Validate predicate would go here\n        break;\n    }\n  }\n\n  private getExpressionType(expr: Expression): string {\n    switch (expr.type) {\n      case 'Literal':\n        const lit = expr as Literal;\n        switch (lit.literalType) {\n          case 'number': return 'Numeriek';\n          case 'string': return 'Tekst';\n          case 'boolean': return 'Boolean';\n          case 'date': return 'Datum';\n          default: return 'Unknown';\n        }\n      \n      case 'NumberLiteral':\n        return 'Numeriek';\n      \n      case 'StringLiteral':\n        return 'Tekst';\n      \n      case 'BooleanLiteral':\n        return 'Boolean';\n      \n      case 'AttributeReference':\n        // Would need to resolve attribute type\n        return 'Unknown';\n      \n      case 'ParameterReference':\n        const paramRef = expr as ParameterReference;\n        const paramName = paramRef.name || (paramRef as any).parameterName;\n        const param = this.parameters.get(paramName);\n        return param?.datatype || 'Unknown';\n      \n      case 'BinaryExpression':\n        const binExpr = expr as BinaryExpression;\n        // Comparison operators return boolean\n        if (['<', '>', '<=', '>=', '==', '!='].includes(binExpr.operator)) {\n          return 'Boolean';\n        }\n        // Arithmetic operators return numeric\n        if (['+', '-', '*', '/', '^'].includes(binExpr.operator)) {\n          return 'Numeriek';\n        }\n        // Logical operators return boolean\n        if (['AND', 'OR'].includes(binExpr.operator)) {\n          return 'Boolean';\n        }\n        return 'Unknown';\n      \n      case 'FunctionCall':\n        // Would need function return type registry\n        return 'Unknown';\n      \n      default:\n        return 'Unknown';\n    }\n  }\n\n  private isTypeCompatible(sourceType: string, targetType: string): boolean {\n    // Simple type compatibility check\n    if (sourceType === targetType) return true;\n    if (sourceType === 'Unknown' || targetType === 'Unknown') return true;\n    \n    // Numeriek variations are compatible\n    if (sourceType.startsWith('Numeriek') && targetType.startsWith('Numeriek')) {\n      return true;\n    }\n    \n    // Add more compatibility rules as needed\n    return false;\n  }\n\n  private getDataTypeString(dataType: DataType | DomainReference): string {\n    if ('domain' in dataType) {\n      return dataType.domain;\n    }\n    switch (dataType.type) {\n      case 'Tekst': return 'Tekst';\n      case 'Numeriek': return dataType.specification ? `Numeriek(${dataType.specification})` : 'Numeriek';\n      case 'Boolean': return 'Boolean';\n      case 'Datum': return 'Datum';\n      case 'DatumTijd': return 'DatumTijd';\n      default: return 'Unknown';\n    }\n  }\n\n  private addError(message: string, severity: 'error' | 'warning' = 'error'): void {\n    this.errors.push({ message, severity });\n  }\n}"],
  "mappings": "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",
  "names": ["SymbolKind"]
}
