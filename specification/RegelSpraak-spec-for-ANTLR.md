**Structure:**

1.  **Introduction:** Overview and scope.
2.  **Lexer Specification:** Defining the tokens (keywords, identifiers, literals, operators, etc.).
3.  **Parser Specification:** Defining the grammatical structure (how tokens combine).
4.  **Illustrative Examples:** Showing RegelSpraak snippets and how the grammar rules apply.
5.  **Handling Specific Constructs:** Notes on complex areas like expressions, conditions, and beslistabellen.

---

## 1. Introduction

This document specifies the grammar for RegelSpraak v2.1.0 in a format intended for use with ANTLR v4. It translates the concepts and EBNF provided in the "RegelSpraak-specificatie v2.1.0.md" document into distinct lexer and parser rules.

The goal is to define a grammar (`.g4` file) that can parse files containing GegevensSpraak definitions (Objecttypes, Parameters, Dimensies, etc.) and RegelSpraak rules (Regels, Beslistabellen).

**Scope:** This specification focuses on the syntactic structure defined in the source document. Semantic validation (e.g., type checking, ensuring referenced names exist) is typically handled *after* parsing, often using listeners or visitors generated by ANTLR based on the parse tree.

**ANTLR Conventions:**
*   Parser rule names start with a lowercase letter (e.g., `regel`).
*   Lexer rule names start with an uppercase letter (e.g., `REGEL`, `IDENTIFIER`).
*   Literals (keywords, operators) are enclosed in single quotes (e.g., `'Regel'`, `'plus'`).
*   Whitespace is generally skipped.

---

## 2. Lexer Specification

The lexer breaks the input character stream into tokens.

**2.1 Keywords:** These are reserved words with specific meanings in RegelSpraak.

```antlr
// --- Top-Level Keywords ---
REGEL: 'Regel';
BESLISTABEL: 'Beslistabel'; // Added based on Chapter 12
OBJECTTYPE: 'Objecttype';
DOMEIN: 'Domein';
DIMENSIE: 'Dimensie';
EENHEIDSYSTEEM: 'Eenheidsysteem';
PARAMETER: 'Parameter';
FEITTYPE: 'Feittype';
WEDERKERIG_FEITTYPE: 'Wederkerig feittype';
DAGSOORT: 'Dagsoort';

// --- Rule Keywords ---
GELDIG: 'geldig';
ALTIJD: 'altijd';
VANAF: 'vanaf';
TM: 't/m'; // Note: Might conflict with division if not handled carefully in context. Use 'TOT_EN_MET'?
TOT_EN_MET: 'tot en met'; // Explicit alternative to TM
TOT: 'tot'; // Added for period specification
INDIEN: 'indien';
DAARBIJ_GELDT: 'Daarbij geldt:';
WORDT_BEREKEND_ALS: 'moet berekend worden als';
WORDT_GESTELD_OP: 'moet gesteld worden op';
WORDT_GEINITIALISEERD_OP: 'moet geïnitialiseerd worden op';
WORDT_VERDEELD_OVER: 'wordt verdeeld over';
IS: 'is';
ZIJN: 'zijn'; // Plural form of 'is'
HEEFT: 'heeft';
HEBBEN: 'hebben'; // Plural form of 'heeft'
MOET: 'moet';
MOETEN: 'moeten'; // Plural form of 'moet'
VOLDOET: 'voldoet';
VOLDOEN: 'voldoen'; // Plural form of 'voldoet'
AAN: 'aan';
DE: 'de';
HET: 'het';
EEN: 'een';
HIJ: 'hij'; // Pronoun for bezield object
ZIJN_BEZITTELIJK: 'zijn'; // Possessive pronoun (distinct from plural verb)
// Note: Distinguishing ZIJN verb and ZIJN_BEZITTELIJK might require parser context or different lexer modes if ambiguous.
// Let's assume context handles it for now.

// --- Data Types & Structures ---
BEZIELD: '(bezield)';
MV: '(mv:'; // Start of plural marker
KENMERK: 'kenmerk';
BEZITTELIJK: '(bezittelijk)';
BIJVOEGLIJK: '(bijvoeglijk)';
GEDIMENSIONEERD_MET: 'gedimensioneerd met';
EN: 'en';
OF: 'of'; // Used in concatenation predicate 'is gelijk aan'
IS_VAN_HET_TYPE: 'is van het type';
ENUMERATIE: 'Enumeratie';
NUMERIEK: 'Numeriek';
TEKST: 'Tekst';
BOOLEAN: 'Boolean';
DATUM_IN_DAGEN: 'Datum in dagen';
DATUM_TIJD_MILLIS: 'Datum en tijd in millisecondes';
PERCENTAGE: 'Percentage';
MET_EENHEID: 'met eenheid';
DECIMALEN: 'decimalen';
GETAL: 'getal';
GEHEEL_GETAL: 'geheel getal';
NEGATIEF: 'negatief';
NIET_NEGATIEF: 'niet-negatief';
POSITIEF: 'positief';
VOOR_ELKE_DAG: 'voor elke dag';
VOOR_ELKE_MAAND: 'voor elke maand';
VOOR_ELK_JAAR: 'voor elk jaar';
BESTAANDE_UIT: ', bestaande uit de'; // Part of Dimensie definition
NA_HET_ATTRIBUUT_MET_VOORZETSEL: '(na het attribuut met voorzetsel';
VOOR_HET_ATTRIBUUT_ZONDER_VOORZETSEL: '(voor het attribuut zonder voorzetsel):';
VAN: 'van';
IN: 'in';
VOOR: 'voor';
OVER: 'over';
OP: 'op';
BIJ: 'bij';
UIT: 'uit';
DAG: 'dag'; // Used in Dagsoort definition, Date extraction
MAAND: 'maand'; // Used in Date extraction, Time units
JAAR: 'jaar'; // Used in Date extraction, Time units
WEEK: 'week'; // Time unit
KWARTAAL: 'kwartaal'; // Time unit
MILLISECONDE: 'milliseconde'; // Time unit
SECONDE: 'seconde'; // Time unit
MINUUT: 'minuut'; // Time unit
UUR: 'uur'; // Time unit

// --- Expressions & Operators ---
PLUS: 'plus';
MIN: 'min';
VERMINDERD_MET: 'verminderd met';
MAAL: 'maal';
GEDEELD_DOOR: 'gedeeld door';
GEDEELD_DOOR_ABS: 'gedeeld door (ABS)';
WORTEL_VAN: 'de wortel van';
TOT_DE_MACHT: 'tot de macht';
ABSOLUTE_WAARDE_VAN: 'de absolute waarde van';
TIJDSDUUR_VAN: 'de tijdsduur van';
ABSOLUTE_TIJDSDUUR_VAN: 'de absolute tijdsduur van';
IN_HELE: 'in hele';
EERSTE_PAASDAG_VAN: 'de eerste paasdag van';
TOTAAL_VAN: 'het totaal van'; // Time aggregation
AANTAL_DAGEN_IN: 'het aantal dagen in'; // Time counting
TIJDSEVENREDIG_DEEL_PER: 'het tijdsevenredig deel per'; // Time pro-rata
REEKS_VAN_TEKSTEN_EN_WAARDEN: 'reeks van teksten en waarden'; // String interpolation intro (hypothetical, spec uses «»)
// Note: The actual `«` and `»` are handled below in Punctuation/Operators.

// --- Aggregation ---
AANTAL: 'het aantal';
SOM_VAN: 'de som van';
MAXIMALE_WAARDE_VAN: 'de maximale waarde van';
MINIMALE_WAARDE_VAN: 'de minimale waarde van';
EERSTE_VAN: 'de eerste van';
LAATSTE_VAN: 'de laatste van';
ALLE: 'alle'; // Used in aggregation over dimensions, conditions

// --- Conditions & Predicates ---
GELIJK_AAN: 'gelijk aan';
ONGELIJK_AAN: 'ongelijk aan';
GROTER_DAN: 'groter dan';
GROTER_OF_GELIJK_AAN: 'groter of gelijk aan';
KLEINER_DAN: 'kleiner dan';
KLEINER_OF_GELIJK_AAN: 'kleiner of gelijk aan';
LATER_DAN: 'later dan';
LATER_OF_GELIJK_AAN: 'later of gelijk aan';
EERDER_DAN: 'eerder dan';
EERDER_OF_GELIJK_AAN: 'eerder of gelijk aan';
LEEG: 'leeg';
GEVULD: 'gevuld';
AAN_DE_ELFPROEF: 'aan de elfproef'; // Part of elfproef predicate
NIET: 'niet';
NUMERIEK_MET_EXACT: 'numeriek met exact';
CIJFERS: 'cijfers';
UNIEK: 'uniek';
VERENIGD_MET: 'verenigd met';
CONCATENATIE_VAN: 'de concatenatie van';
GEVUURD: 'gevuurd';
INCONSISTENT: 'inconsistent';
GEDURENDE_DE_TIJD_DAT: 'gedurende de tijd dat';
GEDURENDE_HET_GEHELE: 'gedurende het gehele';
GEDURENDE_DE_GEHELE: 'gedurende de gehele'; // Specific for month
PERIODE: 'periode'; // Used in elementaire periodevergelijking

// --- Quantifiers ---
GEEN_VAN_DE: 'geen van de';
TEN_MINSTE: 'ten minste';
TEN_HOOGSTE: 'ten hoogste';
PRECIES: 'precies';
EEN_TELWOORD: 'één';
TWEE_TELWOORD: 'twee';
DRIE_TELWOORD: 'drie';
VIER_TELWOORD: 'vier';
// Note: Higher numbers are literals (NUMBER token)

// --- Afronding & Begrenzing ---
NAAR_BENEDEN: 'naar beneden';
NAAR_BOVEN: 'naar boven';
REKENKUNDIG: 'rekenkundig';
RICHTING_NUL: 'richting nul';
WEG_VAN_NUL: 'weg van nul';
AFGEROND_OP: 'afgerond op';
MET_EEN_MINIMUM_VAN: 'met een minimum van';
MET_EEN_MAXIMUM_VAN: 'met een maximum van';

// --- Verdeling ---
WAARBIJ_WORDT_VERDEELD: ', waarbij wordt verdeeld';
IN_GELIJKE_DELEN: 'in gelijke delen';
NAAR_RATO_VAN: 'naar rato van';
OP_VOLGORDE_VAN: 'op volgorde van';
TOENEMENDE: 'toenemende';
AFNEMENDE: 'afnemende';
BIJ_EVEN_GROOT_CRITERIUM: 'bij even groot criterium';
ALS_ONVERDEELDE_REST_BLIJFT: 'Als onverdeelde rest blijft';
OVER_VERDELING: 'over.'; // End of Verdeling rest clause

// --- Datum Literals ---
DD_PUNT: 'dd.';

// --- Other ---
REGELVERSIE: 'regelversie'; // Used in rule predicate
VOLGENDE_VOORWAARDE: 'volgende voorwaarde';
VOLGENDE_VOORWAARDEN: 'volgende voorwaarden'; // Plural
VOLGEND_CRITERIUM: 'het volgende criterium:';
VOLGENDE_CRITERIA: 'volgende criteria:'; // Plural
DIE: 'die'; // Subselectie relative pronoun
DAT: 'dat'; // Subselectie relative pronoun
REKENDATUM: 'Rekendatum';
REKENJAAR: 'Rekenjaar';
```

**2.2 Identifiers:** Names for rules, object types, attributes, parameters, roles, etc. RegelSpraak uses Dutch phrases. ANTLR typically uses a simpler pattern. We need a flexible IDENTIFIER rule.

```antlr
IDENTIFIER: LETTER (LETTER | DIGIT | '_' | '-' | ' ')* LETTER | LETTER; // Allows spaces, underscores, hyphens within multi-word identifiers, but must start/end with a letter.
// Basic version (simpler, less true to examples, but common in programming languages):
// IDENTIFIER: LETTER (LETTER | DIGIT | '_')*;

// Define LETTER and DIGIT based on Unicode or restrict as needed.
// Simple ASCII for illustration:
// fragment LETTER: [a-zA-ZáàâéèêíìîóòôúùûüïÁÀÂÉÈÊÍÌÎÓÒÔÚÙÛÜÏ];
// fragment DIGIT: [0-9];

// More complete Unicode approach (requires ANTLR Unicode support):
fragment LETTER_PROPERTY: [_] | [\p{L}]; // Underscore or any Unicode Letter
fragment DIGIT_PROPERTY: [\p{Nd}]; // Any Unicode Decimal Digit
IDENTIFIER : LETTER_PROPERTY (LETTER_PROPERTY | DIGIT_PROPERTY | '-' | ' ')* LETTER_PROPERTY | LETTER_PROPERTY; // Allow hyphen and space internally
```
*Self-correction:* The complex `IDENTIFIER` allowing spaces and hyphens is closer to RegelSpraak examples like `Natuurlijk persoon` or `belasting op basis van afstand`. However, this can create ambiguity with keywords. For robust parsing, it might be better to *require* quoting for identifiers containing spaces/hyphens, or enforce `CamelCase` or `snake_case`. Given the spec uses natural language freely, the space-allowing `IDENTIFIER` is chosen, accepting the potential need for careful grammar design or semantic checks later to resolve ambiguities (e.g., `is gelijk aan` vs an identifier `is gelijk aan`). *Let's stick with the space-allowing version for now.*

**2.3 Literals:**

```antlr
// --- Numeric Literals ---
// Integer, Decimal (with comma), Rational (fraction)
// Needs careful definition to handle structure like 1_2/3 or -12,34
NUMBER: MINUS? DIGIT+ (',' DIGIT+)? // Simple decimal/integer
       | MINUS? DIGIT+ '_' DIGIT+ '/' DIGIT+ // Integer part of fraction
       | MINUS? DIGIT+ '/' DIGIT+;          // Simple fraction
fragment MINUS: '-';
fragment DIGIT : [0-9] ;

// --- Percentage Literals ---
PERCENTAGE_LITERAL: NUMBER '%'; // A number followed by %

// --- String Literals ---
STRING_LITERAL: '"' (~["\r\n\\] | '\\' .)*? '"'; // Standard string literal, allows escapes

// --- Enumeration Literals ---
ENUM_LITERAL: '\'' (~['\r\n\\] | '\\' .)*? '\''; // Single quotes

// --- Boolean Literals ---
WAAR: 'waar';
ONWAAR: 'onwaar';

// --- Date Literals ---
// Format: dd-mm-yyyy (and potentially hh:mm:ss.ms)
// Lexer rule needs to be robust enough to capture valid date/time formats.
// Example: 'dd. 12-03-2023' or 'dd. 12-03-2023 11:34:42.679'
// A single complex regex or multiple simpler rules might be needed.
// Let's use a placeholder name and refine the regex if needed.
DATE_TIME_LITERAL: DD_PUNT WS? DIGIT{1,2} '-' DIGIT{1,2} '-' DIGIT{4} (WS? DIGIT{2} ':' DIGIT{2} ':' DIGIT{2} '.' DIGIT{3})?;
```

**2.4 Operators and Punctuation:**

```antlr
// --- Arithmetic Operators (already defined as keywords) ---
// PLUS, MIN, MAAL, GEDEELD_DOOR, GEDEELD_DOOR_ABS

// --- Comparison Operators (already defined as keywords) ---
// GELIJK_AAN, ONGELIJK_AAN, GROTER_DAN, etc.

// --- Punctuation ---
LPAREN: '(';
RPAREN: ')';
LBRACK: '['; // Used for optional parts in EBNF, maybe not needed in Regelspraak itself? Check spec. Found in 13.1.7 - used for EBNF spec itself, not Regelspraak language.
RBRACK: ']'; // See LBRACK.
LBRACE: '{'; // Used in dimension aggregation over set
RBRACE: '}'; // Used in dimension aggregation over set
COMMA: ',';
DOT: '.';
COLON: ':';
SEMICOLON: ';';
SLASH: '/'; // Used in units (e.g., km/u) and potentially division if not keyword
ASTERISK: '*'; // Used for EBNF repetition, not seen as operator in Regelspraak spec examples
PLUS_SIGN: '+'; // Used for EBNF repetition, not seen as operator in Regelspraak spec examples (uses 'plus')
EQUALS: '='; // Used in Eenheidsysteem omrekening, Feittype cardinality
QUOTE: '"'; // Handled in STRING_LITERAL
APOSTROPHE: '\''; // Handled in ENUM_LITERAL
PERCENT_SIGN: '%'; // Handled in PERCENTAGE_LITERAL
BULLET: '•'; // Used in nested conditions
L_ANGLE_QUOTE: '«'; // Start of expression interpolation
R_ANGLE_QUOTE: '»'; // End of expression interpolation
CARET: '^'; // Used for exponent in units
```

**2.5 Whitespace and Comments:**

```antlr
WS: [ \t\r\n]+ -> skip; // Skip spaces, tabs, newlines

// Comments are not explicitly defined in the spec. If needed, add rules like:
// LINE_COMMENT: '//' .*? '\r'? '\n' -> skip;
// BLOCK_COMMENT: '/*' .*? '*/' -> skip;
```

---

## 3. Parser Specification

The parser defines how tokens are combined to form valid RegelSpraak structures. We translate the EBNF from Chapter 13 of the specification.

**(Note: This will be a substantial translation. Key parts are shown below, a complete grammar would require translating *all* EBNF rules from Chapter 13.)**

```antlr
grammar RegelSpraak;

// Import common tokens if defined separately, or include lexer rules above

// Start Rule (e.g., parsing a file containing definitions and rules)
regelSpraakDocument
    : ( definition | regel | beslistabel )* EOF
    ;

// Definitions (GegevensSpraak)
definition
    : objectTypeDefinition
    | domeinDefinition
    | dimensieDefinition
    | eenheidsysteemDefinition
    | parameterDefinition
    | feitTypeDefinition
    | dagsoortDefinition
    ;

// --- Object Type Definition (Ref: 3.1, 13.3.1) ---
objectTypeDefinition
    : OBJECTTYPE naamwoord (BEZIELD)? NEWLINE
      ( objectTypeMember NEWLINE )+
    ;

objectTypeMember
    : koptekst // Optional header separator
    | kenmerkSpecificatie
    | attribuutSpecificatie
    ;

naamwoord // Generic name structure (Ref: 3.1, 13.2.27)
    : (DE | HET)? identifier (MV identifier RPAREN)?
    ;

identifier // Parser rule using the lexer token
    : IDENTIFIER
    ;

kenmerkSpecificatie // Ref: 3.5, 13.3.2
    : ( (naamwoord KENMERK)
      | (naamwoord KENMERK BEZITTELIJK)
      | (IS identifier (MV identifier RPAREN)? KENMERK BIJVOEGLIJK)
      ) tijdlijn? SEMICOLON
    ;

attribuutSpecificatie // Ref: 3.2.1, 13.3.2
    : naamwoord (datatype | domeinNaam) (GEDIMENSIONEERD_MET dimensieNaam (EN dimensieNaam)*)? tijdlijn? SEMICOLON
    ;

tijdlijn // Ref: 3.8, 13.3.6
    : VOOR (VOOR_ELKE_DAG | VOOR_ELKE_MAAND | VOOR_ELK_JAAR)
    ;

// --- Datatypes (Ref: 3.3, 13.3.3) ---
datatype
    : numeriekDatatype
    | percentageDatatype
    | tekstDatatype
    | booleanDatatype
    | datumTijdDatatype
    ;

numeriekDatatype
    : NUMERIEK LPAREN getalSpecificatie RPAREN (MET_EENHEID eenheidExpressie)?
    ;

percentageDatatype
    : PERCENTAGE LPAREN getalSpecificatie RPAREN (MET_EENHEID PERCENT_SIGN (SLASH identifier)?)?
    ;

tekstDatatype
    : TEKST
    ;

booleanDatatype
    : BOOLEAN
    ;

datumTijdDatatype
    : DATUM_IN_DAGEN | DATUM_TIJD_MILLIS
    ;

getalSpecificatie
    : (NEGATIEF | NIET_NEGATIEF | POSITIEF)? (GEHEEL_GETAL | (GETAL MET numberLiteral DECIMALEN) | GETAL)
    ;

eenheidExpressie
    : (eenheidMacht+ | '1') (SLASH eenheidMacht+)?
    ;

eenheidMacht
    : identifier (CARET LPAREN integerLiteral RPAREN)?
    ;

// --- Domein Definition (Ref: 3.4, 13.3.4) ---
domeinDefinition
    : DOMEIN domeinNaam IS_VAN_HET_TYPE (datatype | enumeratieSpecificatie)
    ;

domeinNaam : identifier;

enumeratieSpecificatie
    : ENUMERATIE NEWLINE (ENUM_LITERAL NEWLINE)+
    ;

// --- Dimensie Definition (Ref: 3.6, 13.3.7) ---
dimensieDefinition
    : DIMENSIE (DE | HET) dimensieNaam BESTAANDE_UIT dimensieNaamMeervoud voorzetselSpecificatie NEWLINE
      (labelWaardeSpecificatie NEWLINE)+
    ;

dimensieNaam : identifier;
dimensieNaamMeervoud : identifier;

voorzetselSpecificatie
    : ( NA_HET_ATTRIBUUT_MET_VOORZETSEL voorzetsel RPAREN COLON )
    | VOOR_HET_ATTRIBUUT_ZONDER_VOORZETSEL
    ;

voorzetsel
    : VAN | IN | VOOR | OVER | OP | BIJ | UIT
    ;

labelWaardeSpecificatie
    : DIGIT+ DOT identifier // Assuming DIGIT+ represents the number before the label
    ;

// --- Parameter Definition (Ref: 3.10, 13.3.8) ---
parameterDefinition
    : PARAMETER parameterMetLidwoord COLON (datatype | domeinNaam) tijdlijn? SEMICOLON
    ;

parameterMetLidwoord
    : (DE | HET) parameterNaam
    ;

parameterNaam : identifier;

// --- Feit Type Definition (Ref: 3.11, 13.3.9) ---
feitTypeDefinition
    : (FEITTYPE | WEDERKERIG_FEITTYPE) feitTypeNaam NEWLINE
      rolSpecificatie NEWLINE
      (rolSpecificatie NEWLINE)? // Second role only for non-wederkerig
      feitTypeCardinaliteit
    ;

feitTypeNaam : identifier;

rolSpecificatie
    : (DE | HET)? rolNaam (MV identifier RPAREN)? objectTypeNaam
    ;

rolNaam : identifier;
objectTypeNaam : identifier;

feitTypeCardinaliteit
    : (EEN rolNaam | MEERDERE identifier) relatieBeschrijving (EEN rolNaam | MEERDERE identifier)
    ;

relatieBeschrijving : identifier+ ; // Capture multi-word descriptions

// --- Dagsoort Definition (Ref: 3.12, 13.3.10) ---
dagsoortDefinition
    : DAGSOORT naamwoord
    ;

dagsoortNaam : identifier; // From naamwoord

// --- Regel Definition (Ref: 4, 13.4.2) ---
regel
    : REGEL regelNaam NEWLINE
      (regelVersie)+
    ;

regelNaam : identifier;

regelVersie
    : versie NEWLINE regelSpraakRegel
    ;

versie
    : GELDIG versieGeldigheid
    ;

versieGeldigheid
    : ALTIJD
    | (VANAF datumOfJaar ( (TM | TOT_EN_MET) datumOfJaar)? )
    | ( (TM | TOT_EN_MET) datumOfJaar )
    ;

datumOfJaar
    : datumLiteral | jaarLiteral
    ;

regelSpraakRegel
    : resultaatDeel NEWLINE? (voorwaardeDeel DOT)? NEWLINE? (variabeleDeel)?
    ;

// --- Resultaat Deel (Ref: 9, 13.4.3) ---
resultaatDeel
    : gelijkstelling
    | kenmerkToekenning
    | objectCreatie
    | feitCreatie
    | consistentieRegel
    | initialisatie
    | verdeling
    | dagsoortResultaatDefinitie // Naming distinct from top-level definition
    ;

gelijkstelling // Ref: 9.1, 13.4.4
    : attribuutVanOnderwerp (WORDT_GESTELD_OP expressie | WORDT_BEREKEND_ALS (getalExpressie | datumExpressie))
    ;

kenmerkToekenning // Ref: 9.2, 13.4.5
    : onderwerpKeten (IS | HEEFT) EEN? kenmerkNaam
    ;

kenmerkNaam : identifier;

objectCreatie // Ref: 9.3, 13.4.6
    : EEN onderwerpKeten HEEFT EEN rolNaam (MET waardeToekenning (COMMA waardeToekenning)* (EN waardeToekenning))?
    ;

waardeToekenning
    : (attribuutNaam | kenmerkNaam) GELIJK_AAN expressie // Simplified, spec differentiates attribuut/kenmerk types
    ;

attribuutNaam : identifier;

feitCreatie // Ref: 9.4, 13.4.7
    : EEN rolNaam VAN EEN onderwerpKeten IS (DE | HET | EEN) rolNaam VAN (DE | HET | EEN) onderwerpKeten
    ;

initialisatie // Ref: 9.6, 13.4.9
    : attribuutVanOnderwerp WORDT_GEINITIALISEERD_OP expressie
    ;

verdeling // Ref: 9.7, 13.4.10 - Simplified structure
    : attribuutVanOnderwerp WORDT_VERDEELD_OVER attribuutVanOnderwerp WAARBIJ_WORDT_VERDEELD
      ( verdelenZonderGroepen | meervoudigVerdeelCriterium )
      ( ALS_ONVERDEELDE_REST_BLIJFT attribuutVanOnderwerp OVER_VERDELING )? // If needed by options
    ;

verdelenZonderGroepen
    : IN_GELIJKE_DELEN
    | (NAAR_RATO_VAN attribuutMetLidwoord)
    ;

meervoudigVerdeelCriterium // Placeholder for complex structure
    : COLON NEWLINE // ... structure with ordering, grouping, maximum, rounding
      verdelenOverGroepen?
      maximumAanspraak?
      verdeelAfronding?
    ;

verdelenOverGroepen : // Placeholder
    OP_VOLGORDE_VAN (AFNEMENDE | TOENEMENDE) attribuutMetLidwoord NEWLINE criteriumBijGelijkeVolgorde COMMA
    ;
criteriumBijGelijkeVolgorde : // Placeholder
    BIJ_EVEN_GROOT_CRITERIUM (IN_GELIJKE_DELEN | (NAAR_RATO_VAN attribuutMetLidwoord)) COMMA
    ;
maximumAanspraak : // Placeholder
    MET_EEN_MAXIMUM_VAN attribuutMetLidwoord COMMA
    ;
verdeelAfronding : // Placeholder
    AFGEROND_OP integerLiteral DECIMALEN NAAR_BENEDEN DOT? // DOT might be optional depending on position
    ;


dagsoortResultaatDefinitie // Ref: 9.8, 13.4.11
    : EEN DAG IS EEN dagsoortNaam
    ;

// --- Voorwaarde Deel (Ref: 10, 13.4.12) ---
voorwaardeDeel
    : ( (INDIEN | GEDURENDE_DE_TIJD_DAT) (toplevelElementaireVoorwaarde | toplevelSamengesteldeVoorwaarde) )
    | periodeVergelijkingEnkelvoudig // Standalone period condition
    ;

toplevelElementaireVoorwaarde
    : toplevelVoorwaardeVergelijking
    | toplevelConsistentieVoorwaarde
    ;

toplevelSamengesteldeVoorwaarde // Ref: 10.2, 13.4.13
    : ( objectExpressie | referentie | aggregatie | ER )
      AAN voorwaardeKwantificatie (VOLGENDE_VOORWAARDE | VOLGENDE_VOORWAARDEN) (VOLDOET | VOLDOEN | WORDT_BEREKEND_ALS) COLON
      samengesteldeVoorwaardeOnderdeel
    ;

samengesteldeVoorwaardeOnderdeel
    : (NEWLINE genesteVoorwaarde)+
    ;

genesteVoorwaarde
    : BULLET+ (elementaireVoorwaarde | genesteSamengesteldeVoorwaarde)
    ;

genesteSamengesteldeVoorwaarde // Similar to toplevel but nested
    : ( objectExpressie | referentie | aggregatie | ER )
      (VOLDOET | VOLDOEN | WORDT_BEREKEND_ALS) // Clause from 13.4.13.2
      AAN voorwaardeKwantificatie (VOLGENDE_VOORWAARDE | VOLGENDE_VOORWAARDEN) COLON
      samengesteldeVoorwaardeOnderdeel
    ;


elementaireVoorwaarde // Ref: 10.1, 13.4.14
    : voorwaardeVergelijking
    | consistentieVoorwaarde
    ;

voorwaardeVergelijking // General structure for comparisons
    : expressie ( predicaatOperator expressie? ) // Operator and optional second operand
    ;

predicaatOperator // Placeholder for specific comparison operators
    : GELIJK_AAN | ONGELIJK_AAN | GROTER_DAN | KLEINER_DAN // ... etc.
    | LEEG IS | GEVULD IS // ... unary operators
    ;

// --- Variabele Deel (Ref: 11, 13.4.2) ---
variabeleDeel
    : DAARBIJ_GELDT (NEWLINE variabeleOnderdeel)* DOT
    ;

variabeleOnderdeel
    : (DE | HET)? variabeleNaam IS expressie
    ;

variabeleNaam : identifier;

// --- Expressies (Ref: 5, 6, 7, 13.4.16) ---
expressie
    : getalExpressie
    | objectExpressie
    | datumExpressie
    | tekstExpressie
    | booleanExpressie
    | expressieTussenHaakjes
    | parameterMetLidwoord
    | variabeleNaam
    | concatenatie
    | ENUM_LITERAL // Literal enum value
    // Note: Literal values like numbers, strings, dates, booleans are handled here or within specific expression types
    ;

expressieTussenHaakjes : LPAREN expressie RPAREN;

concatenatie // Ref: 5.7
    : expressie (COMMA expressie)* (EN | OF) expressie
    ;

// Arithmetic expressions need precedence handling. ANTLR allows left-recursion for this.
// Example for additive/multiplicative precedence:
getalExpressie
    : getalExpressie (PLUS | MIN) getalExpressie # AdditiveExpr
    | getalExpressie (MAAL | GEDEELD_DOOR | GEDEELD_DOOR_ABS) getalExpressie # MultiplicativeExpr
    | getalExpressie VERMINDERD_MET getalExpressie # VerminderdMetExpr (handle precedence relative to +/-/ * / /)
    | getalExpressie TOT_DE_MACHT getalExpressie afronding # MachtsVerheffenExpr (handle precedence)
    | getalExpressie PERCENT_SIGN? VAN getalExpressie # PercentageVanExpr
    | WORTEL_VAN getalExpressie afronding # WortelExpr
    | ABSOLUTE_WAARDE_VAN LPAREN getalExpressie RPAREN # AbsoluteWaardeExpr
    | TIJDSDUUR_VAN datumExpressie TOT datumExpressie IN HELE? eenheidNaam # TijdsduurExpr
    | ABSOLUTE_TIJDSDUUR_VAN datumExpressie TOT datumExpressie IN HELE? eenheidNaam # AbsoluteTijdsduurExpr
    | JAAR UIT datumExpressie # JaarUitExpr
    | MAAND UIT datumExpressie # MaandUitExpr
    | DAG UIT datumExpressie # DagUitExpr
    | afrondingExpressie # AfrondingExpr
    | begrenzingExpressie # BegrenzingExpr
    | getalAggregatie # AggregatieExpr
    | REKENJAAR # RekenjaarExpr
    | NUMBER # NumberLiteralExpr
    | attribuutVanOnderwerp # AttribuutRefExpr // If returns number
    | parameterMetLidwoord # ParameterRefExpr // If returns number
    | variabeleNaam # VariableRefExpr // If returns number
    | LPAREN getalExpressie RPAREN # ParenGetalExpr // Parenthesized expression
    ;
    // TODO: Add other numeric functions/aggregations and ensure precedence is correct.
    // Precedence order (highest first): (), ^, sqrt, abs, *, /, %, +, -

afrondingExpressie
    : getalExpressie afronding
    ;

begrenzingExpressie
    : getalExpressie COMMA begrenzing
    ;

afronding // Ref: 6.1.3
    : (NAAR_BENEDEN | NAAR_BOVEN | REKENKUNDIG | RICHTING_NUL | WEG_VAN_NUL) AFGEROND_OP integerLiteral DECIMALEN
    ;

begrenzing // Ref: 6.1.4
    : (begrenzingMinimum | begrenzingMaximum | (begrenzingMinimum EN begrenzingMaximum))
    ;

begrenzingMinimum : MET_EEN_MINIMUM_VAN getalExpressie;
begrenzingMaximum : MET_EEN_MAXIMUM_VAN getalExpressie;

datumExpressie // Ref: 6.10, 6.11, 6.12, 6.13
    : EERSTE_PAASDAG_VAN LPAREN jaarLiteral RPAREN # EerstePaasdagExpr
    | datumExpressie (PLUS | MIN) getalExpressie eenheidNaam # DatumPlusMinTijdExpr
    | datumAggregatie # DatumAggregatieExpr
    | REKENDATUM # RekendatumExpr
    | DATE_TIME_LITERAL # DatumLiteralExpr
    | attribuutVanOnderwerp # AttribuutRefExpr // If returns date
    | parameterMetLidwoord # ParameterRefExpr // If returns date
    | variabeleNaam # VariableRefExpr // If returns date
    | LPAREN datumExpressie RPAREN # ParenDatumExpr
    ;
    // TODO: Add other date functions/aggregations

tekstExpressie // Ref: 5.4
    : tekstenWaardeReeks
    | STRING_LITERAL
    | attribuutVanOnderwerp // If returns text
    | parameterMetLidwoord // If returns text
    | variabeleNaam // If returns text
    | LPAREN tekstExpressie RPAREN
    ;

tekstenWaardeReeks // Ref: 5.4, 13.4.16.9
    : QUOTE ( L_ANGLE_QUOTE expressie R_ANGLE_QUOTE | karakterReeks )+ QUOTE
    ;

booleanExpressie // Ref: 3.3.3
    : WAAR | ONWAAR
    | attribuutVanOnderwerp // If returns boolean
    | parameterMetLidwoord // If returns boolean
    | variabeleNaam // If returns boolean
    | LPAREN booleanExpressie RPAREN
    ;

objectExpressie // Ref: 5.5
    : kwantificatie? onderwerpKeten
    ;

// --- Onderwerp & Selectie (Ref: 5.5, 13.4.1) ---
onderwerpKeten
    : ( (DE | HET | EEN | ZIJN_BEZITTELIJK) (objectTypeNaam | rolNaam | kenmerkNaam) )
    | ( selector VAN onderwerpKeten )
    | subselectie
    ;

selector
    : (DE | HET | EEN)? rolNaam
    ;

attribuutVanOnderwerp // Ref: 5.5.2, 13.4.2.9
    : kwantificatie? attribuutMetLidwoord VAN onderwerpKeten
    ;

attribuutMetLidwoord
    : (DE | HET | EEN)? attribuutNaam
    ;

kwantificatie // Ref: 5.5.5, 10, 13.4.13.5
    : ALLE | GEEN_VAN_DE
    | ( (TEN_MINSTE | TEN_HOOGSTE | PRECIES) (EEN_TELWOORD | TWEE_TELWOORD | DRIE_TELWOORD | VIER_TELWOORD | integerLiteral) (VAN DE)? ) // 'VAN DE' might be optional or context-dependent
    ;

subselectie // Ref: 5.6, 13.4.2.8
    : onderwerpKeten (DIE | DAT) predicaat
    ;

predicaat // Ref: 8.1, 13.4.12.2
    : elementairPredicaat | samengesteldPredicaat
    ;

elementairPredicaat // Structure depends on type (numeric, date, text, object)
    : // ... specific comparison/check operators ...
      predicaatOperator expressie?
    ;

samengesteldPredicaat // Ref: 8.3.2, 13.4.12.4 - Similar to samengesteldeVoorwaarde
    : AAN kwantificatie (VOLGENDE_VOORWAARDE | VOLGENDE_VOORWAARDEN) (VOLDOET | VOLDOEN) COLON
      samengesteldeVoorwaardeOnderdeel // Re-use condition structure
    ;

// --- Aggregatie (Ref: 5.8, 13.4.16) ---
aggregatie
    : getalAggregatie | datumAggregatie | dimensieAggregatie | tijdAggregatie // Added Time Aggregation
    ;

getalAggregatie
    : getalAggregatieFunctie expressie (OF NUMBER)? // Added optional 'of 0' for sum
    ;

getalAggregatieFunctie
    : AANTAL | MAXIMALE_WAARDE_VAN | MINIMALE_WAARDE_VAN | SOM_VAN
    ;

datumAggregatie
    : datumAggregatieFunctie expressie
    ;

datumAggregatieFunctie
    : EERSTE_VAN | LAATSTE_VAN
    ;

dimensieAggregatie // Ref: 5.8.5, 13.4.16.45
    : (getalAggregatieFunctie | datumAggregatieFunctie) attribuutVanOnderwerp dimensieSelectie
    ;

dimensieSelectie
    : OVER (aggregerenOverAlleDimensies | aggregerenOverVerzameling | aggregerenOverBereik) DOT? // Dot might be end of sentence marker
    ;

aggregerenOverAlleDimensies : ALLE dimensieNaamMeervoud;
aggregerenOverVerzameling : (DE | HET) dimensieNaamMeervoud VANAF identifier TM identifier;
aggregerenOverBereik : (DE | HET) dimensieNaamMeervoud IN LBRACE identifier (COMMA identifier)* EN identifier RBRACE;

tijdAggregatie // Ref: 7
    : waardePerTijdseenheidAggregatie
    | tellingAantalDagen
    | tijdsevenredigDeel
    ;

waardePerTijdseenheidAggregatie // Ref: 7.1
    : TOTAAL_VAN expressie conditieBijExpressie?
    ;

tellingAantalDagen // Ref: 7.2
    : AANTAL_DAGEN_IN (DE MAAND | HET JAAR) DAT expressie
    ;

tijdsevenredigDeel // Ref: 7.3.2
    : TIJDSEVENREDIG_DEEL_PER (MAAND | JAAR) VAN expressie conditieBijExpressie
    ;

conditieBijExpressie // Ref: 7.1, 7.3.2 uses time conditions
    : GEDURENDE_DE_TIJD_DAT (toplevelElementaireVoorwaarde | toplevelSamengesteldeVoorwaarde)
    | periodeVergelijkingEnkelvoudig
    ;

// --- Helper Rules ---
integerLiteral : MINUS? DIGIT+ ;
numberLiteral : NUMBER; // Use the lexer token
datumLiteral : DATE_TIME_LITERAL;
jaarLiteral : DIGIT{4};
booleanLiteral : WAAR | ONWAAR;
eenheidNaam : identifier; // e.g., 'jr', 'km', 'euro'

// ... other helper rules based on EBNF ...

// Recursie marker (Not directly parseable, typically metadata)
// recursieveRegelGroep : RECURSIEF_START regel+ RECURSIEF_EIND ; // Hypothetical markers

// Beslistabel (Structure Parsing - Limited Scope)
// Parsing the *content* of cells uses the main RegelSpraak rules (expressie, voorwaardeVergelijking etc.)
// Parsing the table structure itself might require dedicated rules or pre-processing.
beslistabel
    : BESLISTABEL regelNaam NEWLINE versie NEWLINE // Header
      // Placeholder for table structure parsing if needed
      // For now, assume content within cells is parsed by existing rules
      // e.g., a cell might contain an 'expressie' or a 'voorwaardeVergelijking' fragment.
      tableStructure // Placeholder rule
    ;

tableStructure : .*? ; // Non-greedy match until next rule/EOF - Needs refinement for actual table parsing

```

---

## 4. Illustrative Examples

**Example 1: Object Type Definition (Ref: §3.9)**

```regelspraak
Objecttype de Natuurlijk persoon (mv: Natuurlijke personen) (bezield)
    is minderjarig kenmerk (bijvoeglijk);
    het recht op duurzaamheidskorting kenmerk (bezittelijk);
    het identificatienummer Numeriek (positief geheel getal);
    de geboortedatum Datum in dagen;
    de leeftijd Numeriek (niet-negatief geheel getal) met eenheid jr;
```

*ANTLR Parsing:*
*   `objectTypeDefinition` rule matches.
*   `OBJECTTYPE` token: `Objecttype`
*   `naamwoord` rule: `DE` (`de`), `identifier` (`Natuurlijk persoon`), `MV`, `identifier` (`Natuurlijke personen`), `RPAREN`.
*   `BEZIELD` token: `(bezield)`
*   `objectTypeMember` rules match for each line:
    *   `kenmerkSpecificatie` (`is minderjarig...`)
    *   `kenmerkSpecificatie` (`het recht op...`)
    *   `attribuutSpecificatie` (`het identificatienummer...`) matches `naamwoord`, `numeriekDatatype` (`NUMERIEK`, `LPAREN`, `getalSpecificatie` (`POSITIEF`, `GEHEEL_GETAL`), `RPAREN`), `SEMICOLON`.
    *   `attribuutSpecificatie` (`de geboortedatum...`) matches `naamwoord`, `datumTijdDatatype` (`DATUM_IN_DAGEN`), `SEMICOLON`.
    *   `attribuutSpecificatie` (`de leeftijd...`) matches `naamwoord`, `numeriekDatatype` with `MET_EENHEID`.

**Example 2: Simple Rule - Gelijkstelling (Ref: §4.4, §9.1)**

```regelspraak
Regel bepaal leeftijd
    geldig altijd
        De leeftijd van een Natuurlijk persoon moet berekend worden als de tijdsduur van zijn geboortedatum tot de datum van de vlucht van zijn reis in hele jaren.
```

*ANTLR Parsing:*
*   `regel` rule matches.
*   `REGEL` token, `regelNaam` (`bepaal leeftijd`).
*   `regelVersie` rule:
    *   `versie`: `GELDIG`, `versieGeldigheid` (`ALTIJD`).
    *   `regelSpraakRegel`:
        *   `resultaatDeel` is a `gelijkstelling`.
            *   `attribuutVanOnderwerp`: `DE`, `attribuutNaam` (`leeftijd`), `VAN`, `onderwerpKeten` (`EEN`, `objectTypeNaam` (`Natuurlijk persoon`)).
            *   `WORDT_BEREKEND_ALS` token.
            *   `getalExpressie` (`TijdsduurExpr`): `TIJDSDUUR_VAN`, `datumExpressie` (`ZIJN_BEZITTELIJK`, `attribuutNaam` (`geboortedatum`)), `TOT`, `datumExpressie` (`DE`, `attribuutNaam` (`datum`), `VAN`, ... `zijn reis`), `IN_HELE`, `eenheidNaam` (`jaren`).
        *   No `voorwaardeDeel` or `variabeleDeel`.

**Example 3: Rule with Condition and Variable (Ref: §4.4, §10.1, §11)**

```regelspraak
Parameter de volwassenleeftijd : Numeriek met eenheid jaren
Regel Kenmerktoekenning persoon minderjarig
geldig altijd
Een Natuurlijk persoon is minderjarig
indien X kleiner is dan de volwassenleeftijd.
Daarbij geldt:
X is de tijdsduur van zijn geboortedatum tot de datum van de vlucht in hele jaren.
```

*ANTLR Parsing:*
*   `parameterDefinition` matches first.
*   `regel` rule matches.
*   `REGEL`, `regelNaam` (`Kenmerktoekenning persoon minderjarig`).
*   `regelVersie`:
    *   `versie`: `GELDIG`, `ALTIJD`.
    *   `regelSpraakRegel`:
        *   `resultaatDeel` is `kenmerkToekenning`: `onderwerpKeten` (`EEN`, `Natuurlijk persoon`), `IS`, `kenmerkNaam` (`minderjarig`).
        *   `voorwaardeDeel`: `INDIEN`, `toplevelElementaireVoorwaarde` (`toplevelVoorwaardeVergelijking` (`getalExpressie` (`X`), `predicaatOperator` (`kleiner is dan`), `getalExpressie` (`DE`, `volwassenleeftijd`))).
        *   `DOT` token.
        *   `variabeleDeel`: `DAARBIJ_GELDT`, `variabeleOnderdeel` (`variabeleNaam` (`X`), `IS`, `expressie` (`TijdsduurExpr`)).

**Example 4: Samengestelde Voorwaarde (Ref: §10.2)**

```regelspraak
indien hij aan alle volgende voorwaarden voldoet:
- zijn reis is duurzaam
- de afstand tot bestemming ... is groter of gelijk aan ...
```

*ANTLR Parsing (within `voorwaardeDeel`):*
*   `INDIEN` token.
*   `toplevelSamengesteldeVoorwaarde` matches:
    *   `objectExpressie` (`HIJ`).
    *   `AAN`, `voorwaardeKwantificatie` (`ALLE`), `VOLGENDE_VOORWAARDEN`, `VOLDOET`, `COLON`.
    *   `samengesteldeVoorwaardeOnderdeel`:
        *   `genesteVoorwaarde`: `BULLET`, `elementaireVoorwaarde` (`voorwaardeVergelijking` (`objectVergelijking`: `ZIJN_BEZITTELIJK`, `reis`, `IS`, `duurzaam`)).
        *   `genesteVoorwaarde`: `BULLET`, `elementaireVoorwaarde` (`voorwaardeVergelijking` (`getalVergelijking`: `DE`, `afstand ...`, `GROTER_OF_GELIJK_AAN`, `...`)).

---

## 5. Handling Specific Constructs

*   **Identifiers with Spaces:** The `IDENTIFIER` lexer rule allows spaces. This mirrors RegelSpraak's natural language style but can cause ambiguity (e.g., is `is gelijk aan` a keyword sequence or an identifier?). The parser relies on keyword tokens having higher priority. If ambiguity persists, grammar adjustments or semantic checks might be needed. For example, `attribuutNaam : identifier;` simply uses the token recognized by the lexer.
*   **Expression Precedence:** The `getalExpressie` rule uses ANTLR's left-recursive style (`# AdditiveExpr`, `# MultiplicativeExpr`, etc.) to implicitly handle standard arithmetic precedence. Ensure the order of alternatives within `getalExpressie` reflects the desired precedence, or use explicit precedence markers if needed. Functions like `WORTEL_VAN` usually have high precedence.
*   **Tijdlijnen/Tijdsafhankelijkheid:** The syntax for *defining* a tijdlijn (`voor elke dag` etc.) is captured (`tijdlijn` rule). The *semantics* of how this affects calculations (knips, aggregation over time) are not part of the pure syntax parsing but are crucial for the interpreter/engine built using the parser output. The specific time-related *expressions* (`TOTAAL_VAN`, `AANTAL_DAGEN_IN`, `TIJDSEVENREDIG_DEEL_PER`) have dedicated parser rules.
*   **Beslistabellen (Chapter 12):** The grammar primarily focuses on parsing the core RegelSpraak constructs *within* rules. Beslistabellen are a tabular *presentation* of rules. Parsing the literal table structure (rows, columns, headers) is complex and likely outside the scope of this *RegelSpraak language* grammar. The provided grammar can parse the RegelSpraak fragments found *inside* the table cells (e.g., the conditions like `indien zijn woonprovincie gelijk is aan` and the conclusions like `moet gesteld worden op 1`). A pre-processor might be needed to extract these fragments from a table representation before feeding them to this parser, or a separate grammar could handle the table structure itself. The `beslistabel` rule includes a basic placeholder.
*   **Unicode:** Ensure the ANTLR target environment and the lexer rules (like `LETTER_PROPERTY`, `STRING_LITERAL`) fully support Unicode as specified.
*   **Ambiguity:** Natural language features (like `zijn` being a verb and a pronoun) can introduce ambiguity. Context in the parser rules helps, but some cases might require semantic analysis post-parsing.

---

This document provides the structural basis for the RegelSpraak ANTLR grammar. Building the complete `.g4` file involves filling in all the EBNF details from Chapter 13 and testing thoroughly against diverse RegelSpraak examples.